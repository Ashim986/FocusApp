{
  "solutions" : [
    {
      "approaches" : [
        {
          "approach" : "1. Sort the array.\n2. For each index i, use two pointers (l, r) to find pairs where nums[i] + nums[l] + nums[r] == 0.\n3. Skip duplicate values for i, l, and r.",
          "code" : "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let nums = nums.sorted()\n    var result: [[Int]] = []\n    if nums.count < 3 { return result }\n\n    for i in 0..<(nums.count - 2) {\n        if i > 0 && nums[i] == nums[i - 1] { continue }\n        var left = i + 1\n        var right = nums.count - 1\n        while left < right {\n            let sum = nums[i] + nums[left] + nums[right]\n            if sum == 0 {\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right && nums[left] == nums[left - 1] { left += 1 }\n                while left < right && nums[right] == nums[right + 1] { right -= 1 }\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    return result\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Sorting is in-place; extra space is constant (excluding output).",
            "time" : "O(n^2)",
            "timeExplanation" : "For each i, two pointers scan the rest of the array."
          },
          "explanation" : "Sorting enables a linear scan for each fixed i, resulting in O(n^2) time.",
          "id" : "fa457d53-4a83-48c1-970e-eaf8ac79fa61",
          "intuition" : "Sorting allows us to skip duplicates and adjust pointers based on the sum.",
          "name" : "Sort + Two Pointers",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[-1,-1,2],[-1,0,1]]",
              "explanation" : "Two unique triplets sum to 0.",
              "id" : "6952a73f-5e39-4a3c-b7e4-212d9d10d643",
              "input" : "nums = [-1,0,1,2,-1,-4]"
            },
            {
              "expectedOutput" : "[]",
              "explanation" : "No triplet sums to 0.",
              "id" : "e88c71f1-6f39-4502-a988-d62d817a8e42",
              "input" : "nums = [0,1,1]"
            },
            {
              "expectedOutput" : "[[0,0,0]]",
              "explanation" : "Single unique triplet.",
              "id" : "1caf588c-d8b4-4469-9a6d-a8f0c0dcc42b",
              "input" : "nums = [0,0,0]"
            }
          ]
        }
      ],
      "id" : "82ca8435-3b76-41f5-9985-8646f575a687",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "3sum",
      "relatedProblems" : [
        "two-sum",
        "4sum"
      ],
      "summary" : "Sort the array and fix one element, then use two pointers to find pairs that sum to the negative."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible combinations of three numbers, calculate their sum, and keep track of the sum that is closest to the target",
          "code" : "func threeSumClosest(_ nums: [Int], _ target: Int) -> Int { \n    var minDiff = Int.max \n    var result = 0 \n    for i in 0..<nums.count { \n        for j in i + 1..<nums.count { \n            for k in j + 1..<nums.count { \n                let sum = nums[i] + nums[j] + nums[k] \n                let diff = abs(sum - target) \n                if diff < minDiff { \n                    minDiff = diff \n                    result = sum \n                } \n            } \n        } \n    } \n    return result \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the result and the minimum difference",
            "time" : "O(n^3)",
            "timeExplanation" : "We have three nested loops, each of which iterates over the array"
          },
          "explanation" : "This approach is straightforward but has high time complexity due to the generation of all combinations",
          "id" : "5c492f41-c962-476f-8989-3aaff097b5f6",
          "intuition" : "This approach works by checking all possible combinations of three numbers in the array",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The sum of -1, 2, and 1 is 2, which is closest to the target 1",
              "id" : "2249d72d-8d25-43c2-a569-ae219a32dacc",
              "input" : "nums = [-1,2,1,-4], target = 1"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The sum of 0, 0, and 0 is 0, which is closest to the target 1",
              "id" : "f0861048-3b20-427d-a28e-de51fcfa8bfd",
              "input" : "nums = [0,0,0], target = 1"
            }
          ]
        },
        {
          "approach" : "Sort the array, then iterate over the array and use two pointers to find a pair of numbers that, when added to the current number, give a sum closest to the target",
          "code" : "func threeSumClosest(_ nums: [Int], _ target: Int) -> Int { \n    let sortedNums = nums.sorted() \n    var minDiff = Int.max \n    var result = 0 \n    for i in 0..<sortedNums.count - 2 { \n        var left = i + 1 \n        var right = sortedNums.count - 1 \n        while left < right { \n            let sum = sortedNums[i] + sortedNums[left] + sortedNums[right] \n            let diff = abs(sum - target) \n            if diff < minDiff { \n                minDiff = diff \n                result = sum \n            } \n            if sum < target { \n                left += 1 \n            } else if sum > target { \n                right -= 1 \n            } else { \n                return sum \n            } \n        } \n    } \n    return result \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to sort the array, which requires additional space",
            "time" : "O(n^2)",
            "timeExplanation" : "We have two nested loops, the outer loop iterates over the array and the inner loop uses two pointers to find a pair of numbers"
          },
          "explanation" : "This approach is more efficient than the brute force approach because it avoids generating all combinations",
          "id" : "269eb0bf-6016-483d-9b6d-5cc918ae8914",
          "intuition" : "This approach works by sorting the array and using two pointers to find the closest sum",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The sum of -1, 2, and 1 is 2, which is closest to the target 1",
              "id" : "1ae1accd-9e68-4c68-92b9-088ccae08501",
              "input" : "nums = [-1,2,1,-4], target = 1"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The sum of 0, 0, and 0 is 0, which is closest to the target 1",
              "id" : "a5bedf11-a1b1-4201-bf9b-e007e6736d60",
              "input" : "nums = [0,0,0], target = 1"
            }
          ]
        }
      ],
      "id" : "70339e54-831d-41fc-9f02-d7de9fd6beae",
      "lastUpdated" : "2026-02-06T21:03:57Z",
      "problemSlug" : "3sum-closest",
      "relatedProblems" : [
        "3sum",
        "4sum-ii"
      ],
      "summary" : "The 3Sum Closest problem asks to find the sum of three numbers in an array that is closest to a given target, and the key insight is to use sorting and two pointers to solve it efficiently."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize count to 0. Step 2: Iterate through all possible pairs of numbers in the array. Step 3: For each pair, iterate through the remaining numbers and check if the sum of the three numbers equals the target. If it does, increment the count.",
          "code" : "\nimport Foundation\n\nfunc threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n    var count: Int = 0\n    for i in 0...nums.count - 3 {\n        for j in i + 1...nums.count - 2 {\n            for k in j + 1...nums.count - 1 {\n                if nums[i] + nums[j] + nums[k] == target {\n                    count += 1\n                }\n            }\n        }\n    }\n    return count\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the count variable.",
            "time" : "O(n^3)",
            "timeExplanation" : "We have three nested loops, each of which iterates up to n times, resulting in a time complexity of O(n^3)."
          },
          "explanation" : "The brute-force approach is straightforward but not efficient for large arrays because it has a time complexity of O(n^3).",
          "id" : "aca1f10b-2e7d-43ab-a2a3-088cf6000ca2",
          "intuition" : "This approach works by iterating through all possible pairs of numbers in the array, and then for each pair, it checks all remaining numbers to see if their sum equals the target.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "20",
              "explanation" : "There are 20 triples (a, b, c) that satisfy a + b + c = 6: (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2)",
              "id" : "781c3ea8-9dcc-4f7e-a744-f528720d1660",
              "input" : "nums = [1,1,2,2,2,2,3,3,4,4,8,8], target = 6"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "There are 4 triples (a, b, c) that satisfy a + b + c = 8: (1, 3, 4), (1, 3, 4), (2, 2, 4), (2, 3, 3)",
              "id" : "4c0e95d7-13a0-4d66-92de-4414f38284ab",
              "input" : "nums = [1,1,2,2,3,3,4,4,5,5], target = 8"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are 0 triples (a, b, c) that satisfy a + b + c = 9: ",
              "id" : "9e3f617d-0390-4bf1-a745-688b9a2876ff",
              "input" : "nums = [2,7,11,15], target = 9"
            }
          ]
        },
        {
          "approach" : "Step 1: Sort the array. Step 2: Iterate through the array. For each number, initialize two pointers, one at the next number and one at the end of the array. Step 3: Calculate the sum of the current number and the numbers at the two pointers. If the sum is less than the target, move the left pointer to the right. If the sum is greater than the target, move the right pointer to the left. If the sum equals the target, increment the count and move both pointers.",
          "code" : "\nimport Foundation\n\nfunc threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n    let sortedNums = nums.sorted()\n    var count: Int = 0\n    for i in 0...sortedNums.count - 3 {\n        var left: Int = i + 1\n        var right: Int = sortedNums.count - 1\n        while left < right {\n            let sum: Int = sortedNums[i] + sortedNums[left] + sortedNums[right]\n            if sum < target {\n                left += 1\n            } else if sum > target {\n                right -= 1\n            } else {\n                var leftCount: Int = 1\n                var rightCount: Int = 1\n                while left + 1 < right && sortedNums[left] == sortedNums[left + 1] {\n                    leftCount += 1\n                    left += 1\n                }\n                while right - 1 > left && sortedNums[right] == sortedNums[right - 1] {\n                    rightCount += 1\n                    right -= 1\n                }\n                count += leftCount * rightCount\n                left += 1\n                right -= 1\n            }\n        }\n    }\n    return count\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the count variable and the pointers.",
            "time" : "O(n^2)",
            "timeExplanation" : "We have one loop that iterates n times, and for each iteration, we have another loop that iterates up to n times, resulting in a time complexity of O(n^2)."
          },
          "explanation" : "The two-pointer approach is more efficient than the brute-force approach because it has a time complexity of O(n^2).",
          "id" : "2e181cb7-47d5-488c-af3c-9f6ec822f892",
          "intuition" : "This approach works by sorting the array first, and then for each number, it uses two pointers to find a pair of numbers that sum to the target minus the current number.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "20",
              "explanation" : "There are 20 triples (a, b, c) that satisfy a + b + c = 6: (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2), (1, 3, 2)",
              "id" : "3a547ff4-dd0d-45bc-88cb-47c2f54c7f70",
              "input" : "nums = [1,1,2,2,2,2,3,3,4,4,8,8], target = 6"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "There are 4 triples (a, b, c) that satisfy a + b + c = 8: (1, 3, 4), (1, 3, 4), (2, 2, 4), (2, 3, 3)",
              "id" : "addd9526-21c5-4db8-91a3-abbf50d07a7e",
              "input" : "nums = [1,1,2,2,3,3,4,4,5,5], target = 8"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are 0 triples (a, b, c) that satisfy a + b + c = 9: ",
              "id" : "a8b93da1-cb48-4d76-9193-5e969d24caef",
              "input" : "nums = [2,7,11,15], target = 9"
            }
          ]
        }
      ],
      "id" : "33fdedf2-72ba-402f-90c8-0b87cd75a6e4",
      "lastUpdated" : "2026-02-06T21:48:59Z",
      "problemSlug" : "3sum-with-multiplicity",
      "relatedProblems" : [
        "3sum",
        "3sum-closest",
        "4sum"
      ],
      "summary" : "Given an integer array nums, return the number of triples (a, b, c) with a <= b <= c that satisfy a + b + c = 0. Key insight is to use a hashmap to store the count of numbers and then apply a two-pointer technique to find the triples."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over the array with four nested loops, 2. Check if the sum of the current four numbers equals the target, 3. If it does, add the quadruplet to the result list.",
          "code" : "\n            func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\n               var result: [[Int]] = []\n               for i in 0..<nums.count {\n                  for j in i + 1..<nums.count {\n                     for k in j + 1..<nums.count {\n                        for last in k + 1..<nums.count {\n                           if nums[i] + nums[j] + nums[k] + nums[last] == target {\n                              let sortedQuadruplet = [nums[i], nums[j], nums[k], nums[last]].sorted()\n                              if !result.contains(sortedQuadruplet) {\n                                 result.append(sortedQuadruplet)\n                              }\n                           }\n                        }\n                     }\n                  }\n               }\n               return result\n            }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, all quadruplets will be added to the result list.",
            "time" : "O(n^4)",
            "timeExplanation" : "The time complexity is O(n^4) because there are four nested loops, each of which iterates over the array."
          },
          "explanation" : "This approach is straightforward but has a high time complexity due to the four nested loops.",
          "id" : "be90b13a-8920-4408-a010-e6f45946e4e4",
          "intuition" : "This approach works by checking all possible combinations of four numbers in the array to see if their sum equals the target.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
              "explanation" : "The quadruplets that sum up to 0 are [-2, -1, 1, 2], [-2, 0, 0, 2], and [-1, 0, 0, 1].",
              "id" : "96121c95-2822-470f-9abc-98e26d2741e5",
              "input" : "nums = [1, 0, -1, 0, -2, 2], target = 0"
            },
            {
              "expectedOutput" : "[[2, 2, 2, 2]]",
              "explanation" : "The only quadruplet that sums up to 8 is [2, 2, 2, 2].",
              "id" : "6b33a03e-be38-41d8-80c7-4f5c589bd065",
              "input" : "nums = [2, 2, 2, 2, 2], target = 8"
            }
          ]
        },
        {
          "approach" : "1. Sort the array, 2. Iterate over the array with two nested loops, 3. Use two pointers to find a pair of numbers that sum up to the remaining target.",
          "code" : "\n            func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\n               let sortedNums = nums.sorted()\n               var result: [[Int]] = []\n               for i in 0..<sortedNums.count - 3 {\n                  if i > 0 && sortedNums[i] == sortedNums[i - 1] { continue }\n                  for j in i + 1..<sortedNums.count - 2 {\n                     if j > i + 1 && sortedNums[j] == sortedNums[j - 1] { continue }\n                     var left = j + 1\n                     var right = sortedNums.count - 1\n                     while left < right {\n                        let sum = sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right]\n                        if sum < target {\n                           left += 1\n                        } else if sum > target {\n                           right -= 1\n                        } else {\n                           result.append([sortedNums[i], sortedNums[j], sortedNums[left], sortedNums[right]])\n                           while left < right && sortedNums[left] == sortedNums[left + 1] { left += 1 }\n                           while left < right && sortedNums[right] == sortedNums[right - 1] { right -= 1 }\n                           left += 1\n                           right -= 1\n                        }\n                     }\n                  }\n               }\n               return result\n            }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, all quadruplets will be added to the result list.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is O(n^3) because there are three nested loops, each of which iterates over the array."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it uses sorting and two pointers to reduce the time complexity.",
          "id" : "9be2e04e-8ed4-415d-9fa4-30716d062580",
          "intuition" : "This approach works by sorting the array and using two pointers to find a pair of numbers that sum up to the remaining target.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
              "explanation" : "The quadruplets that sum up to 0 are [-2, -1, 1, 2], [-2, 0, 0, 2], and [-1, 0, 0, 1].",
              "id" : "99f7096e-d15b-4f13-bc74-ee1710d3ab11",
              "input" : "nums = [1, 0, -1, 0, -2, 2], target = 0"
            },
            {
              "expectedOutput" : "[[2, 2, 2, 2]]",
              "explanation" : "The only quadruplet that sums up to 8 is [2, 2, 2, 2].",
              "id" : "95b12fc9-2bb7-4385-9aa3-59678403709a",
              "input" : "nums = [2, 2, 2, 2, 2], target = 8"
            }
          ]
        }
      ],
      "id" : "2801f972-64e9-466d-bcf9-27661105ea93",
      "lastUpdated" : "2026-02-06T21:04:09Z",
      "problemSlug" : "4sum",
      "relatedProblems" : [
        "two-sum",
        "three-sum"
      ],
      "summary" : "This problem is about finding all quadruplets in an array that sum up to a given target, and the key insight is to use sorting and two pointers to reduce the time complexity."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of the second list, calculate the total difference for each permutation, and return the permutation with the maximum total difference.",
          "code" : "import Foundation\n\nfunc advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n    let n = A.count\n    var res: [Int] = Array(repeating: 0, count: n)\n    var permutations = getPermutations(arr: B)\n    var maxDiff: Int = Int.min\n    var maxDiffPermutation: [Int] = []\n    for permutation in permutations {\n        var diff = 0\n        for i in 0..<n {\n            diff += max(0, permutation[i] - A[i])\n        }\n        if diff > maxDiff {\n            maxDiff = diff\n            maxDiffPermutation = permutation\n        }\n    }\n    return maxDiffPermutation\n}\n\nfunc getPermutations(arr: [Int]) -> [[Int]] {\n    if arr.count == 1 {\n        return [arr]\n    }\n    var result: [[Int]] = []\n    for i in 0..<arr.count {\n        let element = arr[i]\n        let rest = Array(arr[0..<i] + arr[(i+1)...])\n        for p in getPermutations(arr: rest) {\n            result.append([element] + p)\n        }\n    }\n    return result\n}",
          "complexity" : {
            "space" : "O(n!)",
            "spaceExplanation" : "Storing all permutations of a list of length n takes O(n!) space.",
            "time" : "O(n!)",
            "timeExplanation" : "Generating all permutations of a list of length n takes O(n!) time."
          },
          "explanation" : "This approach involves generating all permutations of the second list, which can be very time-consuming for large lists.",
          "id" : "3db17530-092c-4002-baa3-a323d10c5d1d",
          "intuition" : "This approach works by checking every possible permutation of the second list and calculating the total difference for each permutation. It then returns the permutation with the maximum total difference.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2,11,7,15]",
              "explanation" : "B is sorted in descending order and A is sorted in ascending order and then compared.",
              "id" : "3d1eb348-b76a-4926-b38f-92124a9f025d",
              "input" : "A = [2,7,11,15], B = [1,10,4,11]"
            },
            {
              "expectedOutput" : "[24,8,12,32]",
              "explanation" : "After sorting A and B, we compare the elements from the end.",
              "id" : "f1870616-483e-4e4d-babd-d9568568676f",
              "input" : "A = [12,24,8,32], B = [13,25,32,11]"
            }
          ]
        },
        {
          "approach" : "Sort the first list in ascending order and the second list in descending order, then compare elements from the end and assign them based on the maximum difference.",
          "code" : "import Foundation\n\nfunc advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n    let n = A.count\n    var res: [Int] = Array(repeating: 0, count: n)\n    let a = A.sorted()\n    let b = B.sorted { $0 > $1 }\n    var left = 0\n    var right = n - 1\n    for bIndex in 0..<n {\n        if a[right] > b[bIndex] {\n            res[bIndex] = a[right]\n            right -= 1\n        } else {\n            res[bIndex] = a[left]\n            left += 1\n        }\n    }\n    return res\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Creating new sorted lists takes O(n) space.",
            "time" : "O(n log n)",
            "timeExplanation" : "Sorting two lists of length n takes O(n log n) time."
          },
          "explanation" : "The idea is to assign the smallest element in A to the largest element in B that is not larger than it, and assign any remaining elements from A to the remaining elements from B.",
          "id" : "d0102684-2074-478f-b287-5de6f5389696",
          "intuition" : "This approach works by sorting the first list in ascending order and the second list in descending order, then comparing elements from the end and assigning them based on the maximum difference.",
          "name" : "Greedy Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2,11,7,15]",
              "explanation" : "B is sorted in descending order and A is sorted in ascending order and then compared.",
              "id" : "e46f0aaf-ca01-43d7-a03a-5f8ccae7c5d7",
              "input" : "A = [2,7,11,15], B = [1,10,4,11]"
            },
            {
              "expectedOutput" : "[24,8,12,32]",
              "explanation" : "After sorting A and B, we compare the elements from the end.",
              "id" : "8b11b003-07ae-4160-9e77-973c97f85942",
              "input" : "A = [12,24,8,32], B = [13,25,32,11]"
            }
          ]
        }
      ],
      "id" : "5cd193ba-2ba3-4894-a5f5-22f3edfe214e",
      "lastUpdated" : "2026-02-06T21:45:37Z",
      "problemSlug" : "advantage-shuffle",
      "relatedProblems" : [
        "relative-ranks",
        "largest-number"
      ],
      "summary" : "The Advantage Shuffle problem involves shuffling two lists to maximize the difference, and the key insight is to sort both lists and then compare elements from the end to maximize the difference. A greedy approach can help in solving this."
    },
    {
      "approaches" : [
        {
          "approach" : "For each child, try each cookie and check if it satisfies the child's hunger level. If it does, mark the child as satisfied and remove the cookie from the list.",
          "code" : "func findContentChildren(g: [Int], s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var satisfiedChildren = 0; for cookie in sortedS { for i in 0..<sortedG.count { if cookie >= sortedG[i] { satisfiedChildren += 1; sortedG.remove(at: i); break; } } } return satisfiedChildren; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The algorithm only uses a constant amount of space to store the input and output values.",
            "time" : "O(n^2)",
            "timeExplanation" : "The algorithm has a nested loop structure, where the outer loop iterates through the cookies and the inner loop iterates through the children."
          },
          "explanation" : "The brute force solution is straightforward but has a high time complexity. It tries all possible combinations, making it inefficient for large inputs.",
          "id" : "e21b8677-bdba-45ba-a70f-901dfd5a626d",
          "intuition" : "Try all possible combinations of cookies and children to find the maximum number of satisfied children.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The first child is satisfied with the first cookie, and the second child is satisfied with the second cookie.",
              "id" : "5485c7e2-e8ee-4cc7-b58a-ce38b67cb2e5",
              "input" : "g = [1,2,3], s = [1,2]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Both children are satisfied with the first two cookies, and the third cookie is not needed.",
              "id" : "47f63068-9c8d-4ee6-b96d-e7af1f9baee9",
              "input" : "g = [1,2], s = [1,2,3]"
            }
          ]
        },
        {
          "approach" : "Sort the hunger levels of the children and the sizes of the cookies. Then, use two pointers to iterate through the sorted lists. For each child, find the smallest cookie that satisfies their hunger level.",
          "code" : "func findContentChildren(_ g: [Int], _ s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var childIndex = 0; var cookieIndex = 0; while childIndex < sortedG.count && cookieIndex < sortedS.count { if sortedS[cookieIndex] >= sortedG[childIndex] { childIndex += 1; } cookieIndex += 1; } return childIndex; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The algorithm only uses a constant amount of space to store the input and output values.",
            "time" : "O(n log n)",
            "timeExplanation" : "The algorithm sorts the input lists, which takes O(n log n) time. The two-pointer technique then takes O(n) time."
          },
          "explanation" : "The two-pointer technique allows us to find the smallest cookie that satisfies each child's hunger level in a single pass.",
          "id" : "143c5038-4e6f-4e64-8de1-9217f5a627a8",
          "intuition" : "Use a two-pointer technique to assign cookies to children in a greedy manner.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The first child is satisfied with the first cookie, and the second child is satisfied with the second cookie.",
              "id" : "3ab109e4-b8af-4cfa-9e32-cfa0077be3f4",
              "input" : "g = [1,2,3], s = [1,2]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Both children are satisfied with the first two cookies, and the third cookie is not needed.",
              "id" : "148438e6-d710-4d1a-bc5b-77ee4140167d",
              "input" : "g = [1,2], s = [1,2,3]"
            }
          ]
        }
      ],
      "id" : "c28b6245-33a2-498f-9df2-a8af69e055fa",
      "lastUpdated" : "2026-02-06T21:19:59Z",
      "problemSlug" : "assign-cookies",
      "relatedProblems" : [
        "partition-equal-subset-sum",
        "jump-game"
      ],
      "summary" : "The problem requires assigning cookies to children based on their hunger levels. The key insight is to use a greedy algorithm, where the smallest cookie is given to the child with the smallest hunger level."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Define a helper function to process a string with backspaces. 2. In the helper function, iterate over the string and use a stack to store valid characters. 3. When encountering a backspace, pop the top of the stack if it's not empty. 4. Return the processed string by joining the characters in the stack. 5. Process both input strings and compare them.",
          "code" : "func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "We use a stack to store the valid characters from the input strings. In the worst case, we might need to store all characters from both strings, resulting in a space complexity of O(n + m).",
            "time" : "O(n + m)",
            "timeExplanation" : "We process each string once, iterating over each character. This results in a time complexity of O(n + m), where n and m are the lengths of the input strings."
          },
          "explanation" : "The helper function processes the strings by removing backspaces, resulting in a clean string for comparison. This approach ensures that backspaces are handled correctly and that the resulting strings are directly comparable.",
          "id" : "b01d7b0b-61ab-45c9-bf11-008a1a5b4243",
          "intuition" : "We create a helper function to process the strings and remove backspaces, then compare the processed strings.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become 'ac' after processing backspaces.",
              "id" : "dec89b31-d25d-4821-8b63-24bbe7ce3ef3",
              "input" : "s = \"ab#c\", t = \"ad#c\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become empty after processing backspaces.",
              "id" : "cc82dba3-92ae-4065-9f0e-93b023b1e425",
              "input" : "s = \"ab##\", t = \"c#d#\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become 'c' after processing backspaces.",
              "id" : "9f360841-9d6a-4d67-8fc1-5f805be0e7d4",
              "input" : "s = \"a##c\", t = \"#a#c\""
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers, one at the end of each string. 2. When encountering a backspace, move the pointer back by two positions (for the '#') and the character it affects, skipping any subsequent backspaces until we reach a valid character. 3. Compare characters at the current positions of the pointers and move them forward if they are equal. 4. Repeat steps 2-3 until we reach the start of either string or the pointers diverge due to inequality.",
          "code" : "func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "This approach has the same space complexity as the brute force approach because we create arrays to hold the characters of the input strings.",
            "time" : "O(n + m)",
            "timeExplanation" : "Similar to the brute force approach, we iterate over each character in the strings, resulting in a time complexity of O(n + m). However, this approach might be more efficient in practice because it avoids the overhead of string concatenation."
          },
          "explanation" : "By moving the pointers in a way that accounts for backspaces, we effectively 'skip' over backspaces and the characters they remove, allowing us to compare the valid characters from the end of the strings toward the beginning.",
          "id" : "430bd6b7-b976-4af8-9ace-535c90ddfb94",
          "intuition" : "This approach involves utilizing two pointers to track the positions of valid characters in each string as we iterate backward through the strings.",
          "name" : "Two Pointer Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become 'ac' after processing backspaces.",
              "id" : "bf1fbea1-71e0-4f0e-8cfd-5b28bc0fd98a",
              "input" : "s = \"ab#c\", t = \"ad#c\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become empty after processing backspaces.",
              "id" : "b91ed40f-9982-4c2a-a5be-06ec3ab0b3c1",
              "input" : "s = \"ab##\", t = \"c#d#\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Both strings become 'c' after processing backspaces.",
              "id" : "3c19c65b-2674-4d8d-a795-386c1e7489a3",
              "input" : "s = \"a##c\", t = \"#a#c\""
            }
          ]
        }
      ],
      "id" : "d66fc7be-cb95-4173-9fb7-4136f9286f68",
      "lastUpdated" : "2026-02-06T21:43:49Z",
      "problemSlug" : "backspace-string-compare",
      "relatedProblems" : [
        "reverse-integer",
        "valid-parentheses"
      ],
      "summary" : "This problem involves comparing two strings with backspace characters. The key insight is to utilize a two-pointer approach to track the positions of valid characters in each string."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of token indices. For each permutation, calculate the score based on the given conditions. Keep track of the maximum score encountered.",
          "code" : "class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; let tokens = tokens.sorted(); for token in tokens { if points >= token { points -= token; score += 1; maxScore = max(maxScore, score); } } return maxScore } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are sorting the array in place.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is dominated by the sorting step, which takes O(n log n) time in Swift."
          },
          "explanation" : "This approach involves a lot of repeated calculations and does not scale well for large inputs. For each permutation, we calculate the score, which involves checking if we have enough points to play a token, playing the token, and updating the score accordingly.",
          "id" : "f0013647-2cad-42cb-8832-63d4aa7016f0",
          "intuition" : "This approach involves trying all possible combinations of tokens to determine the maximum achievable score. It is not efficient but serves as a baseline for understanding the problem.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "We do not have enough points to play the token.",
              "id" : "5b6c744c-f3de-456d-a394-6ced4952a93a",
              "input" : "tokens = [100], P = 50"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "We can play one token by using our points.",
              "id" : "117c937a-e343-48ec-af74-ac88241b798f",
              "input" : "tokens = [100, 200], P = 150"
            }
          ]
        },
        {
          "approach" : "Sort the tokens in ascending order. Initialize a window with the first token. If we have enough points to play a token, play the token with the lowest value and move the window to the right. If we do not have enough points, remove the token with the highest value from the window and move the window to the left.",
          "code" : "class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; var left = 0; var right = n - 1; let tokens = tokens.sorted(); while left <= right { if points >= tokens[left] { points -= tokens[left]; score += 1; left += 1; maxScore = max(maxScore, score); } else if score > 0 { points += tokens[right]; score -= 1; right -= 1; } else { break; } } return maxScore } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are sorting the array in place.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is dominated by the sorting step, which takes O(n log n) time in Swift."
          },
          "explanation" : "This approach is more efficient than the brute force approach. By always playing the token with the lowest value and removing the token with the highest value when necessary, we can maximize the score.",
          "id" : "e4ce42cd-4803-49ee-b998-a22d3b90a38a",
          "intuition" : "This approach involves always playing the token with the lowest value if we have enough points, and removing the token with the highest value if we do not have enough points to maximize the score.",
          "name" : "Greedy Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "We can play one token with a value of 100.",
              "id" : "c79fc9d5-467e-4913-b87d-f0fd268af173",
              "input" : "tokens = [100, 200, 300, 400], P = 200"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "We cannot play any tokens with the given points.",
              "id" : "1c35f811-048b-44ed-bc07-19138bda03ff",
              "input" : "tokens = [71, 55, 82], P = 54"
            }
          ]
        }
      ],
      "id" : "0441504b-eccf-4179-b79e-960a6a0712a8",
      "lastUpdated" : "2026-02-06T21:50:39Z",
      "problemSlug" : "bag-of-tokens",
      "relatedProblems" : [
        "coin-change",
        "jump-game"
      ],
      "summary" : "This problem involves sorting tokens in a way that maximizes the score, with a key insight being to maintain a balance between the highest possible score and the number of tokens. The goal is to return the maximum possible score that can be achieved."
    },
    {
      "approaches" : [
        {
          "approach" : "Sort people by weights, then iterate over all possible combinations of people, checking if their total weight is within the boat capacity",
          "code" : "\n       func numRescueBoats(_ people: [Int], _ limit: Int) -> Int {\n         var people = people.sorted()\n         var light = 0\n         var heavy = people.count - 1\n         var boats = 0\n         while light <= heavy {\n           if people[light] + people[heavy] <= limit {\n             light += 1\n           }\n           heavy -= 1\n           boats += 1\n         }\n         return boats\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The array is sorted in place, but the space needed to store the result is constant",
            "time" : "O(n log n)",
            "timeExplanation" : "The sorting step dominates the time complexity, while the iteration over people is linear but follows sorting"
          },
          "explanation" : "This approach is straightforward but not efficient, especially for large inputs, as it involves trying all possible combinations",
          "id" : "6a680f45-fa50-4ece-8fe4-649ce54bb16f",
          "intuition" : "Try all possible combinations of people to save in boats, but this is inefficient for large inputs",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "Only one boat is needed to save both people",
              "id" : "6df224ec-c428-470c-8b76-20e85bab124b",
              "input" : "people = [1,2], limit = 3"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Three boats are needed to save all people due to the capacity constraint",
              "id" : "af6f09fd-63d5-4f36-8c7c-351c8a16c6ba",
              "input" : "people = [3,2,2,1], limit = 3"
            }
          ]
        },
        {
          "approach" : "Sort people by their weights, initialize two pointers at the start and end of the sorted array, and move them based on whether the combined weight of people at the pointers fits within the boat capacity",
          "code" : "\n       func numRescueBoats(_ people: [Int], _ limit: Int) -> Int {\n         var people = people.sorted()\n         var light = 0\n         var heavy = people.count - 1\n         var boats = 0\n         while light <= heavy {\n           if people[light] + people[heavy] <= limit {\n             light += 1\n           }\n           heavy -= 1\n           boats += 1\n         }\n         return boats\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "After sorting, the space required does not grow with the size of the input, making it constant",
            "time" : "O(n log n)",
            "timeExplanation" : "The sorting step remains the dominant time complexity, but the subsequent pointer movement is linear"
          },
          "explanation" : "This approach is more efficient than the brute force method because it only requires a single pass through the sorted array, pairing people optimally",
          "id" : "8063ab2a-91df-49d5-840d-d0325c19d78e",
          "intuition" : "Use two pointers to efficiently pair the heaviest and lightest people, maximizing the use of each boat's capacity",
          "name" : "Two Pointers Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "This case is straightforward; one boat suffices for two people with weights 1 and 2 when the limit is 3",
              "id" : "3d3839c8-8db0-4e88-ad85-31ebb0dabf4e",
              "input" : "people = [1,2], limit = 3"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The people with weights 3 and 2 are paired in one boat, while the other two people each need their own boat, totaling 4 boats",
              "id" : "ca789f11-d863-48c2-a5a9-f666025f9a4a",
              "input" : "people = [3,5,3,4], limit = 5"
            }
          ]
        }
      ],
      "id" : "c4208855-1d61-4fcb-853a-236815b0315b",
      "lastUpdated" : "2026-02-06T21:46:08Z",
      "problemSlug" : "boats-to-save-people",
      "relatedProblems" : [
        "max-consecutive-ones",
        "jump-game-ii"
      ],
      "summary" : "The problem involves saving people using the minimum number of boats, given their weights and a limit on the capacity of each boat, leveraging two pointers for efficiency."
    },
    {
      "approaches" : [
        {
          "approach" : "Start by generating all possible substrings of the given string, then compare each substring to the pattern to see if it matches. Use two nested loops to generate the substrings and compare them to the pattern.",
          "code" : "func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); for i in 0..<queryArray.count { for j in i..<queryArray.count { if compareSubString(start: i, end: j, queryArray: queryArray, patternArray: patternArray) { return true } } } return false }; func compareSubString(start: Int, end: Int, queryArray: [Character], patternArray: [Character]) -> Bool { if start == 0 && queryArray[start] != patternArray[0] { return false }; var queryIndex = start; var patternIndex = 0; while queryIndex <= end && patternIndex < patternArray.count { if queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; if queryArray[queryIndex].isUppercase && queryArray[queryIndex] != patternArray[patternIndex] { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because no additional data structures are used that scale with the size of the input.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is cubic because there are two nested loops generating substrings and an additional loop to compare each substring to the pattern."
          },
          "explanation" : "The outer loop generates the starting index of the substrings, the inner loop generates the ending index. For each substring, compare it to the pattern to check if the uppercase characters match and appear in the correct order. If a match is found, return true. If no match is found after checking all substrings, return false.",
          "id" : "0ab63e20-588d-4134-af97-d26373015645",
          "intuition" : "The brute force approach works by iterating over all possible substrings of the given string that could match the camelcase pattern, checking each substring against the pattern. It relies on the idea that any substring that matches the pattern must start at a lowercase letter and end before the next uppercase letter.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The camelcase pattern 'FBT' can be found in the string 'FooBarTest' because the uppercase characters match and appear in the correct order.",
              "id" : "74bf9383-1846-40f6-8805-1a374e906f14",
              "input" : "query = \"FooBarTest\", pattern = \"FBT\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The camelcase pattern 'FBT' cannot be found in the string 'fooBarTest' because the first character 'F' does not match the case of 'f' in the string.",
              "id" : "1381b4e9-e402-4518-a703-ed48a445836b",
              "input" : "query = \"fooBarTest\", pattern = \"FBT\""
            }
          ]
        },
        {
          "approach" : "Initialize two pointers, one at the start of the string and one at the start of the pattern. Compare characters at corresponding positions and move the pointers accordingly. If an uppercase character in the string matches the character at the current position in the pattern, move both pointers forward. If the characters do not match or if the character in the string is uppercase and does not match the character in the pattern, return false.",
          "code" : "func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); var queryIndex = 0; var patternIndex = 0; while queryIndex < queryArray.count { if patternIndex < patternArray.count && queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; else if queryArray[queryIndex].isUppercase { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because no additional data structures are used that scale with the size of the input.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are scanning the string once with the queryIndex pointer."
          },
          "explanation" : "The key insight behind this approach is that any uppercase characters in the string must match an uppercase character in the pattern for the string to match the camelcase pattern. By using two pointers and comparing characters at corresponding positions, we can efficiently check if the string matches the pattern. If at any point the comparison fails, we immediately return false.",
          "id" : "c0f7afdc-4824-4532-a403-c57385c40350",
          "intuition" : "The two pointers approach uses two pointers, one for the string and one for the pattern, to compare characters at corresponding positions. It relies on the insight that an uppercase character in the string must match an uppercase character in the pattern if the string matches the camelcase pattern.",
          "name" : "Two Pointers Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The camelcase pattern 'FBT' can be found in the string 'FooBarTest' because the uppercase characters match and appear in the correct order.",
              "id" : "55826cf5-39e5-4c49-96a6-2f5621e52fa2",
              "input" : "query = \"FooBarTest\", pattern = \"FBT\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The camelcase pattern 'FBT' cannot be found in the string 'fooBarTest' because the first character 'F' does not match the case of 'f' in the string.",
              "id" : "f532b060-0ff3-4994-b339-7e63129cda95",
              "input" : "query = \"fooBarTest\", pattern = \"FBT\""
            }
          ]
        }
      ],
      "id" : "5cd97c1b-2401-49d2-a1c7-bf94385146b5",
      "lastUpdated" : "2026-02-06T21:56:31Z",
      "problemSlug" : "camelcase-matching",
      "relatedProblems" : [
        "find-all-anagrams-in-a-string",
        "word-subsets"
      ],
      "summary" : "The problem requires determining whether a given string matches a pattern of camelcase words, with the key insight being the use of two pointers to compare the pattern and the string. The goal is to verify if the string's uppercase characters match those in the pattern and appear in the correct order."
    },
    {
      "approaches" : [
        {
          "approach" : "Start from each index, follow the array value to the next index, and keep track of visited indices. If a cycle is detected by revisiting an index, return true. If no cycle is found after checking all indices, return false.",
          "code" : "func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because only a fixed amount of space is used to store the slow and fast pointers.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear with respect to the number of elements in the array because each element is visited once."
          },
          "explanation" : "This solution is straightforward but inefficient because it involves iterating over the array multiple times.",
          "id" : "73e36a11-8393-4e67-82ab-e1295d6a49c0",
          "intuition" : "This approach works by iterating over all possible paths in the array to detect a cycle.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "A cycle exists in the array because the element at index 0 points to index 2, which then points back to index 0.",
              "id" : "1a3a1df4-2270-43f8-9859-995e1785f304",
              "input" : "nums = [2,-1,1,2,2]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "No cycle exists in the array because there are no pointing relationships that would lead to a cycle.",
              "id" : "8d391903-aeb4-4496-95df-fceac37555a2",
              "input" : "nums = [1,2,3,4,-5]"
            }
          ]
        },
        {
          "approach" : "Start from the beginning of the array with two pointers, one moving one step at a time and the other moving two steps at a time. If the two pointers eventually meet, there is a cycle in the array.",
          "code" : "func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because a hash table is used to store the results of subproblems.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear with respect to the number of elements in the array because the slow and fast pointers may need to visit every element."
          },
          "explanation" : "This solution is efficient because it can detect a cycle in a single pass through the array.",
          "id" : "3956a328-6623-4b81-b3b0-ee15b7e50c24",
          "intuition" : "This approach works by detecting a cycle using Floyd's cycle-finding algorithm, which involves using two pointers with different speeds.",
          "name" : "Floyd's Cycle Detection Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "No cycle exists in the array because the values at each index point to other indices without creating a cycle.",
              "id" : "7135e135-63e5-4b1c-93f2-c04e3de449a0",
              "input" : "nums = [2,7,11,13]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "A cycle exists in the array because the value at index 0 points to index 2, which then points back to index 0.",
              "id" : "3662cef0-32e2-46c3-9653-63f4fda2323f",
              "input" : "nums = [2,-1,1,2,2]"
            }
          ]
        }
      ],
      "id" : "a984eafa-1a91-4620-80d1-f68bcea28c25",
      "lastUpdated" : "2026-02-06T21:20:10Z",
      "problemSlug" : "circular-array-loop",
      "relatedProblems" : [
        "linked-list-cycle",
        "find-the-duplicate-number"
      ],
      "summary" : "The problem involves determining whether a circular array loop exists and this can be solved by checking for a cycle in the array using Floyd's cycle detection algorithm. The key insight is to use two pointers with different speeds to detect the cycle."
    },
    {
      "approaches" : [
        {
          "approach" : "Split the version numbers by the dot, convert each part to an integer, and compare each part from left to right.",
          "code" : "func compareVersion(_ version1: String, _ version2: String) -> Int {\n    let v1 = version1.components(separatedBy: \".\")\n    let v2 = version2.components(separatedBy: \".\")\n    let maxLen = max(v1.count, v2.count)\n    for i in 0..<maxLen {\n        let n1 = i < v1.count ? Int(v1[i]) ?? 0 : 0\n        let n2 = i < v2.count ? Int(v2[i]) ?? 0 : 0\n        if n1 < n2 { return -1 }\n        if n1 > n2 { return 1 }\n    }\n    return 0\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n), where n is the maximum number of parts in the version numbers.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n), where n is the maximum number of parts in the version numbers."
          },
          "explanation" : "This approach works by comparing each part of the version numbers. If a part is missing, it is considered to be 0.",
          "id" : "d95afe5d-d3d8-4c4b-8262-410e63404fc2",
          "intuition" : "Split the version numbers by the dot and compare each part.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The second version is considered to be 1.0.0, so the first version is greater.",
              "id" : "ace194a3-3d4c-4a3d-a885-3a5c0a893f91",
              "input" : "version1 = \"1.0.1\", version2 = \"1\""
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "The second version is greater than the first version.",
              "id" : "6ec68f5d-a2a8-4874-94be-39da7496a3f7",
              "input" : "version1 = \"7.5.2.4\", version2 = \"7.5.3\""
            }
          ]
        },
        {
          "approach" : "Use two pointers to split the version numbers by the dot and compare each part from left to right.",
          "code" : "func compareVersion(_ version1: String, _ version2: String) -> Int {\n    var i = 0, j = 0\n    let v1 = version1 + \".\"\n    let v2 = version2 + \".\"\n    while i < v1.count && j < v2.count {\n        var n1 = 0\n        while i < v1.count && v1[v1.index(v1.startIndex, offsetBy: i)] != \".\" {\n            n1 = n1 * 10 + Int(v1[v1.index(v1.startIndex, offsetBy: i)])!\n            i += 1\n        }\n        i += 1\n        var n2 = 0\n        while j < v2.count && v2[v2.index(v2.startIndex, offsetBy: j)] != \".\" {\n            n2 = n2 * 10 + Int(v2[v2.index(v2.startIndex, offsetBy: j)])!\n            j += 1\n        }\n        j += 1\n        if n1 < n2 { return -1 }\n        if n1 > n2 { return 1 }\n    }\n    return 0\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1), as only a constant amount of space is used.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n), where n is the total number of digits in the version numbers."
          },
          "explanation" : "This approach works by using two pointers to compare each part of the version numbers. If a part is missing, it is considered to be 0.",
          "id" : "0c0a8acd-0f2f-45e0-ab35-cf73778ab671",
          "intuition" : "Use two pointers to compare each part of the version numbers.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "-1",
              "explanation" : "The second version is greater than the first version.",
              "id" : "3c394123-bf12-44a5-a4a6-d46a2c68862e",
              "input" : "version1 = \"0.1\", version2 = \"1.0\""
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The second version is considered to be 1.0.0, so the first version is greater.",
              "id" : "a5d1a89b-1641-4e9b-8cbc-918df171729d",
              "input" : "version1 = \"1.0.1\", version2 = \"1\""
            }
          ]
        }
      ],
      "id" : "6dedd3b6-960a-4899-b4ec-ed2fda0ba79e",
      "lastUpdated" : "2026-02-06T21:07:50Z",
      "problemSlug" : "compare-version-numbers",
      "relatedProblems" : [
        "reverse-integer",
        "roman-to-integer"
      ],
      "summary" : "The problem requires comparing two version numbers, with the key insight being to compare each part of the version numbers from left to right. This can be solved using a brute-force or an optimized approach."
    },
    {
      "approaches" : [
        {
          "approach" : "1. left = 0, right = n-1\n2. Calculate area = min(height[left], height[right]) * (right - left)\n3. Move pointer with smaller height inward\n4. Track max area",
          "code" : "func maxArea(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxArea = 0\n    \n    while left < right {\n        let area = min(height[left], height[right]) * (right - left)\n        maxArea = max(maxArea, area)\n        \n        if height[left] < height[right] {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    \n    return maxArea\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Constant space",
            "time" : "O(n)",
            "timeExplanation" : "Single pass with two pointers"
          },
          "explanation" : "Width decreases as we move inward, so we need taller lines. Moving shorter line is only way to potentially increase area.",
          "id" : "550e8400-e29b-41d4-a716-446655440148",
          "intuition" : "Water limited by shorter line. Moving shorter line might find taller one; moving taller never helps.",
          "name" : "Two Pointers",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "49",
              "explanation" : "Lines at index 1 and 8 (heights 8,7) give area 7*7=49",
              "id" : "550e8400-e29b-41d4-a716-446655440254",
              "input" : "[1,8,6,2,5,4,8,3,7]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440037",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "container-with-most-water",
      "relatedProblems" : [
        "trapping-rain-water"
      ],
      "summary" : "Find two lines that hold most water. Two pointers from ends, move the shorter one inward."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Generate all possible substrings. 2. For each substring, count the number of consecutive 0s and 1s. 3. If the counts are equal, increment the result counter.",
          "code" : "let countBinarySubstrings = { (s: String) -> Int in\n    var count = 0\n    for i in 0..<s.count {\n        for j in i + 1...s.count {\n            let substr = s[i..<j]\n            var ones = 0\n            var zeros = 0\n            var prev: Character = \"\"\n            for char in substr {\n                if char == \"0\" {\n                    if prev == \"0\" {\n                        zeros += 1\n                    } else {\n                        zeros = 1\n                    }\n                } else {\n                    if prev == \"1\" {\n                        ones += 1\n                    } else {\n                        ones = 1\n                    }\n                }\n                prev = char\n            }\n            if ones == zeros {\n                count += 1\n            }\n        }\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the counters and the substring.",
            "time" : "O(n^3)",
            "timeExplanation" : "The outer loop runs n times, the inner loop runs up to n times, and for each substring, we iterate through it which can take up to n time in the worst case."
          },
          "explanation" : "We utilize a nested loop to generate all substrings and then verify if each one has equal counts of 0s and 1s by iterating through the substring and updating the count of consecutive characters.",
          "id" : "8cb73c16-7f25-40fe-a08b-efbb6028b877",
          "intuition" : "This approach involves checking every possible substring of the given string and verifying if it's a binary substring.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "The binary substrings are \"01\", \"10\", \"01\", \"10\", \"0011\", and \"1100\".",
              "id" : "519f1403-2b73-4190-a7c7-b2b6b5fe5a91",
              "input" : "s = \"00110011\""
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The binary substrings are \"10\", \"01\", \"10\", and \"01\".",
              "id" : "2e7013d3-ad4e-4340-a5fd-419e2be382f5",
              "input" : "s = \"10101\""
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers at the start of the string. 2. Move the pointers based on the characters encountered and update the counts of consecutive 0s and 1s. 3. Whenever we encounter a different character, calculate the minimum count and add it to the result.",
          "code" : "let countBinarySubstrings = { (s: String) -> Int in\n    var ones = 0\n    var zeros = 0\n    var prev: Character = \"\"\n    var count = 0\n    for char in s {\n        if char == \"0\" {\n            if prev == \"0\" {\n                zeros += 1\n            } else {\n                count += min(ones, zeros)\n                zeros = 1\n            }\n        } else {\n            if prev == \"1\" {\n                ones += 1\n            } else {\n                count += min(ones, zeros)\n                ones = 1\n            }\n        }\n        prev = char\n    }\n    return count + min(ones, zeros)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the counters and the previous character.",
            "time" : "O(n)",
            "timeExplanation" : "We only iterate through the string once."
          },
          "explanation" : "We iterate through the string with two pointers. Whenever we encounter a '0' or '1', we update the corresponding count. When we encounter a different character, we calculate the minimum count and add it to the result.",
          "id" : "597678c3-759c-49a9-9165-2e05a410f0ef",
          "intuition" : "This approach involves using two pointers to track consecutive 0s and 1s in the string and then calculating the minimum of these counts.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "The binary substrings are \"01\", \"10\", \"01\", \"10\", \"0011\", and \"1100\".",
              "id" : "e16c3a25-14b9-4fed-ae2c-73e3b514acb7",
              "input" : "s = \"00110011\""
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The binary substrings are \"10\", \"01\", \"10\", and \"01\".",
              "id" : "d485cf8b-223c-4328-83c8-60e4b20e5d9e",
              "input" : "s = \"10101\""
            }
          ]
        }
      ],
      "id" : "7a633cb3-1f28-42f0-a902-0067e4f0e431",
      "lastUpdated" : "2026-02-06T21:34:23Z",
      "problemSlug" : "count-binary-substrings",
      "relatedProblems" : [
        "consecutive-numbers-sum",
        "number-of-substrings-containing-at-least-one-odd-digit"
      ],
      "summary" : "The problem requires counting the number of binary substrings in a given string, with a key insight being that a binary substring must have an equal number of consecutive 0s and 1s. We will use two approaches: a brute-force approach checking all substrings and an optimized approach using two pointers to track consecutive 0s and 1s."
    },
    {
      "approaches" : [
        {
          "approach" : "Create an array and fill it with numbers from 0 to n. Generate all possible permutations of the array. For each permutation, check if the sum of indices of 'D' characters equals the sum of indices of 'I' characters.",
          "code" : "func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the current permutation.",
            "time" : "O(n!)",
            "timeExplanation" : "The time complexity is O(n!) due to generating all permutations."
          },
          "explanation" : "This approach works because it checks every possible order of indices. However, it is inefficient for large inputs due to its time complexity.",
          "id" : "627526cb-54b5-44d9-99cd-736b50f64d20",
          "intuition" : "The brute-force approach is used to check every possible combination of indices for 'D' and 'I' characters and find the ones that satisfy the condition.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,4,1,3,2]",
              "explanation" : "The valid DI string match is [0,4,1,3,2].",
              "id" : "4d14439c-b561-40f3-b88e-0823a5b9b265",
              "input" : "S = \"IDID\""
            },
            {
              "expectedOutput" : "[0,1,2]",
              "explanation" : "The valid DI string match is [0,1,2].",
              "id" : "feb26ed9-d2eb-4384-a1db-a740e9cb862b",
              "input" : "S = \"III\""
            }
          ]
        },
        {
          "approach" : "Initialize two pointers, low and high, to 0 and n respectively. Initialize an empty result array. Iterate through the string and for each 'D' character, append the current low value to the result array and increment low. For each 'I' character, append the current high value to the result array and decrement high.",
          "code" : "func diStringMatch(_ S: String) -> [Int] { let n = S.count; var low = 0, high = n; var result = [Int](); for c in S { if c == \"D\" { result.append(low); low += 1 } else if c == \"I\" { result.append(high); high -= 1 } } if S.last == \"D\" { result.append(low) } else { result.append(high) } return result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the result array.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) due to a single pass through the string."
          },
          "explanation" : "This approach works because it constructs the result array in a single pass and avoids unnecessary computations.",
          "id" : "ff98a02b-d1bf-4bb1-9323-4715076420c1",
          "intuition" : "The optimized approach uses two pointers, one from the start and one from the end, and constructs the result array based on 'D' and 'I' characters.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0,4,1,3,2]",
              "explanation" : "The valid DI string match is [0,4,1,3,2].",
              "id" : "9e169706-7ab4-4ab8-87d5-c64b3541d653",
              "input" : "S = \"IDID\""
            },
            {
              "expectedOutput" : "[0,1,2,3]",
              "explanation" : "The valid DI string match is [0,1,2,3].",
              "id" : "87681964-0d8b-4108-86b8-5d5c77d66d8e",
              "input" : "S = \"III\""
            }
          ]
        }
      ],
      "id" : "5d8c89ca-2f3d-42fe-96c9-e94a00e735da",
      "lastUpdated" : "2026-02-06T21:50:16Z",
      "problemSlug" : "di-string-match",
      "relatedProblems" : [
        "valid-parentheses",
        "next-greater-element-i"
      ],
      "summary" : "Given a string S of length n, S consists of n letters 'D' or 'I'. The string is a valid DI string if and only if the sum of the indices of the 'D' characters equals the total sum of indices of the 'I' characters. Two approaches will be used to solve the problem, brute-force and optimized."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through the list of words and for each word, compare it character by character with the target word, applying the 'expressive' rules.",
          "code" : "\n           import Foundation\n\n           func expressiveWords(_ S: String, _ words: [String]) -> Int {\n               var count = 0\n               for word in words {\n                   if canTransform(word, S) {\n                       count += 1\n                   }\n               }\n               return count\n           }\n\n           func canTransform(_ word: String, _ S: String) -> Bool {\n               guard word.count <= S.count else { return false }\n\n               var wordIndex = 0\n               var sIndex = 0\n\n               while sIndex < S.count {\n                   if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n                       wordIndex += 1\n                       sIndex += 1\n                   } else if sIndex > 0 && S[sIndex] == S[sIndex - 1] {\n                       let charCountInS = countConsecutive(S, at: sIndex)\n                       if charCountInS > 1 {\n                           sIndex += charCountInS\n                       } else {\n                           return false\n                       }\n                   } else {\n                       return false\n                   }\n               }\n\n               return wordIndex == word.count\n           }\n\n           func countConsecutive(_ str: String, at index: Int) -> Int {\n               let targetChar = str[str.index(str.startIndex, offsetBy: index)]\n               var count = 1\n               var currentIndex = index + 1\n               while currentIndex < str.count, str[str.index(str.startIndex, offsetBy: currentIndex)] == targetChar {\n                   count += 1\n                   currentIndex += 1\n               }\n               return count\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because no additional data structures are used that scale with input size.",
            "time" : "O(n*m*k)",
            "timeExplanation" : "n is the number of words, m is the average length of a word, and k is the average length of sequences of the same character in the target word."
          },
          "explanation" : "The comparison involves checking for matching characters and handling sequences of characters that can be 'stretched' by repetition. The brute force approach does this comparison linearly, without optimization.",
          "id" : "f357581b-b4ac-46f6-89e8-c13de67e1a95",
          "intuition" : "This approach involves checking each word against the target word by comparing characters one by one and considering the 'expressiveness' rules.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "Only \"b\" can be transformed into \"abcd\" by inserting characters.",
              "id" : "1cae37d0-ac50-492f-aaac-73d029e8c0eb",
              "input" : "S = \"abcd\", words = [\"abdb\",\"bcdc\",\"ac\",\"ba\",\"b\",\"a\"]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "None of the given words can be transformed into \"abcd\" by 'expressive' rules.",
              "id" : "29fa9860-3601-4ffd-bb93-aae2cf2662e4",
              "input" : "S = \"abcd\", words = [\"abc\",\"abdb\",\"bcdc\",\"ac\"]"
            }
          ]
        },
        {
          "approach" : "Use two pointers to iterate through the word and the target string. When encountering a sequence of the same character in the target string, determine the count of consecutive occurrences and compare it with the corresponding sequence in the word.",
          "code" : "\n           import Foundation\n\n           func expressiveWords(_ S: String, _ words: [String]) -> Int {\n               var count = 0\n               for word in words {\n                   if isExpressive(word, S) {\n                       count += 1\n                   }\n               }\n               return count\n           }\n\n           func isExpressive(_ word: String, _ S: String) -> Bool {\n               var wordIndex = 0\n               var sIndex = 0\n\n               while sIndex < S.count {\n                   if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n                       let wordCount = countConsecutive(word, at: wordIndex)\n                       let sCount = countConsecutive(S, at: sIndex)\n\n                       if wordCount != sCount && !(sCount > wordCount && sCount >= 3) {\n                           return false\n                       }\n\n                       wordIndex += wordCount\n                       sIndex += sCount\n                   } else {\n                       return false\n                   }\n               }\n\n               return wordIndex == word.count\n           }\n\n           func countConsecutive(_ str: String, at index: Int) -> Int {\n               let targetChar = str[str.index(str.startIndex, offsetBy: index)]\n               var count = 1\n               var currentIndex = index + 1\n               while currentIndex < str.count, str[str.index(str.startIndex, offsetBy: currentIndex)] == targetChar {\n                   count += 1\n                   currentIndex += 1\n               }\n               return count\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because no additional data structures are used that scale with input size.",
            "time" : "O(n*m)",
            "timeExplanation" : "n is the number of words, m is the average length of a word."
          },
          "explanation" : "The optimized approach efficiently handles sequences of characters by counting consecutive occurrences in the target string and comparing these counts with the word's sequences, significantly reducing unnecessary comparisons.",
          "id" : "d6a8abb5-5d5c-4968-9bcb-fa0c5f3c6c8f",
          "intuition" : "This approach uses two pointers to compare the characters in the word and the target string, optimizing the comparison by handling repeated characters efficiently.",
          "name" : "Two Pointers Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "Only \"hello\" can be transformed into \"heeellooo\" by applying 'expressive' rules.",
              "id" : "26ba7aab-ae9f-468b-83ce-11fb96bedeba",
              "input" : "S = \"heeellooo\", words = [\"hello\", \"hi\", \"helolo\"]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "Only \"b\" can be transformed into \"abcd\" by inserting characters.",
              "id" : "51f98d62-f010-4474-9a62-dfa4b200ca21",
              "input" : "S = \"abcd\", words = [\"abdb\",\"bcdc\",\"ac\",\"ba\",\"b\",\"a\"]"
            }
          ]
        }
      ],
      "id" : "a51da46f-3f32-4d3a-9341-1975cac1bdc7",
      "lastUpdated" : "2026-02-06T21:41:14Z",
      "problemSlug" : "expressive-words",
      "relatedProblems" : [
        "valid-tic-tac-toe-state",
        "number-of-music-plates"
      ],
      "summary" : "The problem requires determining the number of words in a list that are 'expressive' when compared to a given target word. Key insight is understanding how to compare the characters in words to the target word."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize a new array to hold the absolute differences between each element in the input array and the target. 2. Sort the new array in ascending order. 3. Find the K smallest absolute differences and their corresponding indices in the original array. 4. Return the K closest elements.",
          "code" : "\nimport Foundation\n\nfunc findKClosestElementsBruteForce(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n    let sortedDifferences = nums.sorted { abs($0 - x) < abs($1 - x) }\n    return Array(sortedDifferences.prefix(k))\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is due to the creation of a new array to hold the sorted differences.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is dominated by the sorting operation."
          },
          "explanation" : "This method involves calculating all absolute differences, sorting them, and then identifying the K smallest. It is straightforward but inefficient for large arrays due to the sorting operation.",
          "id" : "fafa1516-5a0c-4f7a-85a1-db328501a8a3",
          "intuition" : "The brute force approach works by iterating through all elements in the array, calculating the absolute difference between each element and the target, and selecting the K smallest differences, hence finding the corresponding closest elements.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,3,4]",
              "explanation" : "The four closest elements to 3 in the array [1,2,3,4,5] are indeed 1, 2, 3, and 4.",
              "id" : "15a36c2c-9387-4fb5-8609-901cb5e99bf8",
              "input" : "nums = [1,2,3,4,5], k = 4, x = 3"
            },
            {
              "expectedOutput" : "[5,10]",
              "explanation" : "The two closest elements to 10 in the array [1,5,10,15] are 5 and 10.",
              "id" : "404e43ce-adac-47d0-a1ac-1591c00e7b73",
              "input" : "nums = [1,5,10,15], k = 2, x = 10"
            }
          ]
        },
        {
          "approach" : "1. Use binary search to find the closest element to the target. 2. Initialize two pointers, one before and one after the found element. 3. Compare the absolute differences of the elements at these pointers and move the pointers accordingly to find the K closest elements.",
          "code" : "\nimport Foundation\n\nfunc findKClosestElementsOptimized(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n    var left = 0\n    var right = nums.count - k\n    \n    while left < right {\n        let mid = (left + right) \/ 2\n        if x - nums[mid] > nums[mid + k] - x {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    \n    return Array(nums[left..<left+k])\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant since we are only using a constant amount of space to store the pointers and other variables.",
            "time" : "O(log(n - k) + k)",
            "timeExplanation" : "The time complexity involves a binary search to find the starting point, followed by a linear expansion to find the K closest elements."
          },
          "explanation" : "This method is optimized by using binary search to quickly find a starting point near the closest element, then iteratively expanding outward with two pointers to find the K closest elements, taking advantage of the sorted nature of the array.",
          "id" : "ab797e64-c901-4935-b57c-0f1113cd28a6",
          "intuition" : "The optimized approach leverages a binary search to efficiently find the starting point of the subarray containing the K closest elements, then expands from there, ensuring a significant reduction in complexity compared to the brute force method.",
          "name" : "Optimized Binary Search",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,3,4]",
              "explanation" : "The four closest elements to 3 in the array [1,2,3,4,5] are indeed 1, 2, 3, and 4.",
              "id" : "8544a08b-7e5b-4e6f-b28b-8396ee4cc1e0",
              "input" : "nums = [1,2,3,4,5], k = 4, x = 3"
            },
            {
              "expectedOutput" : "[5,10]",
              "explanation" : "The two closest elements to 10 in the array [1,5,10,15] are indeed 5 and 10.",
              "id" : "a2d7684c-35ab-4816-b9a1-8bee280fa0d5",
              "input" : "nums = [1,5,10,15], k = 2, x = 10"
            }
          ]
        }
      ],
      "id" : "b3648aa9-8c91-4cd4-8c22-7d1ea3c54014",
      "lastUpdated" : "2026-02-06T21:31:52Z",
      "problemSlug" : "find-k-closest-elements",
      "relatedProblems" : [
        "find-k-pairs-with-smallest-sums",
        "kth-smallest-element-in-a-sorted-matrix"
      ],
      "summary" : "The problem requires finding K closest elements to a given target in a sorted array, leveraging the insight that the closest elements will be those whose absolute differences with the target are smallest."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Phase 1 - Find intersection:\n   - slow = nums[slow], fast = nums[nums[fast]]\n   - Continue until they meet (inside cycle)\n2. Phase 2 - Find entry point:\n   - Reset slow to start (index 0)\n   - Move both one step at a time\n   - They meet at the duplicate",
          "code" : "func findDuplicate(_ nums: [Int]) -> Int {\n    \/\/ Phase 1: Find intersection point\n    var slow = nums[0]\n    var fast = nums[0]\n    \n    repeat {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    } while slow != fast\n    \n    \/\/ Phase 2: Find cycle entry (the duplicate)\n    slow = nums[0]\n    while slow != fast {\n        slow = nums[slow]\n        fast = nums[fast]\n    }\n    \n    return slow\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only use two pointer variables",
            "time" : "O(n)",
            "timeExplanation" : "Each phase traverses at most n elements"
          },
          "explanation" : "Why does this work? Consider the array as a graph where index i has an edge to index nums[i].\n\nSince values are in [1,n] and we start at index 0, we never revisit 0. But since there's a duplicate value, some index is pointed to by two different indices - that's our cycle entry.\n\nThe math for why phase 2 works: if slow traveled distance d to the meeting point, and cycle length is C, then fast traveled 2d. The meeting point is d mod C steps into the cycle. The entry point is exactly d mod C steps back, which equals the distance from start.",
          "id" : "550e8400-e29b-41d4-a716-446655440116",
          "intuition" : "Treat the array as a linked list where nums[i] points to index nums[i]. Since there's a duplicate, two indices point to the same location, creating a cycle.\n\nThe cycle's entry point is the duplicate value.",
          "name" : "Floyd's Cycle Detection",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "Graph: 013242 (cycle at 2). Duplicate is 2",
              "id" : "550e8400-e29b-41d4-a716-446655440216",
              "input" : "[1,3,4,2,2]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Graph: 03423 (cycle at 3). Duplicate is 3",
              "id" : "550e8400-e29b-41d4-a716-446655440217",
              "input" : "[3,1,3,4,2]"
            }
          ]
        },
        {
          "approach" : "1. Set lo = 1, hi = n\n2. While lo < hi:\n   - mid = (lo + hi) \/ 2\n   - Count elements  mid\n   - If count > mid: hi = mid (duplicate in lower half)\n   - Else: lo = mid + 1\n3. Return lo",
          "code" : "func findDuplicate(_ nums: [Int]) -> Int {\n    var lo = 1\n    var hi = nums.count - 1\n    \n    while lo < hi {\n        let mid = lo + (hi - lo) \/ 2\n        let count = nums.filter { $0 <= mid }.count\n        \n        if count > mid {\n            hi = mid  \/\/ Duplicate in lower half\n        } else {\n            lo = mid + 1  \/\/ Duplicate in upper half\n        }\n    }\n    \n    return lo\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only use a few variables",
            "time" : "O(n log n)",
            "timeExplanation" : "O(log n) binary search iterations, each counting O(n) elements"
          },
          "explanation" : "The pigeonhole principle: if we have more than mid numbers in [1,mid], at least one must be duplicated.\n\nThis doesn't find which number is duplicated directly - it narrows down the range until lo == hi, which is the duplicate.\n\nExample: [1,3,4,2,2]. Count  2 is 3 (elements 1,2,2). Since 3 > 2, duplicate is in [1,2]. Count  1 is 1. So duplicate is 2.",
          "id" : "550e8400-e29b-41d4-a716-446655440117",
          "intuition" : "Binary search on the answer space [1,n]. For a candidate mid, count numbers  mid. If count > mid, duplicate is in [1,mid].",
          "name" : "Binary Search on Value Range",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "Graph: 013242 (cycle at 2). Duplicate is 2",
              "id" : "fd27b3e5-0357-434a-9355-315ceac2264f",
              "input" : "[1,3,4,2,2]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Graph: 03423 (cycle at 3). Duplicate is 3",
              "id" : "6e592fc3-d3f0-4a1e-9cc1-e6c4951a19db",
              "input" : "[3,1,3,4,2]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440009",
      "lastUpdated" : "2026-02-04T00:00:00Z",
      "problemSlug" : "find-the-duplicate-number",
      "relatedProblems" : [
        "linked-list-cycle-ii",
        "missing-number"
      ],
      "summary" : "Find the duplicate in array of n+1 integers where each is in [1,n]. Use Floyd's cycle detection - treat values as pointers to create a linked list with a cycle at the duplicate."
    },
    {
      "approaches" : [
        {
          "approach" : "For each position in the main string, compare the substring with the corresponding part of the main string to check for a match.",
          "code" : "func strStr(_ haystack: String, _ needle: String) -> Int { let haystack = Array(haystack), needle = Array(needle); if needle.count == 0 { return 0 } else { for i in 0..<haystack.count-needle.count+1 { if Array(haystack[i..<i+needle.count]) == needle { return i } } }; return -1 }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) as no additional space that scales with input size is used.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) due to the nested loop structure where n is the length of the main string and m is the length of the substring."
          },
          "explanation" : "This approach involves a nested loop structure, where the outer loop iterates over all possible starting indices of the substring in the main string, and the inner loop compares the substring with the part of the main string starting at the current index.",
          "id" : "39dba0ba-4aa7-40e0-a64a-f43229944124",
          "intuition" : "This approach works by checking all possible starting indices of the substring in the main string and verifying if the substring matches at that position.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The first occurrence of the substring \"ll\" is at index 2 in the string \"hello\".",
              "id" : "10f82d91-93ea-4e71-92da-1307f9e26265",
              "input" : "haystack = \"hello\", needle = \"ll\""
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "The substring \"bba\" does not exist in the string \"aaaaa\", hence the function returns -1.",
              "id" : "2cc3115d-2fba-4e90-a500-970e3c65dca6",
              "input" : "haystack = \"aaaaa\", needle = \"bba\""
            }
          ]
        },
        {
          "approach" : "First, compute the lps array for the substring. Then, iterate over the main string and use the lps array to skip unnecessary comparisons and efficiently find the first occurrence of the substring.",
          "code" : "func strStr(_ haystack: String, _ needle: String) -> Int { let haystack = Array(haystack), needle = Array(needle); if needle.count == 0 { return 0 } else { let lps = computeLPS(needle); var i = 0, j = 0; while i < haystack.count { if needle[j] == haystack[i] { i += 1; j += 1; if j == needle.count { return i - j } } else if j != 0 { j = lps[j-1] } else { i += 1 } }; return -1 }; func computeLPS(_ pattern: [Character]) -> [Int] { var lps = Array(repeating: 0, count: pattern.count); var length = 0; var i = 1; while i < pattern.count { if pattern[i] == pattern[length] { length += 1; lps[i] = length; i += 1 } else if length != 0 { length = lps[length-1] } else { lps[i] = 0; i += 1 } }; return lps }",
          "complexity" : {
            "space" : "O(m)",
            "spaceExplanation" : "The space complexity is O(m) due to the storage required for the lps array of size m, where m is the length of the substring.",
            "time" : "O(n+m)",
            "timeExplanation" : "The time complexity is O(n+m) as we make a single pass over the main string and the substring to compute the lps array."
          },
          "explanation" : "The lps array is used to keep track of the length of the longest proper prefix that is also a proper suffix for the substring. This allows for efficient skipping of characters in the main string during the matching process.",
          "id" : "6226a908-8484-45a0-8ccd-b3640d772fc0",
          "intuition" : "This approach utilizes the KMP algorithm to pre-compute the longest prefix suffix (lps) array for the substring, reducing unnecessary comparisons during the matching process.",
          "name" : "Optimized KMP (Knuth-Morris-Pratt) Algorithm",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The KMP algorithm efficiently finds the first occurrence of the substring \"ll\" at index 2 in the string \"hello\".",
              "id" : "3b5a063d-ac8b-47c7-a3d9-80af0b4e67c2",
              "input" : "haystack = \"hello\", needle = \"ll\""
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The KMP algorithm correctly identifies the first occurrence of the substring \"abc\" at index 0 in the string \"abcabc\".",
              "id" : "0ae60c2b-e2ca-4117-bfe5-c352887a98bc",
              "input" : "haystack = \"abcabc\", needle = \"abc\""
            }
          ]
        }
      ],
      "id" : "754a7949-8825-46a0-b21c-7fc664d5a93b",
      "lastUpdated" : "2026-02-06T21:04:26Z",
      "problemSlug" : "find-the-index-of-the-first-occurrence-in-a-string",
      "relatedProblems" : [
        "implement-strstr",
        "kmp-algorithm-for-pattern-searching"
      ],
      "summary" : "This problem involves finding the index of the first occurrence of a substring in a given string, with the key insight being to utilize string matching techniques to achieve efficient solutions."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a copy of the input matrix. 2. Iterate through each row in the matrix. 3. For each row, iterate from the start and end, swapping elements and inverting them. 4. Return the modified matrix.",
          "code" : "func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { var left = 0; var right = result[i].count - 1; while left <= right { if result[i][left] == result[i][right] { result[i][left] = 1 - result[i][left]; result[i][right] = 1 - result[i][right]; } left += 1; right -= 1; } } return result; }",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We are creating a copy of the input matrix, so the space complexity is also proportional to the number of elements in the matrix.",
            "time" : "O(n*m)",
            "timeExplanation" : "We are iterating over the matrix once, so the time complexity is proportional to the number of elements in the matrix."
          },
          "explanation" : "This approach uses a simple iterative method to flip and invert the matrix. The time complexity is O(n*m) where n is the number of rows and m is the number of columns in the matrix.",
          "id" : "a1c43e1b-44f6-43af-bc45-5dc9292d10ed",
          "intuition" : "This approach works by iterating through each element in the matrix, flipping it, and then inverting it.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,0,0],[0,1,0],[1,1,1]]",
              "explanation" : "The image is flipped and then inverted.",
              "id" : "f1e753bd-5df9-42c6-bbdc-546882e66e60",
              "input" : "image = [[1,1,0],[1,0,1],[0,0,0]]"
            },
            {
              "expectedOutput" : "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]",
              "explanation" : "The image is flipped and then inverted.",
              "id" : "df54e814-4cda-4cf7-8ba1-b2992ad6c52f",
              "input" : "image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]"
            }
          ]
        },
        {
          "approach" : "1. Iterate through each row in the matrix. 2. For each row, iterate from the start and end, swapping and inverting elements using bitwise XOR operation. 3. Return the modified matrix.",
          "code" : "func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { for j in 0..<result[i].count\/2 { result[i].swapAt(j, result[i].count - j - 1); result[i][j] = result[i][j] ^ 1; result[i][result[i].count - j - 1] = result[i][result[i].count - j - 1] ^ 1; } if result[i].count % 2 == 1 { result[i][result[i].count\/2] = result[i][result[i].count\/2] ^ 1; } } return result; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We are no longer creating a copy of the input matrix, so the space complexity is constant.",
            "time" : "O(n*m)",
            "timeExplanation" : "We are still iterating over the matrix once, so the time complexity is proportional to the number of elements in the matrix."
          },
          "explanation" : "This approach uses bitwise XOR operation to flip and invert the matrix. The time complexity is O(n*m) where n is the number of rows and m is the number of columns in the matrix.",
          "id" : "3c66c2fb-4aea-46ae-91e3-e6fa4e831b28",
          "intuition" : "This approach works by flipping the matrix in-place and then inverting it using bitwise operations.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,0,0],[0,1,0],[1,1,1]]",
              "explanation" : "The image is flipped and then inverted.",
              "id" : "64f9883d-6c2a-40a5-ab8a-2ca2a1a7503a",
              "input" : "image = [[1,1,0],[1,0,1],[0,0,0]]"
            },
            {
              "expectedOutput" : "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]",
              "explanation" : "The image is flipped and then inverted.",
              "id" : "f3912cdb-35be-412d-99ed-3e6c1d7d6464",
              "input" : "image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]"
            }
          ]
        }
      ],
      "id" : "e2fdeab0-0e48-4bf2-a4bb-1ab5fef62cdb",
      "lastUpdated" : "2026-02-06T21:42:55Z",
      "problemSlug" : "flipping-an-image",
      "relatedProblems" : [
        "transpose-and-flip-matrix",
        "rotate-image",
        "matrix-rotation"
      ],
      "summary" : "Given a binary matrix representing an image, the task is to flip the image horizontally and then invert it. The key insight is to perform these operations iteratively or using bitwise operations."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through the array of ages, and for each age, check all previous ages to see if they can be friends based on the given conditions.",
          "code" : "func numFriendRequests(ages: [Int]) -> Int {\n    var count = 0\n    for (i, ageA) in ages.enumerated() {\n        for j in 0..<i {\n            let ageB = ages[j]\n            if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n                count += 1\n            }\n            if ageA < ageB * 2 {\n                count += 1\n            }\n        }\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We are using a constant amount of space to store our count of friendships and other variables, hence the space complexity is constant.",
            "time" : "O(n^2)",
            "timeExplanation" : "We are using two nested loops, each going through the array of ages, hence the time complexity is quadratic."
          },
          "explanation" : "We start by iterating over each age in the array. For each age, we go through all the previous ages and apply the conditions for friendship. If the conditions are met, we increment our count of friendships.",
          "id" : "db36bf9d-e316-4785-8f4d-ccde64d045c2",
          "intuition" : "This approach works by checking every possible pair of friends and counting those that satisfy the given age conditions.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two 16-year-olds can be friends with each other.",
              "id" : "e2bfa747-3a99-482b-b3b1-597b82a912bc",
              "input" : "ages = [16,16]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The 16-year-old and the 17-year-old can be friends, and the 17-year-old and the 18-year-old can be friends.",
              "id" : "a8c0dc1c-5072-49b9-b04c-d620f17a5710",
              "input" : "ages = [16,17,18]"
            }
          ]
        },
        {
          "approach" : "Create a frequency array to store the count of each age, then for each age, calculate the count of ages that can be friends based on the given conditions.",
          "code" : "func numFriendRequests(ages: [Int]) -> Int {\n    var count = 0\n    var freq: [Int: Int] = [:]\n    for age in ages {\n        freq[age, default: 0] += 1\n    }\n    for ageA in freq.keys {\n        for ageB in freq.keys {\n            if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n                count += freq[ageA]! * freq[ageB]!\n            }\n            if ageA < ageB * 2 {\n                count += freq[ageA]! * freq[ageB]!\n            }\n        }\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(uniqueAges)",
            "spaceExplanation" : "We are using a frequency array to store the count of each age, hence the space complexity is linear in the number of unique ages.",
            "time" : "O(n*uniqueAges)",
            "timeExplanation" : "We are iterating over the unique ages and for each age, we are iterating over the unique ages again, hence the time complexity is linear times the number of unique ages."
          },
          "explanation" : "We start by counting the frequency of each age. Then, for each age, we calculate the count of ages that can be friends based on the conditions. We add this count to our total count of friendships.",
          "id" : "ecffc6e1-6112-4abe-a999-589e0471d87b",
          "intuition" : "This approach works by counting the number of ages that satisfy the given conditions for each age, thereby reducing the number of comparisons needed.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two 16-year-olds can be friends with each other.",
              "id" : "35c5a14b-285d-426a-adaa-d4f78d8e701f",
              "input" : "ages = [16,16]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "There are four valid friend requests.",
              "id" : "89fd8963-7bbe-4e1c-a598-0750774b9d49",
              "input" : "ages = [13,19,9,5,15,14]"
            }
          ]
        }
      ],
      "id" : "3f68a2ae-18c6-4863-9f90-a3f36202541f",
      "lastUpdated" : "2026-02-06T21:42:34Z",
      "problemSlug" : "friends-of-appropriate-ages",
      "relatedProblems" : [
        "find-all-people-with-secret",
        "validate-stack-sequences"
      ],
      "summary" : "Friends Of Appropriate Ages is a problem where we need to find the number of friendships based on age conditions, the key insight is to iterate through ages and apply conditions."
    },
    {
      "approaches" : [
        {
          "approach" : "First, we sort both the houses and heaters arrays. Then for each house, we calculate the distance to every heater and update our radius if a closer heater is found.",
          "code" : "func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; for house in houses { var minDistance = Int.max; for heater in heaters { minDistance = min(minDistance, abs(house - heater)); } radius = max(radius, minDistance); } return radius; }",
          "complexity" : {
            "space" : "O(n logn)",
            "spaceExplanation" : "The space complexity comes from the space required to store the sorted houses and heaters arrays.",
            "time" : "O(n^2 logn)",
            "timeExplanation" : "The time complexity comes from the nested loop over houses and heaters, each of which first requires a sorting operation."
          },
          "explanation" : "We start by initializing our radius to a very large number. We then iterate through each house and for each house, we iterate through each heater. If the heater is within our current radius, we update our radius to be the minimum between the current radius and the distance from the house to the heater.",
          "id" : "dfda1543-7528-48e4-b61f-185270228cbf",
          "intuition" : "This approach works by iterating over all possible pairs of houses and heaters to find the minimum radius required to cover all houses.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The only heater is placed in between the first and second houses.",
              "id" : "3d90d754-f2b6-49a8-9868-2e106942c0f3",
              "input" : "houses = [1,2,3], heaters = [2]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "Heaters are placed at the first and last houses. The distance from the second house to the first heater is 1, and from the third house to the last heater is also 1.",
              "id" : "254c3023-9e13-4240-90c2-3f03fbe7fc33",
              "input" : "houses = [1,2,3,4], heaters = [1,4]"
            }
          ]
        },
        {
          "approach" : "We start by initializing two pointers, one at the start of the houses array and one at the start of the heaters array. We then iterate through the houses array, moving the heater pointer forward whenever we find a house that is closer to the next heater than to the current one.",
          "code" : "func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; var heaterIndex = 0; for house in houses { while heaterIndex + 1 < heaters.count && abs(house - heaters[heaterIndex + 1]) <= abs(house - heaters[heaterIndex]) { heaterIndex += 1; } radius = max(radius, abs(house - heaters[heaterIndex])); } return radius; }",
          "complexity" : {
            "space" : "O(n logn)",
            "spaceExplanation" : "The space complexity comes from the space required to store the sorted houses and heaters arrays.",
            "time" : "O(n logn)",
            "timeExplanation" : "The time complexity comes from the single pass through the houses array and the initial sorting of the houses and heaters arrays."
          },
          "explanation" : "We keep track of the minimum distance from the current house to the current heater and the next heater, and update our radius accordingly.",
          "id" : "3df10b64-efac-4f2b-8de6-5c337411cd97",
          "intuition" : "This approach works by using a two-pointer technique to find the nearest heater for each house, taking advantage of the fact that both the houses and heaters arrays are sorted.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The first house is 1 unit away from the first heater, and the second house is 2 units away from the second heater.",
              "id" : "b6c65754-c824-48f6-ab17-9d2a94bf5e6d",
              "input" : "houses = [1,5], heaters = [2,3]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The only heater is placed in between the first and second houses.",
              "id" : "8604f268-030c-4262-a06d-fa20fb58aa31",
              "input" : "houses = [1,2,3], heaters = [2]"
            }
          ]
        }
      ],
      "id" : "59c6f9be-2a03-4c02-9c1c-f63c7a92a437",
      "lastUpdated" : "2026-02-06T21:21:10Z",
      "problemSlug" : "heaters",
      "relatedProblems" : [
        "array-partition-i",
        "closest-binary-search-tree-value"
      ],
      "summary" : "The problem involves finding the minimum radius to cover all houses with heaters. The key insight here is to first sort both the houses and heaters arrays, then iterate through the houses to find the nearest heater and update the radius accordingly."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Create an empty result set to store unique intersection elements. Step 2: Iterate over each element in the first array. Step 3: For each element, iterate over the second array to check if the element exists. Step 4: If the element exists and is not already in the result set, add it to the result set.",
          "code" : "\n       func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n           var result = Set<Int>()\n           for num1 in nums1 {\n               for num2 in nums2 {\n                   if num1 == num2 && !result.contains(num1) {\n                       result.insert(num1)\n                   }\n               }\n           }\n           return Array(result)\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "In the worst case, if all elements are unique and exist in both arrays, we store n elements in the result set.",
            "time" : "O(n*m)",
            "timeExplanation" : "We iterate over each element in the first array (n elements) and then over each element in the second array (m elements)."
          },
          "explanation" : "This brute-force solution has a time complexity of O(n*m) because in the worst-case scenario, we are iterating over each element in the first array and then over each element in the second array.",
          "id" : "68cb5ac9-3c9d-437d-a4ab-dab9280a5689",
          "intuition" : "This approach works by iterating over each element in the first array and checking if it exists in the second array.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2]",
              "explanation" : "The intersection of the two arrays is [2] because it is the only element that exists in both arrays.",
              "id" : "a052da4a-dcf3-44e2-bde9-1780a3f9e475",
              "input" : "nums1 = [1,2,2,1], nums2 = [2,2]"
            },
            {
              "expectedOutput" : "[4,9]",
              "explanation" : "The intersection of the two arrays is [4,9] because these are the elements that exist in both arrays.",
              "id" : "8ef98d3c-e0d2-4a47-b367-ab634f275a6a",
              "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]"
            }
          ]
        },
        {
          "approach" : "Step 1: Create a hash table from the first array. Step 2: Create a result set to store unique intersection elements. Step 3: Iterate over the second array and check if each element exists in the hash table. Step 4: If an element exists and is not already in the result set, add it to the result set.",
          "code" : "\n       func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n           var hashTable = Set<Int>(nums1)\n           var result = Set<Int>()\n           for num in nums2 {\n               if hashTable.contains(num) {\n                   result.insert(num)\n               }\n           }\n           return Array(result)\n       }\n       ",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "We store elements from both arrays in the hash table and the result set.",
            "time" : "O(n + m)",
            "timeExplanation" : "We iterate over the first array to create the hash table (n elements) and then over the second array (m elements)."
          },
          "explanation" : "This optimized solution has a time complexity of O(n + m) because we are performing a constant time lookup for each element in the second array.",
          "id" : "c6697096-a86c-447d-88a1-650b18877f7f",
          "intuition" : "This approach works by using a hash table to store elements from the first array and then checking which elements from the second array exist in the hash table.",
          "name" : "Hash Table",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2]",
              "explanation" : "The intersection of the two arrays is [2] because it is the only element that exists in both arrays.",
              "id" : "ed1cdf99-2095-4897-91d7-7b20487c6e4a",
              "input" : "nums1 = [1,2,2,1], nums2 = [2,2]"
            },
            {
              "expectedOutput" : "[4,9]",
              "explanation" : "The intersection of the two arrays is [4,9] because these are the elements that exist in both arrays.",
              "id" : "485a7e8c-7033-47f5-a95c-bdeb91287707",
              "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]"
            }
          ]
        }
      ],
      "id" : "6cfc6916-0ad6-4d87-8905-3800a31a0ddb",
      "lastUpdated" : "2026-02-06T21:13:52Z",
      "problemSlug" : "intersection-of-two-arrays",
      "relatedProblems" : [
        "intersection-of-two-arrays-ii",
        "intersection-of-three-arrays"
      ],
      "summary" : "This problem involves finding the intersection of two arrays, which can be solved using hash tables or two pointers. The key insight is to use a data structure that allows for efficient lookups."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize an empty hash table to store counts of elements from the first array. Step 2: For each element in the first array, store or increment its count in the hash table. Step 3: For each element in the second array, check if it exists in the hash table and decrement its count if found. Step 4: Collect elements from the hash table with non-zero counts.",
          "code" : "let intersect = func(_ nums1: [Int], _ nums2: [Int]) -> [Int] { let dict1 = Dictionary(grouping: nums1, by: { $0 }).mapValues({ $0.count }); let dict2 = Dictionary(grouping: nums2, by: { $0 }).mapValues({ $0.count }); var result = [Int](); for (value, count) in dict1 { if let count2 = dict2[value] { let minimumCount = min(count, count2); result.append(contentsOf: Array(repeating: value, count: minimumCount)) } }; return result }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "The space used by the hash tables is proportional to the sizes of the input arrays, hence O(n + m).",
            "time" : "O(n + m)",
            "timeExplanation" : "Constructing the hash tables takes O(n) and O(m) time respectively, where n and m are the sizes of the input arrays."
          },
          "explanation" : "By tracking counts of elements in the hash table, we can efficiently count the occurrences of each element and then construct the intersection array based on these counts.",
          "id" : "d1eba3ff-63d0-4075-bcdd-6f7faa7e1505",
          "intuition" : "To find the intersection, we can compare each element in the first array with all elements in the second array, tracking counts of matching elements.",
          "name" : "Brute-Force Hash Table",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2,2]",
              "explanation" : "Since both 2's in the second array match with the two 2's in the first array, the result contains two 2's.",
              "id" : "c4e89d66-0b80-46a1-a5fd-f66884ec0d56",
              "input" : "nums1 = [1,2,2,1], nums2 = [2,2]"
            },
            {
              "expectedOutput" : "[4,9]",
              "explanation" : "The intersection must contain one 4 and one 9 because these are the elements common to both arrays.",
              "id" : "2170646b-65bd-4ae9-b7a3-5398a10fd605",
              "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]"
            }
          ]
        },
        {
          "approach" : "Step 1: Sort both arrays. Step 2: Initialize two pointers, one for each array. Step 3: Compare the elements at the pointers. If they match, add the element to the result and increment both pointers. If one is less than the other, increment the corresponding pointer.",
          "code" : "let intersect = func(_ nums1: [Int], _ nums2: [Int]) -> [Int] { let sortedNums1 = nums1.sorted(); let sortedNums2 = nums2.sorted(); var result = [Int](); var i = 0; var j = 0; while i < sortedNums1.count && j < sortedNums2.count { if sortedNums1[i] == sortedNums2[j] { result.append(sortedNums1[i]); i += 1; j += 1 } else if sortedNums1[i] < sortedNums2[j] { i += 1 } else { j += 1 } }; return result }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "Sorting in-place does not apply here because we need to keep the original arrays and create new sorted ones, hence O(n + m) for storing the sorted arrays.",
            "time" : "O(n log n + m log m)",
            "timeExplanation" : "Sorting each array takes O(n log n) and O(m log m) time, respectively."
          },
          "explanation" : "This approach takes advantage of the fact that the arrays are sorted, allowing for efficient comparison and iteration through the arrays with two pointers.",
          "id" : "12e06ab9-d289-414e-94b0-6c885dc8f6eb",
          "intuition" : "Given sorted arrays, we can use two pointers to efficiently compare elements and find the intersection.",
          "name" : "Two Pointers (Sorted Arrays)",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2,2]",
              "explanation" : "Since both 2's in the second array match with the two 2's in the first array, the result contains two 2's.",
              "id" : "fd4b7ef8-dd2f-4be1-94ae-0df7880d3194",
              "input" : "nums1 = [1,2,2,1], nums2 = [2,2]"
            },
            {
              "expectedOutput" : "[4,9]",
              "explanation" : "The intersection must contain one 4 and one 9 because these are the elements common to both arrays.",
              "id" : "cb6e9acb-e656-4754-9bad-3ab35d07026f",
              "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]"
            }
          ]
        }
      ],
      "id" : "786e55b1-7572-4783-9f8b-acde810330fb",
      "lastUpdated" : "2026-02-06T21:13:57Z",
      "problemSlug" : "intersection-of-two-arrays-ii",
      "relatedProblems" : [
        "single-number",
        "intersection-of-two-arrays"
      ],
      "summary" : "Given two arrays, find their intersection and return the intersection in sorted order. Key insight is to leverage hash tables to store counts of elements."
    },
    {
      "approaches" : [
        {
          "approach" : "For each interval in the first list, iterate over the second list and check if the current interval overlaps with any interval in the second list. If an overlap is found, add the overlap to the result list.",
          "code" : "func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity is also O(n*m) because in the worst case, the result list will contain n*m intervals.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because in the worst case, every interval in the first list overlaps with every interval in the second list."
          },
          "explanation" : "This approach works by checking every possible combination of intervals from the two lists. However, this results in a time complexity of O(n*m), where n and m are the lengths of the two lists.",
          "id" : "1019ea6b-475b-407b-814a-9527e9dedff6",
          "intuition" : "The brute force approach involves comparing every interval from the first list with every interval from the second list to find any overlap.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
              "explanation" : "In this example, the overlap between the intervals [0,2] and [1,5] is [1,2]. The overlap between the intervals [5,10] and [1,5] is [5,5]. The overlap between the intervals [5,10] and [8,12] is [8,10]. The overlap between the intervals [13,23] and [15,24] is [15,23]. The overlap between the intervals [24,25] and [25,26] is [25,25].",
              "id" : "9d3da606-634f-4267-9303-dadf2aaf1260",
              "input" : "A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]"
            },
            {
              "expectedOutput" : "[[5,7]]",
              "explanation" : "In this example, the only overlap is between the intervals [5,7] and [5,10].",
              "id" : "13547dce-9b71-4ab6-ba5e-c3c4a0e2a18c",
              "input" : "A = [[1,3],[5,7],[9,12]], B = [[5,10]]"
            }
          ]
        },
        {
          "approach" : "Initialize two pointers, one at the start of the first list and one at the start of the second list. Compare the start and end of the current intervals from the two lists. If the current intervals overlap, add the overlap to the result list and move the pointer of the interval that ends earlier. If the current intervals do not overlap, move the pointer of the interval that ends earlier.",
          "code" : "func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }",
          "complexity" : {
            "space" : "O(n+m)",
            "spaceExplanation" : "The space complexity is O(n+m) because in the worst case, the result list will contain n+m intervals.",
            "time" : "O(n+m)",
            "timeExplanation" : "The time complexity is O(n+m) because each interval from the two lists is visited at most once."
          },
          "explanation" : "This approach works by comparing the current intervals from the two lists and finding any overlap. The time complexity is O(n+m), where n and m are the lengths of the two lists.",
          "id" : "31c2ce26-4c46-4c08-8f72-a7e401ec4124",
          "intuition" : "The two pointers approach involves using two pointers, one for each list, to compare the start and end of each interval and find any overlap.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
              "explanation" : "In this example, the overlap between the intervals [0,2] and [1,5] is [1,2]. The overlap between the intervals [5,10] and [1,5] is [5,5]. The overlap between the intervals [5,10] and [8,12] is [8,10]. The overlap between the intervals [13,23] and [15,24] is [15,23]. The overlap between the intervals [24,25] and [25,26] is [25,25].",
              "id" : "b907aa37-24d7-45f4-a453-87eec6ca38dc",
              "input" : "A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]"
            },
            {
              "expectedOutput" : "[[5,7]]",
              "explanation" : "In this example, the only overlap is between the intervals [5,7] and [5,10].",
              "id" : "959a441d-7ff3-4ec8-b855-750a69b43fed",
              "input" : "A = [[1,3],[5,7],[9,12]], B = [[5,10]]"
            }
          ]
        }
      ],
      "id" : "4ca89858-2bb2-44dd-a873-71aef59acff4",
      "lastUpdated" : "2026-02-06T21:53:20Z",
      "problemSlug" : "interval-list-intersections",
      "relatedProblems" : [
        "insert-interval",
        "merge-intervals"
      ],
      "summary" : "This problem asks us to find the intersection of two lists of intervals. The key insight is to use two pointers, one for each list, to compare the start and end of each interval and find any overlap."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a recursive function that checks if the current character in the potential subsequence matches the current character in the given string. 2. If the characters match, move to the next character in both strings. 3. If the characters do not match, move to the next character in the given string and keep the current character in the potential subsequence.",
          "code" : "func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1), which means the space required does not change with the size of the input string, making it very space-efficient.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the length of string s and m is the length of string t, because in the worst-case scenario we may need to iterate through all characters in string t for each character in string s."
          },
          "explanation" : "The brute-force approach checks all possible subsequences in the given string. Although it guarantees a correct answer, it does so at a high computational cost due to its recursive nature and lack of optimization.",
          "id" : "78c67530-325e-4fa7-a5e6-e6bbae67d69b",
          "intuition" : "This approach works by checking every possible subsequence in the given string, comparing each character to the corresponding character in the potential subsequence.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Subsequence 'abc' is found in 'ahbgdc'.",
              "id" : "f2ebe76d-eb17-4797-a327-005d719184d4",
              "input" : "s = \"abc\", t = \"ahbgdc\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "Subsequence 'axc' is not found in 'ahbgdc'.",
              "id" : "379ae492-f92d-4c30-965b-5c152e0fd9c2",
              "input" : "s = \"axc\", t = \"ahbgdc\""
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers, one at the beginning of each string. 2. Compare the characters at the current positions of the two pointers. If they match, move the pointer for string s one step forward. 3. Regardless of a match, move the pointer for string t one step forward. 4. Repeat steps 2-3 until the end of either string is reached.",
          "code" : "func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var sIndex = 0; var tIndex = 0; while sIndex < sChars.count && tIndex < tChars.count { if sChars[sIndex] == tChars[tIndex] { sIndex += 1 } tIndex += 1 } return sIndex == sChars.count }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1), which means the space required does not change with the size of the input string, making it very space-efficient.",
            "time" : "O(m)",
            "timeExplanation" : "The time complexity is O(m) where m is the length of string t, because in the worst-case scenario we may need to iterate through all characters in string t once."
          },
          "explanation" : "The optimized approach uses two pointers to compare characters and only moves the pointer for string s when a match is found, reducing the number of comparisons needed.",
          "id" : "67dc7fd9-eda8-4a60-9ca4-5ddf0d7cd26f",
          "intuition" : "This approach works by using two pointers, one for each string, and moving the pointers based on whether the current characters in the strings match.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Subsequence 'abc' is found in 'ahbgdc'.",
              "id" : "a9067c2a-db60-45c0-a8f0-b2356f218e65",
              "input" : "s = \"abc\", t = \"ahbgdc\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "Subsequence 'axc' is not found in 'ahbgdc'.",
              "id" : "16180c9d-c417-47d2-8b3c-92c31110fc01",
              "input" : "s = \"axc\", t = \"ahbgdc\""
            }
          ]
        }
      ],
      "id" : "4e484981-fcc7-4767-ab35-ff1877805e08",
      "lastUpdated" : "2026-02-06T21:16:04Z",
      "problemSlug" : "is-subsequence",
      "relatedProblems" : [
        "string-to-integer-atoi",
        "roman-to-integer"
      ],
      "summary" : "This problem asks to determine if a given string is a subsequence of another string, and the key insight is to use two pointers to compare characters. The optimized approach uses a sliding window technique to improve efficiency."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Create an empty hash table. Step 2: Iterate over the array. Step 3: For each element in the array, check all the other elements to see if the difference between them is k. Step 4: If a pair with a difference of k is found, increment the count.",
          "code" : "func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We are not using any extra space that scales with the input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "We are iterating over the array and for each element, we are checking all the other elements."
          },
          "explanation" : "This approach has a time complexity of O(n^2) because for each element in the array, we are checking all the other elements. The space complexity is O(1) as we are not using any extra space that scales with the input size.",
          "id" : "25a07f11-7b9d-4a7a-9f37-6787b6ba74f7",
          "intuition" : "The brute-force approach works by iterating over the array and for each element, check all the other elements to see if the difference between them is k.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The pairs with a difference of 2 are (1, 3) and (1, 3).",
              "id" : "b8498460-c4c9-479e-8bd4-496851fca272",
              "input" : "nums = [3, 1, 4, 1, 5], k = 2"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The pairs with a difference of 1 are (1, 2), (2, 3), (3, 4) and (4, 5).",
              "id" : "f09dcdfd-98c7-4a03-8179-73614f38de64",
              "input" : "nums = [1, 2, 3, 4, 5], k = 1"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The pair with a difference of 0 is (1, 1).",
              "id" : "83eff77b-f332-4a14-8ad9-93f9aa980a05",
              "input" : "nums = [1, 3, 1, 5, 4], k = 0"
            }
          ]
        },
        {
          "approach" : "Step 1: Create an empty hash table. Step 2: Iterate over the array and store each element in the hash table. Step 3: For each element in the hash table, check if the element plus k or minus k is in the hash table. Step 4: If a pair with a difference of k is found, increment the count.",
          "code" : "func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are using a hash table to store the array elements.",
            "time" : "O(n)",
            "timeExplanation" : "We are iterating over the array once to store the elements in the hash table and then iterating over the hash table once to find the pairs."
          },
          "explanation" : "This approach has a time complexity of O(n) because we are iterating over the array once to store the elements in the hash table and then iterating over the hash table once to find the pairs. The space complexity is O(n) as we are using a hash table to store the array elements.",
          "id" : "76b2280a-5478-4f02-9093-74ebd2fc4b90",
          "intuition" : "The optimized approach works by using a hash table to store the array elements and then for each element, check if the element plus k or minus k is in the hash table.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The pairs with a difference of 2 are (1, 3) and (3, 5).",
              "id" : "c2a1485a-d436-4e61-b615-62a75f503027",
              "input" : "nums = [3, 1, 4, 1, 5], k = 2"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The pairs with a difference of 1 are (1, 2), (2, 3), (3, 4) and (4, 5).",
              "id" : "b9856e02-dad0-4e5b-b2a7-cf3ad1b9fa23",
              "input" : "nums = [1, 2, 3, 4, 5], k = 1"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The pair with a difference of 0 is (1, 1).",
              "id" : "97ed9e15-4ee3-445a-974f-a21f1d39676b",
              "input" : "nums = [1, 3, 1, 5, 4], k = 0"
            }
          ]
        }
      ],
      "id" : "58dc4ca3-4377-4870-a42b-2da4b49ef72f",
      "lastUpdated" : "2026-02-06T21:24:48Z",
      "problemSlug" : "k-diff-pairs-in-an-array",
      "relatedProblems" : [
        "two-sum",
        "closest-pair-with-given-sum"
      ],
      "summary" : "The LeetCode problem K-diff Pairs in an Array is to find the number of pairs of elements in an array that have a difference of k. The key insight is to use a hash table to store the array elements and then check for each element if the element plus k or minus k is in the hash table."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible fractions by dividing each numerator by each denominator, then sort these fractions and return the k-th one.",
          "code" : "\nimport Foundation\n\nfunc kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n    var fractions: [(n: Int, d: Int)] = []\n    for i in 0..<arr.count {\n        for j in i+1..<arr.count {\n            if gcd(arr[i], arr[j]) == 1 {\n                fractions.append((n: arr[i], d: arr[j]))\n            }\n        }\n    }\n    fractions.sort { $0.n * $1.d < $1.n * $0.d }\n    return \"(fractions[k-1].n)\/(fractions[k-1].d)\"\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 {\n        return a\n    }\n    return gcd(b, a % b)\n}\n",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is O(n^2) as we need to store all fractions.",
            "time" : "O(n^2 log n)",
            "timeExplanation" : "The time complexity is O(n^2 log n) due to the nested loops and sorting."
          },
          "explanation" : "The brute force approach works by generating all possible fractions, which can be done by iterating over all possible numerators and denominators. Then, these fractions are sorted in ascending order and the k-th smallest fraction is returned.",
          "id" : "c74aef35-35de-437d-ac7e-4e7b59495fea",
          "intuition" : "This approach involves generating all possible fractions and then sorting them to find the k-th smallest one.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2\/5",
              "explanation" : "The fractions in order are 1\/2, 1\/3, 2\/5, 1\/5, 2\/3, 3\/5.",
              "id" : "04eee3a8-a62b-46f3-850d-c339d92eba8f",
              "input" : "arr = [1,2,3,5], k = 3"
            },
            {
              "expectedOutput" : "1\/7",
              "explanation" : "The only fraction is 1\/7.",
              "id" : "e35ae055-c171-48b0-b13d-870b8a486fc2",
              "input" : "arr = [1,7], k = 1"
            }
          ]
        },
        {
          "approach" : "Use a min-heap to store the current smallest fractions and their corresponding indices. Start with the first numerator and all denominators, then repeatedly pop the smallest fraction from the heap, push the next fraction from the same numerator, and repeat until the k-th smallest fraction is found.",
          "code" : "\nimport Foundation\n\nfunc kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n    let n = arr.count\n    var pq: [(val: Double, i: Int, j: Int)] = []\n    for j in 1..<n {\n        if gcd(arr[0], arr[j]) == 1 {\n            pq.append((val: Double(arr[0]) \/ Double(arr[j]), i: 0, j: j))\n        }\n    }\n    var count = 0\n    while !pq.isEmpty {\n        pq.sort { $0.val < $1.val }\n        let (val, i, j) = pq.removeFirst()\n        count += 1\n        if count == k {\n            return \"(arr[i])\/(arr[j])\"\n        }\n        if i + 1 < n {\n            if gcd(arr[i+1], arr[j]) == 1 {\n                pq.append((val: Double(arr[i+1]) \/ Double(arr[j]), i: i+1, j: j))\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 {\n        return a\n    }\n    return gcd(b, a % b)\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) as we need to store the heap.",
            "time" : "O(k n log n)",
            "timeExplanation" : "The time complexity is O(k n log n) due to the heap operations and sorting."
          },
          "explanation" : "The optimized approach works by maintaining a min-heap of the smallest fractions. The heap initially contains the fractions formed by the first numerator and all denominators. We then enter a loop where we pop the smallest fraction from the heap, push the next fraction from the same numerator into the heap, and repeat this process k times.",
          "id" : "1a3ea9ab-9e8b-49a9-b8d9-532abdc3e07c",
          "intuition" : "Using a min-heap to track the smallest fractions allows us to avoid generating and sorting all fractions.",
          "name" : "Optimized with Min-Heap",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2\/5",
              "explanation" : "The fractions in order are 1\/2, 1\/3, 2\/5, 1\/5, 2\/3, 3\/5.",
              "id" : "14026d15-f601-41cd-8545-eec63418775c",
              "input" : "arr = [1,2,3,5], k = 3"
            },
            {
              "expectedOutput" : "1\/7",
              "explanation" : "The only fraction is 1\/7.",
              "id" : "e00d342a-8c5c-40ee-9e54-8a68a135d4dd",
              "input" : "arr = [1,7], k = 1"
            }
          ]
        }
      ],
      "id" : "da621fcb-80fb-47d3-b208-fafb931755b4",
      "lastUpdated" : "2026-02-06T21:39:30Z",
      "problemSlug" : "k-th-smallest-prime-fraction",
      "relatedProblems" : [
        "kth-largest-element-in-an-array",
        "find-k-pairs-with-smallest-sums"
      ],
      "summary" : "The problem requires finding the k-th smallest fraction from a list of fractions, where each fraction is less than or equal to 1 and the numerator and denominator are coprime. The key insight is to use a min-heap to track the smallest fractions."
    },
    {
      "approaches" : [
        {
          "approach" : "Start by iterating over 'typed'. For each character in 'typed', check the corresponding character in 'name'. If they are the same, move to the next character in 'name'. If they are different, check if the current character in 'typed' is the same as the last character in 'name'. If it is, continue to the next character in 'typed'. If not, return false. If all characters in 'name' are matched, return true.",
          "code" : "\n       func isLongPressedName(_ name: String, _ typed: String) -> Bool {\n           var i = 0\n           for c in typed {\n               if i < name.count && name[name.index(name.startIndex, offsetBy: i)] == c {\n                   i += 1\n               } else if i == 0 || c != name[name.index(name.startIndex, offsetBy: i - 1)] {\n                   return false\n               }\n           }\n           return i == name.count\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) as only a constant amount of space is used to store the indices.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the length of 'typed' and m is the length of 'name'. This is due to the nested loop structure."
          },
          "explanation" : "This approach is simple and intuitive but has a high time complexity due to the nested loop structure. It is used as a baseline to understand the problem before moving to an optimized solution.",
          "id" : "f6f40b35-369a-4a6b-8f7c-7e1de5774653",
          "intuition" : "This approach works by manually checking every possible substring of 'typed' against 'name' to see if 'name' can be formed by long pressing keys.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The string 'alex' can be typed by long pressing 'a' twice, then 'l', 'e' twice, then 'x'.",
              "id" : "2fd2096c-2d51-4bec-829a-5bfd5c1226be",
              "input" : "name = 'alex', typed = 'aaleex'"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The string 'saeed' cannot be typed by long pressing 's' twice, 'a' twice, 'e' twice, then 'd' twice because the 'd's are typed after the 'e's.",
              "id" : "199de40e-f299-4f8f-a05d-b0f3394d2f05",
              "input" : "name = 'saeed', typed = 'ssaaedd'"
            }
          ]
        },
        {
          "approach" : "Start by initializing two pointers, one for 'name' and one for 'typed'. Then, iterate over 'typed'. If the current character in 'typed' is the same as the current character in 'name', move to the next character in 'name'. If the current character in 'typed' is the same as the last character in 'name', continue to the next character in 'typed'. If not, return false. If all characters in 'name' are matched, return true.",
          "code" : "\n       func isLongPressedName(_ name: String, _ typed: String) -> Bool {\n           var p1 = 0\n           var p2 = 0\n           while p2 < typed.count {\n               if p1 < name.count && name[name.index(name.startIndex, offsetBy: p1)] == typed[typed.index(typed.startIndex, offsetBy: p2)] {\n                   p1 += 1\n               } else if p1 == 0 || typed[typed.index(typed.startIndex, offsetBy: p2)] != name[name.index(name.startIndex, offsetBy: p1 - 1)] {\n                   return false\n               }\n               p2 += 1\n           }\n           return p1 == name.count\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) as only a constant amount of space is used to store the indices.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) where n is the length of 'typed'. This is because we only iterate over 'typed' once."
          },
          "explanation" : "This approach is optimized and has a lower time complexity than the brute force approach. It directly uses two pointers to track the current position in both strings.",
          "id" : "d6a2dfcb-49d7-4c94-91df-4aa381077386",
          "intuition" : "This approach works by using two pointers to track the current position in 'name' and 'typed'.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The string 'pyplrz' can be typed by long pressing 'p' twice, 'y' twice, 'l', 'r' twice, then 'z' twice.",
              "id" : "cbaac6c7-d233-4efd-9d6d-e399fa125d49",
              "input" : "name = 'pyplrz', typed = 'ppyypllrzz'"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "The string 'kuoh' can be typed by long pressing 'k', 'u' twice, then 'o', 'h'.",
              "id" : "0d120826-a337-4e56-baf4-01be56d313d3",
              "input" : "name = 'kuoh', typed = 'kuuoh'"
            }
          ]
        }
      ],
      "id" : "ac8edd5e-f155-4a0b-9539-f3af8b114677",
      "lastUpdated" : "2026-02-06T21:49:04Z",
      "problemSlug" : "long-pressed-name",
      "relatedProblems" : [
        "valid-anagram",
        "group-anagrams"
      ],
      "summary" : "The problem is to determine if a string 'name' can be typed in a long press manner given a string 'typed'. The key insight is to use a two-pointer technique to compare characters."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over all possible subarrays of the input array. 2. For each subarray, check if it forms a mountain by comparing each pair of adjacent elements. 3. If the subarray forms a mountain, update the maximum length if necessary.",
          "code" : "\n         func longestMountain(_ A: [Int]) -> Int {\n             guard A.count > 2 else { return 0 }\n             var maxLength = 0\n             for i in 1..<A.count-1 {\n                 if A[i-1] < A[i] && A[i] > A[i+1] {\n                     var left = i-1, right = i+1\n                     while left > 0 && A[left-1] < A[left] {\n                         left -= 1\n                     }\n                     while right < A.count-1 && A[right] > A[right+1] {\n                         right += 1\n                     }\n                     maxLength = max(maxLength, right - left + 1)\n                 }\n             }\n             return maxLength\n         }\n         ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the maximum length and the indices of the subarray.",
            "time" : "O(n^2)",
            "timeExplanation" : "The outer loop runs in O(n) time, and the inner while loops run in O(n) time in the worst case."
          },
          "explanation" : "This approach has a high time complexity due to the nested loops used to generate all possible subarrays and check if they form a mountain.",
          "id" : "40bac9e6-01aa-4b93-9dc5-b9d87d4f361d",
          "intuition" : "This approach involves checking every possible subarray to see if it forms a mountain, and keeping track of the longest one found.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The longest mountain is [1,4,7,3,2].",
              "id" : "a622e765-0c41-42ae-9b3b-ed0e7709f177",
              "input" : "A = [2,1,4,7,3,2,5]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is no mountain in this array.",
              "id" : "ba565fc0-c4e1-4600-8847-152cb0e7176e",
              "input" : "A = [2,2,2]"
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers at the start of the array. 2. Iterate over the array, expanding the pointers outward to find a potential mountain. 3. When a mountain is found, update the maximum length if necessary.",
          "code" : "\n         func longestMountain(_ A: [Int]) -> Int {\n             guard A.count > 2 else { return 0 }\n             var maxLength = 0\n             for i in 1..<A.count-1 {\n                 if A[i-1] < A[i] && A[i] > A[i+1] {\n                     var left = i-1, right = i+1\n                     while left > 0 && A[left-1] < A[left] {\n                         left -= 1\n                     }\n                     while right < A.count-1 && A[right] > A[right+1] {\n                         right += 1\n                     }\n                     maxLength = max(maxLength, right - left + 1)\n                 }\n             }\n             return maxLength\n         }\n         ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the maximum length and the indices of the subarray.",
            "time" : "O(n)",
            "timeExplanation" : "The single loop runs in O(n) time, and the inner while loops run in O(n) time in total because each element is visited at most twice."
          },
          "explanation" : "This approach has a lower time complexity than the brute force approach because it only requires a single pass over the array.",
          "id" : "013d93f4-9f80-432d-9f1e-d145f62bcf5c",
          "intuition" : "This approach involves using two pointers to track the start and end of a potential mountain, and then expanding the pointers outward to find the longest mountain.",
          "name" : "Two Pointers Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The longest mountain is [1,4,7,3,2].",
              "id" : "f869f197-330a-43fb-9aa9-0ebfb93dfcfb",
              "input" : "A = [2,1,4,7,3,2,5]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is no mountain in this array.",
              "id" : "72dd895f-3c69-4d60-9b63-f242b93689a9",
              "input" : "A = [2,2,2]"
            }
          ]
        }
      ],
      "id" : "f079f50a-a69a-40f0-990e-b5688d8d8d21",
      "lastUpdated" : "2026-02-06T21:43:54Z",
      "problemSlug" : "longest-mountain-in-array",
      "relatedProblems" : [
        "max-consecutive-ones",
        "shortest-unsorted-continuous-subarray"
      ],
      "summary" : "The problem asks to find the length of the longest mountain in an array, where a mountain is defined as a sequence of numbers that strictly increases and then strictly decreases. The key insight is to use dynamic programming to track the length of the longest mountain at each position in the array."
    },
    {
      "approaches" : [
        {
          "approach" : "1. For each index i, expand for odd-length (center i) and even-length (center i,i+1)\n2. Track longest palindrome found\n3. Return substring",
          "code" : "func longestPalindrome(_ s: String) -> String {\n    let chars = Array(s)\n    var start = 0, maxLen = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            l -= 1; r += 1\n        }\n        return r - l - 1\n    }\n    \n    for i in 0..<chars.count {\n        let len1 = expand(i, i)      \/\/ Odd length\n        let len2 = expand(i, i + 1)  \/\/ Even length\n        let len = max(len1, len2)\n        if len > maxLen {\n            maxLen = len\n            start = i - (len - 1) \/ 2\n        }\n    }\n    \n    return String(chars[start..<start + maxLen])\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "String conversion",
            "time" : "O(n)",
            "timeExplanation" : "n centers, O(n) expansion each"
          },
          "explanation" : "2n-1 potential centers (n single chars, n-1 pairs). Each expansion is O(n) worst case.",
          "id" : "550e8400-e29b-41d4-a716-446655440142",
          "intuition" : "A palindrome has a center. Try each index as center, expand while characters match.",
          "name" : "Expand Around Center",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"bab\" or \"aba\"",
              "explanation" : "Both are valid longest palindromes",
              "id" : "550e8400-e29b-41d4-a716-446655440248",
              "input" : "\"babad\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440031",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "longest-palindromic-substring",
      "relatedProblems" : [
        "palindromic-substrings",
        "longest-palindromic-subsequence"
      ],
      "summary" : "Find longest palindrome substring. Expand from center for each position (and between positions)."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsequences of each string, store their frequency in a hash table, and then compare them to find the longest uncommon subsequence.",
          "code" : "func findLUSlength(_ strs: [String]) -> Int { let strsSet = Set(strs); var longestUncommonSubsequenceLength = -1; for str in strsSet { let isCommon = strs.allSatisfy { $0.range(of: str) != nil }; if !isCommon { longestUncommonSubsequenceLength = max(longestUncommonSubsequenceLength, str.count) } } return longestUncommonSubsequenceLength }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are using a Set to store the unique strings in the input list, which requires O(n) space.",
            "time" : "O(n*m^2)",
            "timeExplanation" : "We are using the 'allSatisfy' method on an array of n strings, each with a maximum length of m. Inside this method, we use the 'range(of:)' method which has a time complexity of O(m)."
          },
          "explanation" : "Start by defining a function to generate all possible subsequences of a string. Then, iterate over each string in the input list, and for each subsequence, check if it exists in all other strings. If not, update the maximum length of the uncommon subsequence if necessary. Finally, return the longest uncommon subsequence.",
          "id" : "31f762ce-8378-4ed3-b8e7-5d28a9a7d739",
          "intuition" : "This approach involves generating all possible subsequences of each string, storing their frequency in a hash table, and then comparing them to find the longest uncommon subsequence.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The longest uncommon subsequence is \"aba\" (or \"cdc\" or \"eae\")",
              "id" : "92d5dd5d-ada4-43b7-aaf2-dc00ce90dbe5",
              "input" : "strs = [\"aba\",\"cdc\",\"eae\"]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There are no uncommon subsequences.",
              "id" : "f5966f29-5a57-40e8-b61a-927e24393ab9",
              "input" : "strs = [\"aaa\",\"aaa\",\"aa\"]"
            }
          ]
        },
        {
          "approach" : "Sort the input list of strings by length in descending order, and then for each string, check if it is a subsequence of the remaining strings.",
          "code" : "func findLUSlength(_ strs: [String]) -> Int { let sortedStrs = strs.sorted(by: { $0.count > $1.count }); for (index, str) in sortedStrs.enumerated() { let isCommon = (0...strs.count-1).filter { $0 != index }.allSatisfy { strs[$0].range(of: str) != nil }; if !isCommon { return str.count } } return -1 }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are using a sorted array to store the input list of strings, which requires O(n) space.",
            "time" : "O(n^2*m)",
            "timeExplanation" : "We are using a nested loop structure where the outer loop iterates over the sorted list of strings, and the inner loop iterates over the remaining strings to check for the subsequence."
          },
          "explanation" : "Start by sorting the input list of strings by length in descending order. Then, iterate over each string in the sorted list, and for each string, check if it is a subsequence of the remaining strings. If it is not a subsequence of any of the remaining strings, return its length as the longest uncommon subsequence.",
          "id" : "f8188ec0-2d4c-4070-809f-976da6cee1b6",
          "intuition" : "This approach involves sorting the input list of strings by length in descending order and then checking if each string is a subsequence of the remaining strings.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The longest uncommon subsequence is \"un\" and \"iq\" and \"ue\" are not a subsequence of each other.",
              "id" : "f589a04a-e299-41b5-9356-42ae0fd83411",
              "input" : "strs = [\"un\",\"iq\",\"ue\"]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The longest uncommon subsequence is \"abc\" and \"acd\".",
              "id" : "04c54a00-51eb-4093-821a-16c1f0069fc5",
              "input" : "strs = [\"abc\",\"acd\",\"bc\",\"a\",\"a\"]"
            }
          ]
        }
      ],
      "id" : "a781a12c-bd15-4395-9ec7-09e2d6c36861",
      "lastUpdated" : "2026-02-06T21:24:01Z",
      "problemSlug" : "longest-uncommon-subsequence-ii",
      "relatedProblems" : [
        "longest-uncommon-subsequence-i",
        "length-of-longest-fibonacci-subsequence"
      ],
      "summary" : "Given a list of strings, find the longest uncommon subsequence among them, which is the longest subsequence that is not present in all strings. The key insight is to find all possible subsequences of each string and store their frequency in a hash table to compare and find the longest uncommon subsequence."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the dictionary in descending order of string length. Then, iterate through the sorted dictionary. For each string, check if it's a subsequence of the target string. If it is, and its length is greater than the current longest word, update the longest word.",
          "code" : "\nimport Foundation\n\nfunc findLongestWord(_ s: String, _ d: [String]) -> String {\n    var longestWord = \"\"\n    for word in d.sorted(by: { $0.count > $1.count }) {\n        var i = 0, j = 0\n        while i < s.count && j < word.count {\n            if s[i] == word[j] {\n                j += 1\n            }\n            i += 1\n        }\n        if j == word.count && word.count > longestWord.count {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store the longest word, which takes O(n) space in the worst case.",
            "time" : "O(n*m*log(m))",
            "timeExplanation" : "Where n is the length of the target string and m is the number of strings in the dictionary. The reason is that we first sort the dictionary which takes O(m*log(m)) time and then for each string in the dictionary, we check if it's a subsequence of the target string which takes O(n) time."
          },
          "explanation" : "This approach works but is inefficient because it has to check every string in the dictionary. It uses two nested loops, one to iterate through the dictionary and the other to check if a string is a subsequence of the target string.",
          "id" : "4a780003-bee1-4d4b-a3c9-1cd9421a6847",
          "intuition" : "The brute force approach checks every string in the dictionary to see if it's a subsequence of the target string by iterating through each character in the string and target string.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"apple\"",
              "explanation" : "The longest word in the dictionary that can be formed by deleting characters in the target string is \"apple\".",
              "id" : "bdd7bd97-6b7b-40e9-b522-5ed72cf53ecd",
              "input" : "s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]"
            },
            {
              "expectedOutput" : "\"a\"",
              "explanation" : "The longest word in the dictionary that can be formed by deleting characters in the target string is \"a\".",
              "id" : "7eadf369-6e60-4446-bd13-f31a5794c74f",
              "input" : "s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]"
            }
          ]
        },
        {
          "approach" : "First, sort the dictionary in a custom order. The custom order is defined such that two strings are ordered first by their length in descending order and then by their lexicographical order. Then, iterate through the sorted dictionary. For each string, check if it's a subsequence of the target string. If it is and its length is greater than or equal to the current longest word, update the longest word.",
          "code" : "\nimport Foundation\n\nfunc findLongestWord(_ s: String, _ d: [String]) -> String {\n    let sortedD = d.sorted { (a, b) -> Bool in\n        if a.count != b.count {\n            return a.count > b.count\n        } else {\n            return a < b\n        }\n    }\n    var longestWord = \"\"\n    for word in sortedD {\n        var i = 0, j = 0\n        while i < s.count && j < word.count {\n            if s[i] == word[j] {\n                j += 1\n            }\n            i += 1\n        }\n        if j == word.count && (word.count > longestWord.count || (word.count == longestWord.count && word < longestWord)) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store the longest word, which takes O(n) space in the worst case.",
            "time" : "O(n*m*log(m))",
            "timeExplanation" : "Where n is the length of the target string and m is the number of strings in the dictionary. The reason is that we first sort the dictionary which takes O(m*log(m)) time and then for each string in the dictionary, we check if it's a subsequence of the target string which takes O(n) time."
          },
          "explanation" : "This approach works more efficiently than the brute force approach because it sorts the dictionary in a custom order that ensures the longest word comes first.",
          "id" : "6e549a14-45b1-4943-a21a-f1935478a7e9",
          "intuition" : "The optimized approach uses the same idea as the brute force approach but sorts the dictionary in a way that ensures the longest word that can be formed by deleting characters in the target string comes first.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"apple\"",
              "explanation" : "The longest word in the dictionary that can be formed by deleting characters in the target string is \"apple\".",
              "id" : "7080c683-5e37-4285-91a9-63e6cf8afdb4",
              "input" : "s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]"
            },
            {
              "expectedOutput" : "\"a\"",
              "explanation" : "The longest word in the dictionary that can be formed by deleting characters in the target string is \"a\".",
              "id" : "b0daeaa0-ef63-42d2-a5b3-9f0004e0da70",
              "input" : "s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]"
            },
            {
              "expectedOutput" : "\"ab\"",
              "explanation" : "The longest word in the dictionary that can be formed by deleting characters in the target string is \"ab\".",
              "id" : "9ef45f33-51e2-40ba-bd03-a6e6d00ac5d0",
              "input" : "s = \"abpcplea\", d = [\"ab\",\"ale\",\"apple\",\"b\"]"
            }
          ]
        }
      ],
      "id" : "706b9001-b3c1-426c-bcef-66865783cc50",
      "lastUpdated" : "2026-02-06T21:24:11Z",
      "problemSlug" : "longest-word-in-dictionary-through-deleting",
      "relatedProblems" : [
        "subsequence-algorithm",
        "longest-subsequence-length"
      ],
      "summary" : "Given a target string and a string dictionary, find the longest string in the dictionary that can be formed by deleting characters in the target string. The key insight is to sort the dictionary first and then iterate through it to find the longest string."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the initial string '1' and then generate the next characters one by one. For each new character, check the count of the previous character in the string and append that many new characters (either 1 or 2) to the string.",
          "code" : "func magicalString(n: Int) -> Int { var res = [1]; var p = 0; while res.count < n { if res[p] == 1 { for _ in 1...1 { if res.count < n { res.append(2) } } } else { for _ in 1...2 { if res.count < n { res.append(1) } } }; p += 1 }; var count = 0; for i in 0..<n { if res[i] == 1 { count += 1 } }; return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We store the generated string in an array.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate through the string to generate it and then count the number of 1s."
          },
          "explanation" : "We will keep track of the current character and its count. We start with a string containing a single '1'. Then we generate the magical string by checking the current character and its count. If the current character is '1', we append '2' to the string. If the current character is '2', we append '1' to the string.",
          "id" : "cea43846-f69e-4238-afb4-ab5eb09e53b1",
          "intuition" : "We can generate the magical string iteratively based on the given rules.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The generated magical string for n = 6 is [1, 1, 2, 2, 1, 1] and it contains 3 ones in the first 6 positions.",
              "id" : "3d0cb320-561a-49bc-9218-08b8933e1641",
              "input" : "n = 6"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The generated magical string for n = 1 is [1] and it contains 1 one in the first position.",
              "id" : "2478b172-860e-450e-9463-7eb7bb9b334b",
              "input" : "n = 1"
            }
          ]
        },
        {
          "approach" : "We maintain two pointers, one for generating the magical string and one for counting the number of 1s.",
          "code" : "func magicalString(n: Int) -> Int { var res = [1]; var p = 0; var num = 2; var count = 1; while res.count < n { for _ in 1...res[p] { if res.count < n { res.append(num) }; if num == 1 { count += 1 } }; num = num == 1 ? 2 : 1; p += 1 }; return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We store the generated string in an array.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate through the string to generate it and count the number of 1s."
          },
          "explanation" : "We start with the initial string '1' and then generate the next characters one by one using the given rules. We use a two-pointer technique to keep track of the current character and its count. We maintain a separate variable to count the number of 1s.",
          "id" : "b00c5c36-134d-4dd1-9f1b-20576746c9a5",
          "intuition" : "We can improve the brute force approach by utilizing a two-pointer technique.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The generated magical string for n = 7 is [1, 1, 2, 2, 1, 1, 2] and it contains 4 ones in the first 7 positions.",
              "id" : "18f497c2-db26-4f33-a20c-2b41b376b240",
              "input" : "n = 7"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The generated magical string for n = 4 is [1, 1, 2, 2] and it contains 2 ones in the first 4 positions.",
              "id" : "b3126335-c1af-4d24-81f3-30c7954d88d9",
              "input" : "n = 4"
            }
          ]
        }
      ],
      "id" : "ee4491ed-e075-43a9-bd22-4ef8232e4c84",
      "lastUpdated" : "2026-02-06T21:21:29Z",
      "problemSlug" : "magical-string",
      "relatedProblems" : [
        "array-nesting",
        "increasing-subsequences"
      ],
      "summary" : "The magical string problem involves generating a string of 1s and 2s based on a set of rules and determining the number of 1s in the first n positions. The key insight is to utilize the given rules to iteratively generate the string."
    },
    {
      "approaches" : [
        {
          "approach" : "For each element in the array, compare it with every other element and calculate the difference between their indices. Keep track of the maximum difference where the condition is met.",
          "code" : "func maxWidthRamp(_ nums: [Int]) -> Int { \n var maxWidth: Int = 0 \n for i in 0..<nums.count { \n for j in i..<nums.count { \n if nums[i] <= nums[j] { \n let width: Int = j - i \n if width > maxWidth { \n maxWidth = width \n } \n } \n } \n } \n return maxWidth \n }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the maximum width and the loop indices.",
            "time" : "O(n^2)",
            "timeExplanation" : "We have two nested loops, each iterating over the array, resulting in quadratic time complexity."
          },
          "explanation" : "This solution has an exponential time complexity because it checks every possible pair of indices, making it inefficient for large inputs.",
          "id" : "672a7a11-f995-42f5-9245-9d5bed215c47",
          "intuition" : "This approach works by iterating over all possible pairs of indices in the array and checking if the value at the smaller index is less than or equal to the value at the larger index. If so, it updates the maximum width found so far.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The maximum width ramp is [0,4] where the value 0 at index 1 is less than the value 5 at index 5, and the width is 4 - 1 = 3, but [1,5] is not a valid ramp. However, the ramp [0,3] has a width of 3 but [0,4] has a width of 4 which is bigger.",
              "id" : "6f74cf24-915a-4e12-84a2-166428884375",
              "input" : "nums = [6,0,8,2,1,5]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The maximum width ramp is [3,9] where the value 0 at index 3 is less than the value 4 at index 9, and the width is 9 - 3 = 6, but the ramp [3,9] has a width of 6. But the ramp [3,10-1] has a width of 7-1=6 which is not bigger than 7, so the ramp [0,7] is valid and has the width of 7.",
              "id" : "4a929ec5-3129-496f-957a-1b600fb38f33",
              "input" : "nums = [9,8,1,0,1,9,4,0,4,1]"
            }
          ]
        },
        {
          "approach" : "Create a monotonic stack and iterate through the array. Whenever an element is smaller than the top element of the stack, pop the stack and calculate the width.",
          "code" : "func maxWidthRamp(_ nums: [Int]) -> Int { \n var stack: [Int] = [] \n var maxWidth: Int = 0 \n for i in 0..<nums.count { \n while !stack.isEmpty && nums[stack.last!] > nums[i] { \n let index: Int = stack.popLast()! \n let width: Int = i - index \n if width > maxWidth { \n maxWidth = width \n } \n } \n stack.append(i) \n } \n return maxWidth \n }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a stack to keep track of the indices, resulting in linear space complexity in the worst case.",
            "time" : "O(n)",
            "timeExplanation" : "We only iterate through the array once, resulting in linear time complexity."
          },
          "explanation" : "This solution has a linear time complexity because it only iterates through the array once and uses a stack to keep track of the indices.",
          "id" : "be2d872e-b5b2-431a-82cf-dbbbd545f898",
          "intuition" : "This approach uses a monotonic stack to keep track of the indices of the elements in the array. It iterates through the array and whenever it encounters an element that is smaller than the top element of the stack, it pops the stack and updates the maximum width found so far.",
          "name" : "Optimized Monotonic Stack",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The maximum width ramp is [0,4] where the value 0 at index 1 is less than the value 5 at index 5, and the width is 4 - 1 = 3, but [0,4] is not a valid ramp. However, the ramp [0,3] has a width of 3 but [0,4] has a width of 4 which is bigger.",
              "id" : "72bba781-d1fc-4cfb-98db-3bd790211c06",
              "input" : "nums = [6,0,8,2,1,5]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The maximum width ramp is [3,9] where the value 0 at index 3 is less than the value 4 at index 9, and the width is 9 - 3 = 6, but the ramp [3,9] has a width of 6. But the ramp [0,7] is valid and has the width of 7.",
              "id" : "c9ccc8cd-4e3a-4317-abe9-049528cd978f",
              "input" : "nums = [9,8,1,0,1,9,4,0,4,1]"
            }
          ]
        }
      ],
      "id" : "0063661f-90b5-49e0-aaf4-3b114d537f5e",
      "lastUpdated" : "2026-02-06T21:51:43Z",
      "problemSlug" : "maximum-width-ramp",
      "relatedProblems" : [
        "daily-temperatures",
        "asteroid-collision"
      ],
      "summary" : "The Maximum Width Ramp problem involves finding the maximum width of a ramp in a given array, which is essentially finding the maximum difference between two indices where the value at the smaller index is less than or equal to the value at the larger index. The key insight here is to use a monotonic stack to efficiently keep track of the indices of the elements."
    },
    {
      "approaches" : [
        {
          "approach" : "First, we concatenate the two input arrays. Then, we sort the resulting array in ascending order.",
          "code" : "func merge(_ nums1: [Int], _ m: Int, _ nums2: [Int], _ n: Int) -> [Int] { var nums1 = nums1; nums1.append(contentsOf: nums2); nums1.sort(); return nums1 }",
          "complexity" : {
            "space" : "O(m+n)",
            "spaceExplanation" : "The space complexity is O(m+n) because we are creating a new array that contains all elements from both input arrays.",
            "time" : "O((m+n)log(m+n))",
            "timeExplanation" : "This is because the sorting operation in Swift uses a variant of the dual pivot quicksort algorithm, which has an average time complexity of O(n log n)."
          },
          "explanation" : "This approach is straightforward but may not be the most efficient, especially for large input arrays. It works by first combining the two sorted arrays into a single array, and then sorting this combined array. The resulting sorted array is then returned as the result.",
          "id" : "0bdeeeda-aada-4f98-a59b-ca9f19264766",
          "intuition" : "This approach involves concatenating the two input arrays and then sorting the resulting array.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,2,3,5,6]",
              "explanation" : "In this test case, we have two sorted arrays, and we need to merge them into a single sorted array. The expected output is a sorted array containing all elements from both input arrays.",
              "id" : "6aa2ba36-96e3-4a5b-9fcb-038f55895afe",
              "input" : "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3"
            },
            {
              "expectedOutput" : "[1]",
              "explanation" : "In this test case, the second input array is empty. The expected output is the first input array itself, since there are no elements to merge.",
              "id" : "a52d2e16-2d02-45fe-9ea8-23e8687036b7",
              "input" : "nums1 = [1], m = 1, nums2 = [], n = 0"
            }
          ]
        },
        {
          "approach" : "First, we initialize two pointers, one for each input array. Then, we compare the elements at the current positions of the two pointers and place the smaller one in the result array. We repeat this process until we have processed all elements from both arrays.",
          "code" : "func merge(_ nums1: [Int], _ m: Int, _ nums2: [Int], _ n: Int) -> [Int] { var i = m - 1; var j = n - 1; var k = m + n - 1; var nums1 = nums1; while j >= 0 { if i >= 0 && nums1[i] > nums2[j] { nums1[k] = nums1[i]; i -= 1 } else { nums1[k] = nums2[j]; j -= 1 }; k -= 1 }; return nums1 }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are modifying the first input array in-place, without using any additional space that scales with the input size.",
            "time" : "O(m+n)",
            "timeExplanation" : "This is because we are processing each element from both input arrays exactly once."
          },
          "explanation" : "This approach is more efficient than the brute-force approach, especially for large input arrays. It works by comparing elements from both arrays and placing the smaller one first, which ensures that the resulting array is sorted.",
          "id" : "8c7fb26b-0ec4-40ad-ae8c-64417a62166c",
          "intuition" : "This approach involves using two pointers to compare elements from both arrays and place the smaller one first.",
          "name" : "Two-Pointer Technique",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,2,3,5,6]",
              "explanation" : "In this test case, we have two sorted arrays, and we need to merge them into a single sorted array. The expected output is a sorted array containing all elements from both input arrays.",
              "id" : "1853e86f-e4b9-4332-be79-a3bafb972079",
              "input" : "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3"
            },
            {
              "expectedOutput" : "[1]",
              "explanation" : "In this test case, the second input array is empty. The expected output is the first input array itself, since there are no elements to merge.",
              "id" : "235f934a-132b-4685-8041-fb0b8c47a4d0",
              "input" : "nums1 = [1], m = 1, nums2 = [], n = 0"
            }
          ]
        }
      ],
      "id" : "5920b338-5d78-414b-9260-902209fb8efb",
      "lastUpdated" : "2026-02-06T21:05:51Z",
      "problemSlug" : "merge-sorted-array",
      "relatedProblems" : [
        "reverse-string",
        "remove-element"
      ],
      "summary" : "The problem requires merging two sorted arrays into a single sorted array, the key insight is to compare elements from both arrays and place the smaller one first. This can be achieved through brute-force or optimized two-pointer techniques."
    },
    {
      "approaches" : [
        {
          "approach" : "Create all possible worker-job pairs, calculate the potential profit for each pair, and select the pairs that yield the maximum profit.",
          "code" : "func maxProfitAssignment(_ difficulty: [Int], _ profit: [Int], _ worker: [Int]) -> Int {\n  let jobs = zip(difficulty, profit).sorted(by: { $0.0 < $1.0 })\n  var maxProfit = [0]\n  var curMaxProfit = 0\n  for i in 0..<jobs.count {\n    if jobs[i].1 > curMaxProfit {\n      curMaxProfit = jobs[i].1\n    }\n    maxProfit.append(curMaxProfit)\n  }\n  var res = 0\n  for w in worker {\n    if let idx = binarySearch(jobs.map { $0.0 }, w) {\n      res += maxProfit[idx]\n    }\n  }\n  return res\n}\n\nfunc binarySearch(_ arr: [Int], _ target: Int) -> Int? {\n  var left = 0\n  var right = arr.count - 1\n  while left <= right {\n    let mid = (left + right) \/ 2\n    if arr[mid] <= target {\n      left = mid + 1\n    } else {\n      right = mid - 1\n    }\n  }\n  if right >= 0 {\n    return right\n  }\n  return nil\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "It requires O(n) space to store the jobs and worker skills, as well as the maximum profit achieved so far.",
            "time" : "O(n^2)",
            "timeExplanation" : "The brute-force approach tries all possible assignments of workers to jobs and calculates the potential profit for each assignment, resulting in a time complexity of O(n^2)."
          },
          "explanation" : "This brute-force approach considers every possible assignment of workers to jobs and calculates the potential profit for each assignment. However, this method is inefficient for large inputs due to its high time complexity.",
          "id" : "6b3edfbd-f032-46fa-b671-c617e64bd9af",
          "intuition" : "Try all possible assignments of workers to jobs and calculate the maximum profit that can be achieved.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "100",
              "explanation" : "The optimal assignment is worker with skill 4 to job with difficulty 4 and profit 10, worker with skill 5 to job with difficulty 4 and profit 10, worker with skill 6 to job with difficulty 6 and profit 30, and worker with skill 7 to job with difficulty 6 and profit 30. This yields a total profit of 10 + 20 + 30 + 40 = 100.",
              "id" : "b2ef5c18-1aeb-417f-8006-228babf5e349",
              "input" : "difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]"
            },
            {
              "expectedOutput" : "10",
              "explanation" : "The optimal assignment is worker with skill 1 to job with difficulty 1 and profit 2, worker with skill 2 to job with difficulty 2 and profit 3, worker with skill 3 to job with difficulty 3 and profit 4, and so on. This yields a total profit of 2 + 3 + 4 = 9.",
              "id" : "35cd3da5-c65b-46c5-a081-125e8bd90a0c",
              "input" : "difficulty = [1,2,3], profit = [2,3,4], worker = [1,2,3,4,5]"
            }
          ]
        },
        {
          "approach" : "Create a sorted list of jobs along with their corresponding profits and difficulties. For each worker, use binary search to find the most suitable job (i.e., the last job with difficulty less than or equal to the worker's skill). Update the maximum profit achieved so far.",
          "code" : "func maxProfitAssignment(_ difficulty: [Int], _ profit: [Int], _ worker: [Int]) -> Int {\n  let jobs = zip(difficulty, profit).sorted(by: { $0.0 < $1.0 })\n  var maxProfit = [0]\n  var curMaxProfit = 0\n  for i in 0..<jobs.count {\n    if jobs[i].1 > curMaxProfit {\n      curMaxProfit = jobs[i].1\n    }\n    maxProfit.append(curMaxProfit)\n  }\n  var res = 0\n  for w in worker {\n    if let idx = binarySearch(jobs.map { $0.0 }, w) {\n      res += maxProfit[idx]\n    }\n  }\n  return res\n}\n\nfunc binarySearch(_ arr: [Int], _ target: Int) -> Int? {\n  var left = 0\n  var right = arr.count - 1\n  while left <= right {\n    let mid = (left + right) \/ 2\n    if arr[mid] <= target {\n      left = mid + 1\n    } else {\n      right = mid - 1\n    }\n  }\n  if right >= 0 {\n    return right\n  }\n  return nil\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The optimized approach requires O(n) space to store the jobs, worker skills, and the maximum profit achieved so far.",
            "time" : "O(n log n)",
            "timeExplanation" : "The optimized approach involves sorting the jobs, which takes O(n log n) time, and then uses binary search to find the most suitable job for each worker, resulting in a total time complexity of O(n log n)."
          },
          "explanation" : "The optimized approach first sorts the jobs and worker skills. It then uses a two-pointer technique and binary search to efficiently find the most profitable assignments of workers to jobs.",
          "id" : "0733665e-fbb5-42fe-ad8e-1182c92d04a8",
          "intuition" : "Sort the jobs and worker skills, use a two-pointer technique to find the most profitable assignments, and employ binary search to find the most suitable job for each worker.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "100",
              "explanation" : "The optimal assignment is worker with skill 4 to job with difficulty 4 and profit 10, worker with skill 5 to job with difficulty 4 and profit 10, worker with skill 6 to job with difficulty 6 and profit 30, and worker with skill 7 to job with difficulty 6 and profit 30. This yields a total profit of 10 + 20 + 30 + 40 = 100.",
              "id" : "ef236921-a896-4771-9fc9-8d69add722e7",
              "input" : "difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]"
            },
            {
              "expectedOutput" : "11",
              "explanation" : "The optimal assignment is worker with skill 1 to job with difficulty 1 and profit 2, worker with skill 2 to job with difficulty 2 and profit 3, worker with skill 3 to job with difficulty 3 and profit 4, worker with skill 4 to job with difficulty 3 and profit 4, and worker with skill 5 to job with difficulty 3 and profit 4. This yields a total profit of 2 + 3 + 4 + 4 + 4 = 17.",
              "id" : "f7494134-1140-4775-a397-743de7192d02",
              "input" : "difficulty = [1,2,3], profit = [2,3,4], worker = [1,2,3,4,5]"
            }
          ]
        }
      ],
      "id" : "c5dc19a8-cf85-41bd-b222-8487d5ec24ec",
      "lastUpdated" : "2026-02-06T21:42:40Z",
      "problemSlug" : "most-profit-assigning-work",
      "relatedProblems" : [
        "maximum-gap",
        "find-and-replace-pattern"
      ],
      "summary" : "This problem involves assigning workers to jobs to maximize profit, and the key insight is to sort the jobs and worker skills and use a two-pointer technique to find the most profitable assignments."
    },
    {
      "approaches" : [
        {
          "approach" : "1. writeIndex starts at 0\n2. For each non-zero element, write it at writeIndex and increment\n3. Fill remaining positions with zeros",
          "code" : "func moveZeroes(_ nums: inout [Int]) {\n    var writeIndex = 0\n    \n    \/\/ Move all non-zeros to front\n    for num in nums {\n        if num != 0 {\n            nums[writeIndex] = num\n            writeIndex += 1\n        }\n    }\n    \n    \/\/ Fill rest with zeros\n    while writeIndex < nums.count {\n        nums[writeIndex] = 0\n        writeIndex += 1\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place modification with one pointer variable",
            "time" : "O(n)",
            "timeExplanation" : "Two passes through the array"
          },
          "explanation" : "The first pass compacts all non-zero elements to the front, maintaining their relative order. writeIndex ends up at the count of non-zeros. The second pass fills zeros from writeIndex to the end. This is cache-friendly as we write sequentially.",
          "id" : "4c27ce4e-1d2b-475a-916e-425817f46de8",
          "intuition" : "Copy all non-zero elements to the front, then fill the rest with zeros. Two passes but very clean logic.",
          "name" : "Two Pointers (Overwrite + Fill)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,3,12,0,0]",
              "explanation" : "Non-zeros 1,3,12 moved to front, zeros fill the rest",
              "id" : "7520c7aa-1eed-4a4d-89c1-c90e954d6812",
              "input" : "nums = [0,1,0,3,12]"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "Single zero stays in place",
              "id" : "fe7422ae-092a-458f-8774-a980544fb244",
              "input" : "nums = [0]"
            }
          ]
        },
        {
          "approach" : "1. slow pointer marks end of non-zero zone\n2. fast pointer scans through array\n3. When fast finds non-zero, swap with slow and increment slow\n4. Single pass, minimal writes",
          "code" : "func moveZeroes(_ nums: inout [Int]) {\n    var slow = 0\n    \n    for fast in 0..<nums.count {\n        if nums[fast] != 0 {\n            \/\/ Swap only if positions differ (avoid self-swap)\n            if slow != fast {\n                nums.swapAt(slow, fast)\n            }\n            slow += 1\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only using pointer variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through array"
          },
          "explanation" : "The slow pointer always points to the first zero (or end of non-zero section). When fast finds a non-zero, swapping places it at the boundary and moves the boundary forward. This performs fewer writes than the fill approach when there are few zeros.",
          "id" : "a16613bd-2811-47a1-ad61-a7819ceb6902",
          "intuition" : "Maintain a slow pointer for the 'non-zero zone' boundary. When we find a non-zero, swap it with the boundary position and expand the zone.",
          "name" : "Two Pointers (Swap)",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,3,12,0,0]",
              "explanation" : "Swap 10, then 30, then 120",
              "id" : "627eb173-cf19-4d10-b422-0104d97be4e7",
              "input" : "nums = [0,1,0,3,12]"
            },
            {
              "expectedOutput" : "[1,2,3]",
              "explanation" : "No zeros, no swaps needed (slow==fast always)",
              "id" : "08a2f445-fc71-4492-ab02-12b90c7e50dd",
              "input" : "nums = [1,2,3]"
            },
            {
              "expectedOutput" : "[1,0,0]",
              "explanation" : "1 swaps with first 0",
              "id" : "e429ad05-3571-4451-800f-058842518499",
              "input" : "nums = [0,0,1]"
            }
          ]
        }
      ],
      "id" : "1eaeb2ef-7769-43d9-9a82-32a5b0112c9b",
      "lastUpdated" : "2026-02-06T08:36:45Z",
      "problemSlug" : "move-zeroes",
      "relatedProblems" : [
        "remove-element"
      ],
      "summary" : "Move all zeros to the end while maintaining the relative order of non-zero elements. Use two pointers: one for the write position of non-zeros, one to scan."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Find i where nums[i] < nums[i+1] from right\n2. Find j > i where nums[j] > nums[i]\n3. Swap, reverse suffix",
          "code" : "func nextPermutation(_ nums: inout [Int]) {\n    let n = nums.count\n    var i = n - 2\n    while i >= 0 && nums[i] >= nums[i+1] { i -= 1 }\n    if i >= 0 {\n        var j = n - 1\n        while nums[j] <= nums[i] { j -= 1 }\n        nums.swapAt(i, j)\n    }\n    nums[(i+1)...].reverse()\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place",
            "time" : "O(n)",
            "timeExplanation" : "Linear scans"
          },
          "explanation" : "We need smallest increase. Find the rightmost element we can increase, swap with next larger, make suffix ascending.",
          "id" : "050bf7cd-d5b4-4f59-8af2-ea15de4f8838",
          "intuition" : "Find rightmost i where nums[i] < nums[i+1], swap with smallest greater in suffix, reverse.",
          "name" : "Linear Scan",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,3,2]",
              "explanation" : "Next after 123 is 132",
              "id" : "957a3b1c-c9f2-484a-acfd-663c0c7c617b",
              "input" : "[1,2,3]"
            }
          ]
        }
      ],
      "id" : "7ca7e958-9e1c-4ed6-95f8-4b1b4b504673",
      "lastUpdated" : "2026-02-06T01:03:48.938Z",
      "problemSlug" : "next-permutation",
      "relatedProblems" : [
        "permutations",
        "permutations-ii"
      ],
      "summary" : "Rearrange to next lexicographically greater permutation. Find rightmost ascending pair, swap with smallest larger, reverse suffix."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays, check if the maximum of each subarray is within the given bounds, and count them",
          "code" : "\nfunc numSubarrayBoundedMax(_ nums: [Int], _ left: Int, _ right: Int) -> Int {\n    var count = 0\n    for i in 0..<nums.count {\n        var maxInSubarray = Int.min\n        for j in i..<nums.count {\n            maxInSubarray = max(maxInSubarray, nums[j])\n            if left <= maxInSubarray && maxInSubarray <= right {\n                count += 1\n            }\n        }\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No additional data structures used that scale with input size",
            "time" : "O(n^2)",
            "timeExplanation" : "Two nested loops to generate all subarrays and check their maximum values"
          },
          "explanation" : "This approach involves a nested loop structure to generate all possible subarrays and then check each one against the conditions given in the problem statement",
          "id" : "b927d8e4-e32a-4129-8a42-17af80c4fa6e",
          "intuition" : "Count subarrays where the maximum value doesn't exceed the boundary by checking all possible subarrays",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Subarrays are [2], [2,1], [3] which all have max values between 2 and 3 (inclusive)",
              "id" : "601cf786-b265-4557-bc23-355786fbc3b8",
              "input" : "nums = [2,1,4,3], left = 2, right = 3"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "This includes subarrays like [2], [2,9] (9 is within bounds), [2,9,2], etc., where max is between 2 and 8",
              "id" : "4aed465f-52cb-4963-8fc2-13b5e3efb016",
              "input" : "nums = [2,9,2,5,6], left = 2, right = 8"
            }
          ]
        },
        {
          "approach" : "Maintain a window where the maximum value is within the bounds and update the window when this condition is violated",
          "code" : "\nfunc numSubarrayBoundedMax(_ nums: [Int], _ left: Int, _ right: Int) -> Int {\n    var res = 0, start = 0, count = 0, last = -1\n    for end in 0..<nums.count {\n        if nums[end] > right {\n            res += count\n            start = end + 1\n            last = end\n            count = 0\n        } else if nums[end] >= left {\n            if last >= start {\n                count = end - last\n            } else {\n                count = end - start + 1\n            }\n        }\n        if last >= start {\n            res += count\n        }\n    }\n    return res\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only a constant amount of space used",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through the array"
          },
          "explanation" : "We track two pointers, start and end, representing the window. When the max value in this window exceeds the bounds, we move the start pointer. We count all subarrays ending at the current end pointer when the max value is within bounds",
          "id" : "b4fc51ae-2258-432e-89a7-bddbef6966cf",
          "intuition" : "Using the sliding window technique to track the subarrays with max values within the given bounds efficiently",
          "name" : "Optimized Sliding Window Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Counting subarrays with max values within the given range [2,3]",
              "id" : "5e0ba45e-20f6-4d4d-9ed0-247e35a3d6aa",
              "input" : "nums = [2,1,4,3], left = 2, right = 3"
            },
            {
              "expectedOutput" : "22",
              "explanation" : "Example usage of the optimized approach with a larger input set",
              "id" : "b8727e5c-2787-413f-8413-be2fa2994af0",
              "input" : "nums = [73,55,36,5,55,14,9,7,72,52], left = 32, right = 69"
            }
          ]
        }
      ],
      "id" : "2ebc3eb6-2f83-4a0b-8cd9-582d8cfcc7c6",
      "lastUpdated" : "2026-02-06T21:40:13Z",
      "problemSlug" : "number-of-subarrays-with-bounded-maximum",
      "relatedProblems" : [
        "subarray-sum-equals-k",
        "maximum-size-subarray-sum-equals-k"
      ],
      "summary" : "This problem asks for the number of subarrays within an array where the maximum value does not exceed a given boundary. Key insight involves utilizing the sliding window technique to efficiently track and count these subarrays."
    },
    {
      "approaches" : [
        {
          "approach" : "1. For each center (single char and pairs), expand outward\n2. Count each position where chars match\n3. Sum all counts",
          "code" : "func countSubstrings(_ s: String) -> Int {\n    let chars = Array(s)\n    var count = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right, cnt = 0\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            cnt += 1\n            l -= 1; r += 1\n        }\n        return cnt\n    }\n    \n    for i in 0..<chars.count {\n        count += expand(i, i)      \/\/ Odd\n        count += expand(i, i + 1)  \/\/ Even\n    }\n    \n    return count\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "String to array",
            "time" : "O(n)",
            "timeExplanation" : "n centers, O(n) expansion"
          },
          "explanation" : "Each valid expansion is a palindrome. Total count includes all lengths.",
          "id" : "550e8400-e29b-41d4-a716-446655440143",
          "intuition" : "Same as longest palindrome, but count each successful expansion instead of tracking max.",
          "name" : "Expand Around Center",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "a,a,a,aa,aa,aaa = 6 palindromes",
              "id" : "550e8400-e29b-41d4-a716-446655440249",
              "input" : "\"aaa\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440032",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "palindromic-substrings",
      "relatedProblems" : [
        "longest-palindromic-substring"
      ],
      "summary" : "Count all palindromic substrings. Expand from each center, count valid expansions."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of the array, then for each permutation, check if it is a valid sorting of the array by comparing adjacent elements.",
          "code" : "func pancakeSort(_ A: [Int]) -> [Int] { \n    var ans: [Int] = [] \n    var A = A \n    for size in stride(from: A.count, to: 0, by: -1) { \n        if let maxIndex = A.firstIndex(of: size) { \n            if maxIndex != size - 1 { \n                if maxIndex != 0 { \n                    ans.append(maxIndex + 1) \n                    A = A.prefix(maxIndex + 1).reversed() + A.dropFirst(maxIndex + 1) \n                } \n                ans.append(size) \n                A = A.prefix(size).reversed() + A.dropFirst(size) \n            } \n        } \n    } \n    return ans \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to storing the current permutation.",
            "time" : "O(n!)",
            "timeExplanation" : "The time complexity is O(n!) due to generating all permutations."
          },
          "explanation" : "This approach works but is inefficient due to the large number of permutations. It is used as a baseline to compare with more efficient solutions.",
          "id" : "4e99eb38-3165-4dc7-a97c-2912b3e2a167",
          "intuition" : "The brute-force approach involves generating all possible permutations of the array and checking if each permutation is a valid sorting of the array.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[3,4,2,3,2]",
              "explanation" : "The valid sequence of flips to sort the array is [3,4,2,3,2].",
              "id" : "11ae77d3-3b52-4b08-bb89-677bdd7358d6",
              "input" : "A = [3,2,4,1]"
            },
            {
              "expectedOutput" : "[]",
              "explanation" : "The array is already sorted, so no flips are needed.",
              "id" : "2ed3529e-d9e1-4935-990a-96e00eadeba5",
              "input" : "A = [1,2,3]"
            }
          ]
        },
        {
          "approach" : "For each size from the largest to the smallest, find the index of the largest unsorted element, flip the portion of the array containing the largest element to the beginning, then flip the portion of the array containing the largest element to its correct position.",
          "code" : "func pancakeSort(_ A: [Int]) -> [Int] { \n    var ans: [Int] = [] \n    var A = A \n    for size in stride(from: A.count, to: 0, by: -1) { \n        if let maxIndex = A.firstIndex(of: size) { \n            if maxIndex != size - 1 { \n                if maxIndex != 0 { \n                    ans.append(maxIndex + 1) \n                    A = A.prefix(maxIndex + 1).reversed() + A.dropFirst(maxIndex + 1) \n                } \n                ans.append(size) \n                A = A.prefix(size).reversed() + A.dropFirst(size) \n            } \n        } \n    } \n    return ans \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) due to only using a constant amount of space to store the current index and the size of the unsorted portion.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) due to finding the index of the largest unsorted element for each size."
          },
          "explanation" : "This approach works because we are always placing the largest unsorted element in its correct position, which ensures that the rest of the unsorted elements are not affected.",
          "id" : "5f423bdb-efac-440d-8b1f-462b75442606",
          "intuition" : "The greedy approach involves iteratively placing the largest unsorted elements in their correct positions by flipping the portion of the array containing the largest element.",
          "name" : "Greedy Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[3,4,2,3,2]",
              "explanation" : "The valid sequence of flips to sort the array is [3,4,2,3,2].",
              "id" : "ab644221-5837-42d8-93d9-4dae2c016b7d",
              "input" : "A = [3,2,4,1]"
            },
            {
              "expectedOutput" : "[]",
              "explanation" : "The array is already sorted, so no flips are needed.",
              "id" : "cbb465d5-38f6-40b3-9d38-20ca6224d76b",
              "input" : "A = [1,2,3]"
            },
            {
              "expectedOutput" : "[3,2]",
              "explanation" : "The valid sequence of flips to sort the array is [3,2].",
              "id" : "2c355f02-016e-4af5-9978-e729850555f7",
              "input" : "A = [3,1,2]"
            }
          ]
        }
      ],
      "id" : "b3659b8c-0db7-489f-918d-563c50eea774",
      "lastUpdated" : "2026-02-06T21:52:18Z",
      "problemSlug" : "pancake-sorting",
      "relatedProblems" : [
        "reverse-pairs",
        "array-partition-i"
      ],
      "summary" : "The problem involves sorting an array of integers using a limited number of operations, where each operation flips a portion of the array. The key insight is that we can use a greedy approach to iteratively place the largest unsorted elements in their correct positions."
    },
    {
      "approaches" : [
        {
          "approach" : "Start by creating a list to hold the forces acting on each domino. Then, iterate through the dominoes to find the points where forces are being applied and update the forces list accordingly. Finally, create a new list to hold the final state of the dominoes and iterate through the forces list to determine the final state.",
          "code" : "\n           func pushDominoes(dominoes: String) -> String {\n               var forces = Array(repeating: 0, count: dominoes.count)\n               var i = 0\n               var force = 0\n\n               while i < dominoes.count {\n                   if dominoes[i] == '.' {\n                       i += 1\n                       continue\n                   }\n                   force = (dominoes[i] == 'R') ? 1 : -1\n\n                   j = i\n                   while j < dominoes.count && dominoes[j] == '.' {\n                       forces[j] += force\n                       force += (force > 0) ? -1 : 1\n                       j += 1\n                   }\n\n                   i = j\n               }\n\n               var result = Array(repeating: '.', count: dominoes.count)\n\n               for i in 0..<dominoes.count {\n                   if forces[i] > 0 {\n                       result[i] = \"R\"\n                   } else if forces[i] < 0 {\n                       result[i] = \"L\"\n                   }\n               }\n\n               return String(result)\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the forces acting on each domino in a separate list.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are doing a constant amount of work for each domino."
          },
          "explanation" : "This approach involves first calculating the net forces acting on each domino, then using these forces to determine the final state of the dominoes.",
          "id" : "2847c01b-8bd3-4a0d-ac97-afe794e7b01d",
          "intuition" : "This approach works by first identifying all the points where forces are being applied, then iterating through each point to calculate the net force acting on it and updating the state accordingly.",
          "name" : "Iterative Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "LL.RR.LL..",
              "explanation" : "After pushing the dominoes, the final state is LL.RR.LL..",
              "id" : "e7344f4e-151b-47ce-9339-d7726ad5acae",
              "input" : ".L.R...L.."
            },
            {
              "expectedOutput" : "RR.L",
              "explanation" : "After pushing the dominoes, the final state is RR.L",
              "id" : "3284d8dd-db8b-4710-9e43-bdc3429899a7",
              "input" : "RR.L"
            }
          ]
        },
        {
          "approach" : "Start by creating two pointers, one for the current domino and one for the next domino. Then, iterate through the dominoes using the two pointers to calculate the net force acting on each domino and update the state accordingly.",
          "code" : "\n           func pushDominoes(dominoes: String) -> String {\n               var result = Array(repeating: '.', count: dominoes.count)\n               var i = 0\n\n               while i < dominoes.count {\n                   if dominoes[i] == '.' {\n                       i += 1\n                       continue\n                   }\n\n                   j = i\n                   while j < dominoes.count && dominoes[j] == '.' {\n                       if j - i == j - dominoes.count + 1 {\n                           result[j] = dominoes[i]\n                       } else if j - i < j - dominoes.count + 1 {\n                           result[j] = dominoes[i]\n                       }\n                       j += 1\n                   }\n\n                   i = j\n               }\n\n               for i in 0..<dominoes.count {\n                   if result[i] == '.' {\n                       result[i] = dominoes[i]\n                   }\n               }\n\n               return String(result)\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the final state of the dominoes in a separate list.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are doing a constant amount of work for each domino."
          },
          "explanation" : "This approach involves using two pointers to track the interaction between adjacent dominoes, thus reducing the number of iterations needed to determine the final state of the dominoes.",
          "id" : "c5747204-48f9-491e-895d-e8c8d02582eb",
          "intuition" : "This approach works by using two pointers to track the interaction between adjacent dominoes, thus reducing the number of iterations needed.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "LL.RR.LL..",
              "explanation" : "After pushing the dominoes, the final state is LL.RR.LL..",
              "id" : "beac1ed0-be37-4872-81bd-aee67c378cef",
              "input" : ".L.R...L.."
            },
            {
              "expectedOutput" : "RR.L",
              "explanation" : "After pushing the dominoes, the final state is RR.L",
              "id" : "17450101-b95b-4c4f-80cb-13af8d262582",
              "input" : "RR.L"
            }
          ]
        }
      ],
      "id" : "761de83e-b2f9-4f6b-8cd3-d2939db95d6e",
      "lastUpdated" : "2026-02-06T21:43:28Z",
      "problemSlug" : "push-dominoes",
      "relatedProblems" : [
        "array-partition-i",
        "minimum-size-subarray-sum"
      ],
      "summary" : "Given a string of dominoes where each domino can be pushed to the left or right, determine the final state of the dominoes after all pushes. The key insight is to recognize that the resulting state will be determined by the interaction between adjacent dominoes."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Handle empty array edge case\n2. Initialize write pointer at index 1 (first element is always unique)\n3. Scan from index 1 with read pointer\n4. When current element differs from previous, write it and advance write pointer\n5. Return write pointer value (count of unique elements)",
          "code" : "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 1\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[i - 1] {\n            nums[writeIndex] = nums[i]\n            writeIndex += 1\n        }\n    }\n    \n    return writeIndex\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place modification, only using pointer variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through the array of n elements"
          },
          "explanation" : "The key insight is that in a sorted array, duplicates are consecutive. We maintain a 'write' position where the next unique element should go. As we scan, whenever we find a new value (different from previous), we write it to the write position. The array before the write pointer contains all unique elements.",
          "id" : "20cdf256-68d7-4455-885b-95d4a0b885cd",
          "intuition" : "Since the array is sorted, duplicates are adjacent. Use a slow pointer to track where to write the next unique element, and a fast pointer to scan through the array.",
          "name" : "Two Pointers (In-Place)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2, nums = [1,2,_]",
              "explanation" : "Two unique elements: 1 and 2. Array becomes [1,2,...] with returned length 2.",
              "id" : "db20a2f5-5ca6-42f3-bcbd-1c43646c1e7d",
              "input" : "nums = [1,1,2]"
            },
            {
              "expectedOutput" : "5, nums = [0,1,2,3,4,_,_,_,_,_]",
              "explanation" : "Five unique elements: 0,1,2,3,4. Each written once to front of array.",
              "id" : "80edfa7d-0102-4dcb-a2a8-59607c8691a7",
              "input" : "nums = [0,0,1,1,1,2,2,3,3,4]"
            },
            {
              "expectedOutput" : "1, nums = [1]",
              "explanation" : "Single element is always unique.",
              "id" : "4693e995-554e-4fd0-848b-44b9ff73abbd",
              "input" : "nums = [1]"
            }
          ]
        },
        {
          "approach" : "1. Handle empty array\n2. Write pointer starts at 0 (first element always kept)\n3. For each element from index 1:\n   a. If different from element at write pointer, increment write pointer and copy\n4. Return write pointer + 1",
          "code" : "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 0\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[writeIndex] {\n            writeIndex += 1\n            nums[writeIndex] = nums[i]\n        }\n    }\n    \n    return writeIndex + 1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only using index variables, modification is in-place",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through all n elements"
          },
          "explanation" : "This variant compares the current element with the last unique element we've written (at writeIndex). This pattern extends naturally to 'Remove Duplicates II' where we allow at most 2 of each - just compare with writeIndex-1 instead.",
          "id" : "0272bf65-0bcc-4895-a40b-6077271a1d22",
          "intuition" : "Instead of comparing with the previous element, compare with the last written unique element. This makes the logic cleaner for extensions like allowing k duplicates.",
          "name" : "Two Pointers (Compare with Write Position)",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2, nums = [1,2,_]",
              "explanation" : "writeIndex=0. i=1: nums[1]=1 == nums[0]=1, skip. i=2: nums[2]=2 != nums[0]=1, writeIndex=1, nums[1]=2. Return 2.",
              "id" : "91c1e2a4-1874-4392-870e-964c650624f7",
              "input" : "nums = [1,1,2]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "Empty array returns 0.",
              "id" : "edceb704-906a-4dd6-99ef-a1f14c0f262c",
              "input" : "nums = []"
            },
            {
              "expectedOutput" : "3, nums = [1,2,3]",
              "explanation" : "All unique, no changes needed. writeIndex moves to 2, return 3.",
              "id" : "7a0c3408-36ef-4450-b754-7eb88078006a",
              "input" : "nums = [1,2,3]"
            }
          ]
        }
      ],
      "id" : "32578f5a-83f9-4f6f-b4bd-a4f2b7184bba",
      "lastUpdated" : "2026-02-06T08:24:18Z",
      "problemSlug" : "remove-duplicates-from-sorted-array",
      "relatedProblems" : [
        "remove-duplicates-from-sorted-array-ii",
        "remove-element",
        "move-zeroes"
      ],
      "summary" : "Remove duplicates from a sorted array in-place, returning the count of unique elements. Use two pointers: one for the write position of unique elements, one to scan through the array."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a new array to store unique elements, then iterate over the input array. For each element, check if it has occurred more than twice. If not, append it to the new array.",
          "code" : "\n           func removeDuplicates(_ nums: inout [Int]) -> Int {\n               var count = 0\n               var i = 0\n               while i < nums.count {\n                   if i < nums.count - 1 && nums[i] == nums[i + 1] {\n                       count += 1\n                       if count > 2 {\n                           nums.remove(at: i)\n                           continue\n                       }\n                   } else {\n                       count = 0\n                   }\n                   i += 1\n               }\n               return nums.count\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we're modifying the input array in-place.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because in the worst case, we're iterating over the array once."
          },
          "explanation" : "Start by initializing two pointers, one at the beginning of the array and one to keep track of the next position to write. Iterate over the array, comparing each element with its next element. If the current element is the same as the previous one and it has occurred more than once, skip it; otherwise, move it to the next position.",
          "id" : "6eb0f497-2055-4d67-9e73-6e56a6735cd9",
          "intuition" : "The brute force approach compares each element with its next element and removes duplicates. This approach is straightforward but inefficient for large inputs.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The function should return 5 because after removing duplicates, the array becomes [1,1,2,2,3].",
              "id" : "88be7a0a-8b73-421e-ba87-ccc98ee80859",
              "input" : "nums = [1,1,1,2,2,3]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The function should return 7 because after removing duplicates, the array becomes [0,0,1,1,2,3,3].",
              "id" : "01b408eb-d14b-44bc-be8f-a6d585aeb525",
              "input" : "nums = [0,0,1,1,1,1,2,3,3]"
            }
          ]
        },
        {
          "approach" : "Start by initializing two pointers, one at the beginning of the array and one to keep track of the next position to write. Iterate over the array, comparing each element with its next element. If the current element is the same as the previous one and it has occurred more than once, skip it; otherwise, move it to the next position.",
          "code" : "\n           func removeDuplicates(_ nums: inout [Int]) -> Int {\n               if nums.count < 3 {\n                   return nums.count\n               }\n               var j = 2\n               for i in 2...nums.count - 1 {\n                   if nums[i] != nums[j - 2] {\n                       nums[j] = nums[i]\n                       j += 1\n                   }\n               }\n               return j\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we're modifying the input array in-place.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because in the worst case, we're iterating over the array once."
          },
          "explanation" : "Start by initializing two pointers, one at the beginning of the array and one to keep track of the next position to write. Iterate over the array, comparing each element with its next element. If the current element is the same as the previous one and it has occurred more than once, skip it; otherwise, move it to the next position.",
          "id" : "3be402cc-8f4b-4cff-b875-131ae4ff4f04",
          "intuition" : "This approach is more efficient and uses two pointers, one to track the current position and the other to track the next position to write.",
          "name" : "Two Pointers Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The function should return 5 because after removing duplicates, the array becomes [1,1,2,2,3].",
              "id" : "bf7fa27a-f6cc-4ffc-a527-7c3c5a12a0a2",
              "input" : "nums = [1,1,1,2,2,3]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The function should return 7 because after removing duplicates, the array becomes [0,0,1,1,2,3,3].",
              "id" : "062f3227-f2ea-4f06-879d-3bb55360ff45",
              "input" : "nums = [0,0,1,1,1,1,2,3,3]"
            }
          ]
        }
      ],
      "id" : "ec368c45-3c81-42eb-8701-b55b2d37dd2d",
      "lastUpdated" : "2026-02-06T21:05:27Z",
      "problemSlug" : "remove-duplicates-from-sorted-array-ii",
      "relatedProblems" : [
        "remove-duplicates-from-sorted-array",
        "remove-element"
      ],
      "summary" : "This problem requires removing duplicates from a sorted array, allowing at most two occurrences of each element. The key insight is to use a two-pointer technique to track the current position and the next position to write."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a new array, iterate over the given array, and append non-target values to the new array",
          "code" : "\n           func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n               var newNums: [Int] = []\n               for num in nums {\n                   if num != val {\n                       newNums.append(num)\n                   }\n               }\n               nums = newNums\n               return nums.count\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are creating a new array of the same size as the given array in the worst case",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the given array once"
          },
          "explanation" : "This brute-force approach works, but it requires extra space to store the new array and has a higher time complexity",
          "id" : "a9bd84a5-3367-4b1c-908e-f2c31afe2314",
          "intuition" : "This approach involves creating a new array that excludes the target value and returning its length",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The target value does not exist in the array, so the function returns the original length",
              "id" : "76e696e9-90a4-452b-bb3b-c22dec782022",
              "input" : "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The function removes two occurrences of the target value and returns the new length",
              "id" : "3a3a82c4-5bdc-40ef-a6fe-e99749c9bac7",
              "input" : "nums = [3,2,2,3], target = 3"
            }
          ]
        },
        {
          "approach" : "Use two pointers, i and j, where i is the reading pointer and j is the writing pointer, and move j only when the value at i is not the target value",
          "code" : "\n           func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n               var i = 0\n               for j in 0..<nums.count {\n                   if nums[j] != val {\n                       nums[i] = nums[j]\n                       i += 1\n                   }\n               }\n               return i\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are only using a constant amount of space to store the two pointers",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the given array once"
          },
          "explanation" : "This optimized approach works by only moving the writing pointer when the value at the reading pointer is not the target value, effectively removing the target value",
          "id" : "c10cd03b-7692-46d9-8637-c3713f0d37f5",
          "intuition" : "This approach involves using two pointers, one for reading and one for writing, to efficiently replace the target values",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The target value does not exist in the array, so the function returns the original length",
              "id" : "756fbf43-10f6-4979-a8fe-ced532e99cff",
              "input" : "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The function removes two occurrences of the target value and returns the new length",
              "id" : "242ce9dc-38c6-4a6f-a9bc-44108370bbad",
              "input" : "nums = [3,2,2,3], target = 3"
            }
          ]
        }
      ],
      "id" : "538c7ac1-7d2b-43ae-8c60-e3054a049d0c",
      "lastUpdated" : "2026-02-06T21:04:14Z",
      "problemSlug" : "remove-element",
      "relatedProblems" : [
        "move-zeroes",
        "remove-duplicates-from-sorted-array"
      ],
      "summary" : "The problem asks to remove all occurrences of a target value from a given array, and key insight involves using two pointers to efficiently replace the target values."
    },
    {
      "approaches" : [
        {
          "approach" : "Create an empty list of letters, iterate over the input string, and add each letter to the list. Reverse the list of letters. Create a new string and iterate over the input string again, this time inserting the letters from the reversed list into the correct positions in the new string.",
          "code" : "func reverseOnlyLetters(_ S: String) -> String {\n    var s = Array(S)\n    var left = 0\n    var right = s.count - 1\n    while left < right {\n        if !isLetter(s[left]) {\n            left += 1\n        } else if !isLetter(s[right]) {\n            right -= 1\n        } else {\n            let temp = s[left]\n            s[left] = s[right]\n            s[right] = temp\n            left += 1\n            right -= 1\n        }\n    }\n    return String(s)\n}\n\nfunc isLetter(_ c: Character) -> Bool {\n    return (c >= \"A\" && c <= \"Z\") || (c >= \"a\" && c <= \"z\")\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The brute force approach has a space complexity of O(n) because we store the list of letters, which in the worst case could contain all characters from the input string.",
            "time" : "O(n)",
            "timeExplanation" : "The brute force approach has a time complexity of O(n) because we potentially iterate over the input string twice: once to collect the letters and once to reinsert them into the output string."
          },
          "explanation" : "The brute force approach works because it separately stores the letters from the input string, reverses them, and then reinserts them into the correct positions in the output string. However, this approach is inefficient because it requires extra space to store the list of letters.",
          "id" : "7901e6ac-4104-429d-b9d5-fce997ee2376",
          "intuition" : "The brute force approach involves iterating over the string and checking each character to see if it is a letter. If it is, we add it to a separate list of letters, and then reverse this list and insert the letters back into the original string in the correct positions.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "dc-ba",
              "explanation" : "The input string 'ab-cd' contains letters and non-letters. The output string 'dc-ba' has the letters reversed while the non-letter '-' remains in its original position.",
              "id" : "d2493d0b-cea9-48b0-977b-76f6bf5d0719",
              "input" : "ab-cd"
            },
            {
              "expectedOutput" : "a-bc-ba",
              "explanation" : "The input string 'a-bC-ba' contains both uppercase and lowercase letters. The output string 'a-bc-ba' has the letters reversed while the non-letter '-' remains in its original position.",
              "id" : "fe47fbf2-6f02-48ad-aaa7-22946eb38396",
              "input" : "a-bC-ba"
            },
            {
              "expectedOutput" : "7_28]",
              "explanation" : "The input string '7_28]' contains no letters. The output string is the same as the input string because there are no letters to reverse.",
              "id" : "1490f03c-f0d8-47a6-81a9-4ff5a62ed523",
              "input" : "7_28]"
            }
          ]
        },
        {
          "approach" : "Create two pointers, one at the start and one at the end of the string. If the character at the left pointer is not a letter, move the left pointer to the right. If the character at the right pointer is not a letter, move the right pointer to the left. Otherwise, swap the letters at the two pointers and move both pointers.",
          "code" : "func reverseOnlyLetters(_ S: String) -> String {\n    var s = Array(S)\n    var left = 0\n    var right = s.count - 1\n    while left < right {\n        if !isLetter(s[left]) {\n            left += 1\n        } else if !isLetter(s[right]) {\n            right -= 1\n        } else {\n            let temp = s[left]\n            s[left] = s[right]\n            s[right] = temp\n            left += 1\n            right -= 1\n        }\n    }\n    return String(s)\n}\n\nfunc isLetter(_ c: Character) -> Bool {\n    return (c >= \"A\" && c <= \"Z\") || (c >= \"a\" && c <= \"z\")\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The two pointers approach has a space complexity of O(n) because we store the input string in an array.",
            "time" : "O(n)",
            "timeExplanation" : "The two pointers approach has a time complexity of O(n) because we potentially iterate over the input string once."
          },
          "explanation" : "The two pointers approach works because it uses two pointers to traverse the string from both ends towards the center, swapping the letters as it goes. This approach is efficient because it only requires a single pass through the string and uses constant space.",
          "id" : "2b36da6b-5bfc-4127-b916-d29babe19c52",
          "intuition" : "The two pointers approach involves using two pointers, one at the start and one at the end of the string. We then use these pointers to swap the letters in the string.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "dc-ba",
              "explanation" : "The input string 'ab-cd' contains letters and non-letters. The output string 'dc-ba' has the letters reversed while the non-letter '-' remains in its original position.",
              "id" : "9f893c37-43b3-4de4-9d85-5ffb590e8d09",
              "input" : "ab-cd"
            },
            {
              "expectedOutput" : "a-bc-ba",
              "explanation" : "The input string 'a-bC-ba' contains both uppercase and lowercase letters. The output string 'a-bc-ba' has the letters reversed while the non-letter '-' remains in its original position.",
              "id" : "0ce9fae7-f1a8-4281-98bf-aa6fad008e21",
              "input" : "a-bC-ba"
            },
            {
              "expectedOutput" : "7_28]",
              "explanation" : "The input string '7_28]' contains no letters. The output string is the same as the input string because there are no letters to reverse.",
              "id" : "9f7660ea-609f-4a47-ad6e-45a996dfdbb9",
              "input" : "7_28]"
            }
          ]
        }
      ],
      "id" : "b6590f84-4ca3-49a2-97fc-3620d835a8d1",
      "lastUpdated" : "2026-02-06T21:48:19Z",
      "problemSlug" : "reverse-only-letters",
      "relatedProblems" : [
        "valid-palindrome",
        "reverse-string"
      ],
      "summary" : "Reverse Only Letters is a problem where we need to reverse only the letters in a given string while keeping the non-letter characters in their original positions. The key insight is to use two pointers, one at the start and one at the end of the string."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Define a function to reverse the string. 2. Use Swift's built-in string functions to reverse the string.",
          "code" : "func reverseString(_ s: String) -> String { return String(s.reversed()) }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to create a new string to hold the reversed string.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) where n is the number of characters in the string because Swift's built-in reverse function needs to traverse the entire string to reverse it."
          },
          "explanation" : "In this approach, we are reversing the string by using Swift's built-in reverse() function which returns a reversed sequence.",
          "id" : "41370485-16f2-41c4-9f5c-83c579ad2268",
          "intuition" : "The brute-force approach works by using Swift's built-in string functions to reverse the string.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"olleh\"",
              "explanation" : "The function should return the reversed string \"olleh\" when given the input \"hello\".",
              "id" : "ee17d92b-4037-41f7-a2a5-aa60756e761d",
              "input" : "\"hello\""
            },
            {
              "expectedOutput" : "\"gfedcba\"",
              "explanation" : "The function should return the reversed string \"gfedcba\" when given the input \"abcdefg\".",
              "id" : "5df905e8-20e4-4b61-a1b5-b41620e18e98",
              "input" : "\"abcdefg\""
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers, one at the start and one at the end of the string. 2. Swap the characters at the two pointers. 3. Move the pointers towards the center of the string.",
          "code" : "func reverseString(_ s: String) -> String { var charArray = Array(s); var left = 0; var right = charArray.count - 1; while left < right { let temp = charArray[left]; charArray[left] = charArray[right]; charArray[right] = temp; left += 1; right -= 1 }; return String(charArray) }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to create a new array to hold the characters of the string.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) where n is the number of characters in the string because we need to traverse the entire string to reverse it."
          },
          "explanation" : "In this approach, we are reversing the string by using two pointers to swap characters from the start and end of the string, moving towards the center.",
          "id" : "6c56ec64-4c9a-4d2f-a285-f96ee73df5fa",
          "intuition" : "The two pointers approach works by initializing two pointers, one at the start of the string and one at the end, and then swapping the characters at these pointers while moving them towards the center of the string.",
          "name" : "Two Pointers Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"olleh\"",
              "explanation" : "The function should return the reversed string \"olleh\" when given the input \"hello\".",
              "id" : "79164011-6d96-4c9b-a3bc-f3772e82a49f",
              "input" : "\"hello\""
            },
            {
              "expectedOutput" : "\"gfedcba\"",
              "explanation" : "The function should return the reversed string \"gfedcba\" when given the input \"abcdefg\".",
              "id" : "7713d601-a897-4345-ae03-7a363b510e38",
              "input" : "\"abcdefg\""
            }
          ]
        }
      ],
      "id" : "6712a329-5a94-4020-8f5e-ab8629cd1354",
      "lastUpdated" : "2026-02-06T21:13:42Z",
      "problemSlug" : "reverse-string",
      "relatedProblems" : [
        "string-to-integer-atoi",
        "roman-to-integer"
      ],
      "summary" : "This problem involves reversing a given string and the key insight is to use two pointers to swap characters from the start and end of the string, moving towards the center."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an empty result string. 2. Iterate over the input string in steps of k. 3. For each group of k characters, reverse them and append to the result string.",
          "code" : "func reverseStr(_ s: String, _ k: Int) -> String { \n    var result = \"\" \n    var array = Array(s) \n    for i in stride(from: 0, to: array.count, by: k) { \n        let subArray = Array(array[i..<min(i+k, array.count)]) \n        let reversedSubArray = subArray.reversed() \n        result += String(reversedSubArray) \n    } \n    return result \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, we need to store the entire string in the result.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the string once."
          },
          "explanation" : "The brute force approach works by iterating over the input string and reversing every k group of characters. This is done by using a loop to iterate over the string in steps of k, and then using a reverse function to reverse each group of characters.",
          "id" : "60a00ef5-0bdb-4553-8c52-03bbf7c9e17a",
          "intuition" : "This approach involves iterating over the string and reversing every k group of characters. It is the most straightforward way to solve the problem.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"bacdfeg\"",
              "explanation" : "The first group of 2 characters is \"ab\" which is reversed to \"ba\". The second group of 2 characters is \"cd\" which is reversed to \"dc\".",
              "id" : "154f9440-0c23-48a9-9e70-041ba4d4b455",
              "input" : "s = \"abcdefg\", k = 2"
            },
            {
              "expectedOutput" : "\"bacd\"",
              "explanation" : "The first group of 2 characters is \"ab\" which is reversed to \"ba\". The second group of 2 characters is \"cd\" which is reversed to \"dc\".",
              "id" : "12d3a571-2cad-4fbf-b314-b00551940445",
              "input" : "s = \"abcd\", k = 2"
            }
          ]
        },
        {
          "approach" : "1. Initialize a StringBuilder. 2. Iterate over the input string in steps of k. 3. For each group of k characters, reverse them and append to the StringBuilder.",
          "code" : "func reverseStr(_ s: String, _ k: Int) -> String { \n    var result = String() \n    let chars = Array(s) \n    for i in stride(from: 0, to: chars.count, by: k) { \n        let end = min(i+k, chars.count) \n        let subArray = Array(chars[i..<end]) \n        let reversedSubArray = subArray.reversed() \n        result.append(String(reversedSubArray)) \n        if end < chars.count { \n            result.append(String(chars[end..<min(end+k, chars.count)])) \n        } \n    } \n    return result \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, we need to store the entire string in the result.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the string once."
          },
          "explanation" : "The optimized approach works by using a StringBuilder to efficiently build the result string. This avoids the overhead of string concatenation in the brute force approach.",
          "id" : "37ec4ff6-9852-4d32-9b4f-4124dbd57ee8",
          "intuition" : "This approach involves using a StringBuilder to efficiently build the result string. It is the most efficient way to solve the problem.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"bacdfeg\"",
              "explanation" : "The first group of 2 characters is \"ab\" which is reversed to \"ba\". The second group of 2 characters is \"cd\" which is reversed to \"dc\".",
              "id" : "6ad6bb2c-10a7-4b32-b608-73edfe4a90f9",
              "input" : "s = \"abcdefg\", k = 2"
            },
            {
              "expectedOutput" : "\"bacd\"",
              "explanation" : "The first group of 2 characters is \"ab\" which is reversed to \"ba\". The second group of 2 characters is \"cd\" which is reversed to \"dc\".",
              "id" : "9c577d6d-5d0a-4b24-a30d-50b549541cd9",
              "input" : "s = \"abcd\", k = 2"
            }
          ]
        }
      ],
      "id" : "7cb7c685-d041-4eb6-b5df-8862eea32214",
      "lastUpdated" : "2026-02-06T21:25:24Z",
      "problemSlug" : "reverse-string-ii",
      "relatedProblems" : [
        "reverse-words-in-a-string-iii",
        "reverse-string"
      ],
      "summary" : "The problem requires reversing every k group of characters in a given string. The key insight is to use string manipulation techniques to achieve this."
    },
    {
      "approaches" : [
        {
          "approach" : "First, we create a list of vowels. We then iterate through the input string to find vowels and store their indices. Next, we replace each vowel in the string with the corresponding vowel from the end of the list of vowels, moving towards the start.",
          "code" : "func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is also linear because in the worst case, we store all characters of the input string if all of them are vowels.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we potentially scan the string twice: once to find and store the vowels, and once to replace the vowels in the original string."
          },
          "explanation" : "This approach involves creating an array to store the vowels found in the string. The array is then iterated to replace the vowels in the string with the vowels from the end of the array, effectively reversing the vowels. This method, although straightforward, results in additional space complexity due to the storage of vowels.",
          "id" : "872bde31-d476-4c78-9759-429ee3ce63cf",
          "intuition" : "To reverse the vowels in a string, we can first find all the vowels and store them, then replace the vowels in the original string with the vowels from the stored list in reverse order.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"holle\"",
              "explanation" : "The vowels in the string \"hello\" are 'e' and 'o'. Reversing these vowels results in 'holle'.",
              "id" : "c4646e6a-335d-41dd-9827-ecc2c4cfa9f7",
              "input" : "s = \"hello\""
            },
            {
              "expectedOutput" : "\"uoiea\"",
              "explanation" : "The vowels in the string \"aeiou\" are 'a', 'e', 'i', 'o', and 'u'. Reversing these vowels results in \"uoiea\".",
              "id" : "9b5bfafa-e878-4f2a-9269-a05a6832ebc6",
              "input" : "s = \"aeiou\""
            }
          ]
        },
        {
          "approach" : "We initialize two pointers, one at the start and one at the end of the string. We then move these pointers towards each other, swapping any pair of vowels encountered.",
          "code" : "func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we convert the string into a character array to enable in-place modification.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we potentially scan the string once, moving the pointers towards each other."
          },
          "explanation" : "The two-pointer approach is more efficient because it avoids the extra space needed to store the vowels. It achieves this by iterating through the string from both ends and swapping any vowels encountered, effectively reversing the vowels in-place.",
          "id" : "786e70d3-472a-4cc7-876a-c392455511be",
          "intuition" : "Using a two-pointer technique allows for an efficient and in-place reversal of vowels without the need for extra space to store the vowels.",
          "name" : "Two-Pointer Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"leotcede\"",
              "explanation" : "The vowels in the string \"leetcode\" are 'e', 'e', and 'o'. Reversing these vowels results in \"leotcede\".",
              "id" : "02bde1d2-a7c6-4514-97f6-36f6020cd2bd",
              "input" : "s = \"leetcode\""
            },
            {
              "expectedOutput" : "\"racecar\"",
              "explanation" : "The vowels in the string \"racecar\" are 'a' and 'e'. Reversing these vowels results in \"racecar\", which is the same as the original string because 'a' and 'e' are in symmetric positions.",
              "id" : "81089e7f-89b3-4b68-8c01-b290ad970c34",
              "input" : "s = \"racecar\""
            }
          ]
        }
      ],
      "id" : "4e6533f6-ea76-40b0-b8cd-bd8d83c30db5",
      "lastUpdated" : "2026-02-06T21:13:47Z",
      "problemSlug" : "reverse-vowels-of-a-string",
      "relatedProblems" : [
        "implement-strstr",
        "length-of-last-word"
      ],
      "summary" : "The problem requires reversing the vowels of a given string, which can be solved using a two-pointer technique. This approach allows for efficient traversal and swapping of characters."
    },
    {
      "approaches" : [
        {
          "approach" : "First, split the input string into individual words by spaces. Then, store each word in an array. After that, iterate through the array in reverse order and append each word to a result string with a space in between.",
          "code" : "func reverseWords(_ s: String) -> String { let words = s.components(separatedBy: \" \"); var result = \"\"; for i in stride(from: words.count - 1, through: 0, by: -1) { result += words[i] + \" \" }; return String(result.dropLast()) }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we are storing the array of words.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are iterating through the array of words once."
          },
          "explanation" : "The brute force approach involves extra space to store the array of words, but it provides a straightforward solution to the problem.",
          "id" : "2ee95a8f-ce60-4f50-a171-554c242a2b81",
          "intuition" : "This approach works by splitting the string into individual words, storing them in an array, and then iterating through the array to form the reversed string.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"world! hello\"",
              "explanation" : "The input string contains extra spaces at the beginning and end, which should be ignored in the output.",
              "id" : "05006eb4-f8da-4bd3-9280-96c94eb523f3",
              "input" : "s = \"  hello world! \""
            },
            {
              "expectedOutput" : "\"example good a\"",
              "explanation" : "The input string contains multiple spaces between words, which should be treated as a single space in the output.",
              "id" : "1822f64c-c33e-444b-bcca-9ad5afc362db",
              "input" : "s = \"a good   example\""
            }
          ]
        },
        {
          "approach" : "First, initialize two pointers at the beginning of the string. Then, find the end of the first word and reverse the characters in that word. After that, move the pointers to the next word and repeat the process until the end of the string is reached.",
          "code" : "func reverseWords(_ s: String) -> String { var chars = Array(s); var start = 0; for i in 0..<chars.count { if chars[i] == \" \" { reverse(&chars, start: start, end: i - 1); start = i + 1 } }; reverse(&chars, start: start, end: chars.count - 1); reverse(&chars, start: 0, end: chars.count - 1); return String(chars).trimmingCharacters(in: .whitespaces) }; func reverse(_ chars: inout [Character], start: Int, end: Int) { var left = start; var right = end; while left < right { (chars[left], chars[right]) = (chars[right], chars[left]); left += 1; right -= 1 } }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are only using a constant amount of space to store the pointers and temporary variables.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are iterating through the string once."
          },
          "explanation" : "The optimized approach avoids extra space and provides an efficient solution to the problem.",
          "id" : "66bc898c-e6c0-4328-8062-82fba2287393",
          "intuition" : "This approach works by using two pointers to track the start and end of each word in the string, and then reversing the order of the words.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"world! hello\"",
              "explanation" : "The input string contains extra spaces at the beginning and end, which should be ignored in the output.",
              "id" : "6906787a-f4c8-4e12-90af-bd4e535c0ab3",
              "input" : "s = \"  hello world! \""
            },
            {
              "expectedOutput" : "\"example good a\"",
              "explanation" : "The input string contains multiple spaces between words, which should be treated as a single space in the output.",
              "id" : "590b50dd-690b-4456-9299-9ba6439e8221",
              "input" : "s = \"a good   example\""
            }
          ]
        }
      ],
      "id" : "9a82a423-4c3f-4155-aa7a-a9eb34d8a73d",
      "lastUpdated" : "2026-02-06T21:07:35Z",
      "problemSlug" : "reverse-words-in-a-string",
      "relatedProblems" : [
        "reverse-string",
        "reverse-words-in-a-string-iii"
      ],
      "summary" : "The problem requires reversing the order of words in a given string, and the key insight is to split the string into individual words and then reverse their order."
    },
    {
      "approaches" : [
        {
          "approach" : "Split the string into words, iterate over each word, reverse the characters in the word, and append the reversed word to the result string.",
          "code" : "func reverseWords(_ s: String) -> String { let words = s.components(separatedBy: \" \"); var result = \"\"; for i in 0..<words.count { let word = String(words[i].reversed()); result += word; if i < words.count - 1 { result += \" \" } } return result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from the extra space needed to store the result string.",
            "time" : "O(n*m)",
            "timeExplanation" : "We're doing a constant amount of work for each character in the string, where n is the number of characters and m is the average length of a word."
          },
          "explanation" : "First, we split the input string into words using the space character as a delimiter. Then, we iterate over each word, reversing its characters. Finally, we append the reversed word to the result string, followed by a space if it's not the last word.",
          "id" : "c9ec27a8-cd18-4dad-b0ad-d0ffcb6d4673",
          "intuition" : "The brute force approach involves splitting the string into words, reversing each word, and then joining them back together.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"s'Let ekat edoCteeL tsetnoc\"",
              "explanation" : "The input \"Let's take LeetCode contest\" becomes \"s'Let ekat edoCteeL tsetnoc\" after reversing each word.",
              "id" : "45d800d0-e72b-40e6-b09a-96de8ddf802c",
              "input" : "s = \"Let's take LeetCode contest\""
            },
            {
              "expectedOutput" : "\"doG gniD\"",
              "explanation" : "The input \"God ding\" becomes \"doG gniD\" after reversing each word.",
              "id" : "dd068669-c84e-4bb2-a9ae-adee226f3fa5",
              "input" : "s = \"God ding\""
            }
          ]
        },
        {
          "approach" : "Use the split function to split the string into words, use a higher-order function to reverse each word, and then join the reversed words back together.",
          "code" : "func reverseWords(_ s: String) -> String { return s.components(separatedBy: \" \").map { String($0.reversed()) }.joined(separator: \" \") }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from the extra space needed to store the result string.",
            "time" : "O(n*m)",
            "timeExplanation" : "We're doing a constant amount of work for each character in the string, where n is the number of characters and m is the average length of a word."
          },
          "explanation" : "We split the input string into words using the space character as a delimiter. Then, we use a higher-order function to reverse each word. Finally, we join the reversed words back together using the space character as a delimiter.",
          "id" : "f4f5de27-6cec-40f9-8e20-3e203c2442b1",
          "intuition" : "The optimized approach uses the split function to split the string into words and a higher-order function to reverse each word, making the code more concise.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"s'Let ekat edoCteeL tsetnoc\"",
              "explanation" : "The input \"Let's take LeetCode contest\" becomes \"s'Let ekat edoCteeL tsetnoc\" after reversing each word.",
              "id" : "4fa55336-30c4-4e9c-b52f-66789eafc878",
              "input" : "s = \"Let's take LeetCode contest\""
            },
            {
              "expectedOutput" : "\"doG gniD\"",
              "explanation" : "The input \"God ding\" becomes \"doG gniD\" after reversing each word.",
              "id" : "f1291624-b6f6-40c6-9d57-76081d2577c0",
              "input" : "s = \"God ding\""
            }
          ]
        }
      ],
      "id" : "e5e02782-40ad-4b89-bd34-7c5fffc2dad6",
      "lastUpdated" : "2026-02-06T21:26:02Z",
      "problemSlug" : "reverse-words-in-a-string-iii",
      "relatedProblems" : [
        "reverse-words-in-a-string",
        "rotate-array"
      ],
      "summary" : "This problem involves reversing the order of characters in each word of a given string, a key insight being the use of two pointers or split function to isolate and reverse individual words."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Reverse entire array\n2. Reverse first k elements\n3. Reverse remaining elements",
          "code" : "func rotate(_ nums: inout [Int], _ k: Int) {\n    let k = k % nums.count\n    if k == 0 { return }\n    \n    func reverse(_ start: Int, _ end: Int) {\n        var l = start, r = end\n        while l < r {\n            nums.swapAt(l, r)\n            l += 1; r -= 1\n        }\n    }\n    \n    reverse(0, nums.count - 1)\n    reverse(0, k - 1)\n    reverse(k, nums.count - 1)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place",
            "time" : "O(n)",
            "timeExplanation" : "Three passes"
          },
          "explanation" : "Example: [1,2,3,4,5] k=2  [5,4,3,2,1]  [4,5,3,2,1]  [4,5,1,2,3]",
          "id" : "42e3dc27-dd01-4618-9231-47282bb551d8",
          "intuition" : "Reversing brings elements to correct relative positions, then fix order.",
          "name" : "Three Reverses",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[5,6,7,1,2,3,4]",
              "explanation" : "Rotated right by 3",
              "id" : "fa3f4c40-f794-4ff6-b170-4694e6bd5068",
              "input" : "nums = [1,2,3,4,5,6,7], k = 3"
            }
          ]
        }
      ],
      "id" : "8adbcd40-8a88-4571-bd32-1742a771c7cf",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "rotate-array",
      "relatedProblems" : [
        "rotate-image"
      ],
      "summary" : "Rotate array by k positions. Reverse whole, then reverse first k and last n-k."
    },
    {
      "approaches" : [
        {
          "approach" : "Loop through each character in the string. For each character, loop through the rest of the string to find the target character and calculate the distance.",
          "code" : "\n       func shortestToChar(_ s: String, _ c: Character) -> [Int] {\n           let chars = Array(s)\n           var res = [Int]()\n           for i in 0..<chars.count {\n               var minDistance = Int.max\n               for j in 0..<chars.count {\n                   if chars[j] == c {\n                       minDistance = min(minDistance, abs(j - i))\n                   }\n               }\n               res.append(minDistance)\n           }\n           return res\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The result array and the character array take linear space.",
            "time" : "O(n^2)",
            "timeExplanation" : "The outer loop iterates over the string, and the inner loop does the same, resulting in a quadratic time complexity."
          },
          "explanation" : "This approach works by exhaustively checking all possible distances for each character. It's simple but not efficient for large strings.",
          "id" : "0ae630f5-1296-450b-a33e-c3a7a91507c0",
          "intuition" : "For each character in the string, check all other characters to find the shortest distance to the target character.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[3,2,1,0,1,0,0,1,2,2,1,0]",
              "explanation" : "The shortest distance from each character to 'e' is calculated and stored in the result array.",
              "id" : "88743ea4-2252-411a-89cb-4529e6332524",
              "input" : "s = \"loveleetcode\", c = 'e'"
            },
            {
              "expectedOutput" : "[3,2,1,0,0,0]",
              "explanation" : "The shortest distance from each character to 'b' is calculated and stored in the result array.",
              "id" : "f2bcda36-59c1-44a0-86ee-b10bf2a11b03",
              "input" : "s = \"aaabbb\", c = 'b'"
            }
          ]
        },
        {
          "approach" : "First, iterate from left to right and update the distances based on the last seen target character. Then, iterate from right to left and update the distances based on the last seen target character from the right.",
          "code" : "\n       func shortestToChar(_ s: String, _ c: Character) -> [Int] {\n           let chars = Array(s)\n           var res = Array(repeating: Int.max, count: chars.count)\n           var lastSeen = -Int.max\n\n           \/\/ pass 1: from left to right\n           for i in 0..<chars.count {\n               if chars[i] == c {\n                   lastSeen = i\n               }\n               if lastSeen != -Int.max {\n                   res[i] = min(res[i], abs(i - lastSeen))\n               }\n           }\n\n           \/\/ pass 2: from right to left\n           lastSeen = Int.max\n           for i in stride(from: chars.count - 1, through: 0, by: -1) {\n               if chars[i] == c {\n                   lastSeen = i\n               }\n               if lastSeen != Int.max {\n                   res[i] = min(res[i], abs(i - lastSeen))\n               }\n           }\n\n           return res\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The result array takes linear space.",
            "time" : "O(n)",
            "timeExplanation" : "We make two passes through the string, resulting in a linear time complexity."
          },
          "explanation" : "This approach works by maintaining a running minimum distance for each character as we iterate through the string from both directions.",
          "id" : "b4c3e60c-3813-404e-b733-6b3315f4c78b",
          "intuition" : "Use two passes, one from left to right and one from right to left, to find the minimum distance for each character.",
          "name" : "Two-Pass",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[3,2,1,0,1,0,0,1,2,2,1,0]",
              "explanation" : "The shortest distance from each character to 'e' is calculated and stored in the result array.",
              "id" : "c2c49503-c11a-4ea0-9a15-914372d183e0",
              "input" : "s = \"loveleetcode\", c = 'e'"
            },
            {
              "expectedOutput" : "[3,2,1,0,0,0]",
              "explanation" : "The shortest distance from each character to 'b' is calculated and stored in the result array.",
              "id" : "d294a5d7-9ac8-4bf4-972f-7e18fe8923fb",
              "input" : "s = \"aaabbb\", c = 'b'"
            }
          ]
        }
      ],
      "id" : "e610c8ba-d289-4d80-8bc3-eedbee8eb394",
      "lastUpdated" : "2026-02-06T21:42:07Z",
      "problemSlug" : "shortest-distance-to-a-character",
      "relatedProblems" : [
        "min-stack",
        "valid-parentheses"
      ],
      "summary" : "The problem asks for the shortest distance from each character in a string to a specific character. The key insight is to use two passes, one from left to right and one from right to left, to find the minimum distance for each character."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays, sort each one and check if the entire array is sorted after sorting the subarray. Keep track of the shortest such subarray",
          "code" : "\n       func findUnsortedSubarray(_ nums: [Int]) -> Int {\n         let count = nums.count\n         var shortest = count\n         for i in 0...count - 1 {\n           for j in i...count - 1 {\n             var temp = nums\n             temp.replaceSubrange(i...j, with: temp[i...j].sorted())\n             if isSorted(temp) && (j - i + 1) < shortest {\n               shortest = j - i + 1\n             }\n           }\n         }\n         return shortest > count ? 0 : shortest\n       }\n\n       func isSorted(_ nums: [Int]) -> Bool {\n         var prev = Int.min\n         for num in nums {\n           if num < prev {\n             return false\n           }\n           prev = num\n         }\n         return true\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need O(n) space to store the temporary sorted array",
            "time" : "O(n^3)",
            "timeExplanation" : "For each subarray, we sort it and check if the entire array is sorted, resulting in O(n^3) time complexity"
          },
          "explanation" : "We generate all possible subarrays using two nested loops, then sort each subarray and check if the entire array is sorted. If it is, and the length of the subarray is smaller than our current shortest subarray, we update our shortest subarray",
          "id" : "a5ae9cb8-d6f7-4a7c-8fe0-ad7d657d907d",
          "intuition" : "This approach works by trying all possible subarrays and checking if sorting that subarray makes the entire array sorted",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The shortest subarray that needs to be sorted is [8, 10, 9], which has a length of 3, but we need to return the length of the subarray, which is 5",
              "id" : "f2978035-9755-406f-b524-21af68717ef5",
              "input" : "nums = [2,6,4,8,10,9,15]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The array is already sorted, so we return 0",
              "id" : "9c3aa1aa-0c1b-42bd-8793-d1f265030cd1",
              "input" : "nums = [1,2,3,4]"
            }
          ]
        },
        {
          "approach" : "We compare the original array with its sorted version and find the first and last elements that are not in the correct position. These elements are the start and end of the shortest subarray that needs to be sorted",
          "code" : "\n       func findUnsortedSubarray(_ nums: [Int]) -> Int {\n         let sorted = nums.sorted()\n         var left = nums.count\n         var right = 0\n         for i in 0...nums.count - 1 {\n           if nums[i] != sorted[i] {\n             left = min(left, i)\n             right = max(right, i)\n           }\n         }\n         return right - left < 0 ? 0 : right - left + 1\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need O(n) space to store the sorted array",
            "time" : "O(n log n)",
            "timeExplanation" : "Sorting the array takes O(n log n) time complexity"
          },
          "explanation" : "We generate the sorted version of the array, then compare it with the original array to find the start and end indices of the subarray. We use two pointers, one starting from the beginning and one from the end, to find these indices",
          "id" : "0d99e1e4-cb14-4071-a291-338a973786ec",
          "intuition" : "This approach works by finding the first and last elements that are not in the correct position in the sorted array",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The shortest subarray that needs to be sorted is from index 1 to 5",
              "id" : "415faacf-58c9-4c4d-8894-ae7dbcc6d32a",
              "input" : "nums = [2,6,4,8,10,9,15]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The array is already sorted, so we return 0",
              "id" : "62e4a2bb-b1af-4c16-8cf4-125dacb19bca",
              "input" : "nums = [1,2,3,4]"
            }
          ]
        }
      ],
      "id" : "109af803-b3fe-45ee-b255-2417b872d799",
      "lastUpdated" : "2026-02-06T21:27:02Z",
      "problemSlug" : "shortest-unsorted-continuous-subarray",
      "relatedProblems" : [
        "array-partition-i",
        "find-all-duplicates-in-an-array"
      ],
      "summary" : "The problem requires finding the shortest subarray that needs to be sorted in-place to make the entire array sorted, the key insight being to compare the original array with its sorted version."
    },
    {
      "approaches" : [
        {
          "approach" : "First, initialize two empty arrays, one for even numbers and one for odd numbers. Then, iterate over the input array. For each number, check if it's even or odd and add it to the corresponding array. Finally, combine the even and odd arrays.",
          "code" : "\n           func sortArrayByParity(_ A: [Int]) -> [Int] {\n               var evenArray: [Int] = []\n               var oddArray: [Int] = []\n               for num in A {\n                   if num % 2 == 0 {\n                       evenArray.append(num)\n                   } else {\n                       oddArray.append(num)\n                   }\n               }\n               return evenArray + oddArray\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we're storing the even and odd numbers in separate arrays.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we're iterating over the array once."
          },
          "explanation" : "This approach works, but it requires additional space to store the even and odd arrays.",
          "id" : "0c59db92-b2f8-4c42-89ca-0c78e84fc5bc",
          "intuition" : "This approach works by iterating over the array and adding even numbers to one array and odd numbers to another, then combining the two arrays.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2,4,3,1]",
              "explanation" : "The even numbers are 2 and 4, and the odd numbers are 3 and 1.",
              "id" : "52effcb2-444d-45ec-88c9-5d726a677907",
              "input" : "nums = [3,1,2,4]"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "The only number is 0, which is even.",
              "id" : "451ac6d7-3821-4b13-94bb-04712cbfa2d7",
              "input" : "nums = [0]"
            }
          ]
        },
        {
          "approach" : "First, initialize two pointers, one at the beginning of the array and one at the end. Then, iterate over the array. If the current number is even, swap it with the number at the even pointer, and increment the even pointer. If the current number is odd, swap it with the number at the odd pointer, and decrement the odd pointer.",
          "code" : "\n           func sortArrayByParity(_ A: [Int]) -> [Int] {\n               var arr = A\n               var evenIndex = 0\n               for (index, value) in arr.enumerated() {\n                   if value % 2 == 0 {\n                       let temp = arr[evenIndex]\n                       arr[evenIndex] = arr[index]\n                       arr[index] = temp\n                       evenIndex += 1\n                   }\n               }\n               return arr\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we're only using a constant amount of space.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we're iterating over the array once."
          },
          "explanation" : "This approach works in-place, without using any additional space.",
          "id" : "67ad5ad2-5dc1-41f4-a119-24a1b5ca634c",
          "intuition" : "This approach works by using two pointers, one at the beginning and one at the end of the array, to swap even and odd numbers.",
          "name" : "Two Pointers Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2,4,3,1]",
              "explanation" : "The even numbers are 2 and 4, and the odd numbers are 3 and 1.",
              "id" : "4f3faab3-6379-43e2-b165-754539e3d279",
              "input" : "nums = [3,1,2,4]"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "The only number is 0, which is even.",
              "id" : "5a9a82cf-2006-416a-b605-e3b4f9b4908e",
              "input" : "nums = [0]"
            }
          ]
        }
      ],
      "id" : "83904144-7f0d-46c8-89a5-5cf63af06568",
      "lastUpdated" : "2026-02-06T21:47:33Z",
      "problemSlug" : "sort-array-by-parity",
      "relatedProblems" : [
        "single-number",
        "missing-number"
      ],
      "summary" : "The problem requires sorting an array of integers by parity. The key insight is to use two pointers, one at the beginning and one at the end of the array, to separate even and odd numbers."
    },
    {
      "approaches" : [
        {
          "approach" : "First, separate the numbers into two lists: one for even numbers and one for odd numbers. Then, create a new list and add elements to it, alternating between even and odd numbers.",
          "code" : "func sortArrayByParityII(_ nums: [Int]) -> [Int] {\n    var even = [Int](), odd = [Int]()\n    for num in nums {\n        if num % 2 == 0 {\n            even.append(num)\n        } else {\n            odd.append(num)\n        }\n    }\n    var result = [Int]()\n    while !even.isEmpty || !odd.isEmpty {\n        if let firstEven = even.first {\n            result.append(firstEven)\n            even.removeFirst()\n        }\n        if let firstOdd = odd.first {\n            result.append(firstOdd)\n            odd.removeFirst()\n        }\n    }\n    return result\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the even and odd numbers in separate lists before creating the final result list.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we iterate through the input array once to separate the numbers into even and odd lists, and then another pass to combine them into the result list."
          },
          "explanation" : "This approach works by first separating the numbers into two distinct lists and then combining them in an alternating pattern. However, it requires extra space for the separate lists and the result list.",
          "id" : "fd7856df-21e4-4a68-bc3a-25b0e0fcd7fa",
          "intuition" : "This approach involves sorting the array by parity and then rearranging the elements to meet the alternating pattern requirement.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[4,5,2,7]",
              "explanation" : "The numbers are rearranged to meet the alternating pattern requirement.",
              "id" : "bc7df441-4a29-4691-9e53-e77785bf093a",
              "input" : "nums = [4,2,5,7]"
            },
            {
              "expectedOutput" : "[2,9,7,1]",
              "explanation" : "The even numbers are placed before the odd numbers in an alternating pattern.",
              "id" : "bde1d348-1dce-4aee-9481-e123c99712c9",
              "input" : "nums = [2,7,9,1]"
            }
          ]
        },
        {
          "approach" : "Initialize two pointers, one at the start and one at the end of the array. Swap elements if the parity at the start pointer does not match the expected parity.",
          "code" : "func sortArrayByParityII(_ nums: [Int]) -> [Int] {\n    var nums = nums\n    for i in stride(from: 0, to: nums.count, by: 2) {\n        if nums[i] % 2 == 1 {\n            for j in stride(from: i + 1, to: nums.count, by: 2) {\n                if nums[j] % 2 == 0 {\n                    nums.swapAt(i, j)\n                    break\n                }\n            }\n        }\n    }\n    return nums\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity improves to O(1) because we are performing the swap operations in place, without the need for additional data structures that scale with input size.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity remains O(n) because in the worst case, we might need to scan the entire array to find a suitable swap for each element that does not match the expected parity."
          },
          "explanation" : "This approach works by scanning the array from left to right, checking each element's parity against the expected pattern (even, odd, even, odd, etc.), and swapping elements when necessary to correct the pattern.",
          "id" : "d6631733-77e4-4c0f-b51d-c44a885c1fab",
          "intuition" : "We can improve the brute force approach by using two pointers to swap elements in place, thus eliminating the need for extra space.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[4,5,2,7]",
              "explanation" : "The even numbers are correctly placed before the odd numbers in an alternating pattern.",
              "id" : "34a4fe9c-4210-4a87-9669-945364fd24ba",
              "input" : "nums = [4,2,5,7]"
            },
            {
              "expectedOutput" : "[2,9,7,1]",
              "explanation" : "The even and odd numbers are correctly interleaved to meet the problem's requirements.",
              "id" : "874616cb-fc23-4389-ad0c-5dcc17833af0",
              "input" : "nums = [2,7,9,1]"
            }
          ]
        }
      ],
      "id" : "cab36503-e49f-4426-9f0f-a7ed4d2a5eea",
      "lastUpdated" : "2026-02-06T21:48:53Z",
      "problemSlug" : "sort-array-by-parity-ii",
      "relatedProblems" : [
        "reverse-words-in-a-string-iii",
        "sort-colors"
      ],
      "summary" : "The problem requires sorting an array of integers such that all even numbers come before all odd numbers, with the constraint that the resulting array must have an alternating pattern of even and odd numbers. This can be achieved with a two-pointer approach."
    },
    {
      "approaches" : [
        {
          "approach" : "1. low = 0 (boundary for 0s), high = n-1 (boundary for 2s), mid = 0\n2. While mid <= high:\n   a. If nums[mid] == 0: swap with low, increment both low and mid\n   b. If nums[mid] == 1: just increment mid\n   c. If nums[mid] == 2: swap with high, decrement high (don't increment mid!)\n3. Array is sorted",
          "code" : "func sortColors(_ nums: inout [Int]) {\n    var low = 0\n    var mid = 0\n    var high = nums.count - 1\n    \n    while mid <= high {\n        switch nums[mid] {\n        case 0:\n            nums.swapAt(low, mid)\n            low += 1\n            mid += 1\n        case 1:\n            mid += 1\n        case 2:\n            nums.swapAt(mid, high)\n            high -= 1\n            \/\/ Don't increment mid - need to check swapped value\n        default:\n            break\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place sorting with just pointer variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through array"
          },
          "explanation" : "The array is partitioned into 4 regions: [0...low-1] are 0s, [low...mid-1] are 1s, [mid...high] are unknown, [high+1...n-1] are 2s. We scan with mid, placing 0s at low and 2s at high. When swapping with high, we don't advance mid because the swapped element is unknown and needs to be checked.",
          "id" : "0681a423-fedc-4957-8fe3-fae31d7dca79",
          "intuition" : "Maintain three regions: 0s at the front, 2s at the back, 1s in the middle. Use three pointers to expand these regions.",
          "name" : "Dutch National Flag (3 Pointers)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,0,1,1,2,2]",
              "explanation" : "0s moved to front, 2s to back, 1s in middle",
              "id" : "844a778a-0d0d-4c7a-90c6-351278cb66c8",
              "input" : "nums = [2,0,2,1,1,0]"
            },
            {
              "expectedOutput" : "[0,1,2]",
              "explanation" : "Simple case with one of each",
              "id" : "b38571d6-a563-448d-b6db-e3984d068290",
              "input" : "nums = [2,0,1]"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "Single element already sorted",
              "id" : "d0a964d6-024b-4111-ae21-4d5715c6e6ea",
              "input" : "nums = [0]"
            }
          ]
        },
        {
          "approach" : "1. Count how many 0s, 1s, 2s\n2. Fill array: first count0 zeros, then count1 ones, then count2 twos",
          "code" : "func sortColors(_ nums: inout [Int]) {\n    var count = [0, 0, 0]\n    \n    for num in nums {\n        count[num] += 1\n    }\n    \n    var index = 0\n    for color in 0..<3 {\n        for _ in 0..<count[color] {\n            nums[index] = color\n            index += 1\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only 3 counter variables",
            "time" : "O(n)",
            "timeExplanation" : "Two passes through array"
          },
          "explanation" : "Since we only have 3 possible values, counting sort is efficient. First pass counts, second pass writes. This uses O(1) extra space (just 3 counters) but requires two passes through the array.",
          "id" : "1a57e429-0f48-469f-8b63-a78fb5721ab5",
          "intuition" : "Count occurrences of 0, 1, 2, then overwrite array with that many of each. Two passes but very simple.",
          "name" : "Counting Sort",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0,0,1,1,2,2]",
              "explanation" : "Count: [2,2,2]. Write 2 zeros, 2 ones, 2 twos.",
              "id" : "309baa40-9e30-4a02-9f9a-e6660074201a",
              "input" : "nums = [2,0,2,1,1,0]"
            }
          ]
        }
      ],
      "id" : "d9aa754e-e590-4782-babf-c84ee1fdd224",
      "lastUpdated" : "2026-02-06T08:40:26Z",
      "problemSlug" : "sort-colors",
      "relatedProblems" : [
        "sort-list",
        "wiggle-sort",
        "wiggle-sort-ii"
      ],
      "summary" : "Sort array with values 0, 1, 2 (Dutch National Flag problem). Use three pointers to partition in single pass: low for 0s boundary, high for 2s boundary, mid for scanning."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Left pointer at start, right at end\n2. Result array filled from back\n3. Compare abs values at left and right\n4. Place larger square at current result position, move that pointer\n5. Decrement result position",
          "code" : "func sortedSquares(_ nums: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: nums.count)\n    var left = 0\n    var right = nums.count - 1\n    var pos = nums.count - 1\n    \n    while left <= right {\n        let leftSq = nums[left] * nums[left]\n        let rightSq = nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left += 1\n        } else {\n            result[pos] = rightSq\n            right -= 1\n        }\n        pos -= 1\n    }\n    \n    return result\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Result array of size n",
            "time" : "O(n)",
            "timeExplanation" : "Single pass with two pointers"
          },
          "explanation" : "In a sorted array with negatives, the largest absolute values are at the extremes. By using two pointers and filling the result from the end, we efficiently place squares in sorted order without needing to sort afterward.",
          "id" : "540673ac-a87e-4c30-ac12-47ac6a5e8f7c",
          "intuition" : "Largest squares are at the ends (most negative or most positive). Compare absolute values at both ends, place larger square at end of result, move pointer inward.",
          "name" : "Two Pointers",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,1,9,16,100]",
              "explanation" : "Compare |-4|=4 vs |10|=10. 100 goes last. Then |-4| vs |3|, 16 goes next. Etc.",
              "id" : "70106d22-0d1b-461f-8353-6e8fa03eb7e1",
              "input" : "nums = [-4,-1,0,3,10]"
            },
            {
              "expectedOutput" : "[4,9,9,49,121]",
              "explanation" : "Two pointers handle negative numbers efficiently",
              "id" : "453089a5-45c6-4d42-9a1d-1d9abdbf6b01",
              "input" : "nums = [-7,-3,2,3,11]"
            }
          ]
        },
        {
          "approach" : "1. Square each element\n2. Sort the result",
          "code" : "func sortedSquares(_ nums: [Int]) -> [Int] {\n    return nums.map { $0 * $0 }.sorted()\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "New array for result",
            "time" : "O(n log n)",
            "timeExplanation" : "Sorting dominates"
          },
          "explanation" : "This naive approach works but uses O(n log n) time due to sorting. The two-pointer approach is better, but this is simpler to implement and understand.",
          "id" : "75c04428-bf96-4c25-8ec4-d205e19aacee",
          "intuition" : "Simple approach: square all elements, then sort. Less efficient but very straightforward.",
          "name" : "Square and Sort",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0,1,9,16,100]",
              "explanation" : "Square: [16,1,0,9,100]. Sort: [0,1,9,16,100]",
              "id" : "993d38e2-c1b2-4a05-b438-c9ed48cca30b",
              "input" : "nums = [-4,-1,0,3,10]"
            }
          ]
        }
      ],
      "id" : "5c96629b-5cad-4841-826f-81acff3c5cee",
      "lastUpdated" : "2026-02-06T00:53:56.092Z",
      "problemSlug" : "squares-of-a-sorted-array",
      "relatedProblems" : [
        "merge-sorted-array",
        "sort-an-array"
      ],
      "summary" : "Given sorted array (may have negatives), return array of squares in sorted order. Two pointers from ends, compare absolute values, fill result from back."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize an empty result string. Step 2: Iterate over the input string. Step 3: If the current character is the same as the next one, increment the count. Step 4: If the current character is different from the next one, append the character and its count to the result string. Step 5: Return the result string if its length is less than the original string, otherwise return the original string.",
          "code" : "\n           func compress(_ chars: inout [Character]) -> Int {\n               var result = [Character]()\n               var count = 1\n               for i in 0..<chars.count {\n                   if i + 1 < chars.count && chars[i] == chars[i + 1] {\n                       count += 1\n                   } else {\n                       result.append(chars[i])\n                       if count > 1 {\n                           for char in String(count) {\n                               result.append(char)\n                           }\n                       }\n                       count = 1\n                   }\n               }\n               if result.count >= chars.count {\n                   return chars.count\n               }\n               chars = result\n               return result.count\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, we might end up with a result string of the same length as the input string.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the input string."
          },
          "explanation" : "The brute force approach has a high time complexity because it involves iterating over the string multiple times. However, it provides a straightforward solution to the problem.",
          "id" : "a7ed3c74-0b72-42ab-be0f-4f6a338ea175",
          "intuition" : "This approach involves iterating over the string, comparing each character with the next one, and counting the occurrences of each character.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The compressed string is 'a2b2c3', which has a length of 6. Since this is greater than or equal to the original string, we return the original length.",
              "id" : "a572b30f-001b-4e58-a431-dfb82c0c8e76",
              "input" : "['a', 'a', 'b', 'b', 'c', 'c', 'c']"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The compressed string is 'a', which has a length of 1. Since this is equal to the original string, we return the original length.",
              "id" : "58931ce7-caf3-4d2d-a42c-d3545925bbd9",
              "input" : "['a']"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The compressed string is 'abc', which has a length of 3. Since this is equal to the original string, we return the original length.",
              "id" : "b11fee68-fc2b-4e0f-8de4-5d85716189b7",
              "input" : "['a', 'b', 'c']"
            }
          ]
        },
        {
          "approach" : "Step 1: Initialize two pointers, 'left' and 'write'. Step 2: Iterate over the input string using the 'right' pointer. Step 3: If the current character is the same as the next one, increment the count. Step 4: If the current character is different from the next one, append the character and its count to the result string. Step 5: Return the result string if its length is less than the original string, otherwise return the original string.",
          "code" : "\n           func compress(_ chars: inout [Character]) -> Int {\n               let n = chars.count\n               if n == 0 {\n                   return 0\n               }\n               var left = 0\n               var write = 0\n               for (right, char) in chars.enumerated() {\n                   if right == n - 1 || char != chars[right + 1] {\n                       chars[write] = char\n                       write += 1\n                       if right > left {\n                           let count = right - left + 1\n                           for c in String(count) {\n                               chars[write] = c\n                               write += 1\n                           }\n                       }\n                       left = right + 1\n                   }\n               }\n               return min(write, n)\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are only using a constant amount of space to store the pointers and the count.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the input string once."
          },
          "explanation" : "The optimized approach has a lower time complexity than the brute force approach because it only involves iterating over the string once.",
          "id" : "b7911cf2-68b2-4d50-8e2a-1545332288a4",
          "intuition" : "This approach involves using two pointers to track the current character sequence and the next character sequence. It allows us to avoid unnecessary comparisons and counting.",
          "name" : "Optimized Two Pointer Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "The compressed string is 'a2b2c3', which has a length of 6.",
              "id" : "acafa42a-d223-4136-a7a4-209193118eba",
              "input" : "['a', 'a', 'b', 'b', 'c', 'c', 'c']"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The compressed string is 'a', which has a length of 1.",
              "id" : "489a9e59-d3b2-46cc-a0f5-da8225633882",
              "input" : "['a']"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The compressed string is 'abc', which has a length of 3.",
              "id" : "a427ee5f-ba05-44db-87f0-05f9ff189d79",
              "input" : "['a', 'b', 'c']"
            }
          ]
        }
      ],
      "id" : "55f7bea8-cf56-4535-813e-97182bba63cf",
      "lastUpdated" : "2026-02-06T21:19:01Z",
      "problemSlug" : "string-compression",
      "relatedProblems" : [
        "valid-parentheses",
        "min-stack"
      ],
      "summary" : "The String Compression problem involves compressing a given string by replacing sequences of repeated characters with the character followed by the count of its occurrences. This problem can be effectively solved using a two-pointer approach."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the initial string and try swapping each pair of adjacent characters. If the characters are 'L' and 'R', swap them and check if the resulting string matches the target string. Repeat this process until all possible swaps have been tried.",
          "code" : "func canTransform(_ start: String, _ end: String) -> Bool { let s1 = Array(start); let s2 = Array(end); var i = 0; var j = 0; while i < s1.count && j < s2.count { if s1[i] == s2[j] { i += 1; j += 1 } else if s1[i] == \"L\" && s2[j] == \"R\" { return false } else if s1[i] == \"R\" && s2[j] == \"L\" { if j + 1 < s2.count && s2[j + 1] == \"L\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"L\" { i += 1 } else if s1[i] == \"R\" && s2[j] == \"X\" { if j + 1 < s2.count && s2[j + 1] == \"R\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"R\" { i += 1 } else { return false } } return i == s1.count && j == s2.count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The algorithm needs to store the input strings, which requires O(n) space.",
            "time" : "O(n^2)",
            "timeExplanation" : "The algorithm has to try all possible swaps of adjacent characters, which can result in a time complexity of O(n^2) in the worst case."
          },
          "explanation" : "This approach is impractical for large strings because it has to try an exponentially large number of possible swaps. However, it provides a straightforward way to solve the problem.",
          "id" : "c08cfa10-4290-439f-9bbe-f27bab1b58b2",
          "intuition" : "This approach works by trying all possible swaps of adjacent 'L' and 'R' characters and checking if the resulting string matches the target string.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "True",
              "explanation" : "This test case checks if the algorithm can correctly transform the start string into the end string by swapping adjacent 'L' and 'R' characters.",
              "id" : "12f8f8e9-8440-4a62-af0f-7e993856785f",
              "input" : "start = \"RXXLRXRXL\", end = \"XRLXXRRLX\""
            },
            {
              "expectedOutput" : "False",
              "explanation" : "This test case checks if the algorithm can correctly handle cases where the start string cannot be transformed into the end string.",
              "id" : "eda61899-a329-40b9-8846-26c1e90b9026",
              "input" : "start = \"LLR\", end = \"RLL\""
            }
          ]
        },
        {
          "approach" : "Compare the positions of 'L' and 'R' characters in the start and end strings. If the positions are the same, the strings can be transformed into each other.",
          "code" : "func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The algorithm only uses a constant amount of space to store the indices and characters, which results in a space complexity of O(1).",
            "time" : "O(n)",
            "timeExplanation" : "The algorithm only requires a single pass through the input strings, which results in a time complexity of O(n)."
          },
          "explanation" : "This approach is more efficient than the brute-force approach because it only requires a single pass through the input strings.",
          "id" : "2519ab9c-44e6-407f-92bc-e209524c511e",
          "intuition" : "This approach works by comparing the positions of 'L' and 'R' characters in the start and end strings and checking if they can be transformed into each other.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "True",
              "explanation" : "This test case checks if the algorithm can correctly transform the start string into the end string by swapping adjacent 'L' and 'R' characters.",
              "id" : "b67f9596-850b-45b7-bf69-e128b2381df2",
              "input" : "start = \"RXXLRXRXL\", end = \"XRLXXRRLX\""
            },
            {
              "expectedOutput" : "False",
              "explanation" : "This test case checks if the algorithm can correctly handle cases where the start string cannot be transformed into the end string.",
              "id" : "932b608a-8943-4d80-9ad8-54bce040322f",
              "input" : "start = \"LLR\", end = \"RLL\""
            }
          ]
        }
      ],
      "id" : "0b270ebd-6a13-407b-87e4-2dbff536ea33",
      "lastUpdated" : "2026-02-06T21:39:06Z",
      "problemSlug" : "swap-adjacent-in-lr-string",
      "relatedProblems" : [
        "reverse-vowels",
        "rotate-array"
      ],
      "summary" : "The Swap Adjacent in LR String problem requires swapping adjacent characters in a string if the characters are 'L' and 'R', and determining if it's possible to transform one string into another. The key insight is that if two strings have the same number and order of 'L' and 'R' characters, they can be transformed into each other."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Track maxLeft, maxRight, left, right pointers\n2. Process smaller side (we know its constraint)\n3. Water = max - current height\n4. Move pointer inward, update max",
          "code" : "func trap(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxLeft = 0, maxRight = 0\n    var water = 0\n    \n    while left < right {\n        if height[left] < height[right] {\n            if height[left] >= maxLeft {\n                maxLeft = height[left]\n            } else {\n                water += maxLeft - height[left]\n            }\n            left += 1\n        } else {\n            if height[right] >= maxRight {\n                maxRight = height[right]\n            } else {\n                water += maxRight - height[right]\n            }\n            right -= 1\n        }\n    }\n    \n    return water\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Constant space",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "If maxLeft < maxRight, left side is the constraint. Water at left = maxLeft - height[left].",
          "id" : "550e8400-e29b-41d4-a716-446655440149",
          "intuition" : "Water at position depends on min of max heights on left and right. Use two pointers to track.",
          "name" : "Two Pointers",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "Water fills gaps between bars",
              "id" : "550e8400-e29b-41d4-a716-446655440255",
              "input" : "[0,1,0,2,1,0,1,3,2,1,2,1]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440038",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "trapping-rain-water",
      "relatedProblems" : [
        "container-with-most-water"
      ],
      "summary" : "Calculate trapped rainwater. At each position, water = min(maxLeft, maxRight) - height."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an empty list to store the result. 2. Iterate over the array using a nested loop to check every possible pair of elements. 3. If a pair adds up to the target sum, add their indices to the result list and return.",
          "code" : "func twoSum(numbers: [Int], target: Int) -> [Int] {\n    for i in 0...numbers.count-2 {\n        for j in i+1...numbers.count-1 {\n            if numbers[i] + numbers[j] == target {\n                return [i, j]\n            }\n        }\n    }\n    return []\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are only using a constant amount of space to store the result.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is quadratic because we are using a nested loop to check every possible pair of elements."
          },
          "explanation" : "The brute-force approach is straightforward but not efficient for large inputs because it has to check every possible pair of elements.",
          "id" : "ee78dff0-cd51-4a94-9b82-43cd8f9c9911",
          "intuition" : "This approach works by checking every possible pair of elements in the array to see if they add up to the target sum.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,1]",
              "explanation" : "The elements at indices 0 and 1 (2 and 7) add up to the target sum 9.",
              "id" : "04f5ebdc-18d0-47f7-a8a9-d2900d49adef",
              "input" : "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput" : "[0,1]",
              "explanation" : "The elements at indices 0 and 1 (2 and 3) add up to the target sum 6.",
              "id" : "a0bfab52-4523-4702-be83-5048f2970fb0",
              "input" : "nums = [2,3,4], target = 6"
            }
          ]
        },
        {
          "approach" : "1. Initialize two pointers, one at the beginning of the array and one at the end. 2. Calculate the sum of the elements at the current positions of the two pointers. 3. If the sum is equal to the target sum, return the indices of the two elements. 4. If the sum is less than the target sum, move the left pointer to the right. 5. If the sum is greater than the target sum, move the right pointer to the left.",
          "code" : "func twoSum(numbers: [Int], target: Int) -> [Int] {\n    var left = 0\n    var right = numbers.count - 1\n    while left < right {\n        let sum = numbers[left] + numbers[right]\n        if sum == target {\n            return [left, right]\n        } else if sum < target {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    return []\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are only using a constant amount of space to store the result.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are using two pointers to find the target sum."
          },
          "explanation" : "The two pointers approach is more efficient than the brute-force approach because it reduces the search space by using two pointers to find the target sum.",
          "id" : "747d924c-0a80-4d65-b995-3342e2f2a846",
          "intuition" : "This approach works by using two pointers, one starting from the beginning of the array and one from the end, to reduce the search space.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0,1]",
              "explanation" : "The elements at indices 0 and 1 (2 and 7) add up to the target sum 9.",
              "id" : "cc981de6-9fdc-4d0b-9655-f7c4a7bec35e",
              "input" : "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput" : "[0,2]",
              "explanation" : "The elements at indices 0 and 2 (2 and 4) add up to the target sum 6.",
              "id" : "cdef711e-d00e-468c-8f70-a4ac457f55e7",
              "input" : "nums = [2,3,4], target = 6"
            }
          ]
        }
      ],
      "id" : "58411f81-61f9-4008-891d-f393cb9d4677",
      "lastUpdated" : "2026-02-06T21:08:00Z",
      "problemSlug" : "two-sum-ii-input-array-is-sorted",
      "relatedProblems" : [
        "minimum-window-substring",
        "find-first-and-last-position-of-element-in-sorted-array"
      ],
      "summary" : "Given a sorted array of integers and a target sum, find two elements that add up to the target sum. The key insight here is to utilize two pointers, one starting from the beginning of the array and one from the end, to reduce the search space."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Perform a depth-first search of the tree to populate a hash set with all values. 2. Iterate over all pairs of values in the set and check if they add up to the target. 3. If a pair is found, return it.",
          "code" : "func findTarget(root: TreeNode?, target: Int) -> Bool {\n    var values: Set<Int> = []\n    var result = false\n    func dfs(node: TreeNode?) {\n        if node == nil {\n            return\n        }\n        values.insert(node!.val)\n        dfs(node!.left)\n        dfs(node!.right)\n    }\n    dfs(root)\n    for value in values {\n        if values.contains(target - value) {\n            result = true\n            break\n        }\n    }\n    return result\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store all values in the set.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because in the worst case, we have to iterate over all pairs of values in the set."
          },
          "explanation" : "This approach has a high time complexity because it checks every pair of values. However, it is simple to implement and can be useful for small inputs.",
          "id" : "76b18fba-0d8d-4ddf-bbd4-922fa9d9833a",
          "intuition" : "This approach works by using a hash set to store all values in the tree, then checking every pair of values to see if they add up to the target.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The values 3 and 6 add up to 9.",
              "id" : "0052b988-3836-410e-8373-8faa241f543d",
              "input" : "root = [5,3,6,2,4,null,7], target = 9"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "No pair of values in the tree add up to 28.",
              "id" : "f2a56c12-593e-460f-a427-0bf8b773a846",
              "input" : "root = [5,3,6,2,4,null,7], target = 28"
            }
          ]
        },
        {
          "approach" : "1. Initialize a hash set to store values. 2. Perform a depth-first search of the tree. 3. For each value, check if its complement is in the set. 4. If it is, return true. 5. Otherwise, add the value to the set.",
          "code" : "func findTarget(root: TreeNode?, target: Int) -> Bool {\n    var values: Set<Int> = []\n    var result = false\n    func dfs(node: TreeNode?) {\n        if node == nil {\n            return\n        }\n        if values.contains(target - node!.val) {\n            result = true\n            return\n        }\n        values.insert(node!.val)\n        dfs(node!.left)\n        dfs(node!.right)\n    }\n    dfs(root)\n    return result\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store all values in the set.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we only need to iterate over the tree once."
          },
          "explanation" : "This approach has a lower time complexity than the brute force approach because it only needs to iterate over the tree once.",
          "id" : "1c9d055b-5b28-41b3-887b-83c545466299",
          "intuition" : "This approach works by using a hash set to store values we've seen so far and check if the complement of the current value is in the set.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The values 3 and 6 add up to 9.",
              "id" : "13fb0fa8-5b79-4c40-bf78-91c2fadb9e23",
              "input" : "root = [5,3,6,2,4,null,7], target = 9"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "No pair of values in the tree add up to 28.",
              "id" : "31d4b4df-04fe-4e6e-9a7d-aeab018452d9",
              "input" : "root = [5,3,6,2,4,null,7], target = 28"
            }
          ]
        }
      ],
      "id" : "217c4e85-fc53-4e6a-8a91-2fe14f1fff93",
      "lastUpdated" : "2026-02-06T21:31:10Z",
      "problemSlug" : "two-sum-iv-input-is-a-bst",
      "relatedProblems" : [
        "two-sum",
        "two-sum-ii-input-array-is-sorted"
      ],
      "summary" : "Given a binary search tree and a target value, find two values in the tree that add up to the target. The key insight is that we can use a hash set to store values we've seen so far and check if the complement of the current value is in the set."
    },
    {
      "approaches" : [
        {
          "approach" : "1. left = 0, right = n-1\n2. Skip non-alphanumeric from both ends\n3. Compare lowercase versions\n4. Return false if mismatch",
          "code" : "func isPalindrome(_ s: String) -> Bool {\n    let chars = Array(s.lowercased())\n    var left = 0, right = chars.count - 1\n    \n    while left < right {\n        while left < right && !chars[left].isLetter && !chars[left].isNumber {\n            left += 1\n        }\n        while left < right && !chars[right].isLetter && !chars[right].isNumber {\n            right -= 1\n        }\n        if chars[left] != chars[right] { return false }\n        left += 1\n        right -= 1\n    }\n    return true\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Array conversion",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "Filter and compare in one pass without creating new string.",
          "id" : "550e8400-e29b-41d4-a716-446655440152",
          "intuition" : "Compare characters from both ends, skip non-alphanumeric, ignore case.",
          "name" : "Two Pointers",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "amanaplanacanalpanama is palindrome",
              "id" : "550e8400-e29b-41d4-a716-446655440258",
              "input" : "\"A man, a plan, a canal: Panama\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440041",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "valid-palindrome",
      "relatedProblems" : [
        "valid-palindrome-ii"
      ],
      "summary" : "Check if string is palindrome ignoring non-alphanumeric. Two pointers from ends."
    },
    {
      "approaches" : [
        {
          "approach" : "Create all substrings by removing one character at a time, check if each substring is a palindrome",
          "code" : "func validPalindrome(_ s: String) -> Bool { let str = Array(s); var result = false; for i in 0..<str.count { var temp = str; temp.remove(at: i); if isPalindrome(temp) { result = true; break } } return result || isPalindrome(str); func isPalindrome(_ str: [Character]) -> Bool { let str = String(str); return String(str.reversed()) == str } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we're storing all the substrings",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is quadratic because we're generating all substrings and checking each one to see if it's a palindrome"
          },
          "explanation" : "This approach generates all possible substrings by removing one character from the input string. It then checks each substring to see if it's a palindrome. If any of the substrings are palindromes, the function returns true.",
          "id" : "6f6985be-f310-4736-a009-c72df8b45089",
          "intuition" : "Try all possible strings by removing one character at a time and check if the resulting string is a palindrome",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The input string is already a palindrome",
              "id" : "1c5ff136-cdda-4aac-b100-71668b57c1c5",
              "input" : "s = \"aba\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "We can remove the character 'c' to make the string a palindrome",
              "id" : "8fbcdda8-5a93-486b-ab01-fa6db28909b2",
              "input" : "s = \"abca\""
            }
          ]
        },
        {
          "approach" : "Initialize two pointers at the start and end of the string, move them towards the center. When the characters at the two pointers don't match, try removing one of them and check if the resulting string is a palindrome",
          "code" : "func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we're not using any extra space that scales with the input size",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we're only using two pointers to traverse the string"
          },
          "explanation" : "This approach uses two pointers to check for palindrome. When the characters at the two pointers don't match, we try removing one of them and check if the resulting string is a palindrome. We only need to remove one character to make the string a palindrome.",
          "id" : "46e874e9-9dfb-42cb-bbda-7e3a839b5c3f",
          "intuition" : "Use two pointers to check for palindrome and handle the character removal",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The input string is already a palindrome",
              "id" : "61823668-1694-44a6-bf0a-8a99e6533b9c",
              "input" : "s = \"aba\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "We can remove the character 'c' to make the string a palindrome",
              "id" : "e54554ac-af57-42f3-9c23-1f1231dac8c7",
              "input" : "s = \"abca\""
            }
          ]
        }
      ],
      "id" : "ff424caf-d797-4685-8d24-e2eb1364497a",
      "lastUpdated" : "2026-02-06T21:33:19Z",
      "problemSlug" : "valid-palindrome-ii",
      "relatedProblems" : [
        "valid-palindrome",
        "longest-palindromic-substring"
      ],
      "summary" : "Given a string, determine if it's possible to make a palindrome by removing at most one character. The key insight is to use two pointers to check for palindrome and handle the character removal."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Sort the array in ascending order. Step 2: Iterate through all possible triplets in the array. Step 3: For each triplet, check if the sum of the lengths of any two sides is greater than the length of the remaining side.",
          "code" : "\n           func triangleNumber(_ nums: [Int]) -> Int {\n               let sortedNums = nums.sorted()\n               var count = 0\n               for i in 0..<sortedNums.count {\n                   for j in i+1..<sortedNums.count {\n                       for k in j+1..<sortedNums.count {\n                           if sortedNums[i] + sortedNums[j] > sortedNums[k] {\n                               count += 1\n                           }\n                       }\n                   }\n               }\n               return count\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the sorted array.",
            "time" : "O(n^3)",
            "timeExplanation" : "We are using three nested loops to generate all possible triplets, resulting in a time complexity of O(n^3)."
          },
          "explanation" : "This is a straightforward approach that involves checking every possible combination of three sides to see if they can form a valid triangle.",
          "id" : "c7c77264-e270-4eef-b011-96cb6b0184ac",
          "intuition" : "The brute force approach works by iterating through all possible triplets in the array and checking if each triplet satisfies the triangle inequality theorem.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The valid triangles are (2,3,4), (2,2,3), and (2,2,4).",
              "id" : "3672a471-01d1-44f1-aab0-0bf65c58e633",
              "input" : "nums = [2,2,3,4]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "No valid triangles can be formed from the given array.",
              "id" : "ac16c1ec-3208-4c69-bb78-347dab2961da",
              "input" : "nums = [7,4,3]"
            }
          ]
        },
        {
          "approach" : "Step 1: Sort the array in ascending order. Step 2: Iterate through the array and for each element, use two pointers to find all possible combinations of the other two sides that satisfy the triangle inequality theorem.",
          "code" : "\n           func triangleNumber(_ nums: [Int]) -> Int {\n               let sortedNums = nums.sorted()\n               var count = 0\n               for i in 0..<sortedNums.count {\n                   var left = 0\n                   var right = i - 1\n                   while left < right {\n                       if sortedNums[left] + sortedNums[right] > sortedNums[i] {\n                           count += right - left\n                           left += 1\n                       } else {\n                           right -= 1\n                       }\n                   }\n               }\n               return count\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the sorted array.",
            "time" : "O(n^2)",
            "timeExplanation" : "We are using two nested loops to iterate through the array and find all possible combinations of the other two sides, resulting in a time complexity of O(n^2)."
          },
          "explanation" : "This optimized approach reduces the time complexity by avoiding the need to check every possible combination of three sides.",
          "id" : "716f8569-3d69-413e-896b-fd3f08d5106c",
          "intuition" : "The two pointers approach works by fixing one side of the triangle and then using two pointers to find all possible combinations of the other two sides that satisfy the triangle inequality theorem.",
          "name" : "Two Pointers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The valid triangles are (2,3,4), (2,2,3), and (2,2,4).",
              "id" : "45aa3888-5fa4-4c7a-a0ab-9f4bf9fc00fc",
              "input" : "nums = [2,2,3,4]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The valid triangles are (2,3,4), (2,4,4), (3,4,4), and (4,4,4).",
              "id" : "83e3dfbc-e8b1-4c62-9035-dea6a1fc5ca7",
              "input" : "nums = [4,2,3,4]"
            }
          ]
        }
      ],
      "id" : "e281e731-103e-48ba-8f27-82a34744611c",
      "lastUpdated" : "2026-02-06T21:29:00Z",
      "problemSlug" : "valid-triangle-number",
      "relatedProblems" : [
        "valid-triangle",
        "minimum-area-triangle"
      ],
      "summary" : "The problem requires counting the number of valid triangles given an array of integers, and the key insight is to understand and apply the triangle inequality theorem."
    }
  ],
  "topic" : "two-pointers",
  "version" : "2.0.0"
}