{
  "solutions" : [
    {
      "approaches" : [
        {
          "approach" : "For each cell, iterate over the grid to calculate the Manhattan distance to the nearest 0. Store this distance in a result grid.",
          "code" : "\n\/\/ Create a new Swift file named `Solution.swift` and paste this code into it\n\nclass Solution {\n    func updateMatrix(_ mat: [[Int]]) -> [[Int]] {\n        let n = mat.count\n        let m = mat[0].count\n        var result = Array(repeating: Array(repeating: 1000000, count: m), count: n)\n\n        for i in 0..<n {\n            for j in 0..<m {\n                if mat[i][j] == 0 {\n                    result[i][j] = 0\n                } else {\n                    for k in 0..<n {\n                        for l in 0..<m {\n                            if mat[k][l] == 0 {\n                                let distance = abs(k - i) + abs(l - j)\n                                if distance < result[i][j] {\n                                    result[i][j] = distance\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n}",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "We're creating a result grid of the same size as the source grid to store our results, resulting in a space complexity of O(n^2).",
            "time" : "O(n^4)",
            "timeExplanation" : "We're iterating over the grid for each cell and also searching the grid for each cell, resulting in a time complexity of O(n^4)."
          },
          "explanation" : "Start by initializing a result grid with all distances set to maximum value. Then iterate through the source grid cell by cell. For each cell, if it's a 0, update its corresponding value in the result grid to 0 (since distance to itself is 0). Otherwise, start searching surrounding cells, updating its value in the result grid as you find a 0 or smaller distance.",
          "id" : "b69c3f0f-448e-41bc-b515-7ea74b9ba8b0",
          "intuition" : "This works by iterating through the entire grid for each cell to find the closest 0, using brute-force to calculate distances.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0],[0,1,0],[0,0,0]]",
              "explanation" : "All cells are either 0 or adjacent to a 0.",
              "id" : "7e31e864-c073-49bb-8881-b6f2406b404e",
              "input" : "mat = [[0,0,0],[0,1,0],[0,0,0]]"
            },
            {
              "expectedOutput" : "[[0,0,0],[0,1,0],[1,2,1]]",
              "explanation" : "Cells in the last row have a distance of 1 or 2 from the nearest 0.",
              "id" : "5267ef4e-dcc3-4d41-86a5-b4e1af2f22b7",
              "input" : "mat = [[0,0,0],[0,1,0],[1,1,1]]"
            }
          ]
        },
        {
          "approach" : "Start by initializing a result grid with all distances set to maximum value. Add all cells with value 0 to a BFS queue. Then perform a BFS traversal, updating the distances in the result grid as we move away from the 0 cells.",
          "code" : "\n\/\/ Create a new Swift file named `Solution.swift` and paste this code into it\n\nclass Solution {\n    func updateMatrix(_ mat: [[Int]]) -> [[Int]] {\n        let n = mat.count\n        let m = mat[0].count\n        var result = Array(repeating: Array(repeating: 1000000, count: m), count: n)\n        var queue: [(Int, Int)] = []\n        \n        for i in 0..<n {\n            for j in 0..<m {\n                if mat[i][j] == 0 {\n                    result[i][j] = 0\n                    queue.append((i, j))\n                }\n            }\n        }\n\n        let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while !queue.isEmpty {\n            let (x, y) = queue.removeFirst()\n            for (dx, dy) in directions {\n                let nx = x + dx\n                let ny = y + dy\n                if nx >= 0 && nx < n && ny >= 0 && ny < m {\n                    if result[nx][ny] > result[x][y] + 1 {\n                        result[nx][ny] = result[x][y] + 1\n                        queue.append((nx, ny))\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n}",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "We're using a BFS queue that can potentially hold all cells in the grid, resulting in a space complexity of O(n^2).",
            "time" : "O(n^2)",
            "timeExplanation" : "We're visiting each cell once, resulting in a time complexity of O(n^2)."
          },
          "explanation" : "We start the BFS traversal from all the 0 cells in the grid. For each cell visited, if its distance in the result grid is greater than the current distance in the traversal plus 1, we update its distance. We continue this process until all cells have been visited.",
          "id" : "a2da14f7-ad2d-4c8d-bbed-9c23e086a6a0",
          "intuition" : "This works by utilizing a BFS queue, starting from all the 0 cells in the grid, to efficiently calculate the distances.",
          "name" : "Optimized BFS Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0],[0,1,0],[0,0,0]]",
              "explanation" : "All cells are either 0 or adjacent to a 0.",
              "id" : "7dd924de-aeab-4065-97ea-041fb16f31c5",
              "input" : "mat = [[0,0,0],[0,1,0],[0,0,0]]"
            },
            {
              "expectedOutput" : "[[0,0,0],[0,1,0],[1,2,1]]",
              "explanation" : "Cells in the last row have a distance of 1 or 2 from the nearest 0.",
              "id" : "6676edf9-45e1-4eb4-a10c-0e5da1817d4c",
              "input" : "mat = [[0,0,0],[0,1,0],[1,1,1]]"
            },
            {
              "expectedOutput" : "[[2,1,2],[1,0,1],[2,1,2]]",
              "explanation" : "The middle cell is a 0, and all other cells have a distance of 1 or 2 from it.",
              "id" : "d0f39837-106d-4201-afbc-8d544ac211dc",
              "input" : "mat = [[1,1,1],[1,0,1],[1,1,1]]"
            }
          ]
        }
      ],
      "id" : "c7f10164-1c25-477a-b71d-9aef63931145",
      "lastUpdated" : "2026-02-06T21:25:30Z",
      "problemSlug" : "01-matrix",
      "relatedProblems" : [
        " walls-and-gates",
        "nearest-exit-from-entrance-in-maze"
      ],
      "summary" : "Given an n x n matrix consisting of 0s and 1s, find the closest 0 for each cell, where distance between two cells is calculated using Manhattan distance. Key insight is to leverage a breadth-first search (BFS) queue for the optimized approach."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the root node and recursively create all possible left and right subtrees, ensuring that both subtrees have the same height.",
          "code" : "\nimport Foundation\n\n\/\/ Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    func allPossibleFBT(_ n: Int) -> [TreeNode?] {\n        if n % 2 == 0 { return [] }\n        \n        if n == 1 {\n            return [TreeNode(0)]\n        }\n        \n        var result: [TreeNode?] = []\n        \n        for x in stride(from: 1, to: n, by: 2) {\n            let leftTrees = allPossibleFBT(x)\n            let rightTrees = allPossibleFBT(n - 1 - x)\n            \n            for leftTree in leftTrees {\n                for rightTree in rightTrees {\n                    result.append(TreeNode(0, leftTree, rightTree))\n                }\n            }\n        }\n        \n        return result\n    }\n}\n           ",
          "complexity" : {
            "space" : "O(2^n)",
            "spaceExplanation" : "The space complexity is also exponential due to the storage of all possible subtrees.",
            "time" : "O(2^n)",
            "timeExplanation" : "The time complexity is exponential due to the recursive generation of all possible subtrees."
          },
          "explanation" : "This approach involves creating all possible subtrees and combining them to form full binary trees, but it's inefficient due to the overlap in subtree creation.",
          "id" : "2788ff3a-ba09-4219-ae59-f54a89ab4a3a",
          "intuition" : "Generate all possible trees by recursively creating left and right subtrees for each node, ensuring that the resulting trees are full binary trees.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "all possible full binary trees with 7 nodes",
              "explanation" : "The function should return all possible full binary trees that can be constructed with 7 nodes.",
              "id" : "aadfed3c-dc0f-4b73-8c1f-13c71005cfed",
              "input" : "n = 7"
            },
            {
              "expectedOutput" : "all possible full binary trees with 3 nodes",
              "explanation" : "The function should return all possible full binary trees that can be constructed with 3 nodes.",
              "id" : "fb2ce7b3-24bc-4475-b7ce-525a8e938e96",
              "input" : "n = 3"
            }
          ]
        },
        {
          "approach" : "Use a dictionary to store the results of subproblems, where each key represents the number of nodes and the value is the list of possible full binary trees.",
          "code" : "\nimport Foundation\n\n\/\/ Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    private var memo: [Int: [TreeNode?]] = [:]\n    \n    func allPossibleFBT(_ n: Int) -> [TreeNode?] {\n        if n % 2 == 0 { return [] }\n        \n        if n == 1 {\n            return [TreeNode(0)]\n        }\n        \n        if let result = memo[n] {\n            return result\n        }\n        \n        var result: [TreeNode?] = []\n        \n        for x in stride(from: 1, to: n, by: 2) {\n            let leftTrees = allPossibleFBT(x)\n            let rightTrees = allPossibleFBT(n - 1 - x)\n            \n            for leftTree in leftTrees {\n                for rightTree in rightTrees {\n                    result.append(TreeNode(0, leftTree, rightTree))\n                }\n            }\n        }\n        \n        memo[n] = result\n        \n        return result\n    }\n}\n           ",
          "complexity" : {
            "space" : "O(2^n \/ n^(3\/2))",
            "spaceExplanation" : "The space complexity is also reduced due to the storage of subproblem results in the dictionary.",
            "time" : "O(2^n \/ n^(3\/2))",
            "timeExplanation" : "The time complexity is reduced due to the memoization of subproblems."
          },
          "explanation" : "This approach reduces the time complexity by avoiding the recomputation of subproblems and storing the results in a dictionary for future reference.",
          "id" : "a1f51540-2003-4667-9023-cbea32f60be1",
          "intuition" : "Improve the brute force approach by storing the results of subproblems to avoid redundant computation.",
          "name" : "Optimized Memoization",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "all possible full binary trees with 7 nodes",
              "explanation" : "The function should return all possible full binary trees that can be constructed with 7 nodes.",
              "id" : "4429e217-c6a2-46d8-a4a1-568bc7550983",
              "input" : "n = 7"
            },
            {
              "expectedOutput" : "all possible full binary trees with 3 nodes",
              "explanation" : "The function should return all possible full binary trees that can be constructed with 3 nodes.",
              "id" : "9725ac27-ad3b-4579-b445-3d9758df60c8",
              "input" : "n = 3"
            }
          ]
        }
      ],
      "id" : "953b0bba-0f46-40c4-88cd-ea644e1b4d13",
      "lastUpdated" : "2026-02-06T21:46:59Z",
      "problemSlug" : "all-possible-full-binary-trees",
      "relatedProblems" : [
        "unique-binary-search-trees",
        "unique-binary-search-trees-ii"
      ],
      "summary" : "This problem involves generating all possible full binary trees given a number of nodes, leveraging dynamic programming and recursive techniques to efficiently construct the trees."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible slices, calculate the difference between the first two elements and then check if the difference is consistent throughout the slice.",
          "code" : "func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; for i in 0..<nums.count { for j in i + 2..<nums.count { let slice = Array(nums[i...j]); var diff = slice[1] - slice[0]; var valid = true; for k in 2..<slice.count { if slice[k] - slice[k - 1] != diff { valid = false; break; } } if valid { count += 1 } } }; return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we are storing slices of the original array.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is cubic because we have three nested loops."
          },
          "explanation" : "We start by iterating through the array and generating all possible slices. Then we check if a slice is arithmetic by calculating the difference between the first two elements and checking if this difference is consistent throughout the slice.",
          "id" : "3c950fb2-3a42-4733-8f80-9168b732eda2",
          "intuition" : "We will generate all possible slices and check if they are arithmetic.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The three arithmetic slices are [1, 2, 3], [2, 3, 4], and [1, 2, 3, 4].",
              "id" : "091c4bf0-16be-4aa8-9045-bcc7ca72ec6d",
              "input" : "nums = [1, 2, 3, 4]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no arithmetic slices because the common difference is not consistent throughout any slice.",
              "id" : "cddca818-2ef9-4d12-8b61-d41677555ddc",
              "input" : "nums = [1, 2, 4, 5, 7, 10]"
            }
          ]
        },
        {
          "approach" : "Maintain a dictionary where the keys are the differences and the values are the counts of the arithmetic slices ending with the current element and having that difference.",
          "code" : "func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; var dp = [Int: Int](); for i in 2..<nums.count { let diff = nums[i] - nums[i - 1]; for j in (0...i - 2) { let prevDiff = nums[j + 1] - nums[j]; if prevDiff == diff { if let currCount = dp[j] { count += currCount; dp[i] = (dp[i] ?? 0) + currCount } } } dp[i] = (dp[i] ?? 0) + 1 }; return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we are storing the counts of arithmetic slices in a dictionary.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is quadratic because we have two nested loops."
          },
          "explanation" : "We initialize a dictionary to store the count of arithmetic slices ending at each position with each possible difference. Then we iterate through the array and for each element, we calculate the difference with the previous element. If this difference is already in our dictionary, we increment the count of arithmetic slices ending at the current position with this difference.",
          "id" : "99a0b16c-c5ba-4dfe-8849-c5a0c18ffb9f",
          "intuition" : "We can maintain a count of the number of arithmetic slices ending at each position.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The three arithmetic slices are [1, 2, 3], [2, 3, 4], and [1, 2, 3, 4].",
              "id" : "3290bbaa-8d0f-44fd-9bd5-9e9b3911e194",
              "input" : "nums = [1, 2, 3, 4]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no arithmetic slices because the common difference is not consistent throughout any slice.",
              "id" : "4cce3622-00d1-4f09-8146-6e59fe031093",
              "input" : "nums = [1, 2, 4, 5, 7, 10]"
            }
          ]
        }
      ],
      "id" : "5c0f9eb7-df98-4f69-8c20-fcb275fcc2b1",
      "lastUpdated" : "2026-02-06T21:17:20Z",
      "problemSlug" : "arithmetic-slices",
      "relatedProblems" : [
        "longest-arithmetic-sequence",
        "minimum-absolute-sum-difference"
      ],
      "summary" : "This problem involves finding all possible arithmetic slices within an array, and a key insight is that an arithmetic slice must have at least three elements. We can solve this using both brute-force and dynamic programming approaches."
    },
    {
      "approaches" : [
        {
          "approach" : "We start by generating all permutations of the numbers from 1 to n, then we check each permutation to see if it satisfies the condition of beautiful arrangement.",
          "code" : "\nfunc countArrangement(_ n: Int) -> Int {\n    var count = 0\n    var visited = Array(repeating: false, count: n + 1)\n    func dfs(_ index: Int) {\n        if index == n + 1 {\n            count += 1\n            return\n        }\n        for i in 1...n {\n            if !visited[i] && (index % i == 0 || i % index == 0) {\n                visited[i] = true\n                dfs(index + 1)\n                visited[i] = false\n            }\n        }\n    }\n    dfs(1)\n    return count\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) as we need to store the visited array of size n+1.",
            "time" : "O(n!)",
            "timeExplanation" : "The time complexity is O(n!) as we are generating all permutations of n numbers."
          },
          "explanation" : "The brute force approach is straightforward but not efficient as it checks all possible permutations, resulting in an exponential time complexity.",
          "id" : "96f29efa-d364-4e62-b96c-7c2b7515035d",
          "intuition" : "To solve this problem, we can use a brute force approach and check all possible permutations of the numbers from 1 to n.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "For n = 2, the beautiful arrangements are [1,2] and [2,1].",
              "id" : "df4283e1-d9ba-49c9-9cdb-02a1204d7f3a",
              "input" : "n = 2"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "For n = 3, the beautiful arrangements are [1,2,3], [2,1,3] and [3,2,1].",
              "id" : "11e468e3-f97b-4b95-bd82-9f4788f758c3",
              "input" : "n = 3"
            }
          ]
        },
        {
          "approach" : "We start with an empty bitmask and try to place each number from 1 to n at the current position, then we backtrack and try the next number.",
          "code" : "\nfunc countArrangement(_ n: Int) -> Int {\n    var count = 0\n    var visited = 0\n    func dfs(_ index: Int) {\n        if index == n + 1 {\n            count += 1\n            return\n        }\n        for i in 1...n {\n            if (visited & (1 << (i - 1))) == 0 && (index % i == 0 || i % index == 0) {\n                visited |= (1 << (i - 1))\n                dfs(index + 1)\n                visited &= ~(1 << (i - 1))\n            }\n        }\n    }\n    dfs(1)\n    return count\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) as we only use a constant amount of space to store the visited bitmask and the count.",
            "time" : "O(n!)",
            "timeExplanation" : "The time complexity is still O(n!) but the constant factor is reduced due to the use of bit manipulation."
          },
          "explanation" : "The bitmask helps us to quickly check if a number has been visited or not, resulting in a more efficient solution.",
          "id" : "470f693f-fbb5-4933-9d02-378527cadd15",
          "intuition" : "To optimize the solution, we can use backtracking with a bitmask to keep track of the visited numbers.",
          "name" : "Backtracking with Bitmask",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "For n = 2, the beautiful arrangements are [1,2] and [2,1].",
              "id" : "c90a3a74-1fdc-4da8-96cf-d7bd5ae07f07",
              "input" : "n = 2"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "For n = 3, the beautiful arrangements are [1,2,3], [2,1,3] and [3,2,1].",
              "id" : "b242d0ac-8d04-40fa-9dbd-69861a05b6c8",
              "input" : "n = 3"
            }
          ]
        }
      ],
      "id" : "4b55c6fe-08df-4a19-aa79-cec6b1141580",
      "lastUpdated" : "2026-02-06T21:24:27Z",
      "problemSlug" : "beautiful-arrangement",
      "relatedProblems" : [
        "permutations",
        "beautiful-arrangement-ii"
      ],
      "summary" : "The problem requires finding the number of beautiful arrangements that can be formed for a given integer n, where a beautiful arrangement is an array of integers from 1 to n such that for any i, the ith element is either divisible by i or i is divisible by the ith element."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate over the array of scores, fixing the first sight and then trying all possible second sights, keeping track of the maximum score seen so far",
          "code" : "func maxScoreSightseeingPair(_ A: [Int]) -> Int {\n    var maxScore = 0\n    for i in 0..<A.count {\n        for j in (i + 1)..<A.count {\n            let score = A[i] + A[j] - (j - i)\n            maxScore = max(maxScore, score)\n        }\n    }\n    return maxScore\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only a constant amount of space is used to store the maximum score and the current pair's score",
            "time" : "O(n^2)",
            "timeExplanation" : "Two nested loops iterate over the array, resulting in quadratic time complexity"
          },
          "explanation" : "The brute-force approach is straightforward but inefficient because it tries all possible pairs, leading to a time complexity of O(n^2) where n is the number of sights",
          "id" : "c8992976-2e03-498b-ab0a-6e0614631821",
          "intuition" : "This approach involves trying all possible pairs of sights and calculating their scores, which guarantees finding the maximum score achievable but can be computationally expensive",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "Visiting the first and last sights yields the highest score, 8 + 6 - 4 = 10, but visiting the first and fourth sights gives 8 + 2 - 3 = 7, and visiting the second and last gives 1 + 6 - 4 = 3, however, the pair (0, 1) gives 8 + 1 - 1 = 8, and the pair (1, 4) gives 1 + 2 - 3 = 0, and the pair (2, 4) gives 5 + 2 - 2 = 5, but (2, 3) gives 5 + 6 - 1 = 10, but the highest score comes from (0, 4) giving 8 + 2 - 4 = 6 and (3, 4) giving 6 + 6 - 1 = 11",
              "id" : "64d47d61-375f-4139-930e-2cc9dbdaa415",
              "input" : "A = [8,1,5,2,6]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "With only two sights, the score is simply the sum of their scores minus the distance between them, which is 1 in this case",
              "id" : "ea1181d4-5cd0-4532-946e-b54dd80a73f3",
              "input" : "A = [1,2]"
            }
          ]
        },
        {
          "approach" : "Maintain a running maximum of the score that can be achieved by any sight so far plus its position, and for each new sight, calculate the score it can achieve with this running maximum",
          "code" : "func maxScoreSightseeingPair(_ A: [Int]) -> Int {\n    var res = 0, maxScore = A[0] + 0\n    for j in 1..<A.count {\n        res = max(res, maxScore + A[j] - j)\n        maxScore = max(maxScore, A[j] + j)\n    }\n    return res\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only a constant amount of space is used to store the maximum score and the running maximum",
            "time" : "O(n)",
            "timeExplanation" : "A single loop iterates over the array, resulting in linear time complexity"
          },
          "explanation" : "By keeping track of the best score that can be achieved by any sight plus its position as we iterate through the array, we avoid trying all possible pairs and reduce the time complexity to linear",
          "id" : "a472c654-1dc0-4919-be68-61fd81899340",
          "intuition" : "This approach recognizes that for each sight, the score it can achieve with any later sight depends only on the sight's own score and its position, allowing for a more efficient solution",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "The pair of sights that yields the highest score is found efficiently by maintaining a running maximum",
              "id" : "07b4ec04-b220-449e-9bb4-089388236f19",
              "input" : "A = [8,1,5,2,6]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Even with only two sights, the optimized approach works correctly",
              "id" : "3684543b-6c07-4c84-bba3-badb7a55f2a1",
              "input" : "A = [1,2]"
            }
          ]
        }
      ],
      "id" : "ff00725a-ef0d-440a-8f9a-7bfc4fdf4a99",
      "lastUpdated" : "2026-02-06T21:55:40Z",
      "problemSlug" : "best-sightseeing-pair",
      "relatedProblems" : [
        "coin-change",
        "house-robber-ii"
      ],
      "summary" : "The Best Sightseeing Pair problem involves finding the maximum score achievable by visiting two sights in a certain order, given an array of scores for each sight. The key insight is to realize that the score for each pair of sights depends on the order in which they are visited"
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize minPrice to a large value and bestProfit = 0.\n2. For each price:\n   - Update minPrice = min(minPrice, price).\n   - Update bestProfit = max(bestProfit, price - minPrice).\n3. Return bestProfit.",
          "code" : "func maxProfit(_ prices: [Int]) -> Int {\n    var minPrice = Int.max\n    var best = 0\n    for price in prices {\n        minPrice = min(minPrice, price)\n        best = max(best, price - minPrice)\n    }\n    return best\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only two tracking variables are used.",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through the prices."
          },
          "explanation" : "This ensures the buy happens before the sell because minPrice is computed from earlier elements.",
          "id" : "c9cfb94b-b023-477e-9e26-9c69c36ae2c1",
          "intuition" : "The best profit ending today is today's price minus the minimum price seen before today.",
          "name" : "One Pass",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "Buy at 1, sell at 6.",
              "id" : "5953fc34-b62c-4575-8b2a-b399f798db13",
              "input" : "prices = [7,1,5,3,6,4]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "No profitable transaction.",
              "id" : "2ad31b7a-6363-4ec5-b36c-a17bb1b55e57",
              "input" : "prices = [7,6,4,3,1]"
            }
          ]
        }
      ],
      "id" : "22650355-1394-4a7f-8415-15cfe774ea97",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "best-time-to-buy-and-sell-stock",
      "relatedProblems" : [
        "best-time-to-buy-and-sell-stock-ii",
        "best-time-to-buy-and-sell-stock-with-cooldown"
      ],
      "summary" : "Track the minimum price so far and update the max profit as you scan."
    },
    {
      "approaches" : [
        {
          "approach" : "1. For each consecutive day pair\n2. If price increased, add difference to profit",
          "code" : "func maxProfit(_ prices: [Int]) -> Int {\n    var profit = 0\n    for i in 1..<prices.count {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "One variable",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "Equivalent to buying at every local minimum and selling at every local maximum.",
          "id" : "83fab547-68a8-41da-85e7-cb739fdaf6f7",
          "intuition" : "Capture every upward price movement.",
          "name" : "Greedy",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "(5-1)+(6-3)=7",
              "id" : "ab31ce77-9825-4379-a8f7-c3465d874d2b",
              "input" : "prices = [7,1,5,3,6,4]"
            }
          ]
        }
      ],
      "id" : "f0a90680-10d1-4167-9da4-9ce5c8410c13",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "best-time-to-buy-and-sell-stock-ii",
      "relatedProblems" : [
        "best-time-to-buy-and-sell-stock"
      ],
      "summary" : "Max profit with unlimited transactions. Add all positive price differences."
    },
    {
      "approaches" : [
        {
          "approach" : "1. hold[i] = max(hold[i-1], rest[i-1] - price)\n2. sold[i] = hold[i-1] + price\n3. rest[i] = max(rest[i-1], sold[i-1])",
          "code" : "func maxProfit(_ prices: [Int]) -> Int {\n    if prices.isEmpty { return 0 }\n    var hold = -prices[0], sold = 0, rest = 0\n    for i in 1..<prices.count {\n        let prevHold = hold, prevSold = sold\n        hold = max(hold, rest - prices[i])\n        sold = prevHold + prices[i]\n        rest = max(rest, prevSold)\n    }\n    return max(sold, rest)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Three variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "Can only buy from rest state, must rest after selling.",
          "id" : "f27a66e5-0f9c-4778-aa37-f3320cbe1654",
          "intuition" : "Track max profit in each state: holding stock, just sold, resting.",
          "name" : "State Machine DP",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "buy,sell,cooldown,buy,sell",
              "id" : "d5953346-6595-4c12-a998-152f7ed48be2",
              "input" : "prices = [1,2,3,0,2]"
            }
          ]
        }
      ],
      "id" : "c954e913-cfd9-4561-9d88-3f4beb4987d0",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "best-time-to-buy-and-sell-stock-with-cooldown",
      "relatedProblems" : [
        "best-time-to-buy-and-sell-stock-ii"
      ],
      "summary" : "Max profit with cooldown after sell. DP with states: hold, sold, rest."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through the prices array and for each price, try buying and selling at every possible future price, subtracting the transaction fee for each sell operation.",
          "code" : "func maxProfit(prices: [Int], fee: Int) -> Int { var max = 0; for i in 0..<prices.count { for j in i+1..<prices.count { if prices[j] - prices[i] - fee > 0 { max = Swift.max(max, prices[j] - prices[i] - fee) } } } return max }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we only use a fixed amount of space to store the maximum profit.",
            "time" : "O(n^2)",
            "timeExplanation" : "The nested loops result in quadratic time complexity."
          },
          "explanation" : "This approach has a high time complexity because it involves nested loops to try all possible combinations.",
          "id" : "02d1c33a-adc3-4a99-a810-b07c1637fde1",
          "intuition" : "This approach works by trying all possible buy and sell combinations and calculating the maximum profit.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "8",
              "explanation" : "We can buy at price 1, sell at price 3, buy at price 2, and sell at price 9, for a total profit of 8 - 2 = 6, but since we can't sell at price 8 due to the fee, the max profit is actually buying at 1 and selling at 9 after subtracting the fee.",
              "id" : "52af8d4d-f133-4bd0-a142-af29e2df4083",
              "input" : "prices = [1,3,2,8,4,9], fee = 2"
            },
            {
              "expectedOutput" : "6",
              "explanation" : "We can buy at price 1, sell at price 7, and then buy and sell are not needed because the rest of the prices do not lead to a higher profit after the fee.",
              "id" : "276bece4-1fd1-425a-a262-c45182bce587",
              "input" : "prices = [1,3,7,5,10,3], fee = 3"
            }
          ]
        },
        {
          "approach" : "Initialize variables to track the maximum profit after the last buy and sell operations, then iterate through the prices array, updating these variables at each step to reflect the maximum possible profit.",
          "code" : "func maxProfit(_ prices: [Int], _ fee: Int) -> Int { if prices.count < 2 { return 0 }; var buy = -prices[0]; var sell = 0; for i in 1..<prices.count { let newBuy = Swift.max(buy, sell - prices[i]); let newSell = Swift.max(sell, buy + prices[i] - fee); buy = newBuy; sell = newSell }; return sell }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we only use a fixed amount of space to store the maximum profit after the last buy and sell operations.",
            "time" : "O(n)",
            "timeExplanation" : "The single pass through the prices array results in linear time complexity."
          },
          "explanation" : "This approach has a lower time complexity because it only requires a single pass through the prices array.",
          "id" : "bab22cf6-bc20-4558-a16b-6617c29a0fc1",
          "intuition" : "This approach works by maintaining two variables to track the maximum profit when the last operation was a buy or a sell.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "8",
              "explanation" : "We can buy at price 1, sell at price 3, buy at price 2, and sell at price 9, for a total profit of 8 - 2 = 6, but since we can't sell at price 8 due to the fee, the max profit is actually buying at 1 and selling at 9 after subtracting the fee.",
              "id" : "bf59d129-a83a-4f30-9e3a-d91fd8a26925",
              "input" : "prices = [1,3,2,8,4,9], fee = 2"
            },
            {
              "expectedOutput" : "6",
              "explanation" : "We can buy at price 1, sell at price 7, and then buy and sell are not needed because the rest of the prices do not lead to a higher profit after the fee.",
              "id" : "f7ab168a-e201-4b6e-bb1f-5fd85390b6cb",
              "input" : "prices = [1,3,7,5,10,3], fee = 3"
            }
          ]
        }
      ],
      "id" : "04687340-a807-45ad-95bb-973a845ebfff",
      "lastUpdated" : "2026-02-06T21:35:32Z",
      "problemSlug" : "best-time-to-buy-and-sell-stock-with-transaction-fee",
      "relatedProblems" : [
        "best-time-to-buy-and-sell-stock",
        "best-time-to-buy-and-sell-stock-ii"
      ],
      "summary" : "The problem asks to find the maximum profit that can be achieved by buying and selling a stock with a given transaction fee. The key insight is to use dynamic programming to track the maximum profit at each step."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with an empty tree and try adding each value from the array as the root, then recursively add the remaining values as left and right children",
          "code" : "import Foundation\nclass Solution {\n    func numFactoredBinaryTrees(_ arr: [Int]) -> Int {\n        var memo: [Int: Int] = [:]\n        var result = 0\n        let arr = arr.sorted()\n        for i in 0..<arr.count {\n            let num = arr[i]\n            result += dfs(num, &memo, arr)\n        }\n        return result\n    }\n    func dfs(_ num: Int, _ memo: inout [Int: Int], _ arr: [Int]) -> Int {\n        if let result = memo[num] {\n            return result\n        }\n        var result = 1\n        for i in 0..<arr.count {\n            let candidate = arr[i]\n            if candidate > sqrt(Double(num)) {\n                break\n            }\n            if num % candidate == 0 {\n                let other = num \/ candidate\n                if arr.contains(other) {\n                    if candidate == other {\n                        result += dfs(candidate, &memo, arr)\n                    } else {\n                        result += dfs(candidate, &memo, arr) * dfs(other, &memo, arr)\n                    }\n                }\n            }\n        }\n        memo[num] = result\n        return result\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear due to the recursion stack and memoization",
            "time" : "O(2^n)",
            "timeExplanation" : "The brute force approach tries all possible combinations of nodes, resulting in exponential time complexity"
          },
          "explanation" : "The brute force approach tries all possible combinations of nodes to form a binary tree and checks each one to see if it meets the required condition",
          "id" : "992a2a30-d850-4f7a-baec-2ea3d126be56",
          "intuition" : "Generate all possible binary trees and check each one to see if it satisfies the given condition",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The possible binary trees are: 4, 4, and 2-2",
              "id" : "1786f63c-84f7-4a47-86bf-612f8f8bfd6b",
              "input" : "[2, 4]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The possible binary trees are: 4, 2-2, 5, 10, 2-5, 2-10, and 4-10",
              "id" : "72b97c28-a204-4622-a780-6f3aec1c49f0",
              "input" : "[2, 4, 5, 10]"
            }
          ]
        },
        {
          "approach" : "Sort the array and iterate over each value, using memoization to store the number of trees that can be formed for each value",
          "code" : "import Foundation\nclass Solution {\n    func numFactoredBinaryTrees(_ arr: [Int]) -> Int {\n        let arr = arr.sorted()\n        let n = arr.count\n        var memo: [Int: Int] = [:]\n        let mod = 1000000007\n        for i in 0..<n {\n            memo[arr[i]] = 1\n        }\n        var result: Int64 = 0\n        for i in 0..<n {\n            for j in 0..<i {\n                if arr[i] % arr[j] == 0 {\n                    let other = arr[i] \/ arr[j]\n                    if arr.contains(other) {\n                        let val: Int64 = Int64(memo[arr[j]]!) * Int64(memo[other]!)\n                        if arr[j] == other {\n                            memo[arr[i]] = (memo[arr[i]]! + Int(val)) % mod\n                        } else {\n                            memo[arr[i]] = (memo[arr[i]]! + 2 * Int(val)) % mod\n                        }\n                    }\n                }\n            }\n            result = (result + Int64(memo[arr[i]]!)) % Int64(mod)\n        }\n        return Int(result)\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear due to memoization",
            "time" : "O(n^2)",
            "timeExplanation" : "The dynamic programming approach has polynomial time complexity due to the nested loops"
          },
          "explanation" : "The dynamic programming approach uses memoization to store the number of trees that can be formed for each value, reducing the time complexity to polynomial",
          "id" : "90c8a06d-fa10-49d0-ab3d-80f7445ae39a",
          "intuition" : "Use memoization to store the number of trees that can be formed for each value in the array",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The possible binary trees are: 4, 4, and 2-2",
              "id" : "e189ec39-865a-4b6b-8e0c-9e5be141b90e",
              "input" : "[2, 4]"
            },
            {
              "expectedOutput" : "7",
              "explanation" : "The possible binary trees are: 4, 2-2, 5, 10, 2-5, 2-10, and 4-10",
              "id" : "0be3e430-e926-4282-bad3-f69660cd9a68",
              "input" : "[2, 4, 5, 10]"
            }
          ]
        }
      ],
      "id" : "b1e6229d-e95f-495a-81ba-c034637a5673",
      "lastUpdated" : "2026-02-06T21:42:17Z",
      "problemSlug" : "binary-trees-with-factors",
      "relatedProblems" : [
        "unique-binary-search-trees",
        "construct-binary-tree-from-preorder-and-inorder-traversal"
      ],
      "summary" : "The problem asks to find the number of binary trees that can be formed using a given array of node values, where a binary tree is valid if the parent node's value is the product of its two children's values."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an empty set to store unique bitwise OR results. 2. Iterate over the array using two nested loops to generate all possible subarrays. 3. For each subarray, calculate the bitwise OR of its elements and add it to the set.",
          "code" : "func subarrayBitwiseORs(_ A: [Int]) -> [Int] { var ORs: [Int] = []; for i in 0..<A.count { var runningOR = 0; for j in i..<A.count { runningOR |= A[j]; if !ORs.contains(runningOR) { ORs.append(runningOR) } } }; return ORs }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from storing the unique bitwise OR results in the set.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity arises from the two nested loops that generate all possible subarrays, and the.contains() operation on the set."
          },
          "explanation" : "This approach is straightforward but inefficient due to its O(n^3) time complexity, where n is the length of the array.",
          "id" : "dd1f507b-9a86-4789-bcc8-bbf2d3c4acb4",
          "intuition" : "This approach involves calculating the bitwise OR of every possible subarray and storing the results in a set to ensure uniqueness.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,3,4,5,6,7]",
              "explanation" : "For the input [1,2,4], the bitwise OR results of all possible subarrays are [1, 3, 7, 2, 3, 6, 4, 4, 4, 7], which simplifies to [1, 2, 3, 4, 6, 7] when removing duplicates.",
              "id" : "7b8c5d8a-39ce-4262-b2e3-79604ab51392",
              "input" : "nums = [1,2,4]"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "For the input [0,0,0], the bitwise OR result of all possible subarrays is always 0, resulting in a single unique result.",
              "id" : "feb38705-0fbc-4d35-8fce-3948920b8bd7",
              "input" : "nums = [0,0,0]"
            }
          ]
        },
        {
          "approach" : "1. Initialize a prefix OR array. 2. Iterate over the array, updating the prefix OR array at each step. 3. Use the prefix OR array to calculate the OR of any subarray in constant time.",
          "code" : "func subarrayBitwiseORs(_ A: [Int]) -> [Int] { let n = A.count; var prefixOR = Array(repeating: 0, count: n); prefixOR[0] = A[0]; var ORs: [Int] = [A[0]]; for i in 1..<n { prefixOR[i] = prefixOR[i-1] | A[i]; if !ORs.contains(prefixOR[i]) { ORs.append(prefixOR[i]) } }; for i in 0..<n { for j in i..<n { let runningOR = A[i..<j+1].reduce(0, { $0 | $1 }); if !ORs.contains(runningOR) { ORs.append(runningOR) } } }; return ORs }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from storing the prefix OR array and the set of unique bitwise OR results.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity arises from the nested loops that generate all possible subarrays and calculate their bitwise OR results."
          },
          "explanation" : "This approach reduces the time complexity by avoiding redundant calculations and using the prefix OR array for efficient lookups.",
          "id" : "110a41da-236c-4a7a-a4c0-f5f2015f2c3c",
          "intuition" : "This approach involves utilizing a prefix OR array to store the cumulative bitwise OR results, allowing for efficient lookup and calculation of subarray ORs.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,3]",
              "explanation" : "For the input [1,1,2], the bitwise OR results of all possible subarrays are [1, 1, 3, 1, 3, 3], which simplifies to [1, 3] when removing duplicates.",
              "id" : "9176ddfc-cddc-4d5f-aeff-638d3ef3b533",
              "input" : "nums = [1,1,2]"
            },
            {
              "expectedOutput" : "[0,1,2,3,4,5,6,7]",
              "explanation" : "For the input [0,1,2,4], the bitwise OR results of all possible subarrays are [0, 1, 3, 7, 2, 3, 7, 6, 7, 4, 5, 7, 7], which simplifies to [0, 1, 2, 3, 4, 5, 6, 7] when removing duplicates.",
              "id" : "dc9bfeec-4129-466e-865c-ffcd801198d8",
              "input" : "nums = [0,1,2,4]"
            }
          ]
        }
      ],
      "id" : "e66ffd86-6a24-412b-8bc9-9212550c463e",
      "lastUpdated" : "2026-02-06T21:47:14Z",
      "problemSlug" : "bitwise-ors-of-subarrays",
      "relatedProblems" : [
        "maximum-xor-of-two-numbers-in-an-array",
        "find-xor-sum-of-all-pair-subsets"
      ],
      "summary" : "This problem involves finding the number of distinct bitwise OR results of subarrays within a given array. The key insight is to utilize dynamic programming and bitwise manipulation to optimize the solution."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an array to represent the glasses in the champagne tower. 2. Pour the initial amount of champagne into the first glass. 3. For each glass, calculate the excess champagne that flows down to the glasses below. 4. Repeat step 3 until the target glass is reached.",
          "code" : "func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the amount of champagne in each glass, which requires O(n) space. The space usage increases linearly with the number of levels in the champagne tower.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we simulate the pouring process for each glass in the champagne tower, which has n levels. The simulation involves calculating the excess champagne that flows down to the glasses below, which takes O(n) time for each level."
          },
          "explanation" : "The brute force approach simulates the pouring process for each glass in the champagne tower. It calculates the excess champagne that flows down to the glasses below and tracks the amount of champagne in each glass. However, this approach is inefficient and has a high time complexity due to the recursive nature of the simulation.",
          "id" : "3b56b349-45c9-4ec9-8136-6875bcfd0d24",
          "intuition" : "This approach simulates the pouring of champagne into each glass and calculates the excess champagne that flows down to the glasses below. It uses a recursive approach to simulate the pouring process for each glass.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "0.0",
              "explanation" : "The first glass can hold 1 unit of champagne, and the excess champagne flows down to the glasses below. Since the query glass is the first glass, the amount of champagne in the query glass is 0.0.",
              "id" : "e72aa3f5-5a90-4d10-9cb3-6b83e7c983c6",
              "input" : "poured = 1, query_row = 1, query_glass = 1"
            },
            {
              "expectedOutput" : "0.5",
              "explanation" : "The first glass can hold 1 unit of champagne, and the excess champagne flows down to the glasses below. Since the query glass is the first glass, the amount of champagne in the query glass is 0.5.",
              "id" : "c5e15951-f51a-4b1b-be24-425015550f42",
              "input" : "poured = 2, query_row = 1, query_glass = 1"
            },
            {
              "expectedOutput" : "1.0",
              "explanation" : "The amount of champagne in the query glass is greater than or equal to 1.0, so the function returns 1.0.",
              "id" : "6225e30a-9e7f-454d-8013-f3257e50ce48",
              "input" : "poured = 100000009, query_row = 33, query_glass = 17"
            }
          ]
        },
        {
          "approach" : "1. Initialize an array to represent the glasses in the champagne tower. 2. Pour the initial amount of champagne into the first glass. 3. For each glass, calculate the excess champagne that flows down to the glasses below. 4. Repeat step 3 until the target glass is reached.",
          "code" : "func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the amount of champagne in each glass, which requires O(n) space. The space usage increases linearly with the number of levels in the champagne tower.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we simulate the pouring process for each glass in the champagne tower, which has n levels. The simulation involves calculating the excess champagne that flows down to the glasses below, which takes O(n) time for each level."
          },
          "explanation" : "The optimized dynamic programming approach uses an iterative approach to simulate the pouring process for each glass in the champagne tower. It calculates the excess champagne that flows down to the glasses below and tracks the amount of champagne in each glass. This approach has a lower time complexity compared to the brute force approach.",
          "id" : "2b6e9ec4-f32d-4f93-bde2-50701938c0a8",
          "intuition" : "This approach uses a dynamic programming approach to track the amount of champagne in each glass and calculate the final champagne amount in the target glass. It uses an iterative approach to simulate the pouring process for each glass.",
          "name" : "Optimized Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "0.0",
              "explanation" : "The first glass can hold 1 unit of champagne, and the excess champagne flows down to the glasses below. Since the query glass is the first glass, the amount of champagne in the query glass is 0.0.",
              "id" : "824600b7-b8e7-4fe7-9cde-8113b879e2f3",
              "input" : "poured = 1, query_row = 1, query_glass = 1"
            },
            {
              "expectedOutput" : "0.5",
              "explanation" : "The first glass can hold 1 unit of champagne, and the excess champagne flows down to the glasses below. Since the query glass is the first glass, the amount of champagne in the query glass is 0.5.",
              "id" : "250ca486-47db-44c2-8e1f-61aed4338f21",
              "input" : "poured = 2, query_row = 1, query_glass = 1"
            },
            {
              "expectedOutput" : "1.0",
              "explanation" : "The amount of champagne in the query glass is greater than or equal to 1.0, so the function returns 1.0.",
              "id" : "c63f0dda-1791-490b-8e56-0154de7f2b26",
              "input" : "poured = 100000009, query_row = 33, query_glass = 17"
            }
          ]
        }
      ],
      "id" : "90639d89-df0f-4f4d-b70f-3dc4020f013e",
      "lastUpdated" : "2026-02-06T21:40:33Z",
      "problemSlug" : "champagne-tower",
      "relatedProblems" : [
        "poisonous-plants",
        "unique-paths-iii"
      ],
      "summary" : "The Champagne Tower problem involves simulating a champagne tower where each glass can hold a certain amount of champagne and excess champagne flows down to the glasses below. The key insight is to use a dynamic programming approach to track the amount of champagne in each glass and calculate the final champagne amount in the target glass."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize distances (source = 0, others = infinity)\n2. Repeat K+1 times:\n   - Copy current distances\n   - Relax all edges using previous distances\n3. Return destination distance",
          "code" : "func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\n    var dist = [Int](repeating: Int.max, count: n)\n    dist[src] = 0\n    \n    for _ in 0...k {\n        let prev = dist\n        for f in flights {\n            let from = f[0], to = f[1], price = f[2]\n            if prev[from] != Int.max {\n                dist[to] = min(dist[to], prev[from] + price)\n            }\n        }\n    }\n    \n    return dist[dst] == Int.max ? -1 : dist[dst]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Distance array",
            "time" : "O(K * E)",
            "timeExplanation" : "K+1 iterations over E edges"
          },
          "explanation" : "Each iteration adds one more edge to paths. K+1 edges = K intermediate stops.",
          "id" : "550e8400-e29b-41d4-a716-446655440174",
          "intuition" : "Bellman-Ford relaxes all edges. K+1 iterations gives paths with at most K stops.",
          "name" : "Bellman-Ford with K iterations",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "700",
              "explanation" : "0->1->3 costs 700 with 1 stop",
              "id" : "550e8400-e29b-41d4-a716-446655440280",
              "input" : "n=4, flights=[[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src=0, dst=3, k=1"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440063",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "cheapest-flights-within-k-stops",
      "relatedProblems" : [
        "network-delay-time",
        "minimum-cost-to-reach-destination-in-time"
      ],
      "summary" : "Shortest path with at most K stops. Modified Bellman-Ford or BFS with pruning."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Handle small n (1 or 2) directly.\n2. Iterate from 3 to n, keeping only the last two values.\n3. Return the final value.",
          "code" : "func climbStairs(_ n: Int) -> Int {\n    if n <= 2 { return n }\n    var a = 1\n    var b = 2\n    for _ in 3...n {\n        let c = a + b\n        a = b\n        b = c\n    }\n    return b\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only two integers are stored.",
            "time" : "O(n)",
            "timeExplanation" : "We compute each step once."
          },
          "explanation" : "This is a classic DP problem that collapses to a constant-space Fibonacci computation.",
          "id" : "718a7245-392c-498d-82a2-cc018254ba43",
          "intuition" : "The number of ways to reach step i equals ways(i-1) + ways(i-2).",
          "name" : "DP (Fibonacci)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "(1+1), (2).",
              "id" : "f9a175ed-00a1-4238-a6cd-94f239da68e7",
              "input" : "n = 2"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "(1+1+1), (1+2), (2+1).",
              "id" : "3f2247d4-81b4-488b-9f66-e2db963edaf6",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "8",
              "explanation" : "Fibonacci growth.",
              "id" : "f33c3263-9025-4305-81f6-7e0c92dd5514",
              "input" : "n = 5"
            }
          ]
        }
      ],
      "id" : "e3586dfa-a556-4688-8b3e-7c988f871267",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "climbing-stairs",
      "relatedProblems" : [
        "min-cost-climbing-stairs",
        "house-robber"
      ],
      "summary" : "Each step can be reached from the previous two steps; this forms a Fibonacci sequence."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize dp[0] = 0 and dp[i] = amount + 1 as infinity.\n2. For each amount from 1 to target, try each coin.\n3. If coin <= amount, dp[amount] = min(dp[amount], dp[amount - coin] + 1).\n4. Return dp[amount] if reachable, else -1.",
          "code" : "func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n    if amount == 0 { return 0 }\n    var dp = Array(repeating: amount + 1, count: amount + 1)\n    dp[0] = 0\n\n    if amount > 0 {\n        for a in 1...amount {\n            for coin in coins where coin <= a {\n                dp[a] = min(dp[a], dp[a - coin] + 1)\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount]\n}",
          "complexity" : {
            "space" : "O(amount)",
            "spaceExplanation" : "DP array of size amount + 1.",
            "time" : "O(amount * coins)",
            "timeExplanation" : "For each amount we test all coins."
          },
          "explanation" : "This is a classic unbounded knapsack: each coin can be used multiple times.",
          "id" : "b55a038f-25b6-43b9-a7b6-8b9c281971f8",
          "intuition" : "The optimal way to make amount A depends on the optimal way to make A - coin for each coin.",
          "name" : "DP (Unbounded)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "11 = 5 + 5 + 1.",
              "id" : "02761a1e-687a-443d-ad55-42ec7bfee4be",
              "input" : "coins = [1,2,5], amount = 11"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "Cannot make 3 with only 2s.",
              "id" : "722491b7-e337-4740-b52c-143a5b9af547",
              "input" : "coins = [2], amount = 3"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "Zero amount needs zero coins.",
              "id" : "f4c25e0b-fd8f-40bf-a433-ce41c17606e9",
              "input" : "coins = [1], amount = 0"
            }
          ]
        }
      ],
      "id" : "c4d3ba80-256e-421e-a8cd-00902e73d355",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "coin-change",
      "relatedProblems" : [
        "coin-change-2",
        "minimum-cost-for-tickets"
      ],
      "summary" : "Compute the minimum coins needed for every amount up to target."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[0] = 1 (one way to make 0)\n2. For each coin, for each amount, dp[amount] += dp[amount - coin]",
          "code" : "func change(_ amount: Int, _ coins: [Int]) -> Int {\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1\n    for coin in coins {\n        for a in coin...amount {\n            dp[a] += dp[a - coin]\n        }\n    }\n    return dp[amount]\n}",
          "complexity" : {
            "space" : "O(amount)",
            "spaceExplanation" : "DP array",
            "time" : "O(namount)",
            "timeExplanation" : "Each coin  each amount"
          },
          "explanation" : "Processing coins outer loop ensures we count combinations not permutations.",
          "id" : "5911fd0f-1770-422b-a959-0db8de38937d",
          "intuition" : "For each coin, add ways to make each amount using that coin.",
          "name" : "DP",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "5, 2+2+1, 2+1+1+1, 1+1+1+1+1",
              "id" : "df58a382-90b4-4d44-a6b6-6b42d0a06620",
              "input" : "amount=5, coins=[1,2,5]"
            }
          ]
        }
      ],
      "id" : "9a166149-ffbd-4f78-b65e-248f6cb6e773",
      "lastUpdated" : "2026-02-06T01:03:48.939Z",
      "problemSlug" : "coin-change-2",
      "relatedProblems" : [
        "coin-change"
      ],
      "summary" : "Count combinations to make amount with coins. DP: process coins then amounts to avoid counting permutations."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[0] = 1 (one way to make 0)\n2. For each coin, update dp[coin..amount]\n3. dp[i] += dp[i-coin]",
          "code" : "func change(_ amount: Int, _ coins: [Int]) -> Int {\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1\n    \n    for coin in coins {\n        for i in coin...amount {\n            dp[i] += dp[i - coin]\n        }\n    }\n    return dp[amount]\n}",
          "complexity" : {
            "space" : "O(amount)",
            "spaceExplanation" : "DP array",
            "time" : "O(amount  coins)",
            "timeExplanation" : "Nested loops"
          },
          "explanation" : "Processing coins outer loop avoids counting permutations.",
          "id" : "aaae49b0-13d6-46da-922c-a331f89c745d",
          "intuition" : "Count combinations (order doesn't matter). Process coins then amounts.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "5, 2+2+1, 2+1+1+1, 1+1+1+1+1",
              "id" : "020f8331-886e-4cdf-a9c6-6ab11c677bc7",
              "input" : "amount = 5, coins = [1,2,5]"
            }
          ]
        }
      ],
      "id" : "dc227afb-a648-494a-821c-69650be0b2a6",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "coin-change-ii",
      "relatedProblems" : [
        "coin-change"
      ],
      "summary" : "Count ways to make amount. dp[i] += dp[i-coin] for each coin."
    },
    {
      "approaches" : [
        {
          "approach" : "For each number in the array, recursively call the function with the remaining sum and add the number to the current combination. If the remaining sum becomes zero, it means we have found a valid combination.",
          "code" : "\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\n    var memo: [Int: Int] = [:]\n    func dp(_ remaining: Int) -> Int {\n        if remaining < 0 { return 0 }\n        if remaining == 0 { return 1 }\n        if memo[remaining] != nil { return memo[remaining]! }\n        var count = 0\n        for num in nums {\n            count += dp(remaining - num)\n        }\n        memo[remaining] = count\n        return count\n    }\n    return dp(target)\n}\n",
          "complexity" : {
            "space" : "O(target)",
            "spaceExplanation" : "We need to store the number of combinations for each sum from 1 to the target, which requires linear space.",
            "time" : "O(n^target)",
            "timeExplanation" : "For each number in the array, we are recursively calling the function with the remaining sum, which results in an exponential time complexity."
          },
          "explanation" : "However, this approach is not efficient because it involves a lot of repeated computation. It's used as a baseline to understand the problem.",
          "id" : "26e82f85-464b-44bb-b83c-e951d683e7f4",
          "intuition" : "This approach works by recursively trying all possible combinations of numbers to reach the target sum.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "The possible combinations are [1,1,1,1], [1,1,2], [1,2,1], [1,3], [2,1,1], [2,2], [3,1].",
              "id" : "fdf0f4bf-a74b-478d-a3f0-0918c77f7c58",
              "input" : "nums = [1,2,3], target = 4"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no combinations that sum up to 3 using the number 9.",
              "id" : "43bad3de-2c52-491d-ae98-394fd7b477d8",
              "input" : "nums = [9], target = 3"
            }
          ]
        },
        {
          "approach" : "We initialize a table dp of size target + 1 with all values set to 0, except for dp[0] which is set to 1. Then, for each number from 1 to the target, we update the dp table by adding the number of combinations for the current number minus each number in the array.",
          "code" : "\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\n    var dp: [Int] = Array(repeating: 0, count: target + 1)\n    dp[0] = 1\n    for i in 1...target {\n        for num in nums {\n            if i >= num {\n                dp[i] += dp[i - num]\n            }\n        }\n    }\n    return dp[target]\n}\n",
          "complexity" : {
            "space" : "O(target)",
            "spaceExplanation" : "We need to store the number of combinations for each sum from 1 to the target, which requires linear space.",
            "time" : "O(n*target)",
            "timeExplanation" : "We need to iterate over the array of numbers for each sum from 1 to the target, resulting in a time complexity of O(n*target)."
          },
          "explanation" : "This approach avoids the repeated computation of the brute force approach and has a much better time complexity.",
          "id" : "377e7354-1cf3-4ded-a176-56757066b412",
          "intuition" : "This approach works by using a dynamic programming table to store the number of combinations for each sum from 1 to the target.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "The possible combinations are [1,1,1,1], [1,1,2], [1,2,1], [1,3], [2,1,1], [2,2], [3,1].",
              "id" : "1276273b-27ae-41ee-b699-ad501fecd441",
              "input" : "nums = [1,2,3], target = 4"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no combinations that sum up to 3 using the number 9.",
              "id" : "3d353a81-d8ac-4002-82c3-8fed1cf9c318",
              "input" : "nums = [9], target = 3"
            }
          ]
        }
      ],
      "id" : "4052f6cf-ee4c-44fc-8ee9-28e286e31eb0",
      "lastUpdated" : "2026-02-06T21:14:53Z",
      "problemSlug" : "combination-sum-iv",
      "relatedProblems" : [
        "combination-sum",
        "combination-sum-ii",
        "combination-sum-iii"
      ],
      "summary" : "Combination Sum IV is a problem where we need to find the number of combinations that sum up to a given target using the numbers in the given array, with each number allowed to be used any number of times. The key insight is to use dynamic programming to store the number of combinations for each sum from 1 to the target."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create array ans of size n+1\n2. ans[0] = 0\n3. For i from 1 to n: ans[i] = ans[i >> 1] + (i & 1)\n4. Return ans",
          "code" : "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i >> 1] + (i & 1)\n    }\n    \n    return ans\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Output array of size n+1",
            "time" : "O(n)",
            "timeExplanation" : "Single pass from 1 to n"
          },
          "explanation" : "Right shifting drops the last bit. So i's bit count is (i >> 1)'s bit count plus the dropped bit (0 or 1). For example, 5 (101) >> 1 = 2 (10). ans[5] = ans[2] + (5 & 1) = 1 + 1 = 2. We build up from smaller numbers, which we've already computed.",
          "id" : "a061a99c-3f78-41ac-ab70-2c5cfefe9cd5",
          "intuition" : "The number of 1s in i equals the number of 1s in i\/2 (i >> 1) plus whether the last bit is 1 (i & 1).",
          "name" : "DP with Right Shift",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,1,1]",
              "explanation" : "0=0b0 (0), 1=0b1 (1), 2=0b10 (1)",
              "id" : "33d46ac6-aeb7-42c1-8a50-e7de4965922b",
              "input" : "n = 2"
            },
            {
              "expectedOutput" : "[0,1,1,2,1,2]",
              "explanation" : "0,1,10,11,100,101 have 0,1,1,2,1,2 ones respectively",
              "id" : "9fa413ed-869c-400f-8c98-5ab0729dab99",
              "input" : "n = 5"
            }
          ]
        },
        {
          "approach" : "1. Create array ans of size n+1, ans[0] = 0\n2. For i from 1 to n: ans[i] = ans[i & (i-1)] + 1\n3. Return ans",
          "code" : "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i & (i - 1)] + 1\n    }\n    \n    return ans\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Output array of size n+1",
            "time" : "O(n)",
            "timeExplanation" : "Single pass, O(1) work per number"
          },
          "explanation" : "i & (i-1) removes exactly one 1 bit from i. So ans[i] is one more than ans of the result. For example, 6 (110) & 5 (101) = 4 (100). ans[6] = ans[4] + 1 = 1 + 1 = 2. This directly uses the relationship between adjacent numbers in terms of set bits.",
          "id" : "359c7fe7-37ea-468a-af26-f9c326c80395",
          "intuition" : "ans[i] = ans[i & (i-1)] + 1, since i & (i-1) clears the lowest set bit. We've already computed ans for that smaller number.",
          "name" : "DP with Brian Kernighan",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0,1,1,2,1,2]",
              "explanation" : "Same result, different recurrence",
              "id" : "417bdca3-a29f-4525-87fd-272adecdf2a2",
              "input" : "n = 5"
            },
            {
              "expectedOutput" : "[0]",
              "explanation" : "Just zero, which has 0 ones",
              "id" : "2826e6d6-d705-41c3-85a2-e8cb2c2a9635",
              "input" : "n = 0"
            }
          ]
        }
      ],
      "id" : "9e0e6f5c-993a-4a8d-98a6-10b60726633a",
      "lastUpdated" : "2026-02-06T08:38:32Z",
      "problemSlug" : "counting-bits",
      "relatedProblems" : [
        "number-of-1-bits",
        "binary-watch"
      ],
      "summary" : "Return array where ans[i] is the number of 1 bits in i, for i from 0 to n. Use DP: ans[i] = ans[i >> 1] + (i & 1), or ans[i] = ans[i & (i-1)] + 1."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[i] = ways to decode s[0..i-1]\n2. If s[i-1] != '0': dp[i] += dp[i-1] (single digit)\n3. If s[i-2..i-1] in 10-26: dp[i] += dp[i-2] (double digit)",
          "code" : "func numDecodings(_ s: String) -> Int {\n    let chars = Array(s)\n    let n = chars.count\n    if chars[0] == \"0\" { return 0 }\n    \n    var prev2 = 1  \/\/ dp[i-2]\n    var prev1 = 1  \/\/ dp[i-1]\n    \n    for i in 1..<n {\n        var curr = 0\n        let oneDigit = Int(String(chars[i]))!\n        let twoDigit = Int(String(chars[i-1...i]))!\n        \n        if oneDigit >= 1 { curr += prev1 }\n        if twoDigit >= 10 && twoDigit <= 26 { curr += prev2 }\n        \n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Two variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "'0' can't be decoded alone. '06' is invalid. Only '10'-'26' valid as two digits.",
          "id" : "550e8400-e29b-41d4-a716-446655440144",
          "intuition" : "At each position, can decode 1 digit (if valid) or 2 digits (if valid). Sum the ways.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "BZ (2,26), VF (22,6), BBF (2,2,6)",
              "id" : "550e8400-e29b-41d4-a716-446655440250",
              "input" : "\"226\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440033",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "decode-ways",
      "relatedProblems" : [
        "decode-ways-ii"
      ],
      "summary" : "Count ways to decode digit string to letters. DP: check single digit (1-9) and double digit (10-26)."
    },
    {
      "approaches" : [
        {
          "approach" : "For each number, try deleting it and recursively solve for the remaining numbers, then try not deleting it and recursively solve. Keep track of the maximum earnings.",
          "code" : "func deleteAndEarn(_ nums: [Int]) -> Int {\n    let maxNum = nums.max()!\n    var freq = Array(repeating: 0, count: maxNum + 1)\n    for num in nums {\n        freq[num] += 1\n    }\n    var memo: [Int: Int] = [:]\n    func dp(_ num: Int) -> Int {\n        if num == 0 { return 0 }\n        if num == 1 { return freq[1] }\n        if let cached = memo[num] { return cached }\n        let exclude = dp(num - 1)\n        let include = freq[num] * num + dp(num - 2)\n        let result = max(exclude, include)\n        memo[num] = result\n        return result\n    }\n    return dp(maxNum)\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the memoization table.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) due to the recursive calls and memoization."
          },
          "explanation" : "This approach tries all possible combinations of deleting numbers and keeps track of the maximum earnings. However, it is inefficient due to overlapping subproblems.",
          "id" : "345bd2d3-5eb5-4903-ad59-79f2010196cc",
          "intuition" : "This approach works by trying all possible combinations of deleting numbers and choosing the maximum earnings.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "15",
              "explanation" : "The maximum earnings are achieved by deleting the numbers 3 and 4.",
              "id" : "49ab66f4-dc8b-4976-bf95-50a763a4380d",
              "input" : "nums = [3,4,8]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The maximum earnings are achieved by deleting the number 2.",
              "id" : "50ae5612-3c55-4cc6-bab5-3af5ade9e914",
              "input" : "nums = [2]"
            }
          ]
        },
        {
          "approach" : "Initialize an array to store the maximum earnings for each number. For each number, calculate the maximum earnings as the maximum of the maximum earnings for the previous number and the sum of the current number and the maximum earnings for the number two positions before.",
          "code" : "func deleteAndEarn(_ nums: [Int]) -> Int {\n    let maxNum = nums.max()!\n    var freq = Array(repeating: 0, count: maxNum + 1)\n    for num in nums {\n        freq[num] += 1\n    }\n    var dp = Array(repeating: 0, count: maxNum + 1)\n    dp[1] = freq[1]\n    for i in 2...maxNum {\n        dp[i] = max(dp[i - 1], dp[i - 2] + freq[i] * i)\n    }\n    return dp[maxNum]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the dp array.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) due to the iterative calculation."
          },
          "explanation" : "This approach avoids overlapping subproblems by iteratively calculating the maximum earnings for each number.",
          "id" : "24032743-3988-4f8c-bb1f-cfb469e7bbf6",
          "intuition" : "This approach works by iteratively calculating the maximum earnings for each number, using the fact that the maximum earnings for a number is the maximum of the maximum earnings for the previous number and the sum of the current number and the maximum earnings for the number two positions before.",
          "name" : "Optimized Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "15",
              "explanation" : "The maximum earnings are achieved by deleting the numbers 3 and 4.",
              "id" : "54fb3a1d-69d3-41eb-842a-9e00799df032",
              "input" : "nums = [3,4,8]"
            },
            {
              "expectedOutput" : "18",
              "explanation" : "The maximum earnings are achieved by deleting the numbers 4 and 7 and 9.",
              "id" : "7e3cadfe-99db-4556-b28d-1af2e7f3350e",
              "input" : "nums = [2,7,9,4,4]"
            }
          ]
        }
      ],
      "id" : "6fc38b25-05ea-4924-b08c-4c061451b72f",
      "lastUpdated" : "2026-02-06T21:36:52Z",
      "problemSlug" : "delete-and-earn",
      "relatedProblems" : [
        "coin-change-2",
        "minimum-difficulty-to-make-progress-to-targets"
      ],
      "summary" : "The problem requires finding the maximum number that can be earned by deleting elements from an array and earning points equivalent to the deleted number, with the constraint that if a number is deleted, all occurrences of a number one greater or one lesser cannot be deleted. The key insight is using dynamic programming to keep track of the maximum earnings for each possible number."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the first string and delete characters one by one, comparing the resulting string with the second string. Repeat this process until a match is found or all possible transformations have been tried.",
          "code" : "\n           func minDistance(_ word1: String, _ word2: String) -> Int {\n               var m = word1.count\n               var n = word2.count\n               return m + n - 2 * lcs(word1, word2)\n           }\n\n           func lcs(_ word1: String, _ word2: String) -> Int {\n               let m = word1.count\n               let n = word2.count\n               var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\n\n               for i in 1...m {\n                   for j in 1...n {\n                       if word1[i - 1] == word2[j - 1] {\n                           dp[i][j] = dp[i - 1][j - 1] + 1\n                       } else {\n                           dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                       }\n                   }\n               }\n\n               return dp[m][n]\n           }\n           ",
          "complexity" : {
            "space" : "O(m * n)",
            "spaceExplanation" : "The space complexity is also quadratic due to the 2D array used to store the lengths of common subsequences.",
            "time" : "O(m * n)",
            "timeExplanation" : "The time complexity is quadratic due to the nested loops in the lcs function."
          },
          "explanation" : "This approach will work, but it's inefficient due to its exponential time complexity.",
          "id" : "0044c129-4ff1-4040-9352-9c2922dc8a33",
          "intuition" : "The brute-force approach involves comparing each possible string transformation by deleting characters and checking if the resulting strings match.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Delete 's' from 'sea' and 'e' from 'eat' to get 'ea' and 'at'. Then delete 'a' from 'ea' to get 'e' and delete 't' from 'at' to get 'a'. So the total number of operations is 3.",
              "id" : "f18902d0-87fa-451e-b1a5-1567b7b09a88",
              "input" : "word1 = \"sea\", word2 = \"eat\""
            },
            {
              "expectedOutput" : "4",
              "explanation" : "Delete 'd' from 'delete' to get 'elete' and delete 'l' from 'leet' to get 'eet'. Then delete 'e' from 'elete' to get 'lete' and delete 'e' from 'eet' to get 'et'. So the total number of operations is 4.",
              "id" : "9e44af8f-053f-47d7-aa67-9bc5a36cb1d9",
              "input" : "word1 = \"delete\", word2 = \"leet\""
            }
          ]
        },
        {
          "approach" : "Create a 2D array to store the lengths of common subsequences. Iterate through the array, updating the lengths based on whether the current characters in the two strings match. Finally, calculate the minimum number of operations by subtracting the length of the longest common subsequence from the sum of the string lengths.",
          "code" : "\n           func minDistance(_ word1: String, _ word2: String) -> Int {\n               let m = word1.count\n               let n = word2.count\n               var memo = Array(repeating: Array(repeating: -1, count: n + 1), count: m + 1)\n\n               func lcs(_ i: Int, _ j: Int) -> Int {\n                   if i == 0 || j == 0 {\n                       return 0\n                   }\n\n                   if memo[i][j] != -1 {\n                       return memo[i][j]\n                   }\n\n                   if word1[i - 1] == word2[j - 1] {\n                       memo[i][j] = 1 + lcs(i - 1, j - 1)\n                   } else {\n                       memo[i][j] = max(lcs(i - 1, j), lcs(i, j - 1))\n                   }\n\n                   return memo[i][j]\n               }\n\n               return m + n - 2 * lcs(m, n)\n           }\n           ",
          "complexity" : {
            "space" : "O(m * n)",
            "spaceExplanation" : "The space complexity is also quadratic due to the memoization array.",
            "time" : "O(m * n)",
            "timeExplanation" : "The time complexity is quadratic due to the recursive function calls."
          },
          "explanation" : "This approach works by avoiding redundant comparisons and leveraging the overlapping subproblems.",
          "id" : "aa37e1ae-bf1e-4451-9c8f-1a7b77a13b7a",
          "intuition" : "The optimized approach uses dynamic programming to efficiently compare the two strings and find the longest common subsequence.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Delete 'k' from 'kitten' to get 'itten' and delete 's' from 'sitting' to get 'itting'. Then delete 'e' from 'itten' to get 'ittn' and delete 'g' from 'itting' to get 'itng'. So the total number of operations is 3.",
              "id" : "2a2ffde7-cda3-483a-8d5f-998686c4721a",
              "input" : "word1 = \"kitten\", word2 = \"sitting\""
            },
            {
              "expectedOutput" : "4",
              "explanation" : "Delete 'h' from 'hello' to get 'ello' and delete 'w' from 'world' to get 'orld'. Then delete 'e' from 'ello' to get 'llo' and delete 'o' from 'orld' to get 'rld'. So the total number of operations is 4.",
              "id" : "373345bb-1bea-473f-be42-24ccc6734600",
              "input" : "word1 = \"hello\", word2 = \"world\""
            }
          ]
        }
      ],
      "id" : "25a35299-dd28-4de0-b9e2-ed145fd4249a",
      "lastUpdated" : "2026-02-06T21:27:07Z",
      "problemSlug" : "delete-operation-for-two-strings",
      "relatedProblems" : [
        "edit-distance",
        "longest-common-subsequence"
      ],
      "summary" : "The problem requires finding the minimum number of operations to transform two strings into identical strings by deleting characters. The key insight is using dynamic programming to compare the two strings and determine the longest common subsequence."
    },
    {
      "approaches" : [
        {
          "approach" : "We start by initializing an empty board. Then we fill the board by trying all possible tiling combinations, checking after each combination whether the board is completely covered.",
          "code" : "func numTilings(n: Int) -> Int {\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    if n == 3 {\n        return 2\n    }\n    var arr = [0, 0, 1, 2]\n    for i in 4...n {\n        arr.append((2 * arr[i-1]) + arr[i-3])\n    }\n    return arr[n]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is also linear due to the storage required for the dynamic programming array.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are iterating through the board once to fill it."
          },
          "explanation" : "This approach is straightforward but inefficient because it has to check a vast number of possibilities, leading to exponential time complexity.",
          "id" : "1dc1477a-9204-4bb8-a24d-754ec88d9abf",
          "intuition" : "This approach works by simply trying all possible tiling combinations and checking if the board can be completely covered.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "For n = 3, we can have the following combinations: |||, ||-, |-|, --|, |-|-",
              "id" : "72ab5dbd-73d5-404f-9595-61dcaca13c48",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "11",
              "explanation" : "For n = 4, there are 11 possible combinations.",
              "id" : "682cda49-0cff-442e-80c5-20d15b1b70c7",
              "input" : "n = 4"
            }
          ]
        },
        {
          "approach" : "We start by initializing a base case. Then we fill up a DP array where each cell represents the number of ways to tile a board of a certain size.",
          "code" : "func numTilings(n: Int) -> Int {\n    let MOD = 1000000007\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    if n == 3 {\n        return 2\n    }\n    var dp = Array(repeating: 0, count: n + 1)\n    dp[1] = 0\n    dp[2] = 1\n    dp[3] = 2\n    for i in 4...n {\n        dp[i] = (2 * dp[i-1]) + dp[i-3]\n        dp[i] %= MOD\n    }\n    return dp[n]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity also remains linear due to the storage required for the DP array.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity remains linear because we are still filling up the DP array once."
          },
          "explanation" : "This approach is efficient because it avoids the redundant computation present in the brute-force approach by storing and reusing the results of sub-problems.",
          "id" : "06c0e776-816c-4a43-9c76-a0da810e0ed1",
          "intuition" : "This approach works by breaking down the problem into smaller sub-problems and storing the results of these sub-problems to avoid redundant computation.",
          "name" : "Optimized Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The combinations are: |||, ||-, |-|, --|, |-|-",
              "id" : "376f813c-1913-42da-8898-e9047170adcf",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "11",
              "explanation" : "The combinations are counted based on the DP formula.",
              "id" : "b1715c16-e952-4f95-9a49-a6e4176f5574",
              "input" : "n = 4"
            }
          ]
        }
      ],
      "id" : "f464df4f-b79c-4aaa-bbbb-fb47b344313c",
      "lastUpdated" : "2026-02-06T21:39:45Z",
      "problemSlug" : "domino-and-tromino-tiling",
      "relatedProblems" : [
        "partition-equal-subset-sum",
        "coin-change-2"
      ],
      "summary" : "The problem involves tiling a 2xN board with dominoes (2x1) and trominoes (1x3) such that the board is completely covered without any overlaps. A key insight is that to fill the entire board, the number of columns N must be even for dominoes and a multiple of 3 for trominoes."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Base: dp[i][0] = i (delete all), dp[0][j] = j (insert all)\n2. If match: dp[i][j] = dp[i-1][j-1]\n3. Else: 1 + min(replace, insert, delete)",
          "code" : "func minDistance(_ word1: String, _ word2: String) -> Int {\n    let s1 = Array(word1), s2 = Array(word2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 0...m { dp[i][0] = i }\n    for j in 0...n { dp[0][j] = j }\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "2D DP array",
            "time" : "O(m*n)",
            "timeExplanation" : "Fill m*n table"
          },
          "explanation" : "Three choices: replace (i-1,j-1), insert (i,j-1), delete (i-1,j). Take minimum.",
          "id" : "550e8400-e29b-41d4-a716-446655440161",
          "intuition" : "dp[i][j] = min ops for word1[0..i-1] to word2[0..j-1]. If match, no op; else try all three.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "horse -> rorse -> rose -> ros",
              "id" : "550e8400-e29b-41d4-a716-446655440267",
              "input" : "word1 = \"horse\", word2 = \"ros\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440050",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "edit-distance",
      "relatedProblems" : [
        "one-edit-distance",
        "delete-operation-for-two-strings"
      ],
      "summary" : "Min operations (insert\/delete\/replace) to transform word1 to word2. Classic 2D DP."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Define a function to check if the string is monotone increasing. 2. Use a loop to generate all possible combinations of flips. 3. Check each combination to see if the resulting string is monotone increasing and keep track of the minimum number of flips.",
          "code" : "func minFlipsMonoIncr(_ s: String) -> Int { \n    var res = Int.max\n    for mask in 0..<1<<s.count { \n        var flips = 0\n        var ones = 0\n        var mono = true\n        for (i, char) in s.enumerated() {\n            let bit = (mask >> i) & 1\n            if char == \"1\" && bit == 0 { flips += 1 }\n            if char == \"0\" && bit == 1 { flips += 1 }\n            if char == \"1\" || (char == \"0\" && bit == 1) { ones += 1 }\n            if i > 0 && (ones == 1 || (char == \"0\" && ones > 0)) { mono = false; break }\n        }\n        if mono { res = min(res, flips) }\n    }\n    return res\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the result and the current combination of flips.",
            "time" : "O(2^n)",
            "timeExplanation" : "Generating all possible combinations of flips results in exponential time complexity."
          },
          "explanation" : "This approach is inefficient as it generates all possible combinations of flips, resulting in exponential time complexity.",
          "id" : "b15ea0ce-91bb-47c8-a9e0-910268281f19",
          "intuition" : "This approach works by checking all possible combinations of flips and finding the minimum number of flips required to make the string monotone increasing.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "We can flip the 4th bit to get \"00111\", which is monotone increasing.",
              "id" : "28576cf9-aefc-4a4c-9f83-0a0185abe539",
              "input" : "s = \"00110\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "We can flip the 2nd and 4th bits to get \"011111\", which is monotone increasing.",
              "id" : "c10e8b10-41f2-498d-87a1-097e5d9cc2c3",
              "input" : "s = \"010110\""
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The string is already monotone increasing.",
              "id" : "b6517e27-1b1d-4917-ac09-c59ebacddbb2",
              "input" : "s = \"000111\""
            }
          ]
        },
        {
          "approach" : "1. Initialize two arrays to store the minimum number of flips for zeros and ones. 2. Iterate over the string, updating the minimum number of flips for zeros and ones at each position. 3. Return the minimum number of flips for ones at the last position.",
          "code" : "func minFlipsMonoIncr(_ s: String) -> Int { \n    var zeros = 0\n    var ones = 0\n    for char in s { \n        if char == \"0\" { \n            zeros = min(ones + 1, zeros)\n        } else { \n            ones += 1\n        }\n    }\n    return zeros\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the minimum number of flips.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the string once, resulting in linear time complexity."
          },
          "explanation" : "This approach is efficient as it uses dynamic programming to avoid redundant calculations.",
          "id" : "3403f35a-ce63-4a24-abf3-d2258b1305d0",
          "intuition" : "This approach works by using dynamic programming to track the minimum number of flips required to make the string monotone increasing up to each position.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "We can flip the 4th bit to get \"00111\", which is monotone increasing.",
              "id" : "4c09b06c-d26e-4d11-b3c2-b73b909a169c",
              "input" : "s = \"00110\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "We can flip the 2nd and 4th bits to get \"011111\", which is monotone increasing.",
              "id" : "4484c8a6-046b-4e92-9ae7-deb1e23a7507",
              "input" : "s = \"010110\""
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The string is already monotone increasing.",
              "id" : "b5b717c2-5312-4890-8c85-b01373745948",
              "input" : "s = \"000111\""
            }
          ]
        }
      ],
      "id" : "d964aad0-8a1f-4936-b374-66f679a22efa",
      "lastUpdated" : "2026-02-06T21:49:08Z",
      "problemSlug" : "flip-string-to-monotone-increasing",
      "relatedProblems" : [
        "minimum-swap",
        "minimum-cost-to-fill-pools"
      ],
      "summary" : "The problem requires finding the minimum number of flips to make the binary string monotone increasing. The key insight is to use dynamic programming to track the minimum number of flips at each position."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[i] = max money robbing houses 0..i\n2. dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n3. Optimize to O(1) space with two variables",
          "code" : "func rob(_ nums: [Int]) -> Int {\n    var prev2 = 0  \/\/ max from 2 houses back\n    var prev1 = 0  \/\/ max from previous house\n    \n    for num in nums {\n        let curr = max(prev1, prev2 + num)\n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Two variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "Can't rob adjacent, so if we rob house i, previous robbed must be i-2 or earlier.",
          "id" : "550e8400-e29b-41d4-a716-446655440140",
          "intuition" : "At each house, choose: skip it (take prev max) or rob it (take prev-prev max + current).",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "12",
              "explanation" : "Rob houses 0,2,4: 2+9+1=12",
              "id" : "550e8400-e29b-41d4-a716-446655440246",
              "input" : "[2,7,9,3,1]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440029",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "house-robber",
      "relatedProblems" : [
        "house-robber-ii",
        "house-robber-iii"
      ],
      "summary" : "Max money without robbing adjacent houses. DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i])."
    },
    {
      "approaches" : [
        {
          "approach" : "1. If n==1, return nums[0]\n2. Run house robber on nums[0..<n-1]\n3. Run house robber on nums[1..<n]\n4. Return max of both",
          "code" : "func rob(_ nums: [Int]) -> Int {\n    if nums.count == 1 { return nums[0] }\n    \n    func robRange(_ start: Int, _ end: Int) -> Int {\n        var prev2 = 0, prev1 = 0\n        for i in start..<end {\n            let curr = max(prev1, prev2 + nums[i])\n            prev2 = prev1\n            prev1 = curr\n        }\n        return prev1\n    }\n    \n    return max(robRange(0, nums.count - 1), robRange(1, nums.count))\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Constant space",
            "time" : "O(n)",
            "timeExplanation" : "Two passes through array"
          },
          "explanation" : "Breaking the circle by ensuring first and last aren't both included.",
          "id" : "550e8400-e29b-41d4-a716-446655440141",
          "intuition" : "Can't rob both first and last. Solve twice: houses[0..n-2] and houses[1..n-1], take max.",
          "name" : "Two Passes DP",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Can't rob 2 and 2 (adjacent in circle), rob 3",
              "id" : "550e8400-e29b-41d4-a716-446655440247",
              "input" : "[2,3,2]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440030",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "house-robber-ii",
      "relatedProblems" : [
        "house-robber",
        "house-robber-iii"
      ],
      "summary" : "Circular houses (first and last adjacent). Run house robber twice: exclude first or exclude last."
    },
    {
      "approaches" : [
        {
          "approach" : "Start from the root of the tree and for each node, calculate the maximum amount of money that can be robbed by either robbing the current house or not robbing it. If the current house is robbed, do not rob its children. If the current house is not robbed, rob its children if it is profitable.",
          "code" : "\n           class Solution {\n               func rob(_ root: TreeNode?) -> Int {\n                   func dfs(_ node: TreeNode?) -> (Int, Int) {\n                       if node == nil {\n                           return (0, 0)\n                       }\n                       let (lRob, lNotRob) = dfs(node?.left)\n                       let (rRob, rNotRob) = dfs(node?.right)\n                       let rob = node!.val + lNotRob + rNotRob\n                       let notRob = max(lRob + rRob, lRob + rNotRob, lNotRob + rRob, lNotRob + rNotRob)\n                       return (rob, notRob)\n                   }\n                   let (_, res) = dfs(root)\n                   return max(res, dfs(root).0)\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The recursive call stack has a height of n in the worst case, where n is the height of the tree.",
            "time" : "O(2^n)",
            "timeExplanation" : "Each node in the tree is visited multiple times due to the overlapping subproblems in the recursive calls."
          },
          "explanation" : "This brute force approach has an exponential time complexity because it involves recursive calls for each node in the tree. It calculates the maximum amount of money that can be robbed for each possible combination of houses, resulting in a lot of repeated work.",
          "id" : "ce0fee33-a485-424e-b27b-f45dd2d64566",
          "intuition" : "This approach involves trying all possible combinations of houses to rob and selecting the combination with the highest total value. It uses a recursive depth-first search to explore all possible subtrees.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "Rob the root node (3) and the right child of the root node (3), for a total of 6. Then, go to the left subtree of the root node and rob the node (2) for an additional 1, resulting in a total of 7.",
              "id" : "9808ceaa-d1c8-49b9-ab76-0366fe936743",
              "input" : " TreeNode(3), TreeNode(2), TreeNode(3) None None, TreeNode(3) None None"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Rob the only node (3) for a total of 3.",
              "id" : "c67ebd93-6318-4d61-913a-38ee48bfd27a",
              "input" : "TreeNode(3) None None"
            }
          ]
        },
        {
          "approach" : "Start from the root of the tree and for each node, calculate the maximum amount of money that can be robbed by either robbing the current house or not robbing it. If the current house is robbed, do not rob its children. If the current house is not robbed, rob its children if it is profitable.",
          "code" : "\n           class Solution {\n               func rob(_ root: TreeNode?) -> Int {\n                   var memo = [TreeNode: (Int, Int)]()\n                   func dfs(_ node: TreeNode?) -> (Int, Int) {\n                       if node == nil {\n                           return (0, 0)\n                       }\n                       if let val = memo[node] {\n                           return val\n                       }\n                       let (lRob, lNotRob) = dfs(node?.left)\n                       let (rRob, rNotRob) = dfs(node?.right)\n                       let rob = node!.val + lNotRob + rNotRob\n                       let notRob = max(lRob, lNotRob) + max(rRob, rNotRob)\n                       memo[node] = (rob, notRob)\n                       return (rob, notRob)\n                   }\n                   return max(dfs(root).0, dfs(root).1)\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The recursive call stack has a height of n in the worst case, where n is the height of the tree.",
            "time" : "O(n)",
            "timeExplanation" : "Each node in the tree is visited a constant number of times."
          },
          "explanation" : "This optimized approach uses memoization to store the results of subproblems, reducing the time complexity from exponential to linear.",
          "id" : "4153555d-82df-4e25-970b-7fcfb5933887",
          "intuition" : "This approach involves using a post-order depth-first search traversal to calculate the maximum amount of money that can be robbed for each subtree. For each node, calculate the maximum amount of money that can be robbed by either robbing the current house or not robbing it and store the results in a dictionary to avoid repeated work.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Rob the only node (3) for a total of 3.",
              "id" : "11aa6d77-f541-488d-9109-c4f2b598ae65",
              "input" : "TreeNode(3) None None"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "Rob both nodes (2) for a total of 4.",
              "id" : "af4898ab-1df2-4915-9c35-9f00a9dca293",
              "input" : "TreeNode(2), TreeNode(2) None None"
            }
          ]
        }
      ],
      "id" : "3cdd6f4c-7a1f-4971-8a77-50d112dc4903",
      "lastUpdated" : "2026-02-06T21:13:24Z",
      "problemSlug" : "house-robber-iii",
      "relatedProblems" : [
        "house-robber",
        "house-robber-ii"
      ],
      "summary" : "In House Robber III, we need to find the maximum amount of money that can be robbed from a set of houses without robbing adjacent houses in a tree structure. The key insight is to use a post-order depth-first search traversal to calculate the maximum amount of money that can be robbed for each subtree."
    },
    {
      "approaches" : [
        {
          "approach" : "For each state, explore both the possibility of incrementing the number by one and the possibility of decrementing it by one, but only if the resulting number's binary representation does not have two consecutive ones. If it does, it's best to increment it until this condition is met.",
          "code" : "\n       func integerReplacement(n: Int) -> Int {\n         var count = 0\n         var number = n\n         while number != 1 {\n           if number % 2 == 0 {\n             number \/= 2\n           } else if number % 4 == 1 || number == 3 {\n             number += 1\n           } else {\n             number -= 1\n           }\n           count += 1\n         }\n         return count\n       }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we only use a fixed amount of space to store the count and the current number.",
            "time" : "O(log n)",
            "timeExplanation" : "The time complexity comes from the number of divisions by 2 and increments\/decrements needed to reach 1. Since we divide by 2 in the best case, the number of operations is proportional to the number of bits in the binary representation of n."
          },
          "explanation" : "This approach explores the tree of all possible operations, backtracking to explore all paths and finding the minimum. However, it is highly inefficient due to its exponential time complexity.",
          "id" : "96be3aec-3eca-4aaf-86d3-27e912d1f97d",
          "intuition" : "This approach tries all possible sequences of operations and selects the one that results in the minimum number of steps.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "8 -> 4 -> 2 -> 1",
              "id" : "190def83-8821-4923-a96f-b20086e262cd",
              "input" : "n = 8"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "7 -> 8 -> 4 -> 2 -> 1",
              "id" : "4878144e-b443-4877-9e1e-b916eac75aa6",
              "input" : "n = 7"
            }
          ]
        },
        {
          "approach" : "Start with the given number and iteratively apply either the add 1 operation or the divide by 2 operation. If the current number is even, divide by 2; if it is odd, add 1 to make it divisible by 4 if possible, otherwise subtract 1.",
          "code" : "\n       func integerReplacement(n: Int) -> Int {\n         var number = Int64(n)\n         var count = 0\n         while number != 1 {\n           if number % 2 == 0 {\n             number \/= 2\n           } else if number % 4 == 1 || number == 3 {\n             number += 1\n           } else {\n             number -= 1\n           }\n           count += 1\n         }\n         return count\n       }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity remains constant, as only a fixed amount of space is needed to store the count and the current number.",
            "time" : "O(log n)",
            "timeExplanation" : "The time complexity is the same as the brute force approach, as the number of operations still depends on the number of bits in the binary representation of n."
          },
          "explanation" : "The optimized solution reduces the problem to a sequence of simple bit manipulation and division operations. This strategy minimizes the number of steps needed to reach the target number.",
          "id" : "224c9092-4613-4309-ae27-a3dba2e9f811",
          "intuition" : "This approach takes advantage of the bit manipulation insight. The idea is to always make progress towards the target number by either adding 1 or dividing by 2. This strategy allows for an optimal solution.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "2 -> 1",
              "id" : "014dca1c-e84f-4c41-8152-752cd9e4d176",
              "input" : "n = 2"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "4 -> 2 -> 1",
              "id" : "39141e83-1965-4c3f-9367-515e5c92c6b8",
              "input" : "n = 4"
            }
          ]
        }
      ],
      "id" : "8f8c8268-e5de-47ea-997a-bb909cb1aef5",
      "lastUpdated" : "2026-02-06T21:16:25Z",
      "problemSlug" : "integer-replacement",
      "relatedProblems" : [
        "powxn",
        "mincostclimbingstairs"
      ],
      "summary" : "The Integer Replacement problem requires transforming an integer into another by flipping bits (1s to 0s and vice versa). The greedy approach works because we can always make progress towards the target number by either adding 1 or dividing by 2. The optimal solution comes from realizing that adding 1 is only beneficial when the current number is odd and adding 1 turns it into an even number that is divisible by 4."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible interleavings of the two strings, and then check if the given string matches any of them.",
          "code" : "func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }",
          "complexity" : {
            "space" : "O(n+m)",
            "spaceExplanation" : "The space complexity is O(n+m) because we need to store the recursive call stack.",
            "time" : "O(2^(n+m))",
            "timeExplanation" : "The time complexity is O(2^(n+m)) because in the worst case, we need to generate all possible interleavings of the two strings."
          },
          "explanation" : "This approach is not efficient as it has a high time complexity due to generating all possible interleavings.",
          "id" : "e3d38fa4-411b-4f28-9828-0ac6f9070849",
          "intuition" : "This approach works by generating all possible interleavings of the two strings and checking if the given string matches any of them.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The string s3 can be formed by interleaving s1 and s2.",
              "id" : "62743347-a14f-4a1b-a35b-800cdc2ec532",
              "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The string s3 cannot be formed by interleaving s1 and s2.",
              "id" : "340364bb-af0d-43c6-b6e3-74d76e2778dc",
              "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "The string s3 can be formed by interleaving s1 and s2.",
              "id" : "683082b6-a662-4fda-8eac-e0c1faaefa88",
              "input" : "s1 = \"a\", s2 = \"b\", s3 = \"ab\""
            }
          ]
        },
        {
          "approach" : "Create a 2D DP table, where dp[i][j] is true if the first i characters of s1 and the first j characters of s2 can interleave to form the first i+j characters of s3.",
          "code" : "func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var dp = Array(repeating: Array(repeating: false, count: m + 1), count: n + 1); dp[0][0] = true; for i in 0...n { for j in 0...m { if i > 0 { dp[i][j] = dp[i][j] || (dp[i-1][j] && s1[s1.index(s1.startIndex, offsetBy: i-1)] == s3[s3.index(s3.startIndex, offsetBy: i+j-1)]) }; if j > 0 { dp[i][j] = dp[i][j] || (dp[i][j-1] && s2[s2.index(s2.startIndex, offsetBy: j-1)] == s3[s3.index(s3.startIndex, offsetBy: i+j-1)]) }; } }; return dp[n][m]; }",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity is O(n*m) because we need to store the 2D DP table.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because we need to fill up the 2D DP table."
          },
          "explanation" : "This approach is efficient as it uses dynamic programming to avoid redundant computation.",
          "id" : "4f67bc5a-a35a-4fdb-af8e-0e8e1c416acf",
          "intuition" : "This approach works by using a 2D DP table to track the interleaving status of substrings.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The string s3 can be formed by interleaving s1 and s2.",
              "id" : "5931e20a-2b54-43b4-ac9d-6b8947b44269",
              "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The string s3 cannot be formed by interleaving s1 and s2.",
              "id" : "58180941-2d5a-4a62-8bc1-fdea11ca1849",
              "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "The string s3 can be formed by interleaving s1 and s2.",
              "id" : "b616abd7-c21c-41b6-968a-23648b937a2a",
              "input" : "s1 = \"a\", s2 = \"b\", s3 = \"ab\""
            }
          ]
        }
      ],
      "id" : "e8464d98-dcb2-47a4-b3d1-5ef3eff0690e",
      "lastUpdated" : "2026-02-06T21:06:18Z",
      "problemSlug" : "interleaving-string",
      "relatedProblems" : [
        "regular-expression-matching",
        "wildcard-matching"
      ],
      "summary" : "The Interleaving String problem is a dynamic programming problem where we need to check if a given string can be formed by interleaving two other strings. The key insight here is to use a 2D DP table to track the interleaving status of substrings."
    },
    {
      "approaches" : [
        {
          "approach" : "1. maxReach = 0\n2. For each index i:\n   - If i > maxReach: return false\n   - maxReach = max(maxReach, i + nums[i])\n3. Return true if loop completes",
          "code" : "func canJump(_ nums: [Int]) -> Bool {\n    var maxReach = 0\n    \n    for i in 0..<nums.count {\n        if i > maxReach { return false }\n        maxReach = max(maxReach, i + nums[i])\n    }\n    \n    return true\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "One variable",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "At each step, extend reach if possible. If we can't reach current position, we fail.",
          "id" : "550e8400-e29b-41d4-a716-446655440150",
          "intuition" : "Track farthest reachable position. If current index exceeds it, we're stuck.",
          "name" : "Greedy",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Jump 1->2->4 or 1->3->4",
              "id" : "550e8400-e29b-41d4-a716-446655440256",
              "input" : "[2,3,1,1,4]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440039",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "jump-game",
      "relatedProblems" : [
        "jump-game-ii"
      ],
      "summary" : "Can reach last index from first? Track maximum reachable index, update as you go."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Track currentEnd (boundary of current jump) and furthest reachable\n2. For each position, update furthest\n3. When i reaches currentEnd, increment jumps, update currentEnd to furthest\n4. Stop when currentEnd >= last index",
          "code" : "func jump(_ nums: [Int]) -> Int {\n    if nums.count <= 1 { return 0 }\n    \n    var jumps = 0\n    var currentEnd = 0\n    var furthest = 0\n    \n    for i in 0..<nums.count - 1 {\n        furthest = max(furthest, i + nums[i])\n        \n        if i == currentEnd {\n            jumps += 1\n            currentEnd = furthest\n            if currentEnd >= nums.count - 1 { break }\n        }\n    }\n    \n    return jumps\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only tracking three variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass through array"
          },
          "explanation" : "Think of it as BFS where each 'level' is positions reachable with the same number of jumps. currentEnd marks the boundary of current level. When we reach it, we've explored all positions at this level and must jump to next level (furthest becomes new boundary).",
          "id" : "2e990002-4fa0-4754-a659-614198403aee",
          "intuition" : "Track the furthest position reachable. When we reach current boundary, we must jump. Count jumps when boundary is reached.",
          "name" : "Greedy (BFS-like)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "Jump from 01 (can reach up to 4), then 14. Two jumps.",
              "id" : "d50605a9-c2cc-460f-8632-18d5f5de1d9f",
              "input" : "nums = [2,3,1,1,4]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Same: 014",
              "id" : "8046a1b0-aba6-44b2-afe2-c0eda02e20dd",
              "input" : "nums = [2,3,0,1,4]"
            }
          ]
        },
        {
          "approach" : "1. dp[0] = 0, dp[i] = infinity\n2. For each i, for each j reachable from i: dp[j] = min(dp[j], dp[i]+1)\n3. Return dp[n-1]",
          "code" : "func jump(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var dp = [Int](repeating: Int.max, count: n)\n    dp[0] = 0\n    \n    for i in 0..<n {\n        for j in i+1...min(i + nums[i], n - 1) {\n            dp[j] = min(dp[j], dp[i] + 1)\n        }\n    }\n    \n    return dp[n - 1]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "DP array of size n",
            "time" : "O(n)",
            "timeExplanation" : "For each position, potentially update many others"
          },
          "explanation" : "This is the straightforward DP approach. For each position, we update all positions we can jump to. Less efficient than greedy but easier to understand. Shows the greedy solution is optimal.",
          "id" : "4046a33a-693c-4542-a4ce-8efaf4285c4a",
          "intuition" : "dp[i] = minimum jumps to reach position i. For each position, update all reachable positions.",
          "name" : "DP (for comparison)",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "dp builds: [0,1,1,2,2]. Answer is 2.",
              "id" : "020240d7-acfd-4fee-b5ef-7171273966fe",
              "input" : "nums = [2,3,1,1,4]"
            }
          ]
        }
      ],
      "id" : "c1b34626-4b34-4c49-989a-8786f1b8271b",
      "lastUpdated" : "2026-02-06T00:53:56.092Z",
      "problemSlug" : "jump-game-ii",
      "relatedProblems" : [
        "jump-game",
        "jump-game-iii"
      ],
      "summary" : "Find minimum jumps to reach end of array where nums[i] is max jump length from i. Greedy: at each step, jump to position that lets you reach furthest."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with each number on the keypad as the initial state, and for each state, explore all possible moves and keep track of the visited states. Repeat this process for a specified number of steps.",
          "code" : "func knightDialer(_ N: Int) -> Int { \n let moves = [ \n    -1: [0, 0], \n    0: [4, 6], \n    1: [6, 8], \n    2: [7, 9], \n    3: [4, 8], \n    4: [0, 3, 9], \n    6: [0, 1, 7], \n    7: [2, 6], \n    8: [1, 3], \n    9: [2, 4] \n ]; \n  var count = 0; \n  for start in moves.keys { \n    var stack = [(start, N - 1)]; \n    var visited: Set<Int> = [] \n    while !stack.isEmpty { \n      let (node, step) = stack.removeLast() \n      if step == 0 { \n        count += 1 \n      } else { \n        for next in moves[node]! { \n          if !visited.contains(next) { \n            stack.append((next, step - 1)) \n          } \n        } \n      } \n    } \n  }; \n  return count; \n}",
          "complexity" : {
            "space" : "O(10^N)",
            "spaceExplanation" : "The space complexity is O(10^N) because we need to store all the visited states in the set.",
            "time" : "O(10^N)",
            "timeExplanation" : "The time complexity is O(10^N) because in the worst case, we might have to explore all possible moves for each state."
          },
          "explanation" : "We initialize a set to keep track of the visited states and a dictionary to store the mapping of the keypad numbers to their respective possible moves. Then we start a depth-first search from each number on the keypad. For each step, we generate all possible next states and add them to the visited set. We repeat this process for the specified number of steps.",
          "id" : "7ac161a5-a84a-4586-b7fb-eaf3a39598d5",
          "intuition" : "We can calculate the total number of distinct numbers by exploring all possible moves from each state and keeping track of the visited states.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "10",
              "explanation" : "There are 10 distinct numbers that can be dialed with one step.",
              "id" : "86ef577e-b55d-4a7a-8697-4c74e5d9006f",
              "input" : "N = 1"
            },
            {
              "expectedOutput" : "20",
              "explanation" : "There are 20 distinct numbers that can be dialed with two steps.",
              "id" : "1897a440-90b3-4384-9503-23ee24321657",
              "input" : "N = 2"
            }
          ]
        },
        {
          "approach" : "We create a 2D array dp where dp[i][j] represents the number of distinct numbers that can be dialed using the ith number on the keypad and j steps. We initialize the base case where j = 1, and then we fill up the rest of the table using the recurrence relation.",
          "code" : "func knightDialer(_ N: Int) -> Int { \n  let moves = [ \n    0: [4, 6], \n    1: [6, 8], \n    2: [7, 9], \n    3: [4, 8], \n    4: [0, 3, 9], \n    5: [], \n    6: [0, 1, 7], \n    7: [2, 6], \n    8: [1, 3], \n    9: [2, 4] \n  ]; \n  var dp = [Int](repeating: 1, count: 10) \n  if N == 1 { \n    return 10 \n  } \n  for _ in 2...N { \n    var temp = [Int](repeating: 0, count: 10) \n    for i in 0...9 { \n      for j in moves[i]! { \n        temp[i] += dp[j] \n      } \n    } \n    dp = temp \n  } \n  return dp.reduce(0, +) \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because the space required does not grow with the size of the input.",
            "time" : "O(N)",
            "timeExplanation" : "The time complexity is O(N) because we need to fill up the table for N steps."
          },
          "explanation" : "We initialize the base case where j = 1, and then we fill up the rest of the table using the recurrence relation. For each cell dp[i][j], we calculate the number of distinct numbers that can be dialed using the ith number on the keypad and j steps by summing up the number of distinct numbers that can be dialed using the ith number on the keypad and (j - 1) steps and moving to the next possible numbers.",
          "id" : "559b09ae-012e-454d-9e74-2fd676a52daf",
          "intuition" : "We can use dynamic programming to calculate the total number of distinct numbers by building up the solution from smaller sub-problems.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "10",
              "explanation" : "There are 10 distinct numbers that can be dialed with one step.",
              "id" : "13fa74d5-edf1-4b43-b99c-d6fe1aa18191",
              "input" : "N = 1"
            },
            {
              "expectedOutput" : "46",
              "explanation" : "There are 46 distinct numbers that can be dialed with three steps.",
              "id" : "0315ee70-4379-48f4-aaa7-df3370bc1a66",
              "input" : "N = 3"
            }
          ]
        }
      ],
      "id" : "8b8826df-759e-4191-bce8-989d9833da10",
      "lastUpdated" : "2026-02-06T21:49:50Z",
      "problemSlug" : "knight-dialer",
      "relatedProblems" : [
        "unique-paths",
        "climb-stairs"
      ],
      "summary" : "The problem is to calculate the total number of distinct numbers that can be dialed using a knight on a phone keypad, where the knight moves in an L-shape. The key insight is that this is a dynamic programming problem where each state is dependent on previous states."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Start at the given position of the knight. 2. For each possible move, calculate the probability of the knight staying on the board. 3. Repeat step 2 for the given number of moves. 4. Calculate the final probability of the knight staying on the board.",
          "code" : "\n           class Solution {\n               func knightProbability(_ n: Int, _ k: Int, _ row: Int, _ column: Int) -> Double {\n                   var dp: [[[Double]]] = Array.init(repeating: Array.init(repeating: Array.init(repeating: -1.0, count: k + 1), count: n), count: n)\n                   return dfs(n, k, row, column, &dp)\n               }\n               \n               func dfs(_ n: Int, _ k: Int, _ row: Int, _ column: Int, _ dp: inout [[[Double]]]) -> Double {\n                   if row < 0 || row >= n || column < 0 || column >= n {\n                       return 0.0\n                   }\n                   if k == 0 {\n                       return 1.0\n                   }\n                   if dp[row][column][k] != -1.0 {\n                       return dp[row][column][k]\n                   }\n                   let dirs: [[Int]] = [[-2, -1], [-1, -2], [1, -2], [2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1]]\n                   var res: Double = 0.0\n                   for dir in dirs {\n                       res += dfs(n, k - 1, row + dir[0], column + dir[1], &dp) \/ 8.0\n                   }\n                   dp[row][column][k] = res\n                   return res\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n^2 * k)",
            "spaceExplanation" : "The space complexity is O(n^2 * k) because we are storing the probabilities of the knight being at each position on the board after each move.",
            "time" : "O(n^2 * k)",
            "timeExplanation" : "The time complexity is O(n^2 * k) because we are simulating all possible moves of the knight for k moves on an n x n board."
          },
          "explanation" : "The brute force approach is straightforward but inefficient. It involves simulating all possible moves of the knight and calculating the probability of the knight staying on the board after each move. This approach is not practical for large inputs because it has a high time complexity.",
          "id" : "ceaea904-44e8-4de7-89bf-6ee17be93c5c",
          "intuition" : "This approach works by simulating all possible moves of the knight and calculating the probability of the knight staying on the board after each move.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "0.0625",
              "explanation" : "The knight can move to (1, 2), (2, 1), (1, -1), or (-1, 1) with equal probability. From these positions, the knight can move to a total of 8 positions on the board.",
              "id" : "c932244d-7628-4184-9d25-9af21b40a7e7",
              "input" : "n = 3, k = 2, row = 0, column = 0"
            },
            {
              "expectedOutput" : "0.0",
              "explanation" : "The knight can move to (1, 2), (2, 1), (1, -1), or (-1, 1) with equal probability, but all of these positions are on the board, so the probability of staying on the board is 0.0.",
              "id" : "06050ec6-01bc-49a8-ab3b-87e4267beac9",
              "input" : "n = 3, k = 1, row = 0, column = 0"
            }
          ]
        },
        {
          "approach" : "1. Initialize a 2D array to store the probabilities of the knight being at each position on the board. 2. For each move, iterate over all possible positions on the board and update the probabilities of the knight being at each position based on the probabilities of the knight being at the previous positions. 3. Repeat step 2 for the given number of moves.",
          "code" : "\n           class Solution {\n               func knightProbability(_ n: Int, _ k: Int, _ row: Int, _ column: Int) -> Double {\n                   var dp: [[[Double]]] = Array.init(repeating: Array.init(repeating: Array.init(repeating: 0.0, count: k + 1), count: n), count: n)\n                   let dirs: [[Int]] = [[-2, -1], [-1, -2], [1, -2], [2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1]]\n                   dp[row][column][0] = 1.0\n                   for i in 1...k {\n                       for r in 0..<n {\n                           for c in 0..<n {\n                               if dp[r][c][i - 1] != 0.0 {\n                                   for dir in dirs {\n                                       let nr: Int = r + dir[0]\n                                       let nc: Int = c + dir[1]\n                                       if nr >= 0 && nr < n && nc >= 0 && nc < n {\n                                           dp[nr][nc][i] += dp[r][c][i - 1] \/ 8.0\n                                       }\n                                   }\n                               }\n                           }\n                       }\n                   }\n                   return dp[row][column][k]\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n^2 * k)",
            "spaceExplanation" : "The space complexity is O(n^2 * k) because we are storing the probabilities of the knight being at each position on the board after each move.",
            "time" : "O(n^2 * k)",
            "timeExplanation" : "The time complexity is O(n^2 * k) because we are iterating over all positions on the board for k moves."
          },
          "explanation" : "The optimized approach is more efficient than the brute force approach because it only considers the positions that are reachable from the current position, and it uses dynamic programming to avoid redundant calculations.",
          "id" : "c34ca35a-2562-4888-97b3-c0280c355094",
          "intuition" : "This approach works by using dynamic programming to track the probability of the knight being at each position on the board after each move, and only considering the positions that are reachable from the current position.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "0.0625",
              "explanation" : "The knight can move to (1, 2), (2, 1), (1, -1), or (-1, 1) with equal probability. From these positions, the knight can move to a total of 8 positions on the board.",
              "id" : "968e47e4-862d-412d-a6d7-36fab8965170",
              "input" : "n = 3, k = 2, row = 0, column = 0"
            },
            {
              "expectedOutput" : "1.0",
              "explanation" : "The knight is already at the destination position, so the probability of staying on the board is 1.0.",
              "id" : "2633388c-6ff8-49e5-9772-a8aab30634fd",
              "input" : "n = 1, k = 0, row = 0, column = 0"
            }
          ]
        }
      ],
      "id" : "149b0f61-17b9-45a5-a9d2-347a69c91db7",
      "lastUpdated" : "2026-02-06T21:34:04Z",
      "problemSlug" : "knight-probability-in-chessboard",
      "relatedProblems" : [
        "unique-paths",
        "longest-common-subsequence"
      ],
      "summary" : "This problem involves calculating the probability of a knight staying on a chessboard after a certain number of moves. The key insight is to use dynamic programming to track the probability of the knight being at each position on the board after each move."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over each cell in the matrix. 2. For each cell, check all possible sizes of plus signs that can be formed. 3. Keep track of the maximum size of plus sign found so far.",
          "code" : "func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the mines in a set.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is O(n^3) because we are iterating over each cell in the matrix and for each cell, we are checking all possible sizes of plus signs."
          },
          "explanation" : "The brute force approach is not efficient because it has to check all possible sizes of plus signs at each position, resulting in a high time complexity.",
          "id" : "3caf918f-05ea-4a52-a243-31e4bafe3de4",
          "intuition" : "This approach works by checking every possible size of plus sign at each position in the matrix. It iterates over each cell in the matrix and for each cell, it checks all possible sizes of plus signs that can be formed.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The largest plus sign that can be formed has a size of 2.",
              "id" : "8f065df6-8112-439a-b971-4118de5ac0d6",
              "input" : "n = 5, mines = [4]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The largest plus sign that can be formed has a size of 1.",
              "id" : "70dec7f6-6146-4852-8c39-acb444dc8c25",
              "input" : "n = 1, mines = []"
            }
          ]
        },
        {
          "approach" : "1. Initialize four arrays to keep track of the number of consecutive 1s in the four directions from each cell. 2. Iterate over the matrix and update the four arrays. 3. Use the four arrays to calculate the maximum size of the plus sign that can be formed at each position.",
          "code" : "func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; var up = Array(repeating: 0, count: n*n); var down = Array(repeating: 0, count: n*n); var left = Array(repeating: 0, count: n*n); var right = Array(repeating: 0, count: n*n); for i in 0..<n { for j in 0..<n { if !set.contains(i*n+j) { up[i*n+j] = (i == 0 ? 0 : up[(i-1)*n+j]) + 1; left[i*n+j] = (j == 0 ? 0 : left[i*n+j-1]) + 1 } } }; for i in stride(from: n-1, to: -1, by: -1) { for j in stride(from: n-1, to: -1, by: -1) { if !set.contains(i*n+j) { down[i*n+j] = (i == n-1 ? 0 : down[(i+1)*n+j]) + 1; right[i*n+j] = (j == n-1 ? 0 : right[i*n+j+1]) + 1 } } }; for i in 0..<n { for j in 0..<n { if !set.contains(i*n+j) { res = max(res, min(min(up[i*n+j], down[i*n+j]), min(left[i*n+j], right[i*n+j]))) } } }; return res }",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is O(n^2) because we are using four arrays to keep track of the number of consecutive 1s in the four directions.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are iterating over the matrix twice."
          },
          "explanation" : "The optimized approach is more efficient because it only needs to iterate over the matrix once and uses the four arrays to keep track of the number of consecutive 1s in the four directions.",
          "id" : "9c447128-1a54-4c7d-9f49-a82f4103ab13",
          "intuition" : "This approach works by using four arrays to keep track of the number of consecutive 1s in the four directions (up, down, left, right) from each cell. We then use these arrays to calculate the maximum size of the plus sign that can be formed at each position.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The largest plus sign that can be formed has a size of 2.",
              "id" : "01bcfa1e-28d1-4239-924b-c94319aabf4c",
              "input" : "n = 5, mines = [4]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The largest plus sign that can be formed has a size of 1.",
              "id" : "ed0df0be-68fc-45f1-99ca-9a0e1626f766",
              "input" : "n = 1, mines = []"
            }
          ]
        }
      ],
      "id" : "2edc7efb-b211-4faa-aff4-0ed12d27dfc1",
      "lastUpdated" : "2026-02-06T21:38:42Z",
      "problemSlug" : "largest-plus-sign",
      "relatedProblems" : [
        "max-increase-to-fit",
        "number-of-rectangles"
      ],
      "summary" : "This problem involves finding the largest size of a plus sign that can be formed using 1s in a binary matrix. The key insight is to iterate through the matrix and keep track of the maximum size of the plus sign that can be formed at each position."
    },
    {
      "approaches" : [
        {
          "approach" : "To implement this, we start by trying all possible partition points in the array, then for each partition point, we calculate the sum of averages and keep track of the maximum sum found.",
          "code" : "class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the maximum sum and other variables.",
            "time" : "O(n^k)",
            "timeExplanation" : "We are generating all possible partitions of the array which has a time complexity of O(n^k)."
          },
          "explanation" : "We start by generating all possible partitions of the array and then calculate the sum of averages for each partition. We keep track of the maximum sum found so far and update it whenever we find a partition with a larger sum.",
          "id" : "f3d2e91f-8619-4ab3-8cd2-2efe362f6f36",
          "intuition" : "This approach involves trying all possible partitions of the array and calculating the sum of averages for each partition.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "20.0",
              "explanation" : "We can partition the array into [9], [1,2,3], [9] to get a sum of averages as 9 + (1+2+3)\/3 + 9 = 20.",
              "id" : "fc8581e5-b7ab-417f-9912-cdb77492342c",
              "input" : "nums = [9,1,2,3,9], k = 3"
            },
            {
              "expectedOutput" : "18.0",
              "explanation" : "We can partition the array into [1], [2], [3,4], [5,6,7] to get a sum of averages as 1 + 2 + (3+4)\/2 + (5+6+7)\/3 = 18.",
              "id" : "912d6629-2224-4690-aa4b-aec88e65973c",
              "input" : "nums = [1,2,3,4,5,6,7], k = 4"
            }
          ]
        },
        {
          "approach" : "To implement this, we use a 2D table dp where dp[i][j] stores the largest sum of averages that can be obtained by partitioning the first i elements of the array into j partitions.",
          "code" : "class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }",
          "complexity" : {
            "space" : "O(n * k)",
            "spaceExplanation" : "We are using a 2D table of size n*k to store the dp values which has a space complexity of O(n * k).",
            "time" : "O(n^2 * k)",
            "timeExplanation" : "We are using two nested loops to fill up the dp table which has a time complexity of O(n^2 * k)."
          },
          "explanation" : "We start by initializing the dp table and then filling it up in a bottom-up manner. We calculate dp[i][j] by trying all possible previous partition points and keeping track of the maximum sum of averages.",
          "id" : "97fdc870-bc52-4431-8a0e-d2f3e95717d4",
          "intuition" : "This approach involves using dynamic programming to store and reuse the results of subproblems to efficiently calculate the largest sum of averages.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "20.0",
              "explanation" : "We can partition the array into [9], [1,2,3], [9] to get a sum of averages as 9 + (1+2+3)\/3 + 9 = 20.",
              "id" : "b2124373-2fe5-4800-9252-e8cba60e8f98",
              "input" : "nums = [9,1,2,3,9], k = 3"
            },
            {
              "expectedOutput" : "18.166666666666668",
              "explanation" : "We can partition the array into [1], [2], [3,4], [5,6,7] to get a sum of averages as 1 + 2 + (3+4)\/2 + (5+6+7)\/3 = 18.166666666666668.",
              "id" : "2cabd856-5ef8-4c0d-9518-a493ac0fd3aa",
              "input" : "nums = [1,2,3,4,5,6,7], k = 4"
            }
          ]
        }
      ],
      "id" : "9241befe-dbfc-4be4-8f92-a9e8518bc840",
      "lastUpdated" : "2026-02-06T21:41:30Z",
      "problemSlug" : "largest-sum-of-averages",
      "relatedProblems" : [
        "partition-equal-subset-sum",
        "minimum-size-subarray-sum"
      ],
      "summary" : "The problem involves finding the largest sum of averages that can be obtained by partitioning the given array. Key insight is to use dynamic programming to store and reuse the results of subproblems."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsequences, then check each subsequence to see if it is a Fibonacci sequence by comparing each element to the sum of the two preceding ones.",
          "code" : "func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space used does not grow with the size of the input array, making it constant.",
            "time" : "O(n^3)",
            "timeExplanation" : "There are two nested loops to generate all pairs of starting numbers for potential Fibonacci sequences, and for each pair, we potentially scan the entire array to find the next number in the sequence."
          },
          "explanation" : "Start with an empty subsequence and iteratively add elements from the array, checking at each step if the new element can be part of a Fibonacci sequence with the elements already in the subsequence.",
          "id" : "a1b7cf02-475b-4517-a3cb-b6d4379267e1",
          "intuition" : "This approach works by generating all possible subsequences of the given array and checking each one to see if it forms a Fibonacci sequence.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "The longest Fibonacci subsequence is [1,1,2,3,5,8].",
              "id" : "54d1af8b-decc-4dc7-9d41-fd598e6cfdf6",
              "input" : "nums = [1,2,3,5,8,13]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The longest Fibonacci subsequence is [1,11,12].",
              "id" : "41c661cb-671a-49cb-9b03-67a362d39587",
              "input" : "nums = [1,3,7,11,12,14,18]"
            }
          ]
        },
        {
          "approach" : "Create a set from the array for O(1) lookups, then for each pair of numbers in the array, generate the Fibonacci sequence starting with these two numbers and check how many numbers from this sequence are present in the set.",
          "code" : "func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store all elements of the array in a set, hence the space complexity is linear with respect to the input size.",
            "time" : "O(n^2 * m)",
            "timeExplanation" : "The outer two loops run over the array, and for each pair, we potentially generate a sequence of up to the length of the array, hence n^2 * m where m is the average length of the generated sequences."
          },
          "explanation" : "Start by converting the input array into a set for efficient lookups. Then, for each pair of distinct numbers in the array, treat them as the first two numbers of a potential Fibonacci sequence and generate the sequence, checking each new number against the set.",
          "id" : "a9d963e8-e015-4143-83e9-c34658d3b27b",
          "intuition" : "This approach works by utilizing a hash set to store the elements of the array and then checking for the existence of potential next numbers in the Fibonacci sequence, significantly reducing the time complexity.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "The longest Fibonacci subsequence is [1,1,2,3,5,8].",
              "id" : "03407865-b327-44a5-8372-ab58dc3a00f5",
              "input" : "nums = [1,2,3,5,8,13]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The longest Fibonacci subsequence is [1,11,12].",
              "id" : "e68b67ab-0e76-449e-8c1a-8c8ab89acc90",
              "input" : "nums = [1,3,7,11,12,14,18]"
            }
          ]
        }
      ],
      "id" : "7704bb9c-ba4a-4d7a-ab54-f399f442a45a",
      "lastUpdated" : "2026-02-06T21:45:48Z",
      "problemSlug" : "length-of-longest-fibonacci-subsequence",
      "relatedProblems" : [
        "longest-increasing-subsequence",
        "increasing-subsequences"
      ],
      "summary" : "The problem asks to find the length of the longest subsequence of the array that forms a Fibonacci sequence, key insight involves identifying Fibonacci subsequences within the given array."
    },
    {
      "approaches" : [
        {
          "approach" : "1. If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n2. Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n3. Return dp[m][n]",
          "code" : "func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n    let s1 = Array(text1), s2 = Array(text2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1] + 1\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "2D DP array (can optimize to O(n))",
            "time" : "O(m*n)",
            "timeExplanation" : "Fill m*n table"
          },
          "explanation" : "Match extends previous LCS. No match means we must skip one character.",
          "id" : "550e8400-e29b-41d4-a716-446655440160",
          "intuition" : "dp[i][j] = LCS of text1[0..i-1] and text2[0..j-1]. If match, extend; else take max.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "LCS is \"ace\"",
              "id" : "550e8400-e29b-41d4-a716-446655440266",
              "input" : "text1 = \"abcde\", text2 = \"ace\""
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440049",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "longest-common-subsequence",
      "relatedProblems" : [
        "edit-distance",
        "longest-palindromic-subsequence"
      ],
      "summary" : "LCS of two strings. DP: if chars match, 1 + LCS of rest; else max of skipping either."
    },
    {
      "approaches" : [
        {
          "approach" : "1. tails[i] = smallest ending element of LIS of length i+1\n2. For each num: binary search for position in tails\n3. Replace or extend tails array\n4. Return tails.count",
          "code" : "func lengthOfLIS(_ nums: [Int]) -> Int {\n    var tails: [Int] = []\n    \n    for num in nums {\n        var left = 0, right = tails.count\n        while left < right {\n            let mid = (left + right) \/ 2\n            if tails[mid] < num {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n        if left == tails.count {\n            tails.append(num)\n        } else {\n            tails[left] = num\n        }\n    }\n    \n    return tails.count\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "tails array",
            "time" : "O(n log n)",
            "timeExplanation" : "n elements, O(log n) binary search each"
          },
          "explanation" : "tails is always sorted. We find where num fits and either replace (better ending) or extend.",
          "id" : "550e8400-e29b-41d4-a716-446655440146",
          "intuition" : "Maintain array of smallest tail for each length. Binary search for position to update.",
          "name" : "Binary Search (Patience Sort)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "[2,3,7,101] or [2,3,7,18]",
              "id" : "550e8400-e29b-41d4-a716-446655440252",
              "input" : "[10,9,2,5,3,7,101,18]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440035",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "longest-increasing-subsequence",
      "relatedProblems" : [
        "number-of-longest-increasing-subsequence",
        "increasing-triplet-subsequence"
      ],
      "summary" : "Find length of LIS. DP O(n) or binary search O(n log n) with patience sorting."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsequences of the input string and check if each is a palindrome. Keep track of the longest palindromic subsequence encountered.",
          "code" : "\n       func longestPalindromeSubseq(_ s: String) -> Int {\n         func isPalindrome(_ sub: String) -> Bool {\n           var left = 0\n           var right = sub.count - 1\n           while left < right {\n             if sub[sub.index(sub.startIndex, offsetBy: left)] != sub[sub.index(sub.startIndex, offsetBy: right)] {\n               return false\n             }\n             left += 1\n             right -= 1\n           }\n           return true\n         }\n\n         var maxLength = 0\n         for i in 0..<s.count {\n           for j in i..<s.count {\n             let sub = String(s[s.index(s.startIndex, offsetBy: i)...s.index(s.startIndex, offsetBy: j)])\n             if isPalindrome(sub) {\n               maxLength = max(maxLength, sub.count)\n             }\n           }\n         }\n         return maxLength\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because, although we generate many subsequences, we do not need to store them all simultaneously.",
            "time" : "O(2^n * n)",
            "timeExplanation" : "The time complexity arises from generating all possible subsequences (2^n) and checking each for being a palindrome, which takes O(n) time."
          },
          "explanation" : "This approach works by exhaustively exploring all possible subsequences, but it is inefficient due to the large number of subsequences and the repeated computation involved in checking for palindromes.",
          "id" : "03afbc1d-6237-4af1-8c22-02aad63812de",
          "intuition" : "This approach involves checking every possible subsequence to determine if it is a palindrome, and then selecting the longest palindromic subsequence found.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The longest palindromic subsequence is \"bbbb\".",
              "id" : "f06be564-a93a-4ae6-b4bf-34c45ec94899",
              "input" : "s = \"bbbab\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The longest palindromic subsequence is \"bb\".",
              "id" : "65442d61-f8a3-44e8-95fb-33e1e719e234",
              "input" : "s = \"cbbd\""
            }
          ]
        },
        {
          "approach" : "Create a 2D table where each cell [i][j] represents the length of the longest palindromic subsequence within the subarray from i to j. Fill the table in a bottom-up manner, considering all possible subsequences and using previously computed values to avoid redundant computation.",
          "code" : "\n       func longestPalindromeSubseq(_ s: String) -> Int {\n         let n = s.count\n         var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n\n         for i in stride(from: n-1, through: 0, by: -1) {\n           dp[i][i] = 1\n           for j in i+1..<n {\n             if s[s.index(s.startIndex, offsetBy: i)] == s[s.index(s.startIndex, offsetBy: j)] {\n               dp[i][j] = dp[i+1][j-1] + 2\n             } else {\n               dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n             }\n           }\n         }\n         return dp[0][n-1]\n       }\n       ",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is also O(n^2) due to the storage needed for the 2D table.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity comes from filling up the 2D table of size n x n."
          },
          "explanation" : "This approach efficiently solves the problem by breaking it down into smaller subproblems and storing the results in a table for easy lookup, thus avoiding the need to recomputed the same subproblems multiple times.",
          "id" : "206d5209-1070-46eb-a540-203a0a669a23",
          "intuition" : "This approach involves using dynamic programming to efficiently store and retrieve the lengths of palindromic subsequences as they are computed, avoiding redundant computation.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The longest palindromic subsequence is \"bbbb\".",
              "id" : "7e4eafd2-650b-4df3-9abe-0ad4196c8423",
              "input" : "s = \"bbbab\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The longest palindromic subsequence is \"bb\".",
              "id" : "835d9c3d-e8fe-439c-9852-4e000c22a766",
              "input" : "s = \"cbbd\""
            }
          ]
        }
      ],
      "id" : "2d459c28-e236-4ffa-9ed3-bc199d23a483",
      "lastUpdated" : "2026-02-06T21:23:35Z",
      "problemSlug" : "longest-palindromic-subsequence",
      "relatedProblems" : [
        "longest-palindromic-substring",
        "partition-equal-subset-sum"
      ],
      "summary" : "This problem involves finding the longest palindromic subsequence within a given string, with the key insight being the use of dynamic programming to store and reuse overlapping subproblems. The solution can be approached through either a brute-force method or an optimized dynamic programming approach."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays, then for each subarray check if it is turbulent. If it is, update the maximum length if necessary.",
          "code" : "\nfunc maxTurbulenceSize(_ arr: [Int]) -> Int {\n    let n = arr.count\n    var res = 1\n    for i in 0..<n {\n        var up = 1\n        var down = 1\n        for j in i+1..<n {\n            if arr[j] > arr[j-1] {\n                up += 1\n                down = 1\n            } else if arr[j] < arr[j-1] {\n                down += 1\n                up = 1\n            } else {\n                break\n            }\n        }\n        res = max(res, up)\n        res = max(res, down)\n    }\n    return res\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the maximum length and other variables.",
            "time" : "O(n^2)",
            "timeExplanation" : "For each element in the array, we potentially check all subsequent elements, resulting in quadratic time."
          },
          "explanation" : "To check if a subarray is turbulent, we can compare the difference between each pair of consecutive elements. If the differences are all either strictly positive or strictly negative, the subarray is turbulent.",
          "id" : "bc347ffa-0e8b-47b7-be0c-79a733dfd9e8",
          "intuition" : "Check every possible subarray and determine whether it is turbulent or not. Keep track of the longest one found so far.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The longest turbulent subarray is [9,4,2,10,7] or [8,1,9].",
              "id" : "0dbcbf43-0611-49fc-8b13-eb17cc39f0c7",
              "input" : "arr = [9,4,2,10,7,8,8,1,9]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The array contains no turbulent subarrays of length greater than one.",
              "id" : "c54ec761-bf03-4c5b-9f32-711dde365309",
              "input" : "arr = [4,8,12,16]"
            }
          ]
        },
        {
          "approach" : "Use dynamic programming to update the lengths of the turbulent subarrays ending at each position, based on the trend of the subarray.",
          "code" : "\nfunc maxTurbulenceSize(_ arr: [Int]) -> Int {\n    if arr.count == 1 {\n        return 1\n    }\n    var up = 1\n    var down = 1\n    var res = 1\n    for i in 1..<arr.count {\n        if arr[i] > arr[i - 1] {\n            up = down + 1\n            down = 1\n        } else if arr[i] < arr[i - 1] {\n            down = up + 1\n            up = 1\n        } else {\n            up = 1\n            down = 1\n        }\n        res = max(res, max(up, down))\n    }\n    return res\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the lengths of the turbulent subarrays and other variables.",
            "time" : "O(n)",
            "timeExplanation" : "We make a single pass through the array, resulting in linear time."
          },
          "explanation" : "We maintain two arrays, up and down, where up[i] and down[i] store the length of the turbulent subarray ending at index i with the last difference being positive or negative, respectively.",
          "id" : "700018c2-a773-4f16-8e4d-4b7a6de57659",
          "intuition" : "Keep track of the length of the turbulent subarray ending at each position, with either an up or down trend.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The longest turbulent subarray is [9,4,2,10,7] or [8,1,9].",
              "id" : "36cb4bcf-db60-497a-b99a-e16d6fc85540",
              "input" : "arr = [9,4,2,10,7,8,8,1,9]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The array contains no turbulent subarrays of length greater than one.",
              "id" : "5f2932d2-9dfe-42aa-8f78-700c1064f52a",
              "input" : "arr = [4,8,12,16]"
            }
          ]
        }
      ],
      "id" : "58cbc07f-69b6-4f64-a995-db94e47b5ee0",
      "lastUpdated" : "2026-02-06T21:52:42Z",
      "problemSlug" : "longest-turbulent-subarray",
      "relatedProblems" : [
        "longest-increasing-subsequence",
        "shortest-subarray-with-sum-at-least-k"
      ],
      "summary" : "The problem asks to find the length of the longest turbulent subarray in a given array. A turbulent subarray is one where the difference between consecutive elements is either strictly increasing or strictly decreasing."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of the matchsticks and assign them to four sides, checking if the total length of each side is the same.",
          "code" : "func makesquare(matchsticks: [Int]) -> Bool {\n    let total = matchsticks.reduce(0, +)\n    if total % 4 != 0 {\n        return false\n    }\n    let side = total \/ 4\n    var used = Array(repeating: false, count: matchsticks.count)\n    var sides = Array(repeating: 0, count: 4)\n    func dfs(_ index: Int) -> Bool {\n        if index == matchsticks.count {\n            return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3]\n        }\n        for i in 0..<4 {\n            if sides[i] + matchsticks[index] <= side {\n                sides[i] += matchsticks[index]\n                used[index] = true\n                if dfs(index + 1) {\n                    return true\n                }\n                sides[i] -= matchsticks[index]\n                used[index] = false\n            }\n        }\n        return false\n    }\n    return dfs(0)\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear due to the recursion stack and the used array.",
            "time" : "O(4^n)",
            "timeExplanation" : "The time complexity is exponential due to generating all permutations of the matchsticks."
          },
          "explanation" : "The brute force approach tries all possible combinations of matchsticks and checks if they can form a square. However, this approach can be very slow for large inputs due to its exponential time complexity.",
          "id" : "026c0eb7-c9f7-4481-a8d4-507a61a6a564",
          "intuition" : "This approach involves trying all possible combinations of matchsticks to form four sides of a square, and checking if the total length of each side is the same.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The matchsticks can be arranged to form a square with each side having a length of 5.",
              "id" : "31fb8061-70b5-4d32-99c8-2bdf58495c7e",
              "input" : "matchsticks = [1,1,1,1,1,1,1,1,1,1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The matchsticks cannot be arranged to form a square with each side having the same length.",
              "id" : "d5b5f877-69f0-4678-9ea3-24ef5d0d592f",
              "input" : "matchsticks = [3,3,3,3,4]"
            }
          ]
        },
        {
          "approach" : "Use a bitmask to represent the state of the matchsticks and store the intermediate results in a hashmap.",
          "code" : "func makesquare(matchsticks: [Int]) -> Bool {\n    let total = matchsticks.reduce(0, +)\n    if total % 4 != 0 {\n        return false\n    }\n    let side = total \/ 4\n    var dp = [Int: Bool]()\n    var used = Array(repeating: false, count: matchsticks.count)\n    func dfs(_ index: Int, _ mask: Int) -> Bool {\n        if index == matchsticks.count {\n            return true\n        }\n        if let result = dp[mask] {\n            return result\n        }\n        for i in 0..<4 {\n            if !used[i] && sides[i] + matchsticks[index] <= side {\n                used[i] = true\n                sides[i] += matchsticks[index]\n                if dfs(index + 1, mask | (1 << i)) {\n                    dp[mask] = true\n                    return true\n                }\n                used[i] = false\n                sides[i] -= matchsticks[index]\n            }\n        }\n        dp[mask] = false\n        return false\n    }\n    var sides = Array(repeating: 0, count: 4)\n    return dfs(0, 0)\n}",
          "complexity" : {
            "space" : "O(n * 2^n)",
            "spaceExplanation" : "The space complexity is increased due to the use of the hashmap to store the intermediate results.",
            "time" : "O(n * 2^n)",
            "timeExplanation" : "The time complexity is improved due to the use of dynamic programming."
          },
          "explanation" : "The optimized approach uses dynamic programming to store the intermediate results and avoid redundant calculations, resulting in a significant improvement in performance compared to the brute force approach.",
          "id" : "c7c913b3-a475-449a-abf7-cd04f5d722f4",
          "intuition" : "This approach involves using dynamic programming to store the intermediate results and avoid redundant calculations.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The matchsticks can be arranged to form a square with each side having a length of 5.",
              "id" : "c5c793f9-3714-429f-ac35-03a4f8d2fc13",
              "input" : "matchsticks = [1,1,1,1,1,1,1,1,1,1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The matchsticks cannot be arranged to form a square with each side having the same length.",
              "id" : "0db03115-e615-400f-b5b0-e3136fb5257f",
              "input" : "matchsticks = [3,3,3,3,4]"
            }
          ]
        }
      ],
      "id" : "976c4eee-b6bc-4709-bc70-1f4ed04db118",
      "lastUpdated" : "2026-02-06T21:21:00Z",
      "problemSlug" : "matchsticks-to-square",
      "relatedProblems" : [
        "partition-equal-subset-sum",
        "subset-sum"
      ],
      "summary" : "The problem involves determining whether it is possible to form a square using a given set of matchsticks, with the key insight being that forming a square requires each side to have the same total length. This can be achieved by exploring all possible combinations of matchsticks and checking if they can form a square."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with a cell and try to expand the square. Use a helper function to check if it is possible to expand the square.",
          "code" : "\n         class Solution {\n            func maximalSquare(_ matrix: [[Character]]) -> Int {\n               if matrix.isEmpty || matrix[0].isEmpty {\n                  return 0\n               }\n               let rows = matrix.count\n               let cols = matrix[0].count\n               var maxSide = 0\n               for i in 0..<rows {\n                  for j in 0..<cols {\n                     if matrix[i][j] == \"1\" {\n                        let side = findSquare(matrix, i, j)\n                        maxSide = max(maxSide, side)\n                     }\n                  }\n               }\n               return maxSide * maxSide\n            }\n            \n            func findSquare(_ matrix: [[Character]], _ i: Int, _ j: Int) -> Int {\n               let rows = matrix.count\n               let cols = matrix[0].count\n               var side = 1\n               while i + side <= rows && j + side <= cols {\n                  for x in i...i + side {\n                     for y in j...j + side {\n                        if matrix[x][y] != \"1\" {\n                           return side\n                        }\n                     }\n                  }\n                  side += 1\n               }\n               return side\n            }\n         }\n         ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store our variables.",
            "time" : "O(n^3*m^3)",
            "timeExplanation" : "For each cell in the matrix, we potentially expand a square up to the size of the matrix."
          },
          "explanation" : "The brute force solution checks all possible squares centered at each cell and keeps track of the maximum area. However, it has high complexity because for each cell, we are potentially checking the same subproblems multiple times.",
          "id" : "c5262451-ee19-4d05-82f2-c28ab4178ae8",
          "intuition" : "The brute force approach works by iterating through each cell in the matrix and expanding a square outward from that cell until it encounters a zero or reaches the edge of the matrix.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The largest square of 1's has a side length of 2, so the area is 4.",
              "id" : "fd0caaa0-f3f1-431b-ae0d-060aaf600fa1",
              "input" : "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is no square, so the area is 0.",
              "id" : "916a725f-266b-4960-b1c1-2fd8edc32a0f",
              "input" : "matrix = [[\"0\"],[\"0\"]]"
            }
          ]
        },
        {
          "approach" : "Create a 2D array dp of the same size as the input matrix. Initialize the first row and first column of dp based on the corresponding values in the input matrix.",
          "code" : "\n         class Solution {\n            func maximalSquare(_ matrix: [[Character]]) -> Int {\n               if matrix.isEmpty || matrix[0].isEmpty {\n                  return 0\n               }\n               let rows = matrix.count\n               let cols = matrix[0].count\n               var dp = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n               var maxSide = 0\n               for i in 0..<rows {\n                  for j in 0..<cols {\n                     if i == 0 || j == 0 {\n                        dp[i][j] = matrix[i][j] == \"1\" ? 1 : 0\n                     } else if matrix[i][j] == \"1\" {\n                        dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1\n                     }\n                     maxSide = max(maxSide, dp[i][j])\n                  }\n               }\n               return maxSide * maxSide\n            }\n         }\n         ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We need to store the dp array, which has the same size as the input matrix.",
            "time" : "O(n*m)",
            "timeExplanation" : "We only need to iterate through the matrix once."
          },
          "explanation" : "We then fill up the rest of the dp array. The value at dp[i][j] is the minimum of the values at dp[i-1][j], dp[i][j-1], and dp[i-1][j-1], plus one. We keep track of the maximum value we've seen so far in the dp array.",
          "id" : "65659eab-3ec7-4077-8dc3-d4b487ac78fd",
          "intuition" : "The dynamic programming approach works by building up a table where each cell contains the size of the largest square ending at that cell.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The largest square of 1's has a side length of 2, so the area is 4.",
              "id" : "52ee34cf-75e9-4748-8007-c5cc486c896d",
              "input" : "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is no square, so the area is 0.",
              "id" : "bbd2acb5-66dc-4e43-a7b4-be2a226bb025",
              "input" : "matrix = [[\"0\"],[\"0\"]]"
            }
          ]
        }
      ],
      "id" : "0ac0e340-cfc7-48a1-8901-ce5b67bda3ce",
      "lastUpdated" : "2026-02-06T21:10:40Z",
      "problemSlug" : "maximal-square",
      "relatedProblems" : [
        "longest-common-subsequence",
        "unique-paths"
      ],
      "summary" : "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all ones and return the area of the square. A key insight is that each cell can be the bottom-right cell of a square with side length equal to the minimum of the cell above, to the left, and to the top-left plus one."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of the given pairs, and for each permutation, check if the pairs can form a valid chain. If they can, update the maximum length of the chain.",
          "code" : "func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the permutations.",
            "time" : "O(n!)",
            "timeExplanation" : "The time complexity is O(n!) because we generate all permutations of the given pairs."
          },
          "explanation" : "We start by generating all permutations of the given pairs. Then, for each permutation, we check if the pairs can form a valid chain by ensuring that the end of each pair is less than or equal to the start of the next pair. If a valid chain is found, we update the maximum length of the chain.",
          "id" : "06ea2976-f645-4954-b375-b3934e77c466",
          "intuition" : "This approach involves checking all possible combinations of pairs to find the maximum length of a pair chain.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The longest chain that can be formed is [[1,2],[2,3]] or [[2,3],[3,4]].",
              "id" : "d38dd47b-f83a-4bb1-888a-b48995ed59b4",
              "input" : "pairs = [[1,2],[2,3],[3,4]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The longest chain that can be formed is [[1,2],[4,5],[7,8]].",
              "id" : "15834a17-909d-4c2a-954e-071ae6f74aa0",
              "input" : "pairs = [[1,2],[7,8],[4,5]]"
            }
          ]
        },
        {
          "approach" : "Sort the pairs based on their end values. Initialize the count of pairs in the chain to 1 and the end of the last pair in the chain to the end of the first pair. Then, for each remaining pair, check if it can be added to the chain without conflicting with the previously selected pair. If it can, increment the count of pairs in the chain and update the end of the last pair in the chain.",
          "code" : "func findLongestChain(_ pairs: [[Int]]) -> Int { let sortedPairs = pairs.sorted { $0[1] < $1[1] }; var count = 1; var lastEnd = sortedPairs[0][1]; for i in 1..<sortedPairs.count { if sortedPairs[i][0] > lastEnd { count += 1; lastEnd = sortedPairs[i][1] } } return count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) for storing the sorted pairs.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the sorting operation."
          },
          "explanation" : "We start by sorting the pairs based on their end values. Then, we initialize the count of pairs in the chain to 1 and the end of the last pair in the chain to the end of the first pair. We iterate over the remaining pairs, and for each pair, we check if its start value is greater than the end of the last pair in the chain. If it is, we increment the count of pairs in the chain and update the end of the last pair in the chain.",
          "id" : "3488ec7f-1b6e-4e39-906a-5e042362c4db",
          "intuition" : "This approach involves sorting the pairs based on their end values and then iteratively selecting the pair with the smallest end value that does not conflict with the previously selected pair.",
          "name" : "Greedy",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The longest chain that can be formed is [[1,2],[2,3]] or [[2,3],[3,4]].",
              "id" : "c0eba9ab-48e8-4c75-8819-d8e60e55f63a",
              "input" : "pairs = [[1,2],[2,3],[3,4]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The longest chain that can be formed is [[1,2],[2,3]] or [[2,3],[3,4]].",
              "id" : "aef90ab3-aaae-4ca6-b43f-0b8109a61523",
              "input" : "pairs = [[1,2],[7,8],[4,5]]"
            }
          ]
        }
      ],
      "id" : "b2ad8042-4835-4a93-ae16-3b87470a1ae1",
      "lastUpdated" : "2026-02-06T21:30:37Z",
      "problemSlug" : "maximum-length-of-pair-chain",
      "relatedProblems" : [
        "array-partition-i",
        "insert-interval"
      ],
      "summary" : "The problem involves finding the maximum length of a pair chain from given pairs of integers. The key insight is to use a greedy approach to always choose the pair that ends earliest and does not conflict with the previously chosen pair."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Track currentMax, currentMin, result\n2. For each num: newMax = max(num, num*currentMax, num*currentMin)\n3. newMin = min of same\n4. Update result",
          "code" : "func maxProduct(_ nums: [Int]) -> Int {\n    var maxProd = nums[0]\n    var minProd = nums[0]\n    var result = nums[0]\n    \n    for i in 1..<nums.count {\n        let candidates = [nums[i], nums[i] * maxProd, nums[i] * minProd]\n        maxProd = candidates.max()!\n        minProd = candidates.min()!\n        result = max(result, maxProd)\n    }\n    \n    return result\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Three variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "A negative times the most negative gives largest. Hence track both.",
          "id" : "550e8400-e29b-41d4-a716-446655440166",
          "intuition" : "Negative number flips max and min. Track both to handle sign changes.",
          "name" : "DP with Min\/Max",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "[2,3] has product 6",
              "id" : "550e8400-e29b-41d4-a716-446655440272",
              "input" : "[2,3,-2,4]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440055",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "maximum-product-subarray",
      "relatedProblems" : [
        "maximum-subarray",
        "product-of-array-except-self"
      ],
      "summary" : "Max product subarray. Track both max and min (negative * negative = positive)."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Track currentSum and maxSum\n2. For each num: currentSum = max(num, currentSum + num)\n3. Update maxSum = max(maxSum, currentSum)\n4. Return maxSum",
          "code" : "func maxSubArray(_ nums: [Int]) -> Int {\n    var currentSum = nums[0]\n    var maxSum = nums[0]\n    \n    for i in 1..<nums.count {\n        currentSum = max(nums[i], currentSum + nums[i])\n        maxSum = max(maxSum, currentSum)\n    }\n    \n    return maxSum\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Two variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "If currentSum < 0, adding it to next element makes it smaller. So reset to just the next element.",
          "id" : "550e8400-e29b-41d4-a716-446655440147",
          "intuition" : "At each position, decide: extend current subarray or start fresh. If current sum is negative, starting fresh is better.",
          "name" : "Kadane's Algorithm",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "[4,-1,2,1] has sum 6",
              "id" : "550e8400-e29b-41d4-a716-446655440253",
              "input" : "[-2,1,-3,4,-1,2,1,-5,4]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440036",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "maximum-subarray",
      "relatedProblems" : [
        "maximum-product-subarray",
        "maximum-sum-circular-subarray"
      ],
      "summary" : "Find contiguous subarray with maximum sum. Kadane's algorithm: track current sum, reset if negative."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays, calculate their sums, and compare the sums to find the maximum. Consider the array as a circular array by connecting the end of the array to the beginning.",
          "code" : "func maxSubarraySumCircular(_ nums: [Int]) -> Int { var maxSum: Int = Int.min; for i in 0..<nums.count { var sum: Int = 0; for j in i..<nums.count { sum += nums[j]; if sum > maxSum { maxSum = sum } }; let k: Int = i; for j in 0..<i { sum += nums[j]; if sum > maxSum { maxSum = sum } } }; return maxSum }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are only using a constant amount of space to store the sum and maximum sum.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because for each element in the array, we are potentially iterating over the rest of the array."
          },
          "explanation" : "This approach works by considering every possible subarray and checking if it is the maximum sum subarray. However, it is inefficient and has a high time complexity.",
          "id" : "218a7f0e-6c89-46ab-8174-a0a6ba975ada",
          "intuition" : "The brute force approach involves calculating the sum of every possible subarray and comparing them to find the maximum.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "10",
              "explanation" : "The maximum sum subarray is [5,5].",
              "id" : "43c8f51d-ca4c-4250-87c2-58ad331ac1e4",
              "input" : "nums = [5,-3,5]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum sum subarray is [3].",
              "id" : "0f542244-69b1-4758-a91b-f1b9609c0881",
              "input" : "nums = [1,-2,3,-2]"
            }
          ]
        },
        {
          "approach" : "Apply Kadane's Algorithm to find the maximum sum subarray. Then, apply Kadane's Algorithm to the negation of the array to find the minimum sum subarray. The maximum sum of a subarray that wraps around the end of the array is the sum of the array minus the minimum sum subarray.",
          "code" : "func maxSubarraySumCircular(_ nums: [Int]) -> Int { let n: Int = nums.count; let total: Int = nums.reduce(0, +); var maxKadane: Int = kadane(nums); var minKadane: Int = kadane(nums.map { -$0 }); if minKadane == total { return maxKadane } else { return max(maxKadane, total - minKadane) }; func kadane(_ nums: [Int]) -> Int { var maxSoFar: Int = Int.min; var maxEndingHere: Int = 0; for num in nums { maxEndingHere = max(num, maxEndingHere + num); maxSoFar = max(maxSoFar, maxEndingHere) }; return maxSoFar } }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are only using a constant amount of space to store the maximum sum and minimum sum.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating over the array a constant number of times."
          },
          "explanation" : "This approach works by using Kadane's Algorithm to find the maximum sum subarray and the minimum sum subarray, then combining the results to find the maximum sum subarray that wraps around the end of the array.",
          "id" : "659f35f3-93a1-4b1a-9458-2826aca1c20a",
          "intuition" : "Kadane's Algorithm is a dynamic programming approach that finds the maximum sum subarray in linear time.",
          "name" : "Kadane's Algorithm Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "10",
              "explanation" : "The maximum sum subarray is [5,5].",
              "id" : "e332ba40-b2a3-4c59-8abc-84c42e572c89",
              "input" : "nums = [5,-3,5]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum sum subarray is [3].",
              "id" : "fddf8dd0-1c2c-45b7-abc9-2dd0d416da4a",
              "input" : "nums = [1,-2,3,-2]"
            }
          ]
        }
      ],
      "id" : "88a9a61a-0870-4750-8f98-0417f7a09a95",
      "lastUpdated" : "2026-02-06T21:48:23Z",
      "problemSlug" : "maximum-sum-circular-subarray",
      "relatedProblems" : [
        "maximum-subarray",
        "subarray-sum-equals-k"
      ],
      "summary" : "The Maximum Sum Circular Subarray problem is to find the maximum sum of a subarray within a circular array. A key insight is to consider both the maximum sum of a subarray and the maximum sum of a subarray that wraps around the end of the array."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Can start at index 0 or 1\n2. dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n3. Answer is min(dp[n-1], dp[n-2])",
          "code" : "func minCostClimbingStairs(_ cost: [Int]) -> Int {\n    var prev2 = cost[0], prev1 = cost[1]\n    for i in 2..<cost.count {\n        let curr = cost[i] + min(prev1, prev2)\n        prev2 = prev1\n        prev1 = curr\n    }\n    return min(prev1, prev2)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Two variables",
            "time" : "O(n)",
            "timeExplanation" : "Single loop"
          },
          "explanation" : "We can reach the top from either of the last two steps.",
          "id" : "6a78777b-e9de-4555-a704-f08f2f33e79d",
          "intuition" : "At each step, choose cheaper path from previous two steps.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "15",
              "explanation" : "Start at 1, jump to top",
              "id" : "2f44d206-55c4-4c13-8171-45097c50aefd",
              "input" : "cost = [10,15,20]"
            }
          ]
        }
      ],
      "id" : "b3e3ef63-86a4-411c-8608-6ea9ee745d67",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "min-cost-climbing-stairs",
      "relatedProblems" : [
        "climbing-stairs"
      ],
      "summary" : "Minimum cost to climb stairs. dp[i] = cost[i] + min(dp[i-1], dp[i-2])."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible substrings for both strings, compare them to find the longest common subsequence, and calculate the sum of ASCII values of characters to delete.",
          "code" : "func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "The space complexity is also O(m*n) because we are using a 2D array of size (m+1) x (n+1) to store the dp values.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is O(m*n) because we are using two nested loops to fill up the dp array."
          },
          "explanation" : "This approach involves a lot of unnecessary comparisons and calculations, making it inefficient for large strings.",
          "id" : "16834ecd-323a-4688-9cf3-b3fc6bedb311",
          "intuition" : "The brute force approach involves generating all possible substrings for both strings and then comparing them to find the longest common subsequence, which would give us the minimum number of characters to delete.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "231",
              "explanation" : "The minimum ASCII delete sum for the strings 'sea' and 'eat' is 231, which is the sum of ASCII values of characters 's' and 't'.",
              "id" : "c50728e3-e31f-4933-b2f6-843ed4149840",
              "input" : "s1 = \"sea\", s2 = \"eat\""
            },
            {
              "expectedOutput" : "403",
              "explanation" : "The minimum ASCII delete sum for the strings 'delete' and 'leet' is 403, which is the sum of ASCII values of characters 'd' and 'e'.",
              "id" : "8cd4c803-4d29-4ba9-8471-cd9fc7f28a41",
              "input" : "s1 = \"delete\", s2 = \"leet\""
            }
          ]
        },
        {
          "approach" : "Create a 2D array dp where dp[i][j] represents the minimum ASCII delete sum for the first i characters of the first string and the first j characters of the second string.",
          "code" : "func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "The space complexity is also O(m*n) because we are using a 2D array of size (m+1) x (n+1) to store the dp values.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is O(m*n) because we are using two nested loops to fill up the dp array."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it avoids unnecessary comparisons and calculations.",
          "id" : "9d280e6e-8736-4e52-b904-ae3e97d58c5f",
          "intuition" : "This approach involves using dynamic programming to compare the two strings and determine the minimum sum of ASCII values to delete characters to make them identical.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "231",
              "explanation" : "The minimum ASCII delete sum for the strings 'sea' and 'eat' is 231, which is the sum of ASCII values of characters 's' and 't'.",
              "id" : "8371dd8a-ea29-4a7b-8f9d-b5b7ff2ad245",
              "input" : "s1 = \"sea\", s2 = \"eat\""
            },
            {
              "expectedOutput" : "403",
              "explanation" : "The minimum ASCII delete sum for the strings 'delete' and 'leet' is 403, which is the sum of ASCII values of characters 'd' and 'e'.",
              "id" : "4263c4d7-d244-497c-a598-d9b80567882b",
              "input" : "s1 = \"delete\", s2 = \"leet\""
            }
          ]
        }
      ],
      "id" : "d5ce9bd9-bc80-4a5c-92cb-ca8d891d65de",
      "lastUpdated" : "2026-02-06T21:35:23Z",
      "problemSlug" : "minimum-ascii-delete-sum-for-two-strings",
      "relatedProblems" : [
        "string-to-integer-atoi",
        "roman-to-integer"
      ],
      "summary" : "This problem involves finding the minimum ASCII delete sum for two strings, which can be solved by using dynamic programming to compare the two strings and determine the minimum sum of ASCII values to delete characters to make them identical."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an array to store the minimum cost for each day. 2. Iterate through each day and calculate the minimum cost by considering all possible ticket combinations. 3. Update the minimum cost array accordingly.",
          "code" : "func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; var dp = Array(repeating: 0, count: n + 1); for i in 1...n { let oneDay = dp[i - 1] + costs[0]; let sevenDays = (i - 7 >= 0 ? dp[i - 7] : 0) + costs[1]; let thirtyDays = (i - 30 >= 0 ? dp[i - 30] : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n]; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is also linear as we use an array of size n to store the minimum costs.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we iterate through the days array once."
          },
          "explanation" : "This approach is straightforward but inefficient due to its exponential time complexity. It serves as a baseline for understanding the problem.",
          "id" : "7d5a1292-3127-4b29-ba04-38c7f0a26eb9",
          "intuition" : "This approach involves trying all possible combinations of tickets and calculating the total cost for each combination, then selecting the minimum cost.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "The minimum cost can be achieved by buying a 7-day pass for the first 4 days and a 7-day pass starting from the 7th day, covering the 8th and 20th days with the initial pass.",
              "id" : "f40b42a9-42b9-48e7-ba27-e0b29868b5f5",
              "input" : "days = [1,4,6,7,8,20], costs = [2,7,15]"
            },
            {
              "expectedOutput" : "17",
              "explanation" : "Buying a 7-day pass for the first 7 days and a 30-day pass starting from the 8th day covers all the days.",
              "id" : "0beee8cc-4234-43be-bd19-47da03ad5e20",
              "input" : "days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,15,40]"
            }
          ]
        },
        {
          "approach" : "1. Initialize a sparse table to store the minimum cost for each day. 2. Iterate through each day and calculate the minimum cost by considering only the last day for each ticket duration. 3. Update the sparse table accordingly.",
          "code" : "func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear as we use a sparse table to store the minimum costs.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the set operations."
          },
          "explanation" : "This approach is more efficient as it reduces the number of unnecessary calculations by considering only the relevant days for each ticket duration.",
          "id" : "b40ffe57-cff1-487d-b08e-43f45e37acf1",
          "intuition" : "This approach involves using a more efficient method to calculate the minimum cost, considering only the last day for each ticket duration and utilizing a sparse dynamic programming table.",
          "name" : "Optimized Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "The minimum cost can be achieved by buying a 7-day pass for the first 4 days and a 7-day pass starting from the 7th day, covering the 8th and 20th days with the initial pass.",
              "id" : "0aef8dbf-e315-4af6-b9c9-eb7f290ed6ba",
              "input" : "days = [1,4,6,7,8,20], costs = [2,7,15]"
            },
            {
              "expectedOutput" : "17",
              "explanation" : "Buying a 7-day pass for the first 7 days and a 30-day pass starting from the 8th day covers all the days.",
              "id" : "9a6093f8-3ebc-4fec-ae6b-0b70dedb8fa8",
              "input" : "days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,15,40]"
            }
          ]
        }
      ],
      "id" : "35f63350-fefa-4836-b989-21e9a83710ec",
      "lastUpdated" : "2026-02-06T21:52:57Z",
      "problemSlug" : "minimum-cost-for-tickets",
      "relatedProblems" : [
        "unique-paths",
        "minimum-path-sum"
      ],
      "summary" : "This problem requires finding the minimum cost to travel on certain days with given ticket durations and costs, key insight is to utilize dynamic programming to optimize the solution. The goal is to minimize the total cost while considering the constraints of ticket validity periods."
    },
    {
      "approaches" : [
        {
          "approach" : "Start at each cell in the top row and explore all possible paths down to the bottom row, keeping track of the minimum sum encountered.",
          "code" : "\nfunc minFallingPathSum(_ arr: [[Int]]) -> Int {\n    let n = arr.count\n    var minSum = Int.max\n    \n    func dfs(_ row: Int, _ col: Int, _ currentSum: Int) {\n        if row == n {\n            minSum = min(minSum, currentSum)\n            return\n        }\n        \n        for c in [col - 1, col, col + 1] {\n            if c >= 0 && c < n {\n                dfs(row + 1, c, currentSum + arr[row][c])\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        dfs(1, i, arr[0][i])\n    }\n    \n    return minSum\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The maximum depth of the recursion call stack is n, due to the recursive exploration of paths.",
            "time" : "O(3^n)",
            "timeExplanation" : "Each cell has up to three possible paths down, leading to exponential time complexity."
          },
          "explanation" : "This approach works by exhaustively searching all possible paths, ensuring that the minimum sum is found. However, it has high time complexity due to the recursive nature of exploring all paths.",
          "id" : "7aa642c8-a135-44bb-8229-4576861cfa1e",
          "intuition" : "The brute force approach involves trying all possible paths from the top to the bottom of the array and calculating the sum for each path.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "13",
              "explanation" : "The minimum falling path sum is obtained by going from 2 to 5 to 7 (2 + 5 + 7 = 14) or from 1 to 4 to 8 (1 + 4 + 8 = 13).",
              "id" : "de58f948-fec9-411b-9cec-08724f29bfae",
              "input" : "arr = [[2,1,3],[6,5,4],[7,8,9]]"
            },
            {
              "expectedOutput" : "-36",
              "explanation" : "The minimum falling path sum involves moving through the array to minimize the sum of the path, considering the negative numbers.",
              "id" : "3db0aad4-8794-4432-be3b-5aa6f607f2bb",
              "input" : "arr = [[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]"
            }
          ]
        },
        {
          "approach" : "Initialize the first row as the base case. Then, for each subsequent row, calculate the minimum sum at each cell by considering the minimum sums of the cells directly above, to the left, and to the right.",
          "code" : "\nfunc minFallingPathSum(_ arr: [[Int]]) -> Int {\n    let n = arr.count\n    var dp = arr\n    \n    for i in 1..<n {\n        var nextRow = [Int](repeating: Int.max, count: n)\n        \n        for j in 0..<n {\n            for k in [j - 1, j, j + 1] {\n                if k >= 0 && k < n {\n                    nextRow[j] = min(nextRow[j], dp[i-1][k] + arr[i][j])\n                }\n            }\n        }\n        \n        dp = nextRow\n    }\n    \n    return dp.min() ?? 0\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use an additional array of size n to store the minimum sums for the next row, leading to linear space complexity.",
            "time" : "O(n^2)",
            "timeExplanation" : "We iterate over each cell in the array once, resulting in quadratic time complexity."
          },
          "explanation" : "By using dynamic programming, we avoid the need to explore all possible paths and instead build up the solution row by row, significantly reducing the time complexity.",
          "id" : "3c396896-439f-4deb-b7f3-ab39312f20f5",
          "intuition" : "This approach uses dynamic programming to efficiently compute the minimum falling path sum by iteratively updating the minimum sum at each cell based on the cells above it.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "13",
              "explanation" : "The minimum falling path sum is obtained by going from 1 to 4 to 8 (1 + 4 + 8 = 13).",
              "id" : "bb152897-a9d5-4414-954f-a3d098c93353",
              "input" : "arr = [[2,1,3],[6,5,4],[7,8,9]]"
            },
            {
              "expectedOutput" : "-36",
              "explanation" : "The dynamic programming approach efficiently computes the minimum falling path sum by considering the interactions between rows.",
              "id" : "cece5310-0f38-439c-9339-e65e49a5ae4c",
              "input" : "arr = [[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]"
            }
          ]
        }
      ],
      "id" : "0ef42637-f864-4e98-8e27-859be4432bac",
      "lastUpdated" : "2026-02-06T21:49:22Z",
      "problemSlug" : "minimum-falling-path-sum",
      "relatedProblems" : [
        "longest-increasing-subsequence",
        "edit-distance"
      ],
      "summary" : "The problem asks for the minimum falling path sum in a square array. The key insight is to use dynamic programming to track the minimum sum at each cell, considering the cells above it."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a dp table same size as grid\n2. Initialize dp[0][0] = grid[0][0]\n3. Fill first row (can only come from left)\n4. Fill first column (can only come from above)\n5. For other cells: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n6. Return dp[m-1][n-1]",
          "code" : "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n    \n    dp[0][0] = grid[0][0]\n    \n    \/\/ Fill first row\n    for j in 1..<n {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    \n    \/\/ Fill first column\n    for i in 1..<m {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    \n    \/\/ Fill rest\n    for i in 1..<m {\n        for j in 1..<n {\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    \n    return dp[m-1][n-1]\n}",
          "complexity" : {
            "space" : "O(m  n)",
            "spaceExplanation" : "DP table has same dimensions as input grid",
            "time" : "O(m  n)",
            "timeExplanation" : "Visit each cell exactly once"
          },
          "explanation" : "Since we can only move right or down, each cell can only be reached from the cell above or to the left. We compute the minimum cumulative sum for each cell. The first row and column are special cases since they have only one possible path. The answer is the value in the bottom-right cell of our dp table.",
          "id" : "60d1784d-8702-4df7-8e41-af8c58bcaa7b",
          "intuition" : "For each cell, the minimum path sum to reach it is the cell's value plus the minimum of the path sum from above or from the left. Build the solution bottom-up.",
          "name" : "2D Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "Path 13111 = 7. Path goes right, right, down, down.",
              "id" : "335352a7-673f-4c04-8b33-bf9e560e2bba",
              "input" : "grid = [[1,3,1],[1,5,1],[4,2,1]]"
            },
            {
              "expectedOutput" : "12",
              "explanation" : "Path 1236 = 12",
              "id" : "7b6388f3-a1b2-4f61-9d7f-8c27431e7a07",
              "input" : "grid = [[1,2,3],[4,5,6]]"
            }
          ]
        },
        {
          "approach" : "1. Use a 1D dp array of size n\n2. Initialize with first row's cumulative sums\n3. For each subsequent row, update dp left-to-right\n4. dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n5. Return dp[n-1]",
          "code" : "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = [Int](repeating: 0, count: n)\n    \n    \/\/ Initialize with first row\n    dp[0] = grid[0][0]\n    for j in 1..<n {\n        dp[j] = dp[j-1] + grid[0][j]\n    }\n    \n    \/\/ Process remaining rows\n    for i in 1..<m {\n        dp[0] += grid[i][0]  \/\/ First column: only from above\n        for j in 1..<n {\n            dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n        }\n    }\n    \n    return dp[n-1]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Only store one row at a time",
            "time" : "O(m  n)",
            "timeExplanation" : "Still visit each cell once"
          },
          "explanation" : "When computing dp[i][j], we need dp[i-1][j] (above) and dp[i][j-1] (left). In our 1D array, dp[j] still holds the value from the previous row (above), and dp[j-1] was just updated for the current row (left). By processing left-to-right, we always have both values available.",
          "id" : "be3872d1-ca2f-4c3e-9e5c-60b24abe0596",
          "intuition" : "We only need the previous row to compute the current row. Use a 1D array and update it in-place, reducing space from O(mn) to O(n).",
          "name" : "Space-Optimized DP (1D Array)",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "Same result with optimized space",
              "id" : "2bbf05b9-36e3-4d84-b551-d400d026f53b",
              "input" : "grid = [[1,3,1],[1,5,1],[4,2,1]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "Single cell grid",
              "id" : "90c9fcb8-5e8b-4fe1-a38f-4a9ca33ca1a6",
              "input" : "grid = [[1]]"
            }
          ]
        }
      ],
      "id" : "fc295f47-1ddf-4721-b421-4b08b57fe7b0",
      "lastUpdated" : "2026-02-06T08:33:51Z",
      "problemSlug" : "minimum-path-sum",
      "relatedProblems" : [
        "unique-paths",
        "unique-paths-ii",
        "dungeon-game",
        "cherry-pickup"
      ],
      "summary" : "Find the minimum sum path from top-left to bottom-right in a grid, moving only right or down. Classic 2D dynamic programming - each cell's minimum sum is its value plus min of top or left cell."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsequences, filter out those that are not increasing, and count the ones with the maximum length.",
          "code" : "\n         func findNumberOfLIS(_ nums: [Int]) -> Int {\n            func isIncreasing(_ subsequence: [Int]) -> Bool {\n               for i in 1..<subsequence.count {\n                  if subsequence[i] <= subsequence[i-1] {\n                     return false\n                  }\n               }\n               return true\n            }\n\n            var maxLength = 0\n            var count = 0\n            let n = nums.count\n            let total = 1 << n \/\/ 2^n\n\n            for i in 1..<total {\n               var subsequence: [Int] = []\n               for j in 0..<n {\n                  if (i & (1 << j)) != 0 {\n                     subsequence.append(nums[j])\n                  }\n               }\n\n               if isIncreasing(subsequence) {\n                  let length = subsequence.count\n                  if length > maxLength {\n                     maxLength = length\n                     count = 1\n                  } else if length == maxLength {\n                     count += 1\n                  }\n               }\n            }\n            return count\n         }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is due to storing the current subsequence being checked, which can be up to n elements long.",
            "time" : "O(2^n * n)",
            "timeExplanation" : "The time complexity comes from generating all subsets (2^n) and for each subset potentially checking its elements (up to n)."
          },
          "explanation" : "This approach involves generating a power set of the given array, then for each subset, checking if it's an increasing sequence. If it is, and its length is equal to the current maximum length found, increment the count. If its length is greater than the current maximum, update the maximum length and reset the count to 1.",
          "id" : "3da2ac3c-18f5-4b31-a8bd-f03d04b5be74",
          "intuition" : "This approach checks all possible subsequences of the given array and counts the longest increasing ones. It's inefficient but provides a baseline understanding.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two longest increasing subsequences are [1,3,4,7] and [1,3,5,7].",
              "id" : "dcb4fee4-ed4c-47ef-90f0-b38d62bf0c00",
              "input" : "nums = [1,3,5,4,7]"
            },
            {
              "expectedOutput" : "5",
              "explanation" : "The longest increasing subsequence is of length 1, and there are 5 such subsequences (each of the five elements alone).",
              "id" : "0fe7c6db-4968-4ad9-b5cc-4d35663edfc7",
              "input" : "nums = [2,2,2,2,2]"
            }
          ]
        },
        {
          "approach" : "Use two DP arrays, one for lengths and one for counts, and fill them up iteratively based on comparisons with previous elements.",
          "code" : "\n         func findNumberOfLIS(_ nums: [Int]) -> Int {\n            let n = nums.count\n            if n == 0 {\n               return 0\n            }\n            var lengths: [Int] = Array(repeating: 1, count: n)\n            var counts: [Int] = Array(repeating: 1, count: n)\n\n            for i in 1..<n {\n               for j in 0..<i {\n                  if nums[i] > nums[j] {\n                     if lengths[i] == lengths[j] {\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                     } else if lengths[i] == lengths[j] + 1 {\n                        counts[i] += counts[j]\n                     } else if lengths[i] < lengths[j] + 1 {\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                     }\n                  }\n               }\n            }\n\n            let maxLength = lengths.max() ?? 0\n            return lengths.enumerated().filter { $0.element == maxLength }.map { $0.offset }.map { counts[$0] }.reduce(0, +)\n         }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Two arrays of size n are used to store the lengths and counts of the longest increasing subsequences ending at each position.",
            "time" : "O(n^2)",
            "timeExplanation" : "The algorithm iterates over the array and for each element, it potentially checks all previous elements, hence the n^2 complexity."
          },
          "explanation" : "For each element, compare it with all previous elements. If the current element is greater than a previous one, it could potentially extend an increasing subsequence ending at the previous element. Update the length and count accordingly.",
          "id" : "0ca091a0-b752-45b2-9861-f94780c567d1",
          "intuition" : "This approach uses dynamic programming to keep track of the length and count of the longest increasing subsequences ending at each position. It is much more efficient than the brute force approach.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two longest increasing subsequences are [1,3,4,7] and [1,3,5,7].",
              "id" : "0010b6f0-bb01-4118-ad30-cbb308d3c24c",
              "input" : "nums = [1,3,5,4,7]"
            },
            {
              "expectedOutput" : "5",
              "explanation" : "The longest increasing subsequence is of length 1, and there are 5 such subsequences (each of the five elements alone).",
              "id" : "8864458c-23f5-4104-98d5-c39072fd4108",
              "input" : "nums = [2,2,2,2,2]"
            }
          ]
        }
      ],
      "id" : "aa419526-2f22-4fb5-99be-80c2e167143f",
      "lastUpdated" : "2026-02-06T21:32:48Z",
      "problemSlug" : "number-of-longest-increasing-subsequence",
      "relatedProblems" : [
        "length-of-lisi",
        "longest-increasing-subsequence"
      ],
      "summary" : "The problem asks to find the number of longest increasing subsequences in an array of integers. The key insight here is to use dynamic programming to track both the length of the longest increasing subsequence ending at each position and the count of such subsequences."
    },
    {
      "approaches" : [
        {
          "approach" : "Initialize an empty set to store the selected strings. Generate all possible combinations of strings and for each combination, count the total number of 1s and 0s. If the total number of 1s and 0s is less than or equal to the given limits, add the combination to the set.",
          "code" : "func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int { \n    var count = 0 \n    let total = 1 << strs.count \n    for i in 0..<total { \n        var ones = 0, zeros = 0 \n        for j in 0..<strs.count { \n            if (i & (1 << j)) != 0 { \n                ones += countOnes(strs[j]) \n                zeros += countZeros(strs[j]) \n            } \n        } \n        if ones <= m && zeros <= n { \n            count = max(count, countBits(i)) \n        } \n    } \n    return count \n} \n \nfunc countOnes(_ s: String) -> Int { \n    var count = 0 \n    for c in s { \n        if c == \"1\" { \n            count += 1 \n        } \n    } \n    return count \n} \n \nfunc countZeros(_ s: String) -> Int { \n    var count = 0 \n    for c in s { \n        if c == \"0\" { \n            count += 1 \n        } \n    } \n    return count \n} \n \nfunc countBits(_ n: Int) -> Int { \n    var count = 0 \n    while n > 0 { \n        count += n & 1 \n        n >>= 1 \n    } \n    return count \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant as we only use a fixed amount of space to store the count of ones and zeros and the selected strings.",
            "time" : "O(2^n * n * m)",
            "timeExplanation" : "The time complexity is exponential due to generating all possible combinations of strings."
          },
          "explanation" : "This approach is straightforward but inefficient as it involves generating all possible combinations of strings, resulting in an exponential time complexity.",
          "id" : "4507286a-1cb1-44fb-bb00-3c3fe4daf2bf",
          "intuition" : "This approach works by generating all possible combinations of strings and checking if they can be formed with the given number of 1s and 0s.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The optimal solution is to form [\"0\", \"1\"] with the given number of 1s and 0s.",
              "id" : "deb5ae6b-2b87-4241-b54f-498565a057c8",
              "input" : "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The optimal solution is to form [\"111001\", \"10\", \"0001\", \"0\"] with the given number of 1s and 0s.",
              "id" : "d657c57a-6184-457d-a156-5f75375ec621",
              "input" : "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3"
            }
          ]
        },
        {
          "approach" : "Initialize a 2D array dp where dp[i][j] represents the maximum number of strings that can be formed with i 1s and j 0s. Iterate over each string and for each string, count the number of 1s and 0s. Update dp[i][j] by considering whether to include or exclude the current string.",
          "code" : "func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int { \n    var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1) \n    for str in strs { \n        let ones = countOnes(str), zeros = countZeros(str) \n        for i in stride(from: m, through: ones, by: -1) { \n            for j in stride(from: n, through: zeros, by: -1) { \n                dp[i][j] = max(dp[i][j], dp[i - ones][j - zeros] + 1) \n            } \n        } \n    } \n    return dp[m][n] \n} \n \nfunc countOnes(_ s: String) -> Int { \n    var count = 0 \n    for c in s { \n        if c == \"1\" { \n            count += 1 \n        } \n    } \n    return count \n} \n \nfunc countZeros(_ s: String) -> Int { \n    var count = 0 \n    for c in s { \n        if c == \"0\" { \n            count += 1 \n        } \n    } \n    return count \n}",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is polynomial as we use a 2D array to store the dp values.",
            "time" : "O(n * m * s)",
            "timeExplanation" : "The time complexity is polynomial due to using dynamic programming to iterate over each string and update the dp array."
          },
          "explanation" : "This approach is efficient as it avoids generating all possible combinations of strings and instead uses dynamic programming to keep track of the maximum number of strings that can be formed.",
          "id" : "111e52ed-4955-4a51-851e-7f03e5ef8992",
          "intuition" : "This approach works by using dynamic programming to keep track of the maximum number of strings that can be formed with a given number of 1s and 0s.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The optimal solution is to form [\"0\", \"1\"] with the given number of 1s and 0s.",
              "id" : "6c66e61d-03cc-4c9a-9b50-fa1627210d2f",
              "input" : "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The optimal solution is to form [\"111001\", \"10\", \"0001\", \"0\"] with the given number of 1s and 0s.",
              "id" : "b4fc9fd1-416f-478d-b63d-962777f7a53d",
              "input" : "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3"
            }
          ]
        }
      ],
      "id" : "5d426a9f-a960-49e0-afc5-117955af7d70",
      "lastUpdated" : "2026-02-06T21:21:06Z",
      "problemSlug" : "ones-and-zeroes",
      "relatedProblems" : [
        "subarray-sums",
        "partition-equal-subset-sum"
      ],
      "summary" : "The Ones and Zeroes problem involves finding the maximum number of strings that can be formed with a limited number of 1s and 0s. The key insight to solving this problem is to use dynamic programming, keeping track of the maximum number of strings that can be formed with a given number of 1s and 0s."
    },
    {
      "approaches" : [
        {
          "approach" : "Start at the top left cell and try to move in all four directions. If the move is within the boundary, recursively try all possible paths from the new cell. If the move is out of the boundary, increment the count of paths that go out of the boundary.",
          "code" : "\n           import Foundation\n\n           class Solution {\n               func findPaths(_ m: Int, _ n: Int, _ N: Int, _ i: Int, _ j: Int) -> Int {\n                   var count = 0\n                   var visited = Array(repeating: Array(repeating: false, count: n), count: m)\n                   let directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n                   func helper(_ i: Int, _ j: Int, _ steps: Int) -> Int {\n                       if i < 0 || i >= m || j < 0 || j >= n {\n                           return 1\n                       }\n                       if steps == 0 {\n                           return 0\n                       }\n                       var result = 0\n                       for direction in directions {\n                           let newI = i + direction.0\n                           let newJ = j + direction.1\n                           result += helper(newI, newJ, steps - 1)\n                       }\n                       return result\n                   }\n\n                   return helper(i, j, N)\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(N)",
            "spaceExplanation" : "The space complexity is the maximum depth of the recursion call stack, which is the number of steps.",
            "time" : "O(4^N)",
            "timeExplanation" : "We are trying all possible paths, and at each step, we have four choices. So the time complexity is exponential in the number of steps."
          },
          "explanation" : "This approach tries all possible paths and counts the number of paths that go out of the boundary. However, it does a lot of repeated work and has a high time complexity.",
          "id" : "33a41a18-b81a-4f6d-9b0c-64e815b8e8d0",
          "intuition" : "This approach involves trying all possible paths and counting the number of paths that go out of the boundary. It is a simple approach but not efficient for large inputs.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two paths that go out of the boundary are (0,0) -> (1,0) -> (1,1) and (0,0) -> (0,1) -> (1,1).",
              "id" : "bb9e0d27-93bb-44ec-b241-4abb0e653423",
              "input" : "m = 2, n = 2, N = 2, i = 0, j = 0"
            },
            {
              "expectedOutput" : "12",
              "explanation" : "There are 12 paths that go out of the boundary.",
              "id" : "8b6558e9-25ad-4b0a-97f8-c6e85a513fe1",
              "input" : "m = 1, n = 3, N = 3, i = 0, j = 1"
            }
          ]
        },
        {
          "approach" : "Create a 3D array dp where dp[i][j][k] is the number of ways to go out of the boundary from cell (i,j) in k steps. Fill up the dp array using a bottom-up approach.",
          "code" : "\n           import Foundation\n\n           class Solution {\n               func findPaths(_ m: Int, _ n: Int, _ N: Int, _ i: Int, _ j: Int) -> Int {\n                   let mod = 1000000007\n                   let directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n                   var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: N + 1), count: n), count: m)\n\n                   for k in 1...N {\n                       for x in 0..<m {\n                           for y in 0..<n {\n                               for direction in directions {\n                                   let newI = x + direction.0\n                                   let newJ = y + direction.1\n                                   if newI < 0 || newI >= m || newJ < 0 || newJ >= n {\n                                       dp[x][y][k] = (dp[x][y][k] + 1) % mod\n                                   } else {\n                                       dp[x][y][k] = (dp[x][y][k] + dp[newI][newJ][k - 1]) % mod\n                                   }\n                               }\n                           }\n                       }\n                   }\n\n                   return dp[i][j][N]\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(m*n*N)",
            "spaceExplanation" : "We need to store the dp array, which has m*n*N cells.",
            "time" : "O(m*n*N)",
            "timeExplanation" : "We need to fill up the dp array, which has m*n*N cells."
          },
          "explanation" : "We fill up the dp array by trying all possible moves from each cell and counting the number of ways to go out of the boundary.",
          "id" : "5bf73ef9-898f-4b22-b942-dedfe2a370e7",
          "intuition" : "This approach involves using a 3D array to store the number of ways to go out of the boundary from each cell in each step.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two paths that go out of the boundary are (0,0) -> (1,0) -> (1,1) and (0,0) -> (0,1) -> (1,1).",
              "id" : "9786208e-85a1-411f-a44a-bb12a4b50112",
              "input" : "m = 2, n = 2, N = 2, i = 0, j = 0"
            },
            {
              "expectedOutput" : "12",
              "explanation" : "There are 12 paths that go out of the boundary.",
              "id" : "a10ff99e-d734-41b4-9e17-a13c1bc3499e",
              "input" : "m = 1, n = 3, N = 3, i = 0, j = 1"
            }
          ]
        }
      ],
      "id" : "7ead9f71-73cb-41f4-aae1-2d01b34da87a",
      "lastUpdated" : "2026-02-06T21:26:53Z",
      "problemSlug" : "out-of-boundary-paths",
      "relatedProblems" : [
        "unique-paths",
        "unique-paths-ii"
      ],
      "summary" : "The problem asks us to find the number of ways a ball can go out of the boundary of an m x n grid, where at each cell, the ball can move in any of the four directions. We can solve this using dynamic programming and memoization to store the results of subproblems."
    },
    {
      "approaches" : [
        {
          "approach" : "1. If sum is odd, return false\n2. target = sum \/ 2\n3. dp[j] = true if we can make sum j\n4. For each num, update dp from right to left\n5. Return dp[target]",
          "code" : "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total \/ 2\n    var dp = [Bool](repeating: false, count: target + 1)\n    dp[0] = true\n    \n    for num in nums {\n        for j in stride(from: target, through: num, by: -1) {\n            dp[j] = dp[j] || dp[j - num]\n        }\n    }\n    \n    return dp[target]\n}",
          "complexity" : {
            "space" : "O(sum)",
            "spaceExplanation" : "Boolean array of size sum\/2",
            "time" : "O(n  sum)",
            "timeExplanation" : "Process each number against possible sums"
          },
          "explanation" : "We need to find if a subset sums to exactly half the total. dp[j] represents whether sum j is achievable. For each number, we update achievable sums by including it. Process right-to-left to avoid using same number twice.",
          "id" : "cc8335b9-2312-44d6-977b-416387e0bc91",
          "intuition" : "If total sum is odd, impossible. Otherwise, find if any subset sums to total\/2. Classic 0\/1 knapsack.",
          "name" : "DP (Subset Sum)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Partition: [1,5,5] and [11], both sum to 11",
              "id" : "bb218084-f362-4c29-9aa1-670fb1c3048c",
              "input" : "nums = [1,5,11,5]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "Total is 11 (odd), can't split equally",
              "id" : "1ed86229-7935-4978-86dc-1f839cf12009",
              "input" : "nums = [1,2,3,5]"
            }
          ]
        },
        {
          "approach" : "1. Use integer\/bitset where bit j means sum j achievable\n2. For each num, bits |= bits << num\n3. Check if target bit is set",
          "code" : "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total \/ 2\n    var bits = Set<Int>([0])\n    \n    for num in nums {\n        var newBits = Set<Int>()\n        for b in bits {\n            let newSum = b + num\n            if newSum <= target {\n                newBits.insert(newSum)\n            }\n        }\n        bits.formUnion(newBits)\n        if bits.contains(target) { return true }\n    }\n    \n    return bits.contains(target)\n}",
          "complexity" : {
            "space" : "O(sum)",
            "spaceExplanation" : "Set of achievable sums",
            "time" : "O(n  sum)",
            "timeExplanation" : "Similar to DP but with set operations"
          },
          "explanation" : "This is a clever optimization. If bits represents achievable sums, then bits << num shifts all achievable sums up by num. ORing with original gives all sums achievable with or without including num. Very fast in practice.",
          "id" : "46cf8abf-4483-4079-978c-99ec239a13dc",
          "intuition" : "Use bitset where bit j is set if sum j is achievable. Shift and OR to update all sums at once.",
          "name" : "Bitset Optimization",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Early exit when target found",
              "id" : "6dfb3b44-50c2-44d2-a238-b9d0637b865c",
              "input" : "nums = [1,5,11,5]"
            }
          ]
        }
      ],
      "id" : "0462b6a7-f35b-41c6-9230-d2b7d6e85f5b",
      "lastUpdated" : "2026-02-06T00:53:56.092Z",
      "problemSlug" : "partition-equal-subset-sum",
      "relatedProblems" : [
        "target-sum",
        "last-stone-weight-ii",
        "partition-to-k-equal-sum-subsets"
      ],
      "summary" : "Determine if array can be partitioned into two subsets with equal sum. This is subset sum problem: can we find subset summing to total\/2?"
    },
    {
      "approaches" : [
        {
          "approach" : "Start by calculating the total sum of the array and checking if it's divisible by k. If it is, calculate the target sum for each subset and start backtracking from the first element.",
          "code" : "\nfunc canPartitionKSubsets(_ nums: [Int], _ k: Int) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % k != 0 {\n        return false\n    }\n    let target = total \/ k\n    var visited = Array(repeating: false, count: nums.count)\n    return backtrack(nums, k, target, 0, 0, visited)\n}\n\nfunc backtrack(_ nums: [Int], _ k: Int, _ target: Int, _ index: Int, _ currentSum: Int, _ visited: [Bool]) -> Bool {\n    if k == 0 {\n        return true\n    }\n    if currentSum == target {\n        return backtrack(nums, k - 1, target, 0, 0, visited)\n    }\n    for i in index..<nums.count {\n        if !visited[i] {\n            var newVisited = visited\n            newVisited[i] = true\n            if backtrack(nums, k, target, i + 1, currentSum + nums[i], newVisited) {\n                return true\n            }\n        }\n    }\n    return false\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a visited array to keep track of the elements we've included in the current subset.",
            "time" : "O(k * 2^n)",
            "timeExplanation" : "In the worst-case scenario, we might need to generate all possible subsets and check their sums."
          },
          "explanation" : "In this approach, we generate all possible combinations of subsets. For each combination, we calculate the sum of each subset and check if it equals the target sum. If we find a valid combination, we return true. If we've checked all combinations and haven't found a valid one, we return false.",
          "id" : "5594ccea-7373-4bda-b528-cb97db0c6e1a",
          "intuition" : "This approach involves using a brute force method to try all possible combinations and check if the sum of each subset equals the target sum.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "We can partition the array into two subsets with equal sums: [1, 4] and [2, 3].",
              "id" : "81984263-8a77-47d2-ab91-a8166d323033",
              "input" : "nums = [1, 2, 3, 4], k = 2"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "It's impossible to partition the array into two subsets with equal sums.",
              "id" : "556a9f1e-49fe-4f83-a664-622ee8e8dcf4",
              "input" : "nums = [1, 2, 3, 5], k = 2"
            }
          ]
        },
        {
          "approach" : "Start by sorting the array in descending order, then calculate the target sum for each subset and start backtracking from the largest number.",
          "code" : "\nfunc canPartitionKSubsets(_ nums: [Int], _ k: Int) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % k != 0 {\n        return false\n    }\n    let target = total \/ k\n    var visited = Array(repeating: false, count: nums.count)\n    return backtrack(nums.sorted(by: >), k, target, 0, 0, visited)\n}\n\nfunc backtrack(_ nums: [Int], _ k: Int, _ target: Int, _ index: Int, _ currentSum: Int, _ visited: [Bool]) -> Bool {\n    if k == 0 {\n        return true\n    }\n    if currentSum == target {\n        return backtrack(nums, k - 1, target, 0, 0, visited)\n    }\n    for i in index..<nums.count {\n        if !visited[i] && currentSum + nums[i] <= target {\n            var newVisited = visited\n            newVisited[i] = true\n            if backtrack(nums, k, target, i + 1, currentSum + nums[i], newVisited) {\n                return true\n            }\n        }\n    }\n    return false\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity remains the same as we use a visited array to keep track of the elements.",
            "time" : "O(k * n!)",
            "timeExplanation" : "Although the time complexity is still high, the optimization reduces the number of recursive calls."
          },
          "explanation" : "By sorting the array, we can reduce the search space and improve the efficiency of the backtracking algorithm.",
          "id" : "a1a3223c-1de6-468f-830b-71b50df957ae",
          "intuition" : "This approach involves sorting the array in descending order and using the same backtracking technique.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "We can partition the array into four subsets with equal sums: [5, 1, 4], [2, 2, 3], [3], and [3].",
              "id" : "3cb4ee79-5bc8-4651-bced-f7ced1d2aa6b",
              "input" : "nums = [4, 3, 2, 3, 5, 2, 1], k = 4"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "It's impossible to partition the array into three subsets with equal sums.",
              "id" : "c9c6b533-6c7f-4204-9cc9-7a7aab3083d7",
              "input" : "nums = [1, 2, 3, 4], k = 3"
            }
          ]
        }
      ],
      "id" : "012257d1-a632-4c91-908b-f31e61d436e5",
      "lastUpdated" : "2026-02-06T21:34:34Z",
      "problemSlug" : "partition-to-k-equal-sum-subsets",
      "relatedProblems" : [
        "subset-sum",
        "partition-equal-subset-sum",
        "backtracking",
        "combination-sum"
      ],
      "summary" : "The problem involves partitioning an array into k equal sum subsets, and the key insight is to use backtracking to achieve this goal. A second approach will be considered to improve upon the solution."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Start with the first row of Pascal's Triangle as [1]. 2. For each subsequent row, calculate the binomial coefficients using the formula: C(n, k) = n! \/ (k! * (n-k)!) where n is the row number and k is the column number.",
          "code" : "\nlet numRows = 5\nvar result: [[Int]] = [[1]]\nfor i in 1...numRows-1 {\n    var level = [1]\n    let last = result[i-1]\n    for j in 1...last.count - 1 {\n        level.append(last[j-1] + last[j])\n    }\n    level.append(1)\n    result.append(level)\n}\nprint(result)\n",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is also quadratic as we need to store the entire triangle.",
            "time" : "O(n^2)",
            "timeExplanation" : "The brute-force approach calculates each element in the triangle, resulting in a quadratic time complexity."
          },
          "explanation" : "The brute-force approach calculates each row independently, resulting in repeated calculations and inefficiencies.",
          "id" : "12fd6a3b-4996-4576-bfbb-dc4dfe4d2ff3",
          "intuition" : "The brute-force approach involves calculating each row of Pascal's Triangle using the binomial coefficient formula.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]",
              "explanation" : "The first five rows of Pascal's Triangle.",
              "id" : "c6e87852-565f-427a-8aa1-018fef53ae35",
              "input" : "numRows = 5"
            },
            {
              "expectedOutput" : "[[1], [1,1], [1,2,1]]",
              "explanation" : "The first three rows of Pascal's Triangle.",
              "id" : "ba9f0b14-564a-4ff4-b9c1-6ea849dc7f7e",
              "input" : "numRows = 3"
            }
          ]
        },
        {
          "approach" : "1. Initialize the first row as [1]. 2. For each subsequent row, calculate the elements based on the previous row using the formula: C(n, k) = C(n-1, k-1) + C(n-1, k).",
          "code" : "\nlet numRows = 5\nvar result: [[Int]] = [[1]]\nfor i in 1...numRows-1 {\n    var level = [1]\n    let last = result[i-1]\n    for j in 1...last.count - 1 {\n        level.append(last[j-1] + last[j])\n    }\n    level.append(1)\n    result.append(level)\n}\nprint(result)\n",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is also quadratic as we need to store the entire triangle.",
            "time" : "O(n^2)",
            "timeExplanation" : "The optimized approach calculates each element in the triangle based on the previous row, resulting in a quadratic time complexity."
          },
          "explanation" : "The optimized approach calculates each row based on the previous row, reducing repeated calculations and improving efficiency.",
          "id" : "6733875d-0099-440a-8f0b-67d87a2078cd",
          "intuition" : "The optimized approach involves calculating each row of Pascal's Triangle using dynamic programming, where each element is calculated based on the previous row.",
          "name" : "Optimized Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]",
              "explanation" : "The first five rows of Pascal's Triangle.",
              "id" : "61f24ebb-a335-46b2-a8b8-ab113f4e2641",
              "input" : "numRows = 5"
            },
            {
              "expectedOutput" : "[[1], [1,1], [1,2,1]]",
              "explanation" : "The first three rows of Pascal's Triangle.",
              "id" : "6baf4c23-135e-4155-8194-5c88293b5687",
              "input" : "numRows = 3"
            }
          ]
        }
      ],
      "id" : "6bb6c174-38a1-45e7-ac43-0c13ad2f896d",
      "lastUpdated" : "2026-02-06T21:07:03Z",
      "problemSlug" : "pascals-triangle",
      "relatedProblems" : [
        "next-greater-element-iii",
        "minimum-cost-to-fill-given-size"
      ],
      "summary" : "Pascal's Triangle is a triangular array of the binomial coefficients where each number is the sum of the two numbers directly above it, solved using dynamic programming. This problem can be solved using a brute-force approach or optimized using dynamic programming."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the first row as [1]. For each subsequent row, start and end with 1, and for the middle elements, calculate the sum of the two elements directly above it from the previous row.",
          "code" : "func getRow(_ rowIndex: Int) -> [Int] {\n    var result: [[Int]] = [[1]]\n    for i in 1...rowIndex {\n        var row: [Int] = [1]\n        for j in 1..<i {\n            row.append(result[i-1][j-1] + result[i-1][j])\n        }\n        row.append(1)\n        result.append(row)\n    }\n    return result[rowIndex]\n}",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "We store each row up to the nth row in memory.",
            "time" : "O(n^2)",
            "timeExplanation" : "We generate each row up to the nth row. For each row, we calculate the sum of the two elements above it from the previous row."
          },
          "explanation" : "The brute force approach generates all rows up to the nth row. This can be inefficient for large values of n because it does a lot of repeated computation.",
          "id" : "6c4c1d39-eb7d-42d3-bec5-226c831f6e0a",
          "intuition" : "We can generate all rows of Pascal's Triangle up to the nth row by using the property of Pascal's Triangle where each element is the sum of the two elements directly above it.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,3,3,1]",
              "explanation" : "The 4th row of Pascal's Triangle is [1,3,3,1].",
              "id" : "41b555ca-26eb-4f24-9c86-9b4dbbd59fcb",
              "input" : "rowIndex = 3"
            },
            {
              "expectedOutput" : "[1,4,6,4,1]",
              "explanation" : "The 5th row of Pascal's Triangle is [1,4,6,4,1].",
              "id" : "f8d04aab-d0b6-43a3-94de-69fd433421cc",
              "input" : "rowIndex = 4"
            }
          ]
        },
        {
          "approach" : "Start with the first element as 1. For each subsequent element, calculate the sum of the two elements directly above it from the previous row.",
          "code" : "func getRow(_ rowIndex: Int) -> [Int] {\n    var row: [Int] = [1]\n    for _ in 1...rowIndex {\n        var newRow: [Int] = [1]\n        for i in 1..<row.count {\n            newRow.append(row[i-1] + row[i])\n        }\n        newRow.append(1)\n        row = newRow\n    }\n    return row\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We store the previous row in memory.",
            "time" : "O(n^2)",
            "timeExplanation" : "We generate the nth row by calculating the sum of the two elements above it from the previous row."
          },
          "explanation" : "The dynamic programming approach generates only the nth row of Pascal's Triangle. This can be more efficient for large values of n because it only does the computation for the nth row.",
          "id" : "fdb2f5f1-11b9-4be6-9d0e-6a5b458d2ff0",
          "intuition" : "We can use dynamic programming to generate only the nth row of Pascal's Triangle by using the property of Pascal's Triangle where each element is the sum of the two elements directly above it.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,3,3,1]",
              "explanation" : "The 4th row of Pascal's Triangle is [1,3,3,1].",
              "id" : "6315d557-cb98-4cc5-b5d9-2de5fe435ed0",
              "input" : "rowIndex = 3"
            },
            {
              "expectedOutput" : "[1,4,6,4,1]",
              "explanation" : "The 5th row of Pascal's Triangle is [1,4,6,4,1].",
              "id" : "c7af5472-9b8d-40ad-af8e-7879f2ed5dd1",
              "input" : "rowIndex = 4"
            }
          ]
        }
      ],
      "id" : "341b5814-ab06-4cb0-8ac9-1e0b6b1da2ed",
      "lastUpdated" : "2026-02-06T21:07:07Z",
      "problemSlug" : "pascals-triangle-ii",
      "relatedProblems" : [
        "pascals-triangle",
        "next-greater-element-iii"
      ],
      "summary" : "The problem asks us to generate the nth row of Pascal's Triangle. The key insight is that each element in Pascal's Triangle is the sum of the two elements directly above it."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[0] = 0\n2. For each i, dp[i] = min(dp[i - j*j] + 1) for j where j*j <= i",
          "code" : "func numSquares(_ n: Int) -> Int {\n    var dp = [Int](repeating: Int.max, count: n + 1)\n    dp[0] = 0\n    for i in 1...n {\n        var j = 1\n        while j * j <= i {\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n        }\n    }\n    return dp[n]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "DP array",
            "time" : "O(nn)",
            "timeExplanation" : "For each i, check i squares"
          },
          "explanation" : "For each number, try using each perfect square and take minimum.",
          "id" : "2a8d3193-d777-4b08-8ca2-4e0c0babbadb",
          "intuition" : "dp[n] = min squares for n. Try subtracting each square.",
          "name" : "DP",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "4+4+4=12",
              "id" : "fc9e6b6a-4f28-4893-b69a-98bc52145253",
              "input" : "n=12"
            }
          ]
        }
      ],
      "id" : "98039a77-0ff1-48af-9170-44de252a2246",
      "lastUpdated" : "2026-02-06T01:03:48.939Z",
      "problemSlug" : "perfect-squares",
      "relatedProblems" : [
        "coin-change"
      ],
      "summary" : "Find min perfect squares summing to n. DP: dp[i] = min(dp[i-j]+1) for all valid j."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Build 2D prefix sum matrix\n2. Query using inclusion-exclusion principle",
          "code" : "class NumMatrix {\n    var prefix: [[Int]]\n    \n    init(_ matrix: [[Int]]) {\n        let m = matrix.count, n = matrix[0].count\n        prefix = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n        for i in 0..<m {\n            for j in 0..<n {\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]\n            }\n        }\n    }\n    \n    func sumRegion(_ row1: Int, _ col1: Int, _ row2: Int, _ col2: Int) -> Int {\n        return prefix[row2+1][col2+1] - prefix[row1][col2+1] - prefix[row2+1][col1] + prefix[row1][col1]\n    }\n}",
          "complexity" : {
            "space" : "O(mn)",
            "spaceExplanation" : "2D prefix array",
            "time" : "O(1) query",
            "timeExplanation" : "Constant time query"
          },
          "explanation" : "Region sum = prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1]",
          "id" : "301c0d13-18bb-4663-8ad3-11de69c57c12",
          "intuition" : "prefix[i][j] = sum of rectangle (0,0) to (i-1,j-1).",
          "name" : "2D Prefix Sum",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "10",
              "explanation" : "0+1+6+3=10",
              "id" : "c0a8013f-fa46-422f-b63d-d9322c411303",
              "input" : "NumMatrix([[3,0,1],[5,6,3]]), sumRegion(0,1,1,2)"
            }
          ]
        }
      ],
      "id" : "f74592b4-b435-45cb-8203-b10d5937e4c8",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "range-sum-query-2d-immutable",
      "relatedProblems" : [
        "range-sum-query-immutable"
      ],
      "summary" : "Query sum of 2D region. Precompute 2D prefix sums."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Compute prefix sums in constructor\n2. Query: return prefix[j+1] - prefix[i]",
          "code" : "class NumArray {\n    var prefix: [Int]\n    \n    init(_ nums: [Int]) {\n        prefix = [0]\n        for num in nums {\n            prefix.append(prefix.last! + num)\n        }\n    }\n    \n    func sumRange(_ left: Int, _ right: Int) -> Int {\n        return prefix[right + 1] - prefix[left]\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Prefix array",
            "time" : "O(1) query",
            "timeExplanation" : "Constant time query"
          },
          "explanation" : "O(n) precompute, O(1) query.",
          "id" : "22018a47-1ae9-43e3-b36e-a7b74360e016",
          "intuition" : "prefixSum[j+1] - prefixSum[i] gives sum[i..j].",
          "name" : "Prefix Sum",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "-2+0+3=1",
              "id" : "97978dc8-4715-473c-9d26-e909c676998f",
              "input" : "NumArray([-2,0,3,-5,2,-1]), sumRange(0,2)"
            }
          ]
        }
      ],
      "id" : "9037f927-6f32-4270-9a6f-4e67e06cf597",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "range-sum-query-immutable",
      "relatedProblems" : [
        "range-sum-query-2d-immutable"
      ],
      "summary" : "Query sum of range [i,j]. Precompute prefix sums."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsets of items, calculate the total cost for each subset, and return the minimum cost.",
          "code" : "func shoppingOffers(price: [Int], special: [[Int]], needs: [Int]) -> Int { \n    func dfs(_ needs: [Int]) -> Int { \n        let cost = needs.enumerated().map { price[$0.offset] * $0.element }.reduce(0, +) \n        var res = cost \n        for offer in special { \n            var clone = needs \n            var valid = true \n            for i in 0..<offer.count-1 { \n                clone[i] -= offer[i] \n                if clone[i] < 0 { \n                    valid = false \n                    break \n                } \n            } \n            if valid { \n                res = min(res, dfs(clone) + offer.last!) \n            } \n        } \n        return res \n    } \n    return dfs(needs) \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we only use a fixed amount of space to store the input and the current subset.",
            "time" : "O(2^n * m)",
            "timeExplanation" : "The time complexity comes from generating all possible subsets of items and iterating over all offers."
          },
          "explanation" : "The brute force approach works by iterating over all possible subsets of items and calculating the total cost for each subset. It keeps track of the minimum cost found so far and returns it as the result.",
          "id" : "8eb7ef3a-2d8a-4406-8767-13e99f9f385a",
          "intuition" : "Try all possible combinations of items and offers to find the minimum cost.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "14",
              "explanation" : "The minimum cost is achieved by buying 1 item of price 5 and using the offer [3,0,5] to buy the remaining 2 items of price 2 at a discount.",
              "id" : "64b77963-e6de-49a3-a805-f4455b413ec8",
              "input" : "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The minimum cost is achieved by using the offer [1,1,1,0] to buy all items at a discount.",
              "id" : "43d8121f-b62b-4480-b8e6-6719dfdb2120",
              "input" : "price = [0,0,0], special = [[1,1,1,0]], needs = [2,2,2]"
            }
          ]
        },
        {
          "approach" : "Use a memoization table to store the minimum cost for each subset of items and offers.",
          "code" : "func shoppingOffers(price: [Int], special: [[Int]], needs: [Int]) -> Int { \n    var memo: [String: Int] = [:] \n    func dfs(_ needs: [Int]) -> Int { \n        let key = needs.map { String($0) }.joined(separator: \",\") \n        if let val = memo[key] { \n            return val \n        } \n        let cost = needs.enumerated().map { price[$0.offset] * $0.element }.reduce(0, +) \n        var res = cost \n        for offer in special { \n            var clone = needs \n            var valid = true \n            for i in 0..<offer.count-1 { \n                clone[i] -= offer[i] \n                if clone[i] < 0 { \n                    valid = false \n                    break \n                } \n            } \n            if valid { \n                res = min(res, dfs(clone) + offer.last!) \n            } \n        } \n        memo[key] = res \n        return res \n    } \n    return dfs(needs) \n}",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity comes from storing the memoization table.",
            "time" : "O(n * m)",
            "timeExplanation" : "The time complexity comes from iterating over all items and offers."
          },
          "explanation" : "The memoization approach works by storing the minimum cost for each subset of items and offers in a table. Before calculating the minimum cost for a subset, it checks if the result is already stored in the table. If it is, it returns the stored result; otherwise, it calculates the minimum cost and stores it in the table.",
          "id" : "e8669487-d10b-46ee-88ac-0ff7bcff6b7e",
          "intuition" : "Store the results of subproblems to avoid recalculating them and improve the efficiency of the solution.",
          "name" : "Memoization",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "14",
              "explanation" : "The minimum cost is achieved by buying 1 item of price 5 and using the offer [3,0,5] to buy the remaining 2 items of price 2 at a discount.",
              "id" : "22be8ee7-a06e-4d35-9d12-10224a1cc29a",
              "input" : "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The minimum cost is achieved by using the offer [1,1,1,0] to buy all items at a discount.",
              "id" : "b23173a8-d8b1-4ee8-a22d-37813c5cfb72",
              "input" : "price = [0,0,0], special = [[1,1,1,0]], needs = [2,2,2]"
            }
          ]
        }
      ],
      "id" : "46dff896-5a5f-4626-8c9f-3812aebc7df3",
      "lastUpdated" : "2026-02-06T21:30:09Z",
      "problemSlug" : "shopping-offers",
      "relatedProblems" : [
        "combination-sum",
        "subset-sum"
      ],
      "summary" : "This problem involves finding the minimum number of items to purchase in a shopping scenario with offers, with the key insight being the use of dynamic programming to optimize the solution. The goal is to minimize the total cost by selecting the best combination of items and offers."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays, find the minimum value in each subarray, and sum them up.",
          "code" : "func sumSubarrayMins(_ nums: [Int]) -> Int { let n = nums.count; var res = 0; for i in 0..<n { for j in i..<n { let subarray = nums[i...j]; let minVal = subarray.min()!; res += minVal } }; return res }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We are using constant space to store variables, hence the space complexity is constant.",
            "time" : "O(n^3)",
            "timeExplanation" : "We have three nested loops, hence the time complexity is cubic."
          },
          "explanation" : "This approach involves generating all possible subarrays using nested loops, then finding the minimum value in each subarray using another loop, and finally summing up these minimum values to get the total sum.",
          "id" : "fb21b624-94dc-4a47-820a-88baf18d79f2",
          "intuition" : "This approach works by generating all possible subarrays, finding the minimum value in each subarray, and summing them up.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "17",
              "explanation" : "The minimum values of all possible subarrays are 3, 1, 1, 2, 1, 4, 1, 2, 4, hence the sum is 3 + 1 + 1 + 2 + 1 + 4 + 1 + 2 + 4 = 17.",
              "id" : "0650dec8-060f-4f48-8286-d4efbbeefb31",
              "input" : "nums = [3,1,2,4]"
            },
            {
              "expectedOutput" : "444",
              "explanation" : "The minimum values of all possible subarrays are 11, 11, 81, 94, 43, 3, 11, 11, 3, 81, 3, 94, 3, 43, 3, hence the sum is 11 + 11 + 81 + 94 + 43 + 3 + 11 + 11 + 3 + 81 + 3 + 94 + 3 + 43 + 3 = 444.",
              "id" : "c4e332e9-b642-4d11-8d53-9687007d768b",
              "input" : "nums = [11,81,94,43,3]"
            }
          ]
        },
        {
          "approach" : "Maintain a monotonic stack to keep track of the indices of the elements in the array.",
          "code" : "func sumSubarrayMins(_ nums: [Int]) -> Int { let n = nums.count; var stack: [Int] = []; var res = 0; for i in 0..<n { while !stack.isEmpty && nums[stack.last!] > nums[i] { let j = stack.removeLast(); let left = stack.isEmpty ? -1 : stack.last!; let right = i; let count = (i - j) * (j - left); res += nums[j] * count }; stack.append(i) }; while !stack.isEmpty { let j = stack.removeLast(); let left = stack.isEmpty ? -1 : stack.last!; let right = n; let count = (n - j) * (j - left); res += nums[j] * count }; return res }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are using a stack to store the indices of the elements, hence the space complexity is linear.",
            "time" : "O(n)",
            "timeExplanation" : "We are iterating over the array once, hence the time complexity is linear."
          },
          "explanation" : "This approach involves maintaining a monotonic stack to keep track of the indices of the elements in the array. We iterate over the array and for each element, we pop all elements from the stack that are greater than the current element and update the sum of minimum values.",
          "id" : "6f3b5b1a-d28e-4916-8ca5-1c5ae474319b",
          "intuition" : "This approach works by maintaining a monotonic stack to keep track of the indices of the elements in the array, where the top of the stack is the index of the smallest element in the current window.",
          "name" : "Monotonic Stack",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "17",
              "explanation" : "The minimum values of all possible subarrays are 3, 1, 1, 2, 1, 4, 1, 2, 4, hence the sum is 3 + 1 + 1 + 2 + 1 + 4 + 1 + 2 + 4 = 17.",
              "id" : "94e8dfd1-a21d-4dcf-bd0d-c7098979767d",
              "input" : "nums = [3,1,2,4]"
            },
            {
              "expectedOutput" : "444",
              "explanation" : "The minimum values of all possible subarrays are 11, 11, 81, 94, 43, 3, 11, 11, 3, 81, 3, 94, 3, 43, 3, hence the sum is 11 + 11 + 81 + 94 + 43 + 3 + 11 + 11 + 3 + 81 + 3 + 94 + 3 + 43 + 3 = 444.",
              "id" : "78440582-d1d3-4e0b-8b59-eeb184d2d449",
              "input" : "nums = [11,81,94,43,3]"
            }
          ]
        }
      ],
      "id" : "39a2ebd8-0e0b-4093-8cb7-779fd23dcd18",
      "lastUpdated" : "2026-02-06T21:47:38Z",
      "problemSlug" : "sum-of-subarray-minimums",
      "relatedProblems" : [
        "minimum-size-subarray-sum",
        "subarray-sum-equals-k"
      ],
      "summary" : "The problem asks to find the sum of the minimum value of all possible subarrays in a given array, with key insight being using monotonic stack for optimization."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Calculate sum = (total + target) \/ 2\n2. If (total + target) is odd or target > total, return 0\n3. dp[i][j] = ways to get sum j using first i elements\n4. dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]] (exclude or include)\n5. Return dp[n][sum]",
          "code" : "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    let total = nums.reduce(0, +)\n    if (total + target) % 2 != 0 || abs(target) > total {\n        return 0\n    }\n    \n    let sum = (total + target) \/ 2\n    var dp = [Int](repeating: 0, count: sum + 1)\n    dp[0] = 1\n    \n    for num in nums {\n        for j in stride(from: sum, through: num, by: -1) {\n            dp[j] += dp[j - num]\n        }\n    }\n    \n    return dp[sum]\n}",
          "complexity" : {
            "space" : "O(sum)",
            "spaceExplanation" : "1D DP array of size sum+1",
            "time" : "O(n  sum)",
            "timeExplanation" : "Process each number against all possible sums"
          },
          "explanation" : "We transform the problem: instead of +\/- signs, find a subset P where sum(P) = (total + target)\/2. The remaining elements form N = total - P. Then P - N = 2P - total = target. This is a classic 0\/1 knapsack counting problem.",
          "id" : "260a898d-1c25-4543-abc3-1288b634343c",
          "intuition" : "If we assign + to some numbers and - to others: P - N = target, P + N = total. So P = (total + target) \/ 2. Count subsets summing to P.",
          "name" : "2D DP (Subset Sum)",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "5 ways: -1+1+1+1+1, +1-1+1+1+1, etc.",
              "id" : "120e9e9c-80ed-4003-9d3f-7ca488346045",
              "input" : "nums = [1,1,1,1,1], target = 3"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "Only +1 = 1",
              "id" : "c5c8e617-e174-49dd-bc5b-02ba2265370d",
              "input" : "nums = [1], target = 1"
            }
          ]
        },
        {
          "approach" : "1. DFS with parameters (index, currentSum)\n2. Base case: if index == n, return 1 if sum == target, else 0\n3. Try adding and subtracting nums[index]\n4. Memoize results",
          "code" : "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    var memo: [String: Int] = [:]\n    \n    func dfs(_ i: Int, _ sum: Int) -> Int {\n        if i == nums.count {\n            return sum == target ? 1 : 0\n        }\n        \n        let key = \"\\(i),\\(sum)\"\n        if let cached = memo[key] { return cached }\n        \n        let result = dfs(i + 1, sum + nums[i]) + dfs(i + 1, sum - nums[i])\n        memo[key] = result\n        return result\n    }\n    \n    return dfs(0, 0)\n}",
          "complexity" : {
            "space" : "O(n  totalSum)",
            "spaceExplanation" : "Memoization table for all states",
            "time" : "O(n  totalSum)",
            "timeExplanation" : "Each (index, sum) pair computed once"
          },
          "explanation" : "Direct simulation of the problem. At each step, we can add or subtract the current number. Memoization prevents exponential blowup by caching results for (index, sum) pairs we've seen.",
          "id" : "e2ca2b5b-686f-4334-a765-bc855be26b70",
          "intuition" : "Try both + and - for each number. Memoize (index, currentSum) to avoid recomputation.",
          "name" : "Memoized DFS",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "Same result via memoized recursion",
              "id" : "136e7ff9-fd92-4a01-a031-11fc93062b05",
              "input" : "nums = [1,1,1,1,1], target = 3"
            }
          ]
        }
      ],
      "id" : "8b7cef2d-6ed2-4b23-96fd-7b7de1042385",
      "lastUpdated" : "2026-02-06T00:53:56.092Z",
      "problemSlug" : "target-sum",
      "relatedProblems" : [
        "partition-equal-subset-sum",
        "last-stone-weight-ii"
      ],
      "summary" : "Find number of ways to assign + or - to elements to reach target sum. Use DP: convert to subset sum problem where we find subsets summing to (total + target) \/ 2."
    },
    {
      "approaches" : [
        {
          "approach" : "Start from the top of the triangle and for each number, try moving to the left and right child and recursively calculate the minimum path sum.",
          "code" : "\nfunc minimumTotal(_ triangle: [[Int]]) -> Int {\n    let n = triangle.count\n    func dfs(_ row: Int, _ col: Int) -> Int {\n        if row == n - 1 {\n            return triangle[row][col]\n        }\n        return triangle[row][col] + min(dfs(row + 1, col), dfs(row + 1, col + 1))\n    }\n    return dfs(0, 0)\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the recursive call stack.",
            "time" : "O(2^n)",
            "timeExplanation" : "The time complexity is O(2^n) due to the recursive calls."
          },
          "explanation" : "The brute force approach has an exponential time complexity due to the overlapping subproblems. It can be optimized using memoization or dynamic programming.",
          "id" : "aa1be02e-d371-4978-b8aa-90647a498e98",
          "intuition" : "This approach works by trying all possible paths and keeping track of the minimum path sum.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "The minimum path sum is 2 + 3 + 5 + 1 = 11",
              "id" : "29dd26de-3f10-44da-8d4e-4eda2d52d601",
              "input" : "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]"
            },
            {
              "expectedOutput" : "-10",
              "explanation" : "The minimum path sum is -10",
              "id" : "d99c4eb8-bdea-4999-ba2f-c379ffaaf4bb",
              "input" : "triangle = [[-10]]"
            }
          ]
        },
        {
          "approach" : "Start from the bottom of the triangle and for each number, update the minimum path sum by taking the minimum of the two numbers above it and adding the current number.",
          "code" : "\nfunc minimumTotal(_ triangle: [[Int]]) -> Int {\n    let n = triangle.count\n    var dp = triangle.last!\n    for i in stride(from: n - 2, to: -1, by: -1) {\n        for j in 0..<triangle[i].count {\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        }\n    }\n    return dp[0]\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the dynamic programming array.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) due to the nested loops."
          },
          "explanation" : "The dynamic programming approach has a linear time complexity due to the bottom-up iteration.",
          "id" : "b8c75c7e-dfdf-4287-81d4-e878868c0085",
          "intuition" : "This approach works by using dynamic programming to track the minimum path sum at each position.",
          "name" : "Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "11",
              "explanation" : "The minimum path sum is 2 + 3 + 5 + 1 = 11",
              "id" : "f7889481-b3d7-4883-a1d6-e864cb3647a9",
              "input" : "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]"
            },
            {
              "expectedOutput" : "-10",
              "explanation" : "The minimum path sum is -10",
              "id" : "4a356a36-bf34-4000-8218-666335d29209",
              "input" : "triangle = [[-10]]"
            }
          ]
        }
      ],
      "id" : "c49e5a57-f304-4e2f-9fa1-692821cfe14f",
      "lastUpdated" : "2026-02-06T21:07:11Z",
      "problemSlug" : "triangle",
      "relatedProblems" : [
        "HouseRobber",
        "UniquePaths"
      ],
      "summary" : "The Triangle problem involves finding the minimum path sum from the top to the bottom of a triangle, where each step can move to the adjacent number. The key insight is to use dynamic programming to track the minimum path sum at each position."
    },
    {
      "approaches" : [
        {
          "approach" : "Start by generating all possible binary trees with the given number of nodes, then for each tree, check if the tree satisfies the binary search tree property.",
          "code" : "class Solution { \n    func generateTrees(_ n: Int) -> [TreeNode?] { \n        return generateTreesHelper(1, n) \n    } \n\n    private func generateTreesHelper(_ start: Int, _ end: Int) -> [TreeNode?] { \n        if start > end { \n            return [nil] \n        } \n        var result: [TreeNode?] = [] \n        for i in start...end { \n            let leftSubtrees = generateTreesHelper(start, i - 1) \n            let rightSubtrees = generateTreesHelper(i + 1, end) \n            for leftSubtree in leftSubtrees { \n                for rightSubtree in rightSubtrees { \n                    let root = TreeNode(i) \n                    root.left = leftSubtree \n                    root.right = rightSubtree \n                    result.append(root) \n                } \n            } \n        } \n        return result \n    } \n}",
          "complexity" : {
            "space" : "O(4^n \/ n^(3\/2))",
            "spaceExplanation" : "The space complexity is also due to the number of unique binary search trees that need to be stored in the result.",
            "time" : "O(4^n \/ n^(3\/2))",
            "timeExplanation" : "The time complexity is due to the number of unique binary search trees, which is approximately given by the nth Catalan number."
          },
          "explanation" : "To generate all possible binary trees, we can use a recursive approach where we try to place each node as the root, and recursively generate the left and right subtrees. Then we check if each tree satisfies the binary search tree property by performing an in-order traversal and checking if the elements are in ascending order.",
          "id" : "c2bf06bc-f953-441e-a153-267ae53317a6",
          "intuition" : "This approach involves generating all possible binary trees and then filtering out the ones that do not satisfy the binary search tree property.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
              "explanation" : "The output is all unique binary search trees with 3 nodes.",
              "id" : "267967ac-b6d8-4ef5-8c3a-a99b7aaa15fa",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "[[1]]",
              "explanation" : "The output is a single node tree, which is the only possible unique binary search tree with 1 node.",
              "id" : "ecb39d00-3136-46f0-bd92-04d175f25812",
              "input" : "n = 1"
            }
          ]
        },
        {
          "approach" : "We use a recursive approach with memoization to store the results of subproblems. We define a recursive function that generates all unique binary search trees for a given range of nodes, and store the results in a memoization table to avoid redundant computation.",
          "code" : "class Solution { \n    func generateTrees(_ n: Int) -> [TreeNode?] { \n        var memo: [[TreeNode?]] = Array(repeating: [], count: n + 1) \n        return generateTreesHelper(1, n, &memo) \n    } \n\n    private func generateTreesHelper(_ start: Int, _ end: Int, _ memo: inout [[TreeNode?]]) -> [TreeNode?] { \n        if start > end { \n            return [nil] \n        } \n        if !memo[start].isEmpty { \n            return memo[start] \n        } \n        var result: [TreeNode?] = [] \n        for i in start...end { \n            let leftSubtrees = generateTreesHelper(start, i - 1, &memo) \n            let rightSubtrees = generateTreesHelper(i + 1, end, &memo) \n            for leftSubtree in leftSubtrees { \n                for rightSubtree in rightSubtrees { \n                    let root = TreeNode(i) \n                    root.left = leftSubtree \n                    root.right = rightSubtree \n                    result.append(root) \n                } \n            } \n        } \n        memo[start] = result \n        return result \n    } \n}",
          "complexity" : {
            "space" : "O(4^n \/ n^(3\/2))",
            "spaceExplanation" : "The space complexity is also due to the number of unique binary search trees that need to be stored in the result and the memoization table.",
            "time" : "O(4^n \/ n^(3\/2))",
            "timeExplanation" : "The time complexity is due to the number of unique binary search trees, which is approximately given by the nth Catalan number."
          },
          "explanation" : "We start by initializing a memoization table to store the results of subproblems. Then we define a recursive function that generates all unique binary search trees for a given range of nodes. We use the memoization table to store the results of subproblems to avoid redundant computation.",
          "id" : "932c1f4d-1d95-4310-a761-9bc32f865b5a",
          "intuition" : "This approach involves using dynamic programming to store the results of subproblems to avoid redundant computation.",
          "name" : "Optimized Dynamic Programming Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
              "explanation" : "The output is all unique binary search trees with 3 nodes.",
              "id" : "90f0acfd-a88a-4e8c-8e86-d7c800d07af2",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "[[1]]",
              "explanation" : "The output is a single node tree, which is the only possible unique binary search tree with 1 node.",
              "id" : "aa1d3636-105e-47ba-b0b0-215f4f2c0e78",
              "input" : "n = 1"
            }
          ]
        }
      ],
      "id" : "ec542e9a-71c8-45d8-bec6-cff0dee02c85",
      "lastUpdated" : "2026-02-06T21:06:09Z",
      "problemSlug" : "unique-binary-search-trees-ii",
      "relatedProblems" : [
        "unique-binary-search-trees",
        "binary-tree-paths"
      ],
      "summary" : "The problem asks for all unique binary search trees that can be formed with a given number of nodes. Key insight is using dynamic programming and recursion to generate all possible unique binary search trees."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[i][j] = number of paths to reach (i,j)\n2. First row and column are all 1s\n3. dp[i][j] = dp[i-1][j] + dp[i][j-1]\n4. Return dp[m-1][n-1]",
          "code" : "func uniquePaths(_ m: Int, _ n: Int) -> Int {\n    var dp = [Int](repeating: 1, count: n)\n    \n    for _ in 1..<m {\n        for j in 1..<n {\n            dp[j] += dp[j-1]\n        }\n    }\n    \n    return dp[n-1]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Single row DP",
            "time" : "O(m*n)",
            "timeExplanation" : "Fill m*n cells"
          },
          "explanation" : "Can only come from above or left. Sum both possibilities. Optimize to O(n) space with single row.",
          "id" : "550e8400-e29b-41d4-a716-446655440151",
          "intuition" : "Paths to (i,j) = paths to (i-1,j) + paths to (i,j-1). Fill grid row by row.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "28",
              "explanation" : "28 unique paths",
              "id" : "550e8400-e29b-41d4-a716-446655440257",
              "input" : "m = 3, n = 7"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440040",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "unique-paths",
      "relatedProblems" : [
        "unique-paths-ii",
        "minimum-path-sum"
      ],
      "summary" : "Count paths in grid moving only right\/down. DP or combinatorics: C(m+n-2, m-1)."
    },
    {
      "approaches" : [
        {
          "approach" : "Start at the top-left corner, explore all possible paths by moving right or down, and avoid obstacles. At each step, if a path avoids obstacles, increment the count of unique paths.",
          "code" : "func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int { \n let m = obstacleGrid.count \n let n = obstacleGrid[0].count \n func helper(_ i: Int, _ j: Int) -> Int { \n if i == m || j == n { return 0 } \n if obstacleGrid[i][j] == 1 { return 0 } \n if i == m-1 && j == n-1 { return 1 } \n return helper(i+1, j) + helper(i, j+1) \n } \n return helper(0, 0) \n }",
          "complexity" : {
            "space" : "O(m+n)",
            "spaceExplanation" : "The space complexity is linear due to the recursive call stack.",
            "time" : "O(2^(m+n))",
            "timeExplanation" : "The time complexity is exponential because the recursive approach tries all possible paths."
          },
          "explanation" : "The brute force approach tries all possible paths, but it has exponential time complexity and is not efficient for large grids.",
          "id" : "cf01ef4f-01c2-4483-b519-e815dc6a3bd8",
          "intuition" : "This approach works by recursively exploring all possible paths and counting the number of unique paths that avoid obstacles.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "There are two unique paths: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2).",
              "id" : "c85c01cc-d1fd-4705-b628-e7ab7a35aae2",
              "input" : "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There is only one unique path: (0,0) -> (1,0) -> (1,1).",
              "id" : "ac7ca0cc-7112-4d2e-9a3e-1ce19b67de45",
              "input" : "obstacleGrid = [[0,1],[0,0]]"
            }
          ]
        },
        {
          "approach" : "Create a 2D array dp where dp[i][j] is the number of unique paths to cell (i, j). Initialize the first row and column based on the presence of obstacles. Then, fill in the rest of the array using the formula dp[i][j] = dp[i-1][j] + dp[i][j-1].",
          "code" : "func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int { \n let m = obstacleGrid.count \n let n = obstacleGrid[0].count \n var dp = Array(repeating: Array(repeating: 0, count: n), count: m) \n for i in 0..<m { \n for j in 0..<n { \n if obstacleGrid[i][j] == 1 { \n continue \n } \n if i == 0 && j == 0 { \n dp[i][j] = 1 \n } else if i == 0 { \n dp[i][j] = dp[i][j-1] \n } else if j == 0 { \n dp[i][j] = dp[i-1][j] \n } else { \n dp[i][j] = dp[i-1][j] + dp[i][j-1] \n } \n } \n } \n return dp[m-1][n-1] \n }",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "The space complexity is polynomial because we need to store the 2D array.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is polynomial because we are filling in a 2D array."
          },
          "explanation" : "The dynamic programming approach is more efficient because it avoids redundant calculations and has a polynomial time complexity.",
          "id" : "df938614-690f-457f-b2db-76695c9d7aa5",
          "intuition" : "This approach works by creating a 2D array to store the number of unique paths to each cell and using bottom-up dynamic programming to fill in the array.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "There are two unique paths: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2).",
              "id" : "5caa9155-f416-4727-a18e-25dc8b1611ed",
              "input" : "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There is only one unique path: (0,0) -> (1,0) -> (1,1).",
              "id" : "8e6394f5-958b-4b17-9fcf-1699b16523fb",
              "input" : "obstacleGrid = [[0,1],[0,0]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no unique paths because the middle row is blocked by obstacles.",
              "id" : "5d79a025-3881-462d-a7b0-c43b2bbec591",
              "input" : "obstacleGrid = [[0,0],[1,1],[0,0]]"
            }
          ]
        }
      ],
      "id" : "cdca5e34-a26f-4e19-9693-078e984f3988",
      "lastUpdated" : "2026-02-06T21:05:03Z",
      "problemSlug" : "unique-paths-ii",
      "relatedProblems" : [
        "unique-paths",
        "minimum-path-sum"
      ],
      "summary" : "This problem involves finding the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles. The key insight is using dynamic programming to track the paths and handle obstacles by setting their corresponding cell to 0."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a function to generate all substrings, then iterate through the input string to create substrings of all lengths and keep track of unique ones using a set.",
          "code" : "\nfunc findSubstringInWraproundString(p: String) -> Int {\n    var uniqueSubstrings = Set<String>()\n    for length in 1...p.count {\n        for i in 0...(p.count - length) {\n            let substring = String(p.prefix(length + i).suffix(length))\n            uniqueSubstrings.insert(substring)\n        }\n    }\n    return uniqueSubstrings.count\n}\n",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "We store all unique substrings, which in the worst case could be all substrings if no duplicates exist.",
            "time" : "O(n^3)",
            "timeExplanation" : "We're generating all substrings which is O(n^2) and then checking each for uniqueness which adds another factor of n."
          },
          "explanation" : "This method involves creating all possible substrings, checking for uniqueness, and counting them. However, due to its brute force nature, it is not efficient for large strings.",
          "id" : "935ee458-a049-4fb2-9658-f1823dbfed85",
          "intuition" : "Generate all possible substrings and keep track of unique ones. This approach works but is inefficient due to the high number of duplicate substrings that must be checked.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "There's only one substring, 'a' itself.",
              "id" : "b4dd6ce6-3e7f-447a-9074-5dc337e15d04",
              "input" : "a"
            },
            {
              "expectedOutput" : "28",
              "explanation" : "Counting all unique substrings gives us 28.",
              "id" : "af56a635-e4df-46b9-bedb-92f215a1e29b",
              "input" : "abcdefg"
            }
          ]
        },
        {
          "approach" : "Use a dynamic programming table to keep track of the longest substring ending at each character that can be extended by one more character in a circular manner. Update the count of unique substrings accordingly.",
          "code" : "\nfunc findSubstringInWraproundString(_ p: String) -> Int {\n    let n = p.count\n    var dp = Array(repeating: 0, count: 26)\n    var maxLength = 0\n    for (i, char) in p.enumerated() {\n        let currCharIndex = char.asciiValue! - 97\n        if i == 0 || (currCharIndex + 26 - (p[p.index(p.startIndex, offsetBy: i - 1)].asciiValue! - 97)) % 26 != 1 {\n            maxLength = 0\n        }\n        maxLength += 1\n        dp[Int(currCharIndex)] = max(dp[Int(currCharIndex)], maxLength)\n    }\n    return dp.reduce(0) { $0 + $1 }\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a fixed-size array to store the lengths of the longest substrings ending at each character, which does not scale with input size.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate through the string once, giving us linear time complexity."
          },
          "explanation" : "This optimized method considers the circular nature of the alphabet and counts unique substrings ending at each position with dynamic programming, significantly reducing the computational complexity.",
          "id" : "de485f81-f580-4565-a4b5-bf3edf50c82d",
          "intuition" : "This approach involves using dynamic programming to efficiently count unique substrings by considering the wraparound nature of the string and the fact that a substring can only be unique if it ends with a character that is one position ahead in a circular alphabet.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "6",
              "explanation" : "Substrings 'z', 'a', 'b', 'za', 'ab', 'zab' are all unique.",
              "id" : "54bc692f-bd8e-49a4-a83b-fa6415d84c96",
              "input" : "zab"
            },
            {
              "expectedOutput" : "28",
              "explanation" : "There are 28 unique substrings in total.",
              "id" : "017478f2-b175-4267-a0c1-42c1c61b6331",
              "input" : "abcdefg"
            }
          ]
        }
      ],
      "id" : "5f9bcc6f-1d69-45cf-a519-7f723ca73c2f",
      "lastUpdated" : "2026-02-06T21:20:44Z",
      "problemSlug" : "unique-substrings-in-wraparound-string",
      "relatedProblems" : [
        "substring-with-concatenation-of-all-words",
        "find-all-anagrams-in-a-string"
      ],
      "summary" : "Given a string, find the number of unique substrings of a certain length that can be formed by wrapping the string around itself. The key insight is to recognize that the string can be treated as a circular sequence, allowing for the creation of additional unique substrings beyond the standard linear approach."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible strings by replacing * with either open or close parentheses. Check each generated string for validity.",
          "code" : "\nfunc checkValidString(_ s: String) -> Bool {\n    let chars = Array(s)\n    var openStack: [Int] = [], starStack: [Int] = []\n    \n    for (i, c) in chars.enumerated() {\n        if c == \"(\" {\n            openStack.append(i)\n        } else if c == \"*\" {\n            starStack.append(i)\n        } else if c == \")\" {\n            if !openStack.isEmpty {\n                openStack.removeLast()\n            } else if !starStack.isEmpty {\n                starStack.removeLast()\n            } else {\n                return false\n            }\n        }\n    }\n    \n    while !openStack.isEmpty && !starStack.isEmpty {\n        if openStack.last! > starStack.last! {\n            return false\n        }\n        openStack.removeLast()\n        starStack.removeLast()\n    }\n    \n    return openStack.isEmpty\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Two stacks can hold up to n characters where n is the length of the string.",
            "time" : "O(n)",
            "timeExplanation" : "We are iterating over the string once and using two stacks which in the worst case can store all characters."
          },
          "explanation" : "For each *, there are two possibilities: it can be either an open or a close parenthesis. This approach checks all these possibilities.",
          "id" : "aaff1898-ba12-49d3-825e-7590f4c468bf",
          "intuition" : "Try all possible combinations of open and close parentheses for *.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "True",
              "explanation" : "The * can act as either an open or a close parenthesis.",
              "id" : "d5f77537-bc34-4cd7-8a5a-7d818a2abfe4",
              "input" : "s = \"(*)\""
            },
            {
              "expectedOutput" : "False",
              "explanation" : "Regardless of how * is used, the last close parenthesis will not have a matching open parenthesis.",
              "id" : "158e53c8-0f19-48e9-8e9d-85d0beaeb5c7",
              "input" : "s = \"(*)*)\""
            }
          ]
        },
        {
          "approach" : "Iterate over the string and maintain two counts: minOpen and maxOpen. Update these counts based on whether we encounter an open parenthesis, a close parenthesis, or a star.",
          "code" : "\nfunc checkValidString(_ s: String) -> Bool {\n    let chars = Array(s)\n    var minOpen = 0, maxOpen = 0\n    \n    for c in chars {\n        if c == \"(\" {\n            minOpen += 1\n            maxOpen += 1\n        } else if c == \")\" {\n            if minOpen > 0 {\n                minOpen -= 1\n            }\n            if maxOpen > 0 {\n                maxOpen -= 1\n            }\n        } else {\n            minOpen = max(minOpen - 1, 0)\n            maxOpen += 1\n        }\n        \n        if minOpen < 0 {\n            return false\n        }\n    }\n    \n    return minOpen == 0\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the minOpen and maxOpen counts.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate through the string once."
          },
          "explanation" : "minOpen represents the minimum number of open parentheses we could have at any point (e.g., if we've closed more than we've opened because of * acting as a close), and maxOpen represents the maximum (if * always acts as an open). If minOpen is negative at any point, the string cannot be valid.",
          "id" : "b17b6832-495d-4a13-9f21-1535460c22db",
          "intuition" : "Use two pointers to track the minimum and maximum possible open parentheses count at each position.",
          "name" : "Two Pointer Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "True",
              "explanation" : "This string can be made valid by strategically using the * characters.",
              "id" : "943c1a2c-e4ae-4a72-89eb-d627156efc0b",
              "input" : "s = \"(**())\""
            },
            {
              "expectedOutput" : "True",
              "explanation" : "All three * can act as open parentheses, and since there are none to close, it remains valid.",
              "id" : "ee3aea7b-fdbc-465b-a6ee-80be4ba1c714",
              "input" : "s = \"(***)\""
            }
          ]
        }
      ],
      "id" : "3c3f090c-27db-4011-ac6a-458255509283",
      "lastUpdated" : "2026-02-06T21:33:15Z",
      "problemSlug" : "valid-parenthesis-string",
      "relatedProblems" : [
        "valid-palindrome",
        "min-remove-to-make-valid-parentheses"
      ],
      "summary" : "Given a string containing only parentheses and *, return whether the string is valid. The key insight is understanding how * can act as an open or close parenthesis to make a string valid."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Sort the clips based on their start time. 2. Use a recursive function to try all possible combinations of clips. 3. Keep track of the combination that covers the entire duration with the fewest number of clips.",
          "code" : "func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear due to the recursive call stack.",
            "time" : "O(2^n)",
            "timeExplanation" : "The time complexity is exponential due to the recursive nature of the solution."
          },
          "explanation" : "This approach is not efficient and has exponential time complexity due to the recursive nature of the solution.",
          "id" : "3dee4a4b-484e-4643-9c93-04f36a62baef",
          "intuition" : "This approach works by trying all possible combinations of clips and selecting the combination that covers the entire duration with the fewest number of clips.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The clips [0,2], [4,6], and [8,10] can be used to cover the entire duration.",
              "id" : "061979d8-49ab-4b9a-8598-fb467d0e3804",
              "input" : "clips = [[0,2],[4,6],[8,10],[1,9]], T = 9"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The clips [0,4] and [2,8] can be used to cover the entire duration.",
              "id" : "94578f14-9658-442d-b86b-87bd0f4dd3e6",
              "input" : "clips = [[0,4],[2,8]], T = 5"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no combination of clips that can cover the entire duration.",
              "id" : "58f54f8d-b7cd-4f0b-8148-5d6fc9529f67",
              "input" : "clips = [[1,2]], T = 3"
            }
          ]
        },
        {
          "approach" : "1. Sort the clips based on their start time. 2. Initialize the result and the current end time. 3. Iterate through the sorted clips and update the result and the current end time accordingly.",
          "code" : "func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear due to the input clips.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is linear due to the sorting of the clips."
          },
          "explanation" : "This approach is efficient and has linear time complexity due to the greedy nature of the solution.",
          "id" : "8d677f58-c423-46ef-b64b-0055ce703693",
          "intuition" : "This approach works by always selecting the clip that covers the most new duration and has the earliest end time.",
          "name" : "Greedy",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The clips [0,2], [4,6], and [8,10] can be used to cover the entire duration.",
              "id" : "6161d7a6-bea4-4003-98f0-9bfa65bd91a0",
              "input" : "clips = [[0,2],[4,6],[8,10],[1,9]], T = 9"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The clips [0,4] and [2,8] can be used to cover the entire duration.",
              "id" : "b49335ed-7bc5-49b4-82f3-4bd80b27b67c",
              "input" : "clips = [[0,4],[2,8]], T = 5"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no combination of clips that can cover the entire duration.",
              "id" : "d27e4bfd-ac63-401e-a9fd-811d6529212b",
              "input" : "clips = [[1,2]], T = 3"
            }
          ]
        }
      ],
      "id" : "21197a2f-5339-4c36-971a-f2399cbd44bd",
      "lastUpdated" : "2026-02-06T21:56:36Z",
      "problemSlug" : "video-stitching",
      "relatedProblems" : [
        "minimum-window-substring",
        "jump-game-ii"
      ],
      "summary" : "The Video Stitching problem involves stitching together video segments to cover a certain duration, and the key insight is to use a greedy approach to minimize the number of clips used."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subsequences of the given array. For each subsequence, check if it is a wiggle subsequence. Keep track of the longest wiggle subsequence found.",
          "code" : "func wiggleMaxLength(_ nums: [Int]) -> Int {\n    if nums.count < 2 {\n        return nums.count\n    }\n    var longest = 1\n    for i in 0..<nums.count {\n        for j in i+1..<nums.count {\n            var curr = [nums[i]]\n            curr.append(nums[j])\n            var k = j + 1\n            while k < nums.count {\n                if curr.last! < nums[k] {\n                    curr.append(nums[k])\n                    k += 1\n                } else if curr.last! > nums[k] {\n                    curr.append(nums[k])\n                    k += 1\n                } else {\n                    k += 1\n                }\n            }\n            if curr.count > longest {\n                longest = curr.count\n            }\n        }\n    }\n    return longest\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from storing the longest wiggle subsequence found, which takes O(n) space.",
            "time" : "O(2^n * n)",
            "timeExplanation" : "The time complexity comes from generating all possible subsequences of the given array, which has a time complexity of O(2^n). For each subsequence, we check if it is a wiggle subsequence, which takes O(n) time."
          },
          "explanation" : "This approach generates all possible subsequences of the given array and checks each one to see if it is a wiggle subsequence. It keeps track of the longest wiggle subsequence found and returns its length.",
          "id" : "16433ff4-f865-4d0c-967e-5f43aeb11020",
          "intuition" : "We can check all possible subsequences of the given array to find the longest wiggle subsequence. This approach is straightforward but inefficient.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "The longest wiggle subsequence is [1,17,5,10,13,10,16].",
              "id" : "6e79253c-1230-4abe-b95a-a913a6927549",
              "input" : "nums = [1,17,5,10,13,15,10,5,16,8]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The longest wiggle subsequence is [1,2] or [2,3] or [3,4] and so on.",
              "id" : "7fbdf920-b2c8-4829-9981-d8b514554d02",
              "input" : "nums = [1,2,3,4,5,6,7,8,9]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The longest wiggle subsequence is [1].",
              "id" : "1a673caa-eb63-42c5-a05a-560a13bf06be",
              "input" : "nums = [1,1,1,1,1,1,1,1,1]"
            }
          ]
        },
        {
          "approach" : "Initialize two arrays, up and down, of the same length as the given array. Iterate over the array and for each number, update up[i] and down[i] based on the previous numbers.",
          "code" : "func wiggleMaxLength(_ nums: [Int]) -> Int {\n    if nums.count < 2 {\n        return nums.count\n    }\n    var up = Array(repeating: 1, count: nums.count)\n    var down = Array(repeating: 1, count: nums.count)\n    for i in 1..<nums.count {\n        for j in 0..<i {\n            if nums[i] > nums[j] {\n                up[i] = max(up[i], down[j] + 1)\n            } else if nums[i] < nums[j] {\n                down[i] = max(down[i], up[j] + 1)\n            }\n        }\n    }\n    return max(up.max() ?? 0, down.max() ?? 0)\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity comes from storing the up and down arrays, which takes O(n) space.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity comes from iterating over the array and for each number, updating up[i] and down[i] based on the previous numbers, which takes O(n^2) time."
          },
          "explanation" : "This approach uses dynamic programming to efficiently find the longest wiggle subsequence. It maintains two arrays, up and down, where up[i] and down[i] represent the length of the longest wiggle subsequence ending at index i with the last number being greater than or less than its neighboring number.",
          "id" : "8b254daa-4810-4541-b4b4-f530a304cd2b",
          "intuition" : "We can use dynamic programming to solve this problem efficiently. The idea is to maintain two arrays, up and down, where up[i] and down[i] represent the length of the longest wiggle subsequence ending at index i with the last number being greater than or less than its neighboring number.",
          "name" : "Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "The longest wiggle subsequence is [1,17,5,10,13,10,16].",
              "id" : "25716778-bf15-4d10-8ccb-df99318cd4c5",
              "input" : "nums = [1,17,5,10,13,15,10,5,16,8]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The longest wiggle subsequence is [1,2] or [2,3] or [3,4] and so on.",
              "id" : "0b7adff3-7536-4ebf-b0de-d513bb4319af",
              "input" : "nums = [1,2,3,4,5,6,7,8,9]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The longest wiggle subsequence is [1].",
              "id" : "dba01028-8b5d-43cc-a87f-59d4abb108de",
              "input" : "nums = [1,1,1,1,1,1,1,1,1]"
            }
          ]
        }
      ],
      "id" : "99b7114c-5dd5-45dc-a5ed-cd211d48b0b2",
      "lastUpdated" : "2026-02-06T21:14:48Z",
      "problemSlug" : "wiggle-subsequence",
      "relatedProblems" : [
        "subarray-sums",
        "max-subarray"
      ],
      "summary" : "The problem asks us to find the length of the longest wiggle subsequence in a given array, where a wiggle subsequence is a sequence of numbers such that each number is either greater than or less than its neighboring number. The key insight here is to track the longest wiggle subsequence ending with an up wiggle and a down wiggle separately."
    },
    {
      "approaches" : [
        {
          "approach" : "1. dp[0] = true (empty string)\n2. For each i, check all j < i\n3. If dp[j] && s[j..i-1] in dict: dp[i] = true",
          "code" : "func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n    let words = Set(wordDict)\n    let chars = Array(s)\n    let n = chars.count\n    var dp = [Bool](repeating: false, count: n + 1)\n    dp[0] = true\n    \n    for i in 1...n {\n        for j in 0..<i {\n            if dp[j] && words.contains(String(chars[j..<i])) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    \n    return dp[n]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "DP array",
            "time" : "O(n * m)",
            "timeExplanation" : "n pairs, O(m) string comparison"
          },
          "explanation" : "Build up: if we can segment up to j, and j..i is a word, we can segment up to i.",
          "id" : "550e8400-e29b-41d4-a716-446655440145",
          "intuition" : "dp[i] is true if some dp[j] is true and s[j..i-1] is a word. Check all split points.",
          "name" : "Dynamic Programming",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "leet + code",
              "id" : "550e8400-e29b-41d4-a716-446655440251",
              "input" : "s = \"leetcode\", wordDict = [\"leet\",\"code\"]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440034",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "word-break",
      "relatedProblems" : [
        "word-break-ii"
      ],
      "summary" : "Check if string can be segmented into dictionary words. DP: dp[i] = can segment s[0..i-1]."
    }
  ],
  "topic" : "dynamic-programming",
  "version" : "2.0.0"
}