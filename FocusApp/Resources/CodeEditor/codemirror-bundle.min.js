/**
 * CodeMirrorEditor â€” Lightweight code editor for FocusApp iOS
 *
 * A self-contained code editor using a textarea + overlay approach.
 * The textarea handles all native input (including iOS keyboard, selection,
 * autocorrect, undo/redo), while a <pre> overlay renders syntax-highlighted HTML.
 *
 * Architecture:
 *   [.cm-editor]
 *     [.cm-gutter]           <- line numbers
 *     [.cm-content-wrapper]
 *       [.cm-active-line-bg] <- active line highlight
 *       [.cm-placeholder]    <- placeholder text
 *       [.cm-highlight-layer <- <pre> with highlighted HTML
 *       [.cm-input-layer]    <- <textarea> for input (transparent text, visible caret)
 *     [.cm-search-overlay]   <- search bar (shown on Cmd+F)
 */

;(function(global) {
    "use strict";

    // =========================================================================
    // Syntax Definitions
    // =========================================================================

    var LANGUAGES = {
        swift: {
            keywords: new Set([
                "func", "var", "let", "if", "else", "for", "while", "return",
                "class", "struct", "enum", "protocol", "import", "guard",
                "switch", "case", "break", "continue", "do", "try", "catch",
                "throw", "throws", "async", "await", "in", "where", "nil",
                "true", "false", "self", "Self", "super", "init", "deinit",
                "typealias", "extension", "public", "private", "internal",
                "fileprivate", "open", "static", "override", "mutating",
                "inout", "weak", "unowned", "lazy", "final", "required",
                "convenience", "optional", "some", "any", "repeat", "defer",
                "associatedtype", "precedencegroup", "operator", "indirect",
                "is", "as", "default", "fallthrough", "subscript", "get",
                "set", "willSet", "didSet", "rethrows", "dynamic", "prefix",
                "postfix", "infix", "nonisolated", "consuming", "borrowing",
                "actor", "isolated", "sending"
            ]),
            types: new Set([
                "Int", "String", "Bool", "Double", "Float", "Array",
                "Dictionary", "Set", "Optional", "Character", "UInt",
                "Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16",
                "UInt32", "UInt64", "Void", "Never", "Any", "AnyObject",
                "Error", "Result", "Codable", "Hashable", "Equatable",
                "Comparable", "Identifiable", "Sendable", "Collection",
                "Sequence", "IteratorProtocol", "CustomStringConvertible",
                "Data", "URL", "Date", "IndexPath", "CGFloat", "CGPoint",
                "CGSize", "CGRect", "Task", "MainActor"
            ]),
            builtins: new Set([
                "print", "debugPrint", "fatalError", "precondition",
                "preconditionFailure", "assert", "assertionFailure",
                "min", "max", "abs", "stride", "zip", "enumerate",
                "map", "filter", "reduce", "sorted", "reversed",
                "contains", "compactMap", "flatMap", "forEach",
                "type", "unsafeBitCast", "withUnsafePointer",
                "MemoryLayout", "Mirror", "dump"
            ]),
            singleLineComment: "//",
            multiLineCommentStart: "/*",
            multiLineCommentEnd: "*/",
            stringDelimiters: ['"'],
            multiLineStringDelimiter: '"""',
            hasInterpolation: true,
            interpolationPattern: /\\$\(/,
            decoratorPrefix: "@"
        },
        python: {
            keywords: new Set([
                "def", "class", "if", "elif", "else", "for", "while",
                "return", "import", "from", "as", "try", "except",
                "finally", "raise", "with", "yield", "lambda", "pass",
                "break", "continue", "and", "or", "not", "is", "in",
                "True", "False", "None", "global", "nonlocal", "assert",
                "del", "async", "await", "match", "case"
            ]),
            types: new Set([
                "int", "str", "float", "bool", "list", "dict", "set",
                "tuple", "range", "type", "object", "bytes", "bytearray",
                "complex", "frozenset", "memoryview", "property",
                "staticmethod", "classmethod", "super"
            ]),
            builtins: new Set([
                "print", "input", "len", "range", "enumerate", "zip",
                "map", "filter", "sorted", "reversed", "min", "max",
                "sum", "abs", "round", "isinstance", "issubclass",
                "hasattr", "getattr", "setattr", "delattr", "callable",
                "iter", "next", "open", "id", "hash", "repr", "str",
                "int", "float", "bool", "list", "dict", "set", "tuple",
                "format", "chr", "ord", "hex", "oct", "bin", "pow",
                "divmod", "any", "all", "vars", "dir", "help",
                "breakpoint", "compile", "eval", "exec", "globals",
                "locals", "__import__"
            ]),
            singleLineComment: "#",
            multiLineCommentStart: null,
            multiLineCommentEnd: null,
            stringDelimiters: ['"', "'"],
            multiLineStringDelimiter: '"""',
            multiLineStringDelimiterAlt: "'''",
            hasInterpolation: false,
            decoratorPrefix: "@"
        }
    };

    // =========================================================================
    // Tokenizer
    // =========================================================================

    /**
     * Tokenizes a single line of code into spans for syntax highlighting.
     * Returns an array of { text, cls } objects where cls is the CSS class suffix.
     *
     * @param {string} line - The source line
     * @param {object} langDef - Language definition from LANGUAGES
     * @param {object} state - Mutable state carried across lines for multi-line constructs
     * @returns {{ tokens: Array<{text:string, cls:string}>, state: object }}
     */
    function tokenizeLine(line, langDef, state) {
        var tokens = [];
        var i = 0;
        var len = line.length;

        // Continue multi-line comment
        if (state.inBlockComment) {
            var endIdx = line.indexOf(langDef.multiLineCommentEnd, i);
            if (endIdx === -1) {
                tokens.push({ text: line, cls: "comment" });
                return { tokens: tokens, state: state };
            } else {
                var endPos = endIdx + langDef.multiLineCommentEnd.length;
                tokens.push({ text: line.substring(0, endPos), cls: "comment" });
                i = endPos;
                state = copyState(state);
                state.inBlockComment = false;
            }
        }

        // Continue multi-line string
        if (state.inMultiLineString) {
            var delim = state.multiLineStringDelim;
            var strEndIdx = line.indexOf(delim, i);
            if (strEndIdx === -1) {
                tokens.push({ text: line, cls: "string" });
                return { tokens: tokens, state: state };
            } else {
                var strEndPos = strEndIdx + delim.length;
                tokens.push({ text: line.substring(0, strEndPos), cls: "string" });
                i = strEndPos;
                state = copyState(state);
                state.inMultiLineString = false;
                state.multiLineStringDelim = null;
            }
        }

        while (i < len) {
            var ch = line[i];
            var rest = line.substring(i);

            // Whitespace
            if (ch === " " || ch === "\t") {
                var wsEnd = i + 1;
                while (wsEnd < len && (line[wsEnd] === " " || line[wsEnd] === "\t")) {
                    wsEnd++;
                }
                tokens.push({ text: line.substring(i, wsEnd), cls: "" });
                i = wsEnd;
                continue;
            }

            // Single-line comment
            if (langDef.singleLineComment && rest.startsWith(langDef.singleLineComment)) {
                tokens.push({ text: rest, cls: "comment" });
                i = len;
                continue;
            }

            // Multi-line comment start
            if (langDef.multiLineCommentStart && rest.startsWith(langDef.multiLineCommentStart)) {
                var mcEnd = line.indexOf(langDef.multiLineCommentEnd, i + langDef.multiLineCommentStart.length);
                if (mcEnd === -1) {
                    tokens.push({ text: rest, cls: "comment" });
                    state = copyState(state);
                    state.inBlockComment = true;
                    i = len;
                } else {
                    var mcEndPos = mcEnd + langDef.multiLineCommentEnd.length;
                    tokens.push({ text: line.substring(i, mcEndPos), cls: "comment" });
                    i = mcEndPos;
                }
                continue;
            }

            // Decorator
            if (langDef.decoratorPrefix && ch === langDef.decoratorPrefix) {
                var decMatch = rest.match(/^@[a-zA-Z_]\w*/);
                if (decMatch) {
                    tokens.push({ text: decMatch[0], cls: "decorator" });
                    i += decMatch[0].length;
                    continue;
                }
            }

            // Multi-line string (triple quote)
            if (langDef.multiLineStringDelimiter && rest.startsWith(langDef.multiLineStringDelimiter)) {
                var mlDelim = langDef.multiLineStringDelimiter;
                var mlSearch = line.indexOf(mlDelim, i + mlDelim.length);
                if (mlSearch === -1) {
                    tokens.push({ text: rest, cls: "string" });
                    state = copyState(state);
                    state.inMultiLineString = true;
                    state.multiLineStringDelim = mlDelim;
                    i = len;
                } else {
                    var mlEnd = mlSearch + mlDelim.length;
                    tokens.push({ text: line.substring(i, mlEnd), cls: "string" });
                    i = mlEnd;
                }
                continue;
            }

            // Multi-line string alt (Python ''')
            if (langDef.multiLineStringDelimiterAlt && rest.startsWith(langDef.multiLineStringDelimiterAlt)) {
                var mlDelimAlt = langDef.multiLineStringDelimiterAlt;
                var mlSearchAlt = line.indexOf(mlDelimAlt, i + mlDelimAlt.length);
                if (mlSearchAlt === -1) {
                    tokens.push({ text: rest, cls: "string" });
                    state = copyState(state);
                    state.inMultiLineString = true;
                    state.multiLineStringDelim = mlDelimAlt;
                    i = len;
                } else {
                    var mlEndAlt = mlSearchAlt + mlDelimAlt.length;
                    tokens.push({ text: line.substring(i, mlEndAlt), cls: "string" });
                    i = mlEndAlt;
                }
                continue;
            }

            // Strings (single/double quote)
            if (langDef.stringDelimiters.indexOf(ch) !== -1) {
                var strStart = i;
                var quote = ch;
                i++;
                while (i < len) {
                    if (line[i] === "\\") {
                        i += 2; // skip escape
                    } else if (line[i] === quote) {
                        i++;
                        break;
                    } else {
                        i++;
                    }
                }
                tokens.push({ text: line.substring(strStart, i), cls: "string" });
                continue;
            }

            // Numbers
            if (isDigit(ch) || (ch === "." && i + 1 < len && isDigit(line[i + 1]))) {
                var numMatch = rest.match(/^(?:0[xX][0-9a-fA-F_]+|0[oO][0-7_]+|0[bB][01_]+|\d[\d_]*(?:\.[\d_]+)?(?:[eE][+-]?\d[\d_]*)?)/);
                if (numMatch) {
                    tokens.push({ text: numMatch[0], cls: "number" });
                    i += numMatch[0].length;
                    continue;
                }
            }

            // Identifiers and keywords
            if (isIdentStart(ch)) {
                var idEnd = i + 1;
                while (idEnd < len && isIdentPart(line[idEnd])) {
                    idEnd++;
                }
                var word = line.substring(i, idEnd);
                var cls = "";

                if (langDef.keywords.has(word)) {
                    cls = "keyword";
                } else if (langDef.types.has(word)) {
                    cls = "type";
                } else if (langDef.builtins.has(word)) {
                    cls = "builtin";
                } else {
                    // Check if it's a function call (followed by parenthesis)
                    var afterId = idEnd;
                    while (afterId < len && (line[afterId] === " " || line[afterId] === "\t")) {
                        afterId++;
                    }
                    if (afterId < len && line[afterId] === "(") {
                        cls = "function";
                    }
                    // Check if it's a function declaration
                    if (!cls) {
                        var prevTokens = tokens.filter(function(t) { return t.cls !== ""; });
                        var lastMeaningful = prevTokens.length > 0 ? prevTokens[prevTokens.length - 1] : null;
                        if (lastMeaningful && (lastMeaningful.text === "func" || lastMeaningful.text === "def")) {
                            cls = "function";
                        }
                    }
                }

                tokens.push({ text: word, cls: cls });
                i = idEnd;
                continue;
            }

            // Operators and punctuation
            if (isOperator(ch)) {
                // Try multi-char operators
                var opLen = 1;
                if (i + 1 < len) {
                    var two = ch + line[i + 1];
                    if (two === "==" || two === "!=" || two === "<=" || two === ">=" ||
                        two === "&&" || two === "||" || two === "->" || two === "=>" ||
                        two === "+=" || two === "-=" || two === "*=" || two === "/=" ||
                        two === "<<" || two === ">>" || two === "??" || two === "..") {
                        opLen = 2;
                        if (i + 2 < len) {
                            var three = two + line[i + 2];
                            if (three === "===" || three === "!==" || three === "..." ||
                                three === "..<" || three === "<<=" || three === ">>=") {
                                opLen = 3;
                            }
                        }
                    }
                }
                tokens.push({ text: line.substring(i, i + opLen), cls: "operator" });
                i += opLen;
                continue;
            }

            // Brackets and punctuation
            if (isPunctuation(ch)) {
                tokens.push({ text: ch, cls: "punctuation" });
                i++;
                continue;
            }

            // Anything else
            tokens.push({ text: ch, cls: "" });
            i++;
        }

        return { tokens: tokens, state: state };
    }

    function copyState(state) {
        return {
            inBlockComment: state.inBlockComment,
            inMultiLineString: state.inMultiLineString,
            multiLineStringDelim: state.multiLineStringDelim
        };
    }

    function freshState() {
        return {
            inBlockComment: false,
            inMultiLineString: false,
            multiLineStringDelim: null
        };
    }

    function isDigit(ch) {
        return ch >= "0" && ch <= "9";
    }

    function isIdentStart(ch) {
        return (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || ch === "_" || ch === "$";
    }

    function isIdentPart(ch) {
        return isIdentStart(ch) || isDigit(ch);
    }

    function isOperator(ch) {
        return "+-*/%=<>!&|^~?:.".indexOf(ch) !== -1;
    }

    function isPunctuation(ch) {
        return "(){}[],;".indexOf(ch) !== -1;
    }

    // =========================================================================
    // HTML Escaping
    // =========================================================================

    var escapeMap = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };

    function escapeHTML(text) {
        return text.replace(/[&<>"]/g, function(ch) { return escapeMap[ch]; });
    }

    // =========================================================================
    // Bracket Matching
    // =========================================================================

    var OPEN_BRACKETS = { "(": ")", "[": "]", "{": "}" };
    var CLOSE_BRACKETS = { ")": "(", "]": "[", "}": "{" };
    var AUTO_CLOSE_PAIRS = { "(": ")", "[": "]", "{": "}", '"': '"', "'": "'" };

    /**
     * Find the matching bracket position for the character at `pos` in `code`.
     * Returns the index of the matching bracket or -1 if not found.
     */
    function findMatchingBracket(code, pos) {
        var ch = code[pos];
        if (!ch) return -1;

        var isOpen = OPEN_BRACKETS.hasOwnProperty(ch);
        var isClose = CLOSE_BRACKETS.hasOwnProperty(ch);
        if (!isOpen && !isClose) return -1;

        var target = isOpen ? OPEN_BRACKETS[ch] : CLOSE_BRACKETS[ch];
        var direction = isOpen ? 1 : -1;
        var depth = 0;
        var i = pos;
        var len = code.length;

        while (i >= 0 && i < len) {
            var c = code[i];
            if (c === ch) {
                depth++;
            } else if (c === target) {
                depth--;
                if (depth === 0) return i;
            }
            i += direction;
        }

        return -1;
    }

    // =========================================================================
    // Undo/Redo History
    // =========================================================================

    function UndoHistory(maxSize) {
        this.stack = [];
        this.index = -1;
        this.maxSize = maxSize || 200;
        this.groupTimer = null;
        this.lastPushTime = 0;
    }

    UndoHistory.prototype.push = function(entry) {
        var now = Date.now();

        // Group rapid changes (within 400ms) into a single undo step
        if (this.index >= 0 && now - this.lastPushTime < 400) {
            this.stack[this.index] = entry;
            this.lastPushTime = now;
            return;
        }

        // Remove any redo entries
        this.stack.length = this.index + 1;

        this.stack.push(entry);
        if (this.stack.length > this.maxSize) {
            this.stack.shift();
        }
        this.index = this.stack.length - 1;
        this.lastPushTime = now;
    };

    UndoHistory.prototype.undo = function() {
        if (this.index > 0) {
            this.index--;
            return this.stack[this.index];
        }
        return null;
    };

    UndoHistory.prototype.redo = function() {
        if (this.index < this.stack.length - 1) {
            this.index++;
            return this.stack[this.index];
        }
        return null;
    };

    UndoHistory.prototype.forcePush = function(entry) {
        this.lastPushTime = 0;
        this.push(entry);
    };

    // =========================================================================
    // CodeMirrorEditor Class
    // =========================================================================

    /**
     * @param {HTMLElement} container - The container element
     * @param {object} options
     * @param {string} options.language - "swift" or "python"
     * @param {string} options.theme - "light" or "dark"
     * @param {boolean} options.readOnly
     * @param {number} options.fontSize
     * @param {boolean} options.lineNumbers
     * @param {boolean} options.bracketMatching
     * @param {boolean} options.autoCloseBrackets
     * @param {boolean} options.indentWithSpaces
     * @param {number} options.tabSize
     */
    function CodeMirrorEditor(container, options) {
        this.container = container;
        this.options = Object.assign({
            language: "swift",
            theme: "dark",
            readOnly: false,
            fontSize: 14,
            lineNumbers: true,
            bracketMatching: true,
            autoCloseBrackets: true,
            indentWithSpaces: true,
            tabSize: 4
        }, options || {});

        this._changeCallbacks = [];
        this._langDef = LANGUAGES[this.options.language] || LANGUAGES.swift;
        this._history = new UndoHistory(200);
        this._isComposing = false;
        this._searchVisible = false;
        this._searchMatches = [];
        this._searchCurrentIndex = -1;
        this._lastHighlightedCode = null;
        this._highlightRAF = null;
        this._gutterRAF = null;
        this._scrollSyncRAF = null;
        this._diagnostics = [];

        this._buildDOM();
        this._applyTheme();
        this._applyFontSize();
        this._bindEvents();
        this._updateHighlight();
        this._updateGutter();
        this._updatePlaceholder();

        // Initial undo state
        this._history.forcePush({
            code: this._textarea.value,
            selStart: 0,
            selEnd: 0
        });
    }

    // -------------------------------------------------------------------------
    // DOM Construction
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._buildDOM = function() {
        // Root
        this._root = document.createElement("div");
        this._root.className = "cm-editor";
        if (this.options.readOnly) {
            this._root.classList.add("cm-readonly");
        }

        // Gutter
        this._gutter = document.createElement("div");
        this._gutter.className = "cm-gutter";
        this._gutterInner = document.createElement("div");
        this._gutterInner.className = "cm-gutter-inner";
        this._gutter.appendChild(this._gutterInner);
        if (!this.options.lineNumbers) {
            this._gutter.style.display = "none";
        }

        // Content wrapper
        this._contentWrapper = document.createElement("div");
        this._contentWrapper.className = "cm-content-wrapper";

        // Active line background
        this._activeLineBg = document.createElement("div");
        this._activeLineBg.className = "cm-active-line-bg";
        this._activeLineBg.style.display = "none";

        // Placeholder
        this._placeholder = document.createElement("div");
        this._placeholder.className = "cm-placeholder";
        this._placeholder.textContent = "Start typing...";

        // Highlight layer (pre)
        this._highlightLayer = document.createElement("pre");
        this._highlightLayer.className = "cm-highlight-layer cm-shared-text";
        this._highlightLayer.setAttribute("aria-hidden", "true");

        // Input layer (textarea)
        this._textarea = document.createElement("textarea");
        this._textarea.className = "cm-input-layer cm-shared-text";
        this._textarea.setAttribute("autocomplete", "off");
        this._textarea.setAttribute("autocorrect", "off");
        this._textarea.setAttribute("autocapitalize", "off");
        this._textarea.setAttribute("spellcheck", "false");
        this._textarea.setAttribute("data-gramm", "false");
        this._textarea.setAttribute("wrap", "off");
        if (this.options.readOnly) {
            this._textarea.readOnly = true;
        }

        // Assemble
        this._contentWrapper.appendChild(this._activeLineBg);
        this._contentWrapper.appendChild(this._placeholder);
        this._contentWrapper.appendChild(this._highlightLayer);
        this._contentWrapper.appendChild(this._textarea);

        this._root.appendChild(this._gutter);
        this._root.appendChild(this._contentWrapper);

        this.container.innerHTML = "";
        this.container.appendChild(this._root);
    };

    // -------------------------------------------------------------------------
    // Event Binding
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._bindEvents = function() {
        var self = this;

        // Input events
        this._textarea.addEventListener("input", function() {
            if (self._isComposing) return;
            self._onInput();
        });

        this._textarea.addEventListener("compositionstart", function() {
            self._isComposing = true;
        });

        this._textarea.addEventListener("compositionend", function() {
            self._isComposing = false;
            self._onInput();
        });

        // Keyboard events
        this._textarea.addEventListener("keydown", function(e) {
            self._onKeyDown(e);
        });

        // Selection/cursor change
        this._textarea.addEventListener("select", function() {
            self._onSelectionChange();
        });

        this._textarea.addEventListener("click", function() {
            self._onSelectionChange();
        });

        this._textarea.addEventListener("focus", function() {
            self._activeLineBg.style.display = "block";
            self._onSelectionChange();
        });

        this._textarea.addEventListener("blur", function() {
            self._activeLineBg.style.display = "none";
        });

        // Scroll sync
        this._contentWrapper.addEventListener("scroll", function() {
            self._syncGutterScroll();
        });

        this._textarea.addEventListener("scroll", function() {
            self._syncScroll();
        });

        // Gutter click to select line
        this._gutter.addEventListener("click", function(e) {
            var lineEl = e.target.closest(".cm-line-number");
            if (lineEl) {
                var lineNum = parseInt(lineEl.dataset.line, 10);
                self._selectLine(lineNum);
            }
        });
    };

    // -------------------------------------------------------------------------
    // Input Handling
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._onInput = function() {
        this._history.push({
            code: this._textarea.value,
            selStart: this._textarea.selectionStart,
            selEnd: this._textarea.selectionEnd
        });

        this._scheduleHighlight();
        this._scheduleGutter();
        this._updatePlaceholder();
        this._fireChange();
    };

    CodeMirrorEditor.prototype._onKeyDown = function(e) {
        var key = e.key;
        var isMeta = e.metaKey || e.ctrlKey;

        // Undo: Cmd+Z / Ctrl+Z
        if (isMeta && key === "z" && !e.shiftKey) {
            e.preventDefault();
            var undoEntry = this._history.undo();
            if (undoEntry) {
                this._textarea.value = undoEntry.code;
                this._textarea.selectionStart = undoEntry.selStart;
                this._textarea.selectionEnd = undoEntry.selEnd;
                this._scheduleHighlight();
                this._scheduleGutter();
                this._updatePlaceholder();
                this._fireChange();
            }
            return;
        }

        // Redo: Cmd+Shift+Z / Ctrl+Shift+Z or Ctrl+Y
        if ((isMeta && key === "z" && e.shiftKey) || (isMeta && key === "y")) {
            e.preventDefault();
            var redoEntry = this._history.redo();
            if (redoEntry) {
                this._textarea.value = redoEntry.code;
                this._textarea.selectionStart = redoEntry.selStart;
                this._textarea.selectionEnd = redoEntry.selEnd;
                this._scheduleHighlight();
                this._scheduleGutter();
                this._updatePlaceholder();
                this._fireChange();
            }
            return;
        }

        // Search: Cmd+F / Ctrl+F
        if (isMeta && key === "f") {
            e.preventDefault();
            this._showSearch();
            return;
        }

        // Escape to close search
        if (key === "Escape" && this._searchVisible) {
            this._hideSearch();
            this._textarea.focus();
            return;
        }

        // Tab key
        if (key === "Tab") {
            e.preventDefault();
            if (e.shiftKey) {
                this._outdent();
            } else {
                this._indent();
            }
            return;
        }

        // Enter key - auto indent
        if (key === "Enter") {
            e.preventDefault();
            this._handleEnter();
            return;
        }

        // Auto-close brackets
        if (this.options.autoCloseBrackets && !this.options.readOnly) {
            if (AUTO_CLOSE_PAIRS.hasOwnProperty(key)) {
                var selStart = this._textarea.selectionStart;
                var selEnd = this._textarea.selectionEnd;

                // Only auto-close quotes if we're not inside a word
                if (key === '"' || key === "'") {
                    var code = this._textarea.value;
                    var charBefore = selStart > 0 ? code[selStart - 1] : "";
                    var charAfter = selEnd < code.length ? code[selEnd] : "";

                    // If the next char is the same quote, just skip over it
                    if (charAfter === key && selStart === selEnd) {
                        e.preventDefault();
                        this._textarea.selectionStart = selStart + 1;
                        this._textarea.selectionEnd = selStart + 1;
                        this._onSelectionChange();
                        return;
                    }

                    // Don't auto-close if we're in the middle of a word
                    if (isIdentPart(charBefore)) {
                        return;
                    }
                }

                // If there's a selection, wrap it
                if (selStart !== selEnd) {
                    e.preventDefault();
                    var selected = this._textarea.value.substring(selStart, selEnd);
                    var close = AUTO_CLOSE_PAIRS[key];
                    this._replaceRange(selStart, selEnd, key + selected + close);
                    this._textarea.selectionStart = selStart + 1;
                    this._textarea.selectionEnd = selEnd + 1;
                    this._onInput();
                    return;
                }

                // Auto-close for brackets
                if (key !== '"' && key !== "'") {
                    e.preventDefault();
                    var closeBracket = AUTO_CLOSE_PAIRS[key];
                    this._insertAtCursor(key + closeBracket);
                    this._textarea.selectionStart = selStart + 1;
                    this._textarea.selectionEnd = selStart + 1;
                    this._onInput();
                    return;
                }
            }

            // Skip over closing bracket/quote
            if (key === ")" || key === "]" || key === "}") {
                var cCode = this._textarea.value;
                var cPos = this._textarea.selectionStart;
                if (cPos < cCode.length && cCode[cPos] === key) {
                    e.preventDefault();
                    this._textarea.selectionStart = cPos + 1;
                    this._textarea.selectionEnd = cPos + 1;
                    this._onSelectionChange();
                    return;
                }
            }
        }

        // Backspace - handle deleting empty bracket pairs
        if (key === "Backspace" && this.options.autoCloseBrackets && !this.options.readOnly) {
            var bCode = this._textarea.value;
            var bPos = this._textarea.selectionStart;
            if (bPos > 0 && bPos < bCode.length && this._textarea.selectionStart === this._textarea.selectionEnd) {
                var before = bCode[bPos - 1];
                var after = bCode[bPos];
                if (AUTO_CLOSE_PAIRS[before] === after) {
                    e.preventDefault();
                    this._replaceRange(bPos - 1, bPos + 1, "");
                    this._textarea.selectionStart = bPos - 1;
                    this._textarea.selectionEnd = bPos - 1;
                    this._onInput();
                    return;
                }
            }
        }
    };

    // -------------------------------------------------------------------------
    // Indentation
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._indent = function() {
        var start = this._textarea.selectionStart;
        var end = this._textarea.selectionEnd;
        var code = this._textarea.value;
        var indent = this.options.indentWithSpaces ?
            " ".repeat(this.options.tabSize) : "\t";

        if (start === end) {
            // No selection: insert indent at cursor
            this._insertAtCursor(indent);
            this._onInput();
        } else {
            // Selection: indent all selected lines
            var lineStart = code.lastIndexOf("\n", start - 1) + 1;
            var lineEnd = code.indexOf("\n", end);
            if (lineEnd === -1) lineEnd = code.length;

            var selectedBlock = code.substring(lineStart, lineEnd);
            var indented = selectedBlock.split("\n").map(function(l) {
                return indent + l;
            }).join("\n");

            this._replaceRange(lineStart, lineEnd, indented);
            this._textarea.selectionStart = start + indent.length;
            this._textarea.selectionEnd = end + (indented.length - selectedBlock.length);
            this._onInput();
        }
    };

    CodeMirrorEditor.prototype._outdent = function() {
        var start = this._textarea.selectionStart;
        var end = this._textarea.selectionEnd;
        var code = this._textarea.value;
        var tabSize = this.options.tabSize;

        var lineStart = code.lastIndexOf("\n", start - 1) + 1;
        var lineEnd = code.indexOf("\n", end);
        if (lineEnd === -1) lineEnd = code.length;

        var selectedBlock = code.substring(lineStart, lineEnd);
        var removedBefore = 0;
        var totalRemoved = 0;
        var isFirstLine = true;

        var outdented = selectedBlock.split("\n").map(function(l) {
            var removed = 0;
            if (l.startsWith("\t")) {
                l = l.substring(1);
                removed = 1;
            } else {
                var spaces = 0;
                while (spaces < tabSize && spaces < l.length && l[spaces] === " ") {
                    spaces++;
                }
                if (spaces > 0) {
                    l = l.substring(spaces);
                    removed = spaces;
                }
            }
            if (isFirstLine) {
                removedBefore = removed;
                isFirstLine = false;
            }
            totalRemoved += removed;
            return l;
        }).join("\n");

        this._replaceRange(lineStart, lineEnd, outdented);
        this._textarea.selectionStart = Math.max(lineStart, start - removedBefore);
        this._textarea.selectionEnd = Math.max(this._textarea.selectionStart, end - totalRemoved);
        this._onInput();
    };

    CodeMirrorEditor.prototype._handleEnter = function() {
        var code = this._textarea.value;
        var pos = this._textarea.selectionStart;

        // Get current line
        var lineStart = code.lastIndexOf("\n", pos - 1) + 1;
        var currentLine = code.substring(lineStart, pos);

        // Calculate indent of current line
        var indentMatch = currentLine.match(/^(\s*)/);
        var indent = indentMatch ? indentMatch[1] : "";
        var tabIndent = this.options.indentWithSpaces ?
            " ".repeat(this.options.tabSize) : "\t";

        // Check if we should increase indent
        var trimmed = currentLine.trimEnd();
        var lastChar = trimmed.length > 0 ? trimmed[trimmed.length - 1] : "";
        var shouldIndent = lastChar === "{" || lastChar === "(" || lastChar === "[" || lastChar === ":";

        var insertion = "\n" + indent;
        if (shouldIndent) {
            insertion += tabIndent;
        }

        // Check if we need to add closing bracket on next line
        var charAfter = pos < code.length ? code[pos] : "";
        var needsClosingLine = shouldIndent &&
            ((lastChar === "{" && charAfter === "}") ||
             (lastChar === "(" && charAfter === ")") ||
             (lastChar === "[" && charAfter === "]"));

        if (needsClosingLine) {
            insertion += "\n" + indent;
        }

        // Replace selection with new line + indent
        var selEnd = this._textarea.selectionEnd;
        this._replaceRange(pos, selEnd, insertion);

        var newPos = pos + ("\n" + indent + (shouldIndent ? tabIndent : "")).length;
        this._textarea.selectionStart = newPos;
        this._textarea.selectionEnd = newPos;
        this._onInput();
    };

    // -------------------------------------------------------------------------
    // Text Manipulation Helpers
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._insertAtCursor = function(text) {
        var start = this._textarea.selectionStart;
        var end = this._textarea.selectionEnd;
        this._replaceRange(start, end, text);
    };

    CodeMirrorEditor.prototype._replaceRange = function(from, to, text) {
        var code = this._textarea.value;
        this._textarea.value = code.substring(0, from) + text + code.substring(to);
        var newPos = from + text.length;
        this._textarea.selectionStart = newPos;
        this._textarea.selectionEnd = newPos;
    };

    CodeMirrorEditor.prototype._selectLine = function(lineNum) {
        var code = this._textarea.value;
        var lines = code.split("\n");
        if (lineNum < 1 || lineNum > lines.length) return;

        var start = 0;
        for (var i = 0; i < lineNum - 1; i++) {
            start += lines[i].length + 1;
        }
        var end = start + lines[lineNum - 1].length;

        this._textarea.selectionStart = start;
        this._textarea.selectionEnd = end;
        this._textarea.focus();
        this._onSelectionChange();
    };

    // -------------------------------------------------------------------------
    // Syntax Highlighting
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._scheduleHighlight = function() {
        var self = this;
        if (this._highlightRAF) {
            cancelAnimationFrame(this._highlightRAF);
        }
        this._highlightRAF = requestAnimationFrame(function() {
            self._updateHighlight();
        });
    };

    CodeMirrorEditor.prototype._updateHighlight = function() {
        var code = this._textarea.value;

        // Skip if nothing changed
        if (code === this._lastHighlightedCode) return;
        this._lastHighlightedCode = code;

        var lines = code.split("\n");
        var html = [];
        var state = freshState();

        for (var i = 0; i < lines.length; i++) {
            var result = tokenizeLine(lines[i], this._langDef, state);
            state = result.state;

            var lineHtml = "";
            for (var j = 0; j < result.tokens.length; j++) {
                var tok = result.tokens[j];
                var escaped = escapeHTML(tok.text);
                if (tok.cls) {
                    lineHtml += '<span class="cm-tok-' + tok.cls + '">' + escaped + '</span>';
                } else {
                    lineHtml += escaped;
                }
            }

            // Ensure empty lines have content for proper height
            if (lineHtml === "") {
                lineHtml = "\n";
            }

            html.push(lineHtml);
        }

        this._highlightLayer.innerHTML = html.join("\n");

        // Update bracket matching
        if (this.options.bracketMatching) {
            this._updateBracketMatch();
        }
    };

    // -------------------------------------------------------------------------
    // Bracket Matching
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._updateBracketMatch = function() {
        // Remove previous bracket highlights
        var existing = this._highlightLayer.querySelectorAll(".cm-bracket-match");
        for (var i = 0; i < existing.length; i++) {
            var el = existing[i];
            el.outerHTML = el.innerHTML;
        }

        var code = this._textarea.value;
        var pos = this._textarea.selectionStart;
        if (this._textarea.selectionStart !== this._textarea.selectionEnd) return;

        // Check character at cursor and before cursor
        var checkPositions = [pos, pos - 1];
        for (var c = 0; c < checkPositions.length; c++) {
            var checkPos = checkPositions[c];
            if (checkPos < 0 || checkPos >= code.length) continue;
            var ch = code[checkPos];
            if (!OPEN_BRACKETS[ch] && !CLOSE_BRACKETS[ch]) continue;

            var matchPos = findMatchingBracket(code, checkPos);
            if (matchPos === -1) continue;

            // Apply bracket match highlighting by re-rendering the affected positions.
            // We convert flat character positions to line/column and wrap them.
            this._highlightBracketPositions(checkPos, matchPos, code);
            break;
        }
    };

    CodeMirrorEditor.prototype._highlightBracketPositions = function(pos1, pos2, code) {
        // Get all text nodes in the highlight layer
        var walker = document.createTreeWalker(
            this._highlightLayer,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        var charIndex = 0;
        var targets = [
            { pos: Math.min(pos1, pos2), done: false },
            { pos: Math.max(pos1, pos2), done: false }
        ];

        var node;
        while ((node = walker.nextNode())) {
            var text = node.nodeValue;
            var nodeStart = charIndex;
            var nodeEnd = charIndex + text.length;

            for (var t = 0; t < targets.length; t++) {
                if (targets[t].done) continue;
                if (targets[t].pos >= nodeStart && targets[t].pos < nodeEnd) {
                    var offset = targets[t].pos - nodeStart;
                    // Split the text node to wrap the bracket character
                    var before = text.substring(0, offset);
                    var bracketChar = text[offset];
                    var after = text.substring(offset + 1);

                    var span = document.createElement("span");
                    span.className = "cm-bracket-match";
                    span.textContent = bracketChar;

                    var parent = node.parentNode;
                    if (after) {
                        parent.insertBefore(document.createTextNode(after), node.nextSibling);
                    }
                    parent.insertBefore(span, node.nextSibling);
                    if (before) {
                        node.nodeValue = before;
                    } else {
                        parent.removeChild(node);
                    }

                    targets[t].done = true;
                    // Restart walker since DOM changed
                    return this._highlightBracketPositions(
                        pos1, pos2 > pos1 ? pos2 + 0 : pos2, code
                    );
                }
            }

            charIndex = nodeEnd;
        }
    };

    // Re-entry guard for bracket highlighting
    CodeMirrorEditor.prototype._highlightBracketPositions = (function() {
        var _bracketHighlightInProgress = false;

        return function(pos1, pos2, code) {
            if (_bracketHighlightInProgress) return;
            _bracketHighlightInProgress = true;

            try {
                var positions = [Math.min(pos1, pos2), Math.max(pos1, pos2)];

                for (var p = 0; p < positions.length; p++) {
                    var targetPos = positions[p];
                    var walker = document.createTreeWalker(
                        this._highlightLayer,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );

                    var charIndex = 0;
                    var found = false;
                    var node;

                    while ((node = walker.nextNode())) {
                        var text = node.nodeValue;
                        var nodeStart = charIndex;
                        var nodeEnd = charIndex + text.length;

                        if (targetPos >= nodeStart && targetPos < nodeEnd) {
                            var offset = targetPos - nodeStart;
                            var beforeText = text.substring(0, offset);
                            var bracketChar = text[offset];
                            var afterText = text.substring(offset + 1);

                            var span = document.createElement("span");
                            span.className = "cm-bracket-match";
                            span.textContent = bracketChar;

                            var parent = node.parentNode;

                            var frag = document.createDocumentFragment();
                            if (beforeText) {
                                frag.appendChild(document.createTextNode(beforeText));
                            }
                            frag.appendChild(span);
                            if (afterText) {
                                frag.appendChild(document.createTextNode(afterText));
                            }

                            parent.replaceChild(frag, node);
                            found = true;
                            break;
                        }

                        charIndex = nodeEnd;
                    }
                }
            } finally {
                _bracketHighlightInProgress = false;
            }
        };
    })();

    // -------------------------------------------------------------------------
    // Line Numbers / Gutter
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._scheduleGutter = function() {
        var self = this;
        if (this._gutterRAF) {
            cancelAnimationFrame(this._gutterRAF);
        }
        this._gutterRAF = requestAnimationFrame(function() {
            self._updateGutter();
        });
    };

    CodeMirrorEditor.prototype._updateGutter = function() {
        if (!this.options.lineNumbers) return;

        var code = this._textarea.value;
        var lineCount = code.split("\n").length;

        // Get current active line
        var activeLine = this._getActiveLine();

        // Build error line set for fast lookup
        var errorLines = {};
        if (this._diagnostics) {
            for (var d = 0; d < this._diagnostics.length; d++) {
                errorLines[this._diagnostics[d].line] = true;
            }
        }

        // Build gutter HTML
        var html = [];
        for (var i = 1; i <= lineCount; i++) {
            var classes = "cm-line-number";
            if (i === activeLine) classes += " cm-active-line-number";
            if (errorLines[i]) classes += " cm-error-line";
            html.push('<span class="' + classes +
                '" data-line="' + i + '">' + i + '</span>');
        }

        this._gutterInner.innerHTML = html.join("");

        // Adjust gutter width for large line counts
        var digits = String(lineCount).length;
        var gutterWidth = Math.max(52, digits * 10 + 22);
        this._gutter.style.width = gutterWidth + "px";
        this._gutter.style.minWidth = gutterWidth + "px";
    };

    CodeMirrorEditor.prototype._getActiveLine = function() {
        var code = this._textarea.value;
        var pos = this._textarea.selectionStart;
        var line = 1;
        for (var i = 0; i < pos && i < code.length; i++) {
            if (code[i] === "\n") line++;
        }
        return line;
    };

    // -------------------------------------------------------------------------
    // Active Line & Selection
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._onSelectionChange = function() {
        this._updateActiveLine();
        this._scheduleGutter();

        if (this.options.bracketMatching) {
            this._scheduleHighlight();
        }
    };

    CodeMirrorEditor.prototype._updateActiveLine = function() {
        var activeLine = this._getActiveLine();
        var lineHeight = this.options.fontSize * parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue("--editor-line-height") || "1.5"
        );
        var padding = 8; // matches cm-shared-text padding-top

        var top = padding + (activeLine - 1) * lineHeight;
        this._activeLineBg.style.top = top + "px";
        this._activeLineBg.style.height = lineHeight + "px";

        if (document.activeElement === this._textarea) {
            this._activeLineBg.style.display = "block";
        }
    };

    // -------------------------------------------------------------------------
    // Scroll Sync
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._syncScroll = function() {
        var self = this;
        if (this._scrollSyncRAF) {
            cancelAnimationFrame(this._scrollSyncRAF);
        }
        this._scrollSyncRAF = requestAnimationFrame(function() {
            self._highlightLayer.scrollTop = self._textarea.scrollTop;
            self._highlightLayer.scrollLeft = self._textarea.scrollLeft;
            self._syncGutterScroll();
        });
    };

    CodeMirrorEditor.prototype._syncGutterScroll = function() {
        this._gutter.scrollTop = this._contentWrapper.scrollTop;
    };

    // -------------------------------------------------------------------------
    // Placeholder
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._updatePlaceholder = function() {
        if (this._textarea.value.length > 0) {
            this._placeholder.style.display = "none";
        } else {
            this._placeholder.style.display = "block";
        }
    };

    // -------------------------------------------------------------------------
    // Search
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._showSearch = function() {
        if (this._searchVisible) {
            this._searchInput.focus();
            this._searchInput.select();
            return;
        }

        this._searchVisible = true;

        // Build search overlay
        this._searchOverlay = document.createElement("div");
        this._searchOverlay.className = "cm-search-overlay";

        this._searchInput = document.createElement("input");
        this._searchInput.type = "text";
        this._searchInput.className = "cm-search-input";
        this._searchInput.placeholder = "Search...";

        this._searchCount = document.createElement("span");
        this._searchCount.className = "cm-search-count";
        this._searchCount.textContent = "";

        var prevBtn = document.createElement("button");
        prevBtn.className = "cm-search-btn";
        prevBtn.textContent = "\u25B2";
        prevBtn.title = "Previous";

        var nextBtn = document.createElement("button");
        nextBtn.className = "cm-search-btn";
        nextBtn.textContent = "\u25BC";
        nextBtn.title = "Next";

        var closeBtn = document.createElement("button");
        closeBtn.className = "cm-search-close";
        closeBtn.textContent = "\u00D7";
        closeBtn.title = "Close";

        this._searchOverlay.appendChild(this._searchInput);
        this._searchOverlay.appendChild(this._searchCount);
        this._searchOverlay.appendChild(prevBtn);
        this._searchOverlay.appendChild(nextBtn);
        this._searchOverlay.appendChild(closeBtn);
        this._root.appendChild(this._searchOverlay);

        var self = this;

        this._searchInput.addEventListener("input", function() {
            self._performSearch();
        });

        this._searchInput.addEventListener("keydown", function(e) {
            if (e.key === "Enter") {
                e.preventDefault();
                if (e.shiftKey) {
                    self._searchPrev();
                } else {
                    self._searchNext();
                }
            }
            if (e.key === "Escape") {
                self._hideSearch();
                self._textarea.focus();
            }
        });

        prevBtn.addEventListener("click", function() { self._searchPrev(); });
        nextBtn.addEventListener("click", function() { self._searchNext(); });
        closeBtn.addEventListener("click", function() {
            self._hideSearch();
            self._textarea.focus();
        });

        // Pre-fill with selected text
        var sel = this._textarea.value.substring(
            this._textarea.selectionStart,
            this._textarea.selectionEnd
        );
        if (sel && sel.indexOf("\n") === -1) {
            this._searchInput.value = sel;
        }

        this._searchInput.focus();
        this._searchInput.select();

        if (this._searchInput.value) {
            this._performSearch();
        }
    };

    CodeMirrorEditor.prototype._hideSearch = function() {
        if (!this._searchVisible) return;
        this._searchVisible = false;
        this._searchMatches = [];
        this._searchCurrentIndex = -1;

        if (this._searchOverlay && this._searchOverlay.parentNode) {
            this._searchOverlay.parentNode.removeChild(this._searchOverlay);
        }
        this._searchOverlay = null;

        // Re-render to remove search highlights
        this._lastHighlightedCode = null;
        this._updateHighlight();
    };

    CodeMirrorEditor.prototype._performSearch = function() {
        var query = this._searchInput.value;
        this._searchMatches = [];
        this._searchCurrentIndex = -1;

        if (!query) {
            this._searchCount.textContent = "";
            this._lastHighlightedCode = null;
            this._updateHighlight();
            return;
        }

        var code = this._textarea.value;
        var lowerQuery = query.toLowerCase();
        var lowerCode = code.toLowerCase();
        var startPos = 0;

        while (startPos < lowerCode.length) {
            var idx = lowerCode.indexOf(lowerQuery, startPos);
            if (idx === -1) break;
            this._searchMatches.push({ start: idx, end: idx + query.length });
            startPos = idx + 1;
        }

        if (this._searchMatches.length > 0) {
            // Find closest match to cursor
            var cursorPos = this._textarea.selectionStart;
            this._searchCurrentIndex = 0;
            for (var i = 0; i < this._searchMatches.length; i++) {
                if (this._searchMatches[i].start >= cursorPos) {
                    this._searchCurrentIndex = i;
                    break;
                }
            }
            this._goToSearchMatch();
        }

        this._searchCount.textContent = this._searchMatches.length > 0 ?
            (this._searchCurrentIndex + 1) + " / " + this._searchMatches.length :
            "No results";
    };

    CodeMirrorEditor.prototype._searchNext = function() {
        if (this._searchMatches.length === 0) return;
        this._searchCurrentIndex = (this._searchCurrentIndex + 1) % this._searchMatches.length;
        this._goToSearchMatch();
    };

    CodeMirrorEditor.prototype._searchPrev = function() {
        if (this._searchMatches.length === 0) return;
        this._searchCurrentIndex = (this._searchCurrentIndex - 1 + this._searchMatches.length) %
            this._searchMatches.length;
        this._goToSearchMatch();
    };

    CodeMirrorEditor.prototype._goToSearchMatch = function() {
        if (this._searchCurrentIndex < 0 || this._searchCurrentIndex >= this._searchMatches.length) return;

        var match = this._searchMatches[this._searchCurrentIndex];
        this._textarea.selectionStart = match.start;
        this._textarea.selectionEnd = match.end;
        this._textarea.focus();

        // Scroll the match into view
        this._scrollToPosition(match.start);

        this._searchCount.textContent =
            (this._searchCurrentIndex + 1) + " / " + this._searchMatches.length;

        this._onSelectionChange();
    };

    CodeMirrorEditor.prototype._scrollToPosition = function(pos) {
        var code = this._textarea.value;
        var linesBefore = code.substring(0, pos).split("\n").length - 1;
        var lineHeight = this.options.fontSize * parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue("--editor-line-height") || "1.5"
        );
        var targetScroll = linesBefore * lineHeight - this._contentWrapper.clientHeight / 2;
        this._contentWrapper.scrollTop = Math.max(0, targetScroll);
    };

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype.getValue = function() {
        return this._textarea.value;
    };

    CodeMirrorEditor.prototype.setValue = function(code) {
        if (code === this._textarea.value) return;
        this._textarea.value = code;
        this._lastHighlightedCode = null;
        this._updateHighlight();
        this._updateGutter();
        this._updatePlaceholder();
        this._history.forcePush({
            code: code,
            selStart: 0,
            selEnd: 0
        });
    };

    CodeMirrorEditor.prototype.setLanguage = function(lang) {
        var langKey = (lang || "swift").toLowerCase();
        if (langKey === "py") langKey = "python";
        if (langKey === "sw") langKey = "swift";
        this._langDef = LANGUAGES[langKey] || LANGUAGES.swift;
        this.options.language = langKey;
        this._lastHighlightedCode = null;
        this._updateHighlight();
    };

    CodeMirrorEditor.prototype.setTheme = function(theme) {
        this.options.theme = theme;
        this._applyTheme();
        this._lastHighlightedCode = null;
        this._updateHighlight();
    };

    CodeMirrorEditor.prototype.setReadOnly = function(readOnly) {
        this.options.readOnly = readOnly;
        this._textarea.readOnly = readOnly;
        if (readOnly) {
            this._root.classList.add("cm-readonly");
        } else {
            this._root.classList.remove("cm-readonly");
        }
    };

    CodeMirrorEditor.prototype.setFontSize = function(size) {
        this.options.fontSize = size;
        this._applyFontSize();
        this._lastHighlightedCode = null;
        this._updateHighlight();
        this._updateGutter();
        this._updateActiveLine();
    };

    CodeMirrorEditor.prototype.onChange = function(callback) {
        if (typeof callback === "function") {
            this._changeCallbacks.push(callback);
        }
    };

    /**
     * Set diagnostics (error/warning markers) on specific lines.
     * @param {Array<{line: number, message: string}>} diagnostics
     *   line is 1-based.
     */
    CodeMirrorEditor.prototype.setDiagnostics = function(diagnostics) {
        this._diagnostics = diagnostics || [];

        // Remove previous error background overlays
        var existing = this._contentWrapper.querySelectorAll(".cm-error-line-bg");
        for (var i = 0; i < existing.length; i++) {
            existing[i].parentNode.removeChild(existing[i]);
        }

        // Update gutter with error markers
        this._updateGutter();

        // Add error line backgrounds
        if (this._diagnostics.length > 0) {
            var lineHeight = this.options.fontSize * parseFloat(
                getComputedStyle(document.documentElement).getPropertyValue("--editor-line-height") || "1.5"
            );
            var padding = 8; // matches cm-shared-text padding-top
            var errorLines = {};
            for (var d = 0; d < this._diagnostics.length; d++) {
                errorLines[this._diagnostics[d].line] = true;
            }
            for (var lineNum in errorLines) {
                var el = document.createElement("div");
                el.className = "cm-error-line-bg";
                el.style.top = (padding + (parseInt(lineNum) - 1) * lineHeight) + "px";
                el.style.height = lineHeight + "px";
                el.title = this._getDiagnosticMessage(parseInt(lineNum));
                this._contentWrapper.insertBefore(el, this._contentWrapper.firstChild);
            }
        }
    };

    CodeMirrorEditor.prototype._getDiagnosticMessage = function(line) {
        var msgs = [];
        for (var i = 0; i < this._diagnostics.length; i++) {
            if (this._diagnostics[i].line === line) {
                msgs.push(this._diagnostics[i].message);
            }
        }
        return msgs.join("\n");
    };

    CodeMirrorEditor.prototype.focus = function() {
        this._textarea.focus();
    };

    CodeMirrorEditor.prototype.destroy = function() {
        if (this._highlightRAF) cancelAnimationFrame(this._highlightRAF);
        if (this._gutterRAF) cancelAnimationFrame(this._gutterRAF);
        if (this._scrollSyncRAF) cancelAnimationFrame(this._scrollSyncRAF);

        this._changeCallbacks = [];

        if (this._root && this._root.parentNode) {
            this._root.parentNode.removeChild(this._root);
        }

        this._root = null;
        this._gutter = null;
        this._gutterInner = null;
        this._contentWrapper = null;
        this._highlightLayer = null;
        this._textarea = null;
        this._activeLineBg = null;
        this._placeholder = null;
    };

    // -------------------------------------------------------------------------
    // Internal Helpers
    // -------------------------------------------------------------------------

    CodeMirrorEditor.prototype._applyTheme = function() {
        if (this.options.theme === "dark") {
            document.body.classList.add("dark-theme");
            document.body.classList.remove("light-theme");
        } else {
            document.body.classList.add("light-theme");
            document.body.classList.remove("dark-theme");
        }
    };

    CodeMirrorEditor.prototype._applyFontSize = function() {
        var size = this.options.fontSize + "px";
        document.documentElement.style.setProperty("--editor-font-size", size);
    };

    CodeMirrorEditor.prototype._fireChange = function() {
        var code = this._textarea.value;
        for (var i = 0; i < this._changeCallbacks.length; i++) {
            try {
                this._changeCallbacks[i](code);
            } catch (e) {
                console.error("[CodeMirrorEditor] onChange callback error:", e);
            }
        }
    };

    // =========================================================================
    // Export
    // =========================================================================

    global.CodeMirrorEditor = CodeMirrorEditor;

})(typeof window !== "undefined" ? window : this);
