{
  "version": "1.0.0",
  "solutions": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "problemSlug": "reverse-linked-list",
      "summary": "Reverse the direction of pointers in a linked list. The key insight is that you need to track three nodes at once: previous, current, and next.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440101",
          "name": "Iterative",
          "order": 1,
          "intuition": "We traverse the list once, reversing each pointer as we go. At each step, we need to:\n1. Save the next node (before we lose the reference)\n2. Point current node backwards to previous\n3. Move both pointers forward",
          "approach": "1. Initialize prev as nil and curr as head\n2. While curr is not nil:\n   - Store next = curr.next (save reference)\n   - Set curr.next = prev (reverse pointer)\n   - Move prev = curr\n   - Move curr = next\n3. Return prev (the new head)",
          "explanation": "The trick is maintaining three pointers:\n- prev: the node we just processed\n- curr: the node we're currently processing\n- next: the node we'll process next\n\nBefore reversing curr's pointer, we must save curr.next, otherwise we lose access to the rest of the list. After the loop, prev points to what was the last node, which is now the new head.",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    \n    while curr != nil {\n        let next = curr?.next  // Save next\n        curr?.next = prev      // Reverse pointer\n        prev = curr            // Move prev forward\n        curr = next            // Move curr forward\n    }\n    \n    return prev\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We visit each node exactly once",
            "spaceExplanation": "Only use three pointers regardless of list size"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440201",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "[5,4,3,2,1]",
              "explanation": "Each arrow reverses: 1\u21922\u21923\u21924\u21925 becomes 5\u21924\u21923\u21922\u21921"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440202",
              "input": "[1,2]",
              "expectedOutput": "[2,1]",
              "explanation": "Simple case: 1\u21922 becomes 2\u21921"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440102",
          "name": "Recursive",
          "order": 2,
          "intuition": "Recursively reverse the rest of the list, then fix up the current node's pointers. The base case is when we reach the last node (which becomes our new head).",
          "approach": "1. Base case: if head is nil or head.next is nil, return head\n2. Recursively reverse the rest: newHead = reverseList(head.next)\n3. Make the next node point back: head.next.next = head\n4. Clear current node's next: head.next = nil\n5. Return newHead (propagate through all calls)",
          "explanation": "The recursion reaches the end of the list first, then as it unwinds:\n- At each step, head.next still points to the last node we processed\n- We make that node point back to us (head.next.next = head)\n- We clear our own next pointer (will be set by the previous recursive call)\n\nThe newHead is returned unchanged through all recursive calls.",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    // Base case: empty or single node\n    guard let head = head, let next = head.next else {\n        return head\n    }\n    \n    // Recursively reverse the rest\n    let newHead = reverseList(next)\n    \n    // Fix pointers\n    next.next = head  // Make next point back to us\n    head.next = nil   // Clear our forward pointer\n    \n    return newHead\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Visit each node once via recursion",
            "spaceExplanation": "Recursive call stack uses O(n) space"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "reverse-linked-list-ii",
        "palindrome-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440002",
      "problemSlug": "merge-two-sorted-lists",
      "summary": "Merge two sorted linked lists by comparing nodes one at a time and building a new list. Use a dummy head to simplify edge cases.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440103",
          "name": "Iterative with Dummy",
          "order": 1,
          "intuition": "Compare the heads of both lists, take the smaller one, and advance that list's pointer. A dummy node avoids special-casing the first node.",
          "approach": "1. Create a dummy node to serve as the start\n2. Use a tail pointer to build the result\n3. While both lists have nodes:\n   - Compare values, append smaller to tail\n   - Advance the list we took from\n4. Append remaining nodes from non-empty list\n5. Return dummy.next",
          "explanation": "The dummy node trick is powerful: instead of tracking whether we've added the first node, we always have a valid tail to append to. At the end, dummy.next is our actual head.\n\nWhen one list is exhausted, we can directly link the remainder since it's already sorted.",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = list1\n    var l2 = list2\n    \n    while let node1 = l1, let node2 = l2 {\n        if node1.val <= node2.val {\n            tail.next = node1\n            l1 = node1.next\n        } else {\n            tail.next = node2\n            l2 = node2.next\n        }\n        tail = tail.next!\n    }\n    \n    // Append remaining nodes\n    tail.next = l1 ?? l2\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(1)",
            "timeExplanation": "Visit each node in both lists once",
            "spaceExplanation": "Only use a few pointers, reuse existing nodes"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440203",
              "input": "list1 = [1,2,4], list2 = [1,3,4]",
              "expectedOutput": "[1,1,2,3,4,4]",
              "explanation": "Compare 1\u22641, take l1. Compare 2>1, take l2. Continue..."
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440104",
          "name": "Recursive",
          "order": 2,
          "intuition": "The merged list starts with the smaller head, followed by the merge of the remaining elements.",
          "approach": "1. Base case: if either list is empty, return the other\n2. Compare heads, take the smaller one as current head\n3. Recursively merge the rest\n4. Return the current head",
          "explanation": "Each recursive call handles one node, choosing the smaller of the two heads. The recursion naturally unwinds to build the complete list.",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    guard let l1 = list1 else { return list2 }\n    guard let l2 = list2 else { return list1 }\n    \n    if l1.val <= l2.val {\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(n + m)",
            "timeExplanation": "Each node processed once",
            "spaceExplanation": "Recursive stack depth equals total nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "merge-k-sorted-lists",
        "sort-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440003",
      "problemSlug": "linked-list-cycle",
      "summary": "Detect if a linked list has a cycle using Floyd's Tortoise and Hare algorithm. Two pointers moving at different speeds will meet if there's a cycle.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440105",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "intuition": "Use two pointers: slow moves 1 step, fast moves 2 steps. If there's a cycle, fast will eventually catch up to slow. If no cycle, fast will reach the end.",
          "approach": "1. Initialize slow and fast to head\n2. While fast and fast.next exist:\n   - Move slow one step\n   - Move fast two steps\n   - If they meet, return true\n3. Return false (fast reached end)",
          "explanation": "Why does this work? In a cycle, the fast pointer gains one position on slow each iteration. Eventually they must meet.\n\nMathematically: if cycle length is C, fast catches up by 1 each step, so they meet within C steps after slow enters the cycle.",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var slow = head\n    var fast = head\n    \n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        \n        if slow === fast {\n            return true\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "At most 2n iterations before detection or end",
            "spaceExplanation": "Only two pointers used"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440204",
              "input": "[3,2,0,-4], pos = 1",
              "expectedOutput": "true",
              "explanation": "Tail connects to node at index 1 (value 2)"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440205",
              "input": "[1], pos = -1",
              "expectedOutput": "false",
              "explanation": "Single node with no cycle"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440106",
          "name": "Hash Set",
          "order": 2,
          "intuition": "Track visited nodes in a set. If we see a node twice, there's a cycle.",
          "approach": "1. Create an empty set of visited nodes\n2. Traverse the list:\n   - If current node is in set, return true\n   - Add current node to set\n3. Return false if we reach the end",
          "explanation": "Simple but uses extra space. We store node references (not values) to handle duplicate values correctly.",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var visited = Set<ObjectIdentifier>()\n    var current = head\n    \n    while let node = current {\n        let id = ObjectIdentifier(node)\n        if visited.contains(id) {\n            return true\n        }\n        visited.insert(id)\n        current = node.next\n    }\n    \n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Store up to n node references"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "linked-list-cycle-ii",
        "happy-number"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440004",
      "problemSlug": "reorder-list",
      "summary": "Reorder list from L0\u2192L1\u2192...\u2192Ln to L0\u2192Ln\u2192L1\u2192Ln-1\u2192... by finding middle, reversing second half, then merging alternately.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440107",
          "name": "Three-Step Approach",
          "order": 1,
          "intuition": "The reordered list alternates between taking from the start and end. We can achieve this by:\n1. Split the list into two halves\n2. Reverse the second half\n3. Merge both halves by alternating nodes",
          "approach": "1. Find the middle using slow/fast pointers\n2. Split the list at the middle\n3. Reverse the second half\n4. Merge by alternating: take from first, then second, repeat",
          "explanation": "This approach transforms the problem into three simpler sub-problems we already know how to solve:\n\n- Finding middle: slow/fast pointer technique (slow moves 1 step, fast moves 2)\n- Reversing: standard iterative reversal with prev/curr/next pointers\n- Merging: similar to merge two lists, but we alternate instead of comparing\n\nKey insight: after reversing the second half, both halves are the same length (\u00b11), so we can interleave them directly.",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head, head.next != nil else { return }\n    \n    // Step 1: Find middle\n    var slow = head\n    var fast = head\n    while fast.next != nil && fast.next?.next != nil {\n        slow = slow.next!\n        fast = fast.next!.next!\n    }\n    \n    // Step 2: Split and reverse second half\n    var second = slow.next\n    slow.next = nil  // Cut the list\n    second = reverseList(second)\n    \n    // Step 3: Merge alternately\n    var first: ListNode? = head\n    while second != nil {\n        let tmp1 = first?.next\n        let tmp2 = second?.next\n        first?.next = second\n        second?.next = tmp1\n        first = tmp1\n        second = tmp2\n    }\n}\n\nprivate func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    while curr != nil {\n        let next = curr?.next\n        curr?.next = prev\n        prev = curr\n        curr = next\n    }\n    return prev\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each step (find middle, reverse, merge) is O(n), total is O(n)",
            "spaceExplanation": "Only use pointer variables, no extra data structures"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440206",
              "input": "[1,2,3,4]",
              "expectedOutput": "[1,4,2,3]",
              "explanation": "Split: [1,2] and [3,4]. Reverse second: [4,3]. Merge: 1\u21924\u21922\u21923"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440207",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "[1,5,2,4,3]",
              "explanation": "Split: [1,2,3] and [4,5]. Reverse second: [5,4]. Merge: 1\u21925\u21922\u21924\u21923"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440108",
          "name": "Stack-Based",
          "order": 2,
          "intuition": "Use a stack to access nodes from the end. Push all nodes, then pop half while traversing from the front to interleave.",
          "approach": "1. Push all nodes onto a stack\n2. Calculate how many nodes to interleave (n/2)\n3. Traverse from head, pop from stack, insert popped nodes between current nodes\n4. Handle the final next pointer",
          "explanation": "The stack gives us O(1) access to the 'end' of the list. By pushing all nodes, the top of the stack is the last node, second-to-top is second-to-last, etc.\n\nWe only need to interleave n/2 nodes from the end, where n is the total count. After interleaving, we must set the final node's next to nil to avoid a cycle.",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head else { return }\n    \n    // Push all nodes to stack\n    var stack: [ListNode] = []\n    var node: ListNode? = head\n    while let n = node {\n        stack.append(n)\n        node = n.next\n    }\n    \n    let count = stack.count\n    var curr: ListNode? = head\n    \n    // Interleave n/2 nodes from the end\n    for _ in 0..<(count / 2) {\n        let end = stack.removeLast()\n        let next = curr?.next\n        curr?.next = end\n        end.next = next\n        curr = next\n    }\n    \n    // Terminate the list\n    curr?.next = nil\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Push n nodes, then interleave n/2 times",
            "spaceExplanation": "Stack stores all n nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "palindrome-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440005",
      "problemSlug": "remove-nth-node-from-end-of-list",
      "summary": "Remove the nth node from the end using two pointers with a gap of n. When the ahead pointer reaches the end, the behind pointer is at the node before the target.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440109",
          "name": "Two Pointers with Gap",
          "order": 1,
          "intuition": "If we maintain a gap of n nodes between two pointers, when the front pointer reaches the end, the back pointer will be exactly n nodes from the end.\n\nA dummy node handles edge cases like removing the head.",
          "approach": "1. Create dummy node pointing to head\n2. Initialize both pointers at dummy\n3. Move ahead pointer n+1 steps (creates gap of n)\n4. Move both pointers until ahead reaches nil\n5. Skip the target: behind.next = behind.next.next\n6. Return dummy.next",
          "explanation": "The key insight is the gap. If ahead is n+1 nodes ahead of behind, when ahead is nil (past the end), behind is at the node BEFORE the one we want to remove.\n\nWhy n+1 instead of n? Because we need behind to point to the predecessor of the target node so we can update its next pointer.\n\nThe dummy node elegantly handles removing the head: if n equals the list length, behind stays at dummy, and behind.next becomes the original head (which we skip).",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    var behind: ListNode? = dummy\n    var ahead: ListNode? = dummy\n    \n    // Create gap of n+1\n    for _ in 0...n {\n        ahead = ahead?.next\n    }\n    \n    // Move both until ahead reaches end\n    while ahead != nil {\n        behind = behind?.next\n        ahead = ahead?.next\n    }\n    \n    // Skip the nth node from end\n    behind?.next = behind?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(1)",
            "timeExplanation": "Single pass through the list where L is list length",
            "spaceExplanation": "Only use two pointer variables plus dummy"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440208",
              "input": "head = [1,2,3,4,5], n = 2",
              "expectedOutput": "[1,2,3,5]",
              "explanation": "Remove 4 (2nd from end). Gap of 2 means when ahead=nil, behind points to 3"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440209",
              "input": "head = [1], n = 1",
              "expectedOutput": "[]",
              "explanation": "Remove only node. Dummy handles this: behind stays at dummy, skips head"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440210",
              "input": "head = [1,2], n = 1",
              "expectedOutput": "[1]",
              "explanation": "Remove 2 (last node). behind ends at node 1, skips node 2"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440110",
          "name": "Two Pass",
          "order": 2,
          "intuition": "First pass counts the total length. Second pass removes the (length - n)th node from the beginning.",
          "approach": "1. First pass: count total nodes (length)\n2. Calculate target index: length - n\n3. Use dummy node for edge case handling\n4. Second pass: traverse to node at index (target - 1)\n5. Skip the target node",
          "explanation": "Converting 'nth from end' to 'kth from start' simplifies the problem. If list has L nodes, the nth from end is the (L-n)th from start (0-indexed).\n\nWe traverse to position (L-n-1) to reach the predecessor, then update its next pointer.\n\nLess elegant than one-pass but easier to understand and implement correctly.",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    // First pass: count length\n    var length = 0\n    var node = head\n    while node != nil {\n        length += 1\n        node = node?.next\n    }\n    \n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    // Find predecessor of target (at position length - n - 1 from dummy)\n    var curr: ListNode? = dummy\n    for _ in 0..<(length - n) {\n        curr = curr?.next\n    }\n    \n    // Skip target\n    curr?.next = curr?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(1)",
            "timeExplanation": "Two passes: first counts L nodes, second traverses L-n nodes",
            "spaceExplanation": "Only use counter and pointer variables"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "delete-the-middle-node-of-a-linked-list",
        "swapping-nodes-in-a-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440006",
      "problemSlug": "merge-k-sorted-lists",
      "summary": "Merge k sorted linked lists into one sorted list. Use a min-heap for O(n log k) efficiency, or divide and conquer by repeatedly merging pairs.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440111",
          "name": "Min-Heap (Priority Queue)",
          "order": 1,
          "intuition": "Always pick the smallest available node across all k lists. A min-heap gives us O(log k) access to the minimum among k candidates.\n\nAt any time, the heap contains at most one node from each list (the current head).",
          "approach": "1. Create a min-heap ordered by node value\n2. Add the head of each non-empty list to the heap\n3. While heap is not empty:\n   - Pop the minimum node\n   - Append it to the result\n   - If that node has a next, push next to heap\n4. Return the merged list",
          "explanation": "The heap maintains the 'frontier' of each list - the next candidate node from each list. By always extracting the minimum, we build the sorted result.\n\nSwift doesn't have a built-in heap, so we implement a simple one or use an array with manual sorting (less efficient but simpler).\n\nKey insight: each node is pushed and popped exactly once, and each operation is O(log k).",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    // Simple approach using sorted array (for interview, explain heap would be better)\n    var nodes: [ListNode] = []\n    \n    // Collect all nodes\n    for list in lists {\n        var node = list\n        while let n = node {\n            nodes.append(n)\n            node = n.next\n        }\n    }\n    \n    // Sort by value\n    nodes.sort { $0.val < $1.val }\n    \n    // Rebuild list\n    let dummy = ListNode(0)\n    var tail = dummy\n    for node in nodes {\n        tail.next = node\n        tail = node\n    }\n    tail.next = nil\n    \n    return dummy.next\n}\n\n// Optimal with custom min-heap\nfunc mergeKListsHeap(_ lists: [ListNode?]) -> ListNode? {\n    var heap: [ListNode] = lists.compactMap { $0 }\n    \n    func heapifyUp(_ i: Int) {\n        var i = i\n        while i > 0 && heap[(i-1)/2].val > heap[i].val {\n            heap.swapAt(i, (i-1)/2)\n            i = (i-1)/2\n        }\n    }\n    \n    func heapifyDown(_ i: Int) {\n        var i = i\n        while 2*i + 1 < heap.count {\n            var smallest = 2*i + 1\n            if smallest + 1 < heap.count && heap[smallest+1].val < heap[smallest].val {\n                smallest += 1\n            }\n            if heap[i].val <= heap[smallest].val { break }\n            heap.swapAt(i, smallest)\n            i = smallest\n        }\n    }\n    \n    // Build heap\n    for i in (0..<heap.count).reversed() { heapifyDown(i) }\n    \n    let dummy = ListNode(0)\n    var tail = dummy\n    \n    while !heap.isEmpty {\n        let min = heap[0]\n        tail.next = min\n        tail = min\n        \n        if let next = min.next {\n            heap[0] = next\n            heapifyDown(0)\n        } else {\n            heap[0] = heap[heap.count - 1]\n            heap.removeLast()\n            if !heap.isEmpty { heapifyDown(0) }\n        }\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(N log k)",
            "space": "O(k)",
            "timeExplanation": "N total nodes, each pushed/popped once with O(log k) heap operations",
            "spaceExplanation": "Heap stores at most k nodes (one per list)"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440211",
              "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
              "expectedOutput": "[1,1,2,3,4,4,5,6]",
              "explanation": "Heap starts with [1,1,2]. Pop 1, push 4. Pop 1, push 3. Continue..."
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440212",
              "input": "lists = []",
              "expectedOutput": "[]",
              "explanation": "Empty input returns empty list"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440112",
          "name": "Divide and Conquer",
          "order": 2,
          "intuition": "Pair up the k lists and merge each pair. After one round, we have k/2 lists. Repeat until one list remains.\n\nThis is like merge sort's merge step, applied to lists instead of arrays.",
          "approach": "1. If lists is empty, return nil\n2. While we have more than one list:\n   - Pair up lists and merge each pair\n   - Replace lists with merged results\n3. Return the single remaining list",
          "explanation": "Each 'round' halves the number of lists: k \u2192 k/2 \u2192 k/4 \u2192 ... \u2192 1.\n\nThere are O(log k) rounds, and each round processes all N nodes once (spread across the merges). Total: O(N log k).\n\nThis approach reuses our merge-two-lists solution and is often easier to implement correctly than a heap.",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    var lists = lists.compactMap { $0 }  // Remove nils\n    if lists.isEmpty { return nil }\n    \n    while lists.count > 1 {\n        var merged: [ListNode] = []\n        for i in stride(from: 0, to: lists.count, by: 2) {\n            let l1 = lists[i]\n            let l2 = i + 1 < lists.count ? lists[i + 1] : nil\n            if let m = mergeTwoLists(l1, l2) {\n                merged.append(m)\n            }\n        }\n        lists = merged\n    }\n    \n    return lists.first\n}\n\nprivate func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = l1, l2 = l2\n    \n    while let n1 = l1, let n2 = l2 {\n        if n1.val <= n2.val {\n            tail.next = n1\n            l1 = n1.next\n        } else {\n            tail.next = n2\n            l2 = n2.next\n        }\n        tail = tail.next!\n    }\n    tail.next = l1 ?? l2\n    return dummy.next\n}",
          "complexity": {
            "time": "O(N log k)",
            "space": "O(1)",
            "timeExplanation": "log k rounds, each processing all N nodes",
            "spaceExplanation": "Merge is done in-place, only using pointers"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "merge-two-sorted-lists",
        "ugly-number-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440007",
      "problemSlug": "copy-list-with-random-pointer",
      "summary": "Create a deep copy of a linked list where each node has a random pointer. Use a hash map to map original nodes to copies, enabling O(1) lookup for random pointers.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440113",
          "name": "Hash Map (Two Pass)",
          "order": 1,
          "intuition": "The challenge is that random pointers can point to nodes we haven't created yet. Solution: first create all nodes, then wire up the pointers.\n\nA hash map lets us find the copy of any original node in O(1).",
          "approach": "1. First pass: create a copy of each node, store original\u2192copy mapping\n2. Second pass: for each original node:\n   - Set copy.next = map[original.next]\n   - Set copy.random = map[original.random]\n3. Return map[head]",
          "explanation": "The hash map is the key insight. When we encounter original.random pointing to some node X, we need to find the copy of X. The map gives us this in O(1).\n\nFirst pass creates all nodes (values only). Second pass wires up both next and random pointers using the map.\n\nNote: we handle nil by checking before map lookup.",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard let head = head else { return nil }\n    \n    var map: [ObjectIdentifier: Node] = [:]\n    \n    // First pass: create all nodes\n    var curr: Node? = head\n    while let node = curr {\n        map[ObjectIdentifier(node)] = Node(node.val)\n        curr = node.next\n    }\n    \n    // Second pass: wire up pointers\n    curr = head\n    while let node = curr {\n        let copy = map[ObjectIdentifier(node)]!\n        if let next = node.next {\n            copy.next = map[ObjectIdentifier(next)]\n        }\n        if let random = node.random {\n            copy.random = map[ObjectIdentifier(random)]\n        }\n        curr = node.next\n    }\n    \n    return map[ObjectIdentifier(head)]\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Two passes through n nodes, O(1) per node",
            "spaceExplanation": "Hash map stores n node mappings"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440213",
              "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "explanation": "Deep copy with same structure. Node 1's random points to node 0, etc."
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440114",
          "name": "Interleaving (O(1) Space)",
          "order": 2,
          "intuition": "Avoid the hash map by interleaving copies with originals: A\u2192A'\u2192B\u2192B'\u2192C\u2192C'. Now A'.random = A.random.next (the copy is right after the original).",
          "approach": "1. Insert copy after each original: A\u2192A'\u2192B\u2192B'\u2192...\n2. Set random pointers: copy.random = original.random?.next\n3. Separate the two lists: restore original, extract copies",
          "explanation": "The interleaving trick embeds the 'map' in the list structure itself. Original.next always points to its copy.\n\nPhase 1: Create copies, insert after originals.\nPhase 2: Wire random pointers using the interleaved structure.\nPhase 3: Carefully unweave the two lists.\n\nThe separation step is tricky - we must restore the original list while extracting the copy list.",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard head != nil else { return nil }\n    \n    // Phase 1: Insert copies after originals\n    var curr = head\n    while let node = curr {\n        let copy = Node(node.val)\n        copy.next = node.next\n        node.next = copy\n        curr = copy.next\n    }\n    \n    // Phase 2: Set random pointers\n    curr = head\n    while let node = curr {\n        let copy = node.next\n        copy?.random = node.random?.next  // Random's copy is right after random\n        curr = copy?.next\n    }\n    \n    // Phase 3: Separate lists\n    let dummy = Node(0)\n    var copyTail = dummy\n    curr = head\n    while let node = curr {\n        let copy = node.next!\n        let nextOrig = copy.next\n        \n        // Extract copy\n        copyTail.next = copy\n        copyTail = copy\n        \n        // Restore original\n        node.next = nextOrig\n        curr = nextOrig\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Three passes, each O(n)",
            "spaceExplanation": "No extra data structures, only pointers (output doesn't count)"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "clone-graph",
        "clone-binary-tree-with-random-pointer"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440008",
      "problemSlug": "add-two-numbers",
      "summary": "Add two numbers represented as reversed linked lists. Simulate digit-by-digit addition with carry, building the result list as you go.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440115",
          "name": "Elementary Math Simulation",
          "order": 1,
          "intuition": "Since digits are in reverse order (ones place first), we can add them directly left-to-right, just like manual addition.\n\nKeep track of the carry: if sum >= 10, carry 1 to the next digit.",
          "approach": "1. Initialize carry = 0 and result with dummy head\n2. While either list has nodes OR carry > 0:\n   - Get digits (0 if list exhausted)\n   - sum = digit1 + digit2 + carry\n   - Create node with sum % 10\n   - Update carry = sum / 10\n3. Return dummy.next",
          "explanation": "The reverse order is a gift - it means we process from least significant to most significant, exactly as in manual addition.\n\nHandling unequal lengths: treat exhausted list as contributing 0.\n\nDon't forget the final carry! If sum of last digits produces a carry, we need one more node (e.g., 5+5=10 needs [0,1]).\n\nThe dummy node simplifies appending the first result node.",
          "code": "func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var p1 = l1\n    var p2 = l2\n    var carry = 0\n    \n    while p1 != nil || p2 != nil || carry > 0 {\n        let val1 = p1?.val ?? 0\n        let val2 = p2?.val ?? 0\n        let sum = val1 + val2 + carry\n        \n        carry = sum / 10\n        tail.next = ListNode(sum % 10)\n        tail = tail.next!\n        \n        p1 = p1?.next\n        p2 = p2?.next\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(max(m, n))",
            "space": "O(max(m, n))",
            "timeExplanation": "Process max(m,n) digits where m and n are list lengths",
            "spaceExplanation": "Result list has at most max(m,n)+1 nodes"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440214",
              "input": "l1 = [2,4,3], l2 = [5,6,4]",
              "expectedOutput": "[7,0,8]",
              "explanation": "342 + 465 = 807. Process: 2+5=7, 4+6=10 (carry 1), 3+4+1=8"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440215",
              "input": "l1 = [9,9,9], l2 = [1]",
              "expectedOutput": "[0,0,0,1]",
              "explanation": "999 + 1 = 1000. Final carry creates extra digit"
            }
          ]
        }
      ],
      "relatedProblems": [
        "add-two-numbers-ii",
        "multiply-strings"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440009",
      "problemSlug": "find-the-duplicate-number",
      "summary": "Find the duplicate in array of n+1 integers where each is in [1,n]. Use Floyd's cycle detection - treat values as pointers to create a linked list with a cycle at the duplicate.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440116",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "intuition": "Treat the array as a linked list where nums[i] points to index nums[i]. Since there's a duplicate, two indices point to the same location, creating a cycle.\n\nThe cycle's entry point is the duplicate value.",
          "approach": "1. Phase 1 - Find intersection:\n   - slow = nums[slow], fast = nums[nums[fast]]\n   - Continue until they meet (inside cycle)\n2. Phase 2 - Find entry point:\n   - Reset slow to start (index 0)\n   - Move both one step at a time\n   - They meet at the duplicate",
          "explanation": "Why does this work? Consider the array as a graph where index i has an edge to index nums[i].\n\nSince values are in [1,n] and we start at index 0, we never revisit 0. But since there's a duplicate value, some index is pointed to by two different indices - that's our cycle entry.\n\nThe math for why phase 2 works: if slow traveled distance d to the meeting point, and cycle length is C, then fast traveled 2d. The meeting point is d mod C steps into the cycle. The entry point is exactly d mod C steps back, which equals the distance from start.",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    // Phase 1: Find intersection point\n    var slow = nums[0]\n    var fast = nums[0]\n    \n    repeat {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    } while slow != fast\n    \n    // Phase 2: Find cycle entry (the duplicate)\n    slow = nums[0]\n    while slow != fast {\n        slow = nums[slow]\n        fast = nums[fast]\n    }\n    \n    return slow\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each phase traverses at most n elements",
            "spaceExplanation": "Only use two pointer variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440216",
              "input": "[1,3,4,2,2]",
              "expectedOutput": "2",
              "explanation": "Graph: 0\u21921\u21923\u21922\u21924\u21922 (cycle at 2). Duplicate is 2"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440217",
              "input": "[3,1,3,4,2]",
              "expectedOutput": "3",
              "explanation": "Graph: 0\u21923\u21924\u21922\u21923 (cycle at 3). Duplicate is 3"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440117",
          "name": "Binary Search on Value Range",
          "order": 2,
          "intuition": "Binary search on the answer space [1,n]. For a candidate mid, count numbers \u2264 mid. If count > mid, duplicate is in [1,mid].",
          "approach": "1. Set lo = 1, hi = n\n2. While lo < hi:\n   - mid = (lo + hi) / 2\n   - Count elements \u2264 mid\n   - If count > mid: hi = mid (duplicate in lower half)\n   - Else: lo = mid + 1\n3. Return lo",
          "explanation": "The pigeonhole principle: if we have more than mid numbers in [1,mid], at least one must be duplicated.\n\nThis doesn't find which number is duplicated directly - it narrows down the range until lo == hi, which is the duplicate.\n\nExample: [1,3,4,2,2]. Count \u2264 2 is 3 (elements 1,2,2). Since 3 > 2, duplicate is in [1,2]. Count \u2264 1 is 1. So duplicate is 2.",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    var lo = 1\n    var hi = nums.count - 1\n    \n    while lo < hi {\n        let mid = lo + (hi - lo) / 2\n        let count = nums.filter { $0 <= mid }.count\n        \n        if count > mid {\n            hi = mid  // Duplicate in lower half\n        } else {\n            lo = mid + 1  // Duplicate in upper half\n        }\n    }\n    \n    return lo\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(1)",
            "timeExplanation": "O(log n) binary search iterations, each counting O(n) elements",
            "spaceExplanation": "Only use a few variables"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "linked-list-cycle-ii",
        "missing-number"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440010",
      "problemSlug": "lru-cache",
      "summary": "Implement an LRU cache with O(1) get and put. Combine a hash map (O(1) lookup) with a doubly linked list (O(1) insertion/deletion) to track recency.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440118",
          "name": "Hash Map + Doubly Linked List",
          "order": 1,
          "intuition": "We need two operations in O(1):\n1. Find a key \u2192 hash map\n2. Track/update recency \u2192 doubly linked list\n\nMost recently used at head, least recently used at tail. On access, move node to head.",
          "approach": "1. Doubly linked list with dummy head/tail\n2. Hash map: key \u2192 node reference\n3. get(key): if exists, move to head, return value\n4. put(key, value):\n   - If exists: update value, move to head\n   - If new: create node, add to head, add to map\n   - If over capacity: remove tail node, remove from map",
          "explanation": "The doubly linked list maintains order by recency. The hash map provides O(1) access to any node.\n\nWhy doubly linked? We need to remove a node from the middle in O(1). With a doubly linked list, given a node reference, we can update prev.next and next.prev directly.\n\nDummy head and tail simplify edge cases (empty list, single element). The actual nodes are always between these dummies.",
          "code": "class LRUCache {\n    private class Node {\n        let key: Int\n        var value: Int\n        var prev: Node?\n        var next: Node?\n        \n        init(_ key: Int, _ value: Int) {\n            self.key = key\n            self.value = value\n        }\n    }\n    \n    private let capacity: Int\n    private var cache: [Int: Node] = [:]\n    private let head = Node(0, 0)  // Dummy head\n    private let tail = Node(0, 0)  // Dummy tail\n    \n    init(_ capacity: Int) {\n        self.capacity = capacity\n        head.next = tail\n        tail.prev = head\n    }\n    \n    func get(_ key: Int) -> Int {\n        guard let node = cache[key] else { return -1 }\n        moveToHead(node)\n        return node.value\n    }\n    \n    func put(_ key: Int, _ value: Int) {\n        if let node = cache[key] {\n            node.value = value\n            moveToHead(node)\n        } else {\n            let node = Node(key, value)\n            cache[key] = node\n            addToHead(node)\n            \n            if cache.count > capacity {\n                let removed = removeTail()\n                cache.removeValue(forKey: removed.key)\n            }\n        }\n    }\n    \n    private func addToHead(_ node: Node) {\n        node.prev = head\n        node.next = head.next\n        head.next?.prev = node\n        head.next = node\n    }\n    \n    private func removeNode(_ node: Node) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n    }\n    \n    private func moveToHead(_ node: Node) {\n        removeNode(node)\n        addToHead(node)\n    }\n    \n    private func removeTail() -> Node {\n        let node = tail.prev!\n        removeNode(node)\n        return node\n    }\n}",
          "complexity": {
            "time": "O(1)",
            "space": "O(capacity)",
            "timeExplanation": "Both get and put are O(1) - hash lookup and list operations are constant time",
            "spaceExplanation": "Store at most 'capacity' nodes in map and list"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440218",
              "input": "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]",
              "expectedOutput": "[null,null,null,1,null,-1,null,-1,3,4]",
              "explanation": "After put(3,3), cache is [1,3]. get(2) returns -1 (evicted). After put(4,4), cache is [3,4]."
            }
          ]
        }
      ],
      "relatedProblems": [
        "lfu-cache",
        "design-in-memory-file-system"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "113bd68d-ec6b-40ce-b8d5-e276ed1a6f55",
      "problemSlug": "invert-binary-tree",
      "summary": "Invert a binary tree by swapping every node's left and right child. The simplest way is a DFS that swaps then recurses.",
      "approaches": [
        {
          "id": "0d68f729-008b-4c44-a14b-5db7877db5b5",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "If you swap a node's left and right children, and then do the same for its children, the entire tree becomes its mirror image.",
          "approach": "1. If root is nil, return nil.\n2. Swap root.left and root.right.\n3. Recursively invert the left subtree.\n4. Recursively invert the right subtree.\n5. Return root.",
          "explanation": "Each node is visited once. Swapping children at each node creates the mirror image. The recursion unwinds after reaching leaves.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    let temp = root.left\n    root.left = root.right\n    root.right = temp\n    _ = invertTree(root.left)\n    _ = invertTree(root.right)\n    return root\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Every node is visited exactly once",
            "spaceExplanation": "Recursion stack depth equals tree height h"
          },
          "testCases": [
            {
              "id": "0f14dc66-108b-4b35-b924-5eff2f49797c",
              "input": "root = [4,2,7,1,3,6,9]",
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap."
            },
            {
              "id": "67919ef7-73d2-44f6-bf81-ae8463aacbbb",
              "input": "root = [2,1,3]",
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root."
            }
          ]
        },
        {
          "id": "f3ccd674-5539-4a80-a251-444b32df5cb2",
          "name": "Iterative BFS",
          "order": 2,
          "intuition": "A level-order traversal lets us swap children for every node without recursion.",
          "approach": "1. If root is nil, return nil.\n2. Push root to a queue.\n3. While queue not empty: pop a node, swap its children, push non-nil children.\n4. Return root.",
          "explanation": "The queue visits nodes level by level. Swapping children during the visit yields the same mirror as the recursive solution.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    var queue: [TreeNode] = [root]\n    var index = 0\n    while index < queue.count {\n        let node = queue[index]\n        index += 1\n        let temp = node.left\n        node.left = node.right\n        node.right = temp\n        if let left = node.left { queue.append(left) }\n        if let right = node.right { queue.append(right) }\n    }\n    return root\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is processed once",
            "spaceExplanation": "Queue can hold up to a full level of nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "d60edf13-e40b-4234-9de4-80e19e97ae9d",
      "problemSlug": "maximum-depth-of-binary-tree",
      "summary": "Maximum depth is the length of the longest root-to-leaf path. Compute it via DFS recursion or BFS level counting.",
      "approaches": [
        {
          "id": "050c5512-9554-480c-99ec-4fb2c0986636",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "The depth of a node is 1 plus the maximum depth of its children.",
          "approach": "1. If root is nil, return 0.\n2. Recursively compute leftDepth and rightDepth.\n3. Return 1 + max(leftDepth, rightDepth).",
          "explanation": "The recursion bottoms out at empty subtrees (depth 0). Each call returns the depth of that subtree.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height h"
          },
          "testCases": [
            {
              "id": "d8ea7529-25a9-46df-a1d5-ad66d281758e",
              "input": "root = [3,9,20,null,null,15,7]",
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3 \u2192 20 \u2192 15 (or 7)."
            },
            {
              "id": "b57d4658-6b70-4a70-a4c2-e6cc4d34e311",
              "input": "root = [1,null,2]",
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1 \u2192 2."
            }
          ]
        },
        {
          "id": "4a6e14d7-b155-4d01-86fd-0e782f6bb436",
          "name": "BFS Level Order",
          "order": 2,
          "intuition": "Each BFS layer corresponds to one depth level.",
          "approach": "1. If root is nil, return 0.\n2. Push root to a queue.\n3. For each level, process all nodes in the queue, enqueue their children.\n4. Count levels.",
          "explanation": "BFS processes nodes level by level, so the number of levels processed equals the maximum depth.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    var queue: [TreeNode] = [root]\n    var depth = 0\n    var index = 0\n    while index < queue.count {\n        let levelCount = queue.count - index\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        depth += 1\n    }\n    return depth\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node enqueued and dequeued once",
            "spaceExplanation": "Queue stores up to one full level"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "invert-binary-tree",
        "minimum-depth-of-binary-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "e0d239e6-12c6-431f-881c-d362768f9b11",
      "problemSlug": "same-tree",
      "summary": "Two trees are the same if their structures match and all corresponding node values are equal. Compare them node by node.",
      "approaches": [
        {
          "id": "67ad78db-e53d-41e1-bfb6-fc5d00c078c7",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "Both trees are equal if the current values match and both left subtrees and right subtrees are equal.",
          "approach": "1. If both nodes are nil, return true.\n2. If only one is nil, return false.\n3. If values differ, return false.\n4. Recursively compare left and right children.",
          "explanation": "The recursion enforces structural equality and value equality at every position.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited at most once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "122dfbc8-09a4-45e0-a5f3-409788a05360",
              "input": "p = [1,2,3], q = [1,2,3]",
              "expectedOutput": "true",
              "explanation": "Same structure and values."
            },
            {
              "id": "d32e933d-3be7-4018-887f-a9570607ba37",
              "input": "p = [1,2], q = [1,null,2]",
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child)."
            },
            {
              "id": "2dbb90c1-24c7-4b23-bd27-a3af1e8dd072",
              "input": "p = [1,2,1], q = [1,1,2]",
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes."
            }
          ]
        },
        {
          "id": "9901b309-c7f0-4a01-9f62-cb632648a7d1",
          "name": "Iterative Stack",
          "order": 2,
          "intuition": "Use a stack to compare nodes in lockstep without recursion.",
          "approach": "1. Push (p, q) onto a stack.\n2. While stack not empty: pop, compare nodes similarly to recursion.\n3. Push child pairs.\n4. If any mismatch, return false; otherwise true.",
          "explanation": "This mirrors DFS recursion but uses an explicit stack to avoid call stack usage.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    var stack: [(TreeNode?, TreeNode?)] = [(p, q)]\n    while let (left, right) = stack.popLast() {\n        if left == nil && right == nil { continue }\n        guard let l = left, let r = right else { return false }\n        if l.val != r.val { return false }\n        stack.append((l.left, r.left))\n        stack.append((l.right, r.right))\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node pair processed once",
            "spaceExplanation": "Stack holds nodes along a path"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "subtree-of-another-tree",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "39b75eb0-0ce6-46cd-a8d0-18e7f882b767",
      "problemSlug": "subtree-of-another-tree",
      "summary": "Check every node in the main tree as a potential root and compare subtrees for equality.",
      "approaches": [
        {
          "id": "3b0434af-e80d-47ad-985c-7923e0154acd",
          "name": "DFS + Same Tree",
          "order": 1,
          "intuition": "If two trees are identical, then subRoot matches the subtree at that node. Try this at every node in root.",
          "approach": "1. If root is nil, return false (subRoot is non-nil).\n2. If isSameTree(root, subRoot) return true.\n3. Otherwise, recurse on root.left and root.right.",
          "explanation": "We reuse a same-tree check. The first match we find proves subRoot is a subtree.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    guard let root = root else { return false }\n    if isSameTree(root, subRoot) { return true }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}\n\nprivate func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "time": "O(n * m)",
            "space": "O(h)",
            "timeExplanation": "In the worst case, compare subRoot at every node",
            "spaceExplanation": "Recursion stack height of root tree"
          },
          "testCases": [
            {
              "id": "20a2a01b-f130-4d94-b320-438eca23093b",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot."
            },
            {
              "id": "e9aba558-e4fa-4d94-8296-6cbd49810888",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality."
            }
          ]
        },
        {
          "id": "2c55fff8-4140-49a2-b3c2-053861a7769e",
          "name": "Serialization",
          "order": 2,
          "intuition": "Serialize both trees with null markers; subRoot is a subtree if its serialization is a substring of root's serialization.",
          "approach": "1. Serialize root with preorder + null markers.\n2. Serialize subRoot similarly.\n3. Check if subRoot serialization is contained in root serialization.",
          "explanation": "Null markers prevent false matches where different structures have the same value sequence.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    let rootStr = serialize(root)\n    let subStr = serialize(subRoot)\n    return rootStr.contains(subStr)\n}\n\nprivate func serialize(_ node: TreeNode?) -> String {\n    guard let node = node else { return \"#\" }\n    return \"(\\(node.val)),\\(serialize(node.left)),\\(serialize(node.right))\"\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(n + m)",
            "timeExplanation": "Serialize both trees once",
            "spaceExplanation": "Serialized strings store all nodes and nulls"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "same-tree",
        "find-duplicate-subtrees"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "32841a93-64e4-40c2-8f8a-bee6d4c5f666",
      "problemSlug": "lowest-common-ancestor-of-a-binary-search-tree",
      "summary": "Use the BST ordering: if both targets are less than the current node, go left; if greater, go right; otherwise current is the LCA.",
      "approaches": [
        {
          "id": "153d1e3d-75a6-4b8e-86bc-81ea9dbc1dba",
          "name": "Iterative BST Walk",
          "order": 1,
          "intuition": "In a BST, all left values are smaller and all right values are larger. The first split point is the LCA.",
          "approach": "1. Start at root.\n2. If both p and q are smaller, move left.\n3. If both larger, move right.\n4. Otherwise, current node is the LCA.",
          "explanation": "The LCA is the node where the paths to p and q diverge (or where one equals the current node).",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    var node = root\n    guard let p = p, let q = q else { return nil }\n    while let current = node {\n        if p.val < current.val && q.val < current.val {\n            node = current.left\n        } else if p.val > current.val && q.val > current.val {\n            node = current.right\n        } else {\n            return current\n        }\n    }\n    return nil\n}",
          "complexity": {
            "time": "O(h)",
            "space": "O(1)",
            "timeExplanation": "Walks down one path of height h",
            "spaceExplanation": "Iterative, constant extra space"
          },
          "testCases": [
            {
              "id": "38f1a9a5-13a3-4905-a7d9-bd93b2027500",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
              "expectedOutput": "6",
              "explanation": "p and q split at 6, so 6 is the LCA."
            },
            {
              "id": "812c7249-8f40-4310-978c-f8f10b0a8f6f",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
              "expectedOutput": "2",
              "explanation": "p is an ancestor of q, so LCA is 2."
            }
          ]
        },
        {
          "id": "25e41dd6-c040-42ec-83e3-965baa348c08",
          "name": "Recursive BST",
          "order": 2,
          "intuition": "The BST property lets us eliminate half the tree at each step using recursion.",
          "approach": "1. If both values are less than root, recurse left.\n2. If both greater, recurse right.\n3. Otherwise, root is the LCA.",
          "explanation": "Same logic as the iterative approach, but expressed recursively.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root, let p = p, let q = q else { return nil }\n    if p.val < root.val && q.val < root.val {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if p.val > root.val && q.val > root.val {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n}",
          "complexity": {
            "time": "O(h)",
            "space": "O(h)",
            "timeExplanation": "Traverses one root-to-leaf path",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "56d579d8-24d9-4502-8d47-d9c3bf6a0301",
              "input": "root = [2,1], p = 2, q = 1",
              "expectedOutput": "2",
              "explanation": "Root is the ancestor of both nodes."
            }
          ]
        }
      ],
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-tree",
        "validate-binary-search-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "bf8d33be-a2fd-469f-9a92-9dee92c4d0fe",
      "problemSlug": "binary-tree-level-order-traversal",
      "summary": "Traverse the tree level by level using a queue, collecting values for each level as you go.",
      "approaches": [
        {
          "id": "25312294-5031-458e-90c6-4c8cab60dacb",
          "name": "BFS by Level",
          "order": 1,
          "intuition": "Breadth-first search naturally visits nodes in level order. If we process nodes in fixed-size batches per level, we can build the result list of lists.",
          "approach": "1. If root is nil, return [].\n2. Initialize a queue with root.\n3. While queue not empty: record current queue size, pop that many nodes, collect values, and enqueue children.\n4. Append each level list to the result.",
          "explanation": "The queue holds nodes in the next level to process. Capturing the queue size before processing ensures each iteration only handles one level at a time.",
          "code": "func levelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var index = 0\n\n    while index < queue.count {\n        let levelCount = queue.count - index\n        var level: [Int] = []\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(level)\n    }\n\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is enqueued and dequeued exactly once",
            "spaceExplanation": "Queue can hold up to one full level of nodes"
          },
          "testCases": [
            {
              "id": "9f2e77b8-7e7f-4d6b-a5d4-7655d72ac176",
              "input": "root = [3,9,20,null,null,15,7]",
              "expectedOutput": "[[3],[9,20],[15,7]]",
              "explanation": "Level 0: [3], level 1: [9,20], level 2: [15,7]."
            },
            {
              "id": "4151eab9-a595-48a9-8e25-859a8941a9c3",
              "input": "root = [1]",
              "expectedOutput": "[[1]]",
              "explanation": "Single node forms one level."
            },
            {
              "id": "21a31bc5-894f-494f-85d1-1d21f0008299",
              "input": "root = []",
              "expectedOutput": "[]",
              "explanation": "Empty tree produces empty result."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal-ii",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "0353cc5c-702e-4d1a-a450-1ccb23ae4ff3",
      "problemSlug": "validate-binary-search-tree",
      "summary": "A BST is valid if every node value lies within allowed bounds and both subtrees are valid. Use DFS with min/max bounds.",
      "approaches": [
        {
          "id": "89f02580-9ff3-4722-84a5-5c0266733222",
          "name": "DFS with Bounds",
          "order": 1,
          "intuition": "Each node must be greater than all values in its left ancestors and less than all values in its right ancestors.",
          "approach": "1. Recurse with optional min and max bounds.\n2. If node.val <= min or node.val >= max, return false.\n3. Recurse left with max = node.val, right with min = node.val.",
          "explanation": "Bounds carry the valid range down the tree, enforcing the BST rule at every node, not just locally.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    func dfs(_ node: TreeNode?, _ minVal: Int?, _ maxVal: Int?) -> Bool {\n        guard let node = node else { return true }\n        if let minVal = minVal, node.val <= minVal { return false }\n        if let maxVal = maxVal, node.val >= maxVal { return false }\n        return dfs(node.left, minVal, node.val) && dfs(node.right, node.val, maxVal)\n    }\n    return dfs(root, nil, nil)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "c2954d68-4c67-4523-88eb-70976739d27b",
              "input": "root = [2,1,3]",
              "expectedOutput": "true",
              "explanation": "All nodes satisfy BST ordering."
            },
            {
              "id": "dd924f21-6113-4c2b-8b02-b135313db87f",
              "input": "root = [5,1,4,null,null,3,6]",
              "expectedOutput": "false",
              "explanation": "Right subtree contains 3 which is less than 5."
            }
          ]
        },
        {
          "id": "b33d33bc-0d11-40c8-8325-73ad89c9a61a",
          "name": "Inorder Traversal",
          "order": 2,
          "intuition": "Inorder traversal of a BST yields a strictly increasing sequence.",
          "approach": "1. Traverse inorder while tracking previous value.\n2. If current value <= previous, return false.\n3. Otherwise continue.",
          "explanation": "A single pass through the inorder sequence is enough to verify strict ordering.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    var prev: Int? = nil\n    var stack: [TreeNode] = []\n    var node = root\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        if let prev = prev, current.val <= prev { return false }\n        prev = current.val\n        node = current.right\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is pushed/popped once",
            "spaceExplanation": "Stack holds at most one root-to-leaf path"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "validate-binary-search-tree",
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "8caca365-f1ea-4ee1-9d57-18b73d6ffa78",
      "problemSlug": "kth-smallest-element-in-a-bst",
      "summary": "The inorder traversal of a BST is sorted. Walk inorder and stop at the kth value.",
      "approaches": [
        {
          "id": "a4188ae4-1591-4141-a97d-54be7ab95628",
          "name": "Iterative Inorder",
          "order": 1,
          "intuition": "Inorder traversal returns values in increasing order, so the kth visited node is the answer.",
          "approach": "1. Use a stack to simulate inorder traversal.\n2. Pop nodes and count visits.\n3. When count reaches k, return the node value.",
          "explanation": "The stack walks left as far as possible, then processes nodes in ascending order.",
          "code": "func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n    var stack: [TreeNode] = []\n    var node = root\n    var remaining = k\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        remaining -= 1\n        if remaining == 0 { return current.val }\n        node = current.right\n    }\n    return 0\n}",
          "complexity": {
            "time": "O(h + k)",
            "space": "O(h)",
            "timeExplanation": "Walk down height h, then visit k nodes",
            "spaceExplanation": "Stack holds at most h nodes"
          },
          "testCases": [
            {
              "id": "e1c24e01-a57c-4661-a5bc-5c2f02f2a718",
              "input": "root = [3,1,4,null,2], k = 1",
              "expectedOutput": "1",
              "explanation": "Inorder sequence is [1,2,3,4], kth=1."
            },
            {
              "id": "5796f1a9-8de9-4dfc-8d34-dea87d368c27",
              "input": "root = [5,3,6,2,4,null,null,1], k = 3",
              "expectedOutput": "3",
              "explanation": "Inorder sequence is [1,2,3,4,5,6], kth=3."
            }
          ]
        }
      ],
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-search-tree-iterator"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "0f6835b4-c6b9-4e33-9ea7-7652f64e3434",
      "problemSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "summary": "Preorder gives the root, inorder splits left and right subtrees. Rebuild recursively using index boundaries.",
      "approaches": [
        {
          "id": "e371a4eb-53b2-4d10-96d8-2c3844972ffa",
          "name": "Recursive with Index Map",
          "order": 1,
          "intuition": "The first preorder value is always the root. In inorder, everything left of the root belongs to the left subtree, and everything right belongs to the right subtree.",
          "approach": "1. Build a map from inorder value to index.\n2. Use a preorder index pointer.\n3. Recurse on inorder ranges to construct left and right subtrees.",
          "explanation": "The map gives O(1) splits. The preorder index advances as we create nodes, preserving root-left-right ordering.",
          "code": "func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n    var indexMap: [Int: Int] = [:]\n    for (i, val) in inorder.enumerated() { indexMap[val] = i }\n    var preIndex = 0\n\n    func helper(_ left: Int, _ right: Int) -> TreeNode? {\n        if left > right { return nil }\n        let rootVal = preorder[preIndex]\n        preIndex += 1\n        let root = TreeNode(rootVal)\n        let mid = indexMap[rootVal] ?? 0\n        root.left = helper(left, mid - 1)\n        root.right = helper(mid + 1, right)\n        return root\n    }\n\n    return helper(0, inorder.count - 1)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is created once",
            "spaceExplanation": "Index map plus recursion stack"
          },
          "testCases": [
            {
              "id": "9769abcb-30d8-4e89-b038-dfa6aa7917c4",
              "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
              "expectedOutput": "[3,9,20,null,null,15,7]",
              "explanation": "Root 3 splits inorder into [9] and [15,20,7]."
            },
            {
              "id": "7b95b045-a63f-444a-8fe5-3117532115f5",
              "input": "preorder = [-1], inorder = [-1]",
              "expectedOutput": "[-1]",
              "explanation": "Single node tree."
            }
          ]
        }
      ],
      "relatedProblems": [
        "construct-binary-tree-from-inorder-and-postorder-traversal",
        "serialize-and-deserialize-binary-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "cd5da6fc-1d62-4a2a-860f-36786c25a511",
      "problemSlug": "binary-tree-maximum-path-sum",
      "summary": "Compute the maximum path sum by tracking the best gain from each node and updating a global maximum for paths that pass through the node.",
      "approaches": [
        {
          "id": "d9d42e75-cc17-4b5e-bfd9-711ee17cc498",
          "name": "DFS with Max Gain",
          "order": 1,
          "intuition": "For each node, the best path going up can include only one child. But the best path overall might use both children plus the node.",
          "approach": "1. DFS returns max gain from a node to its parent.\n2. At each node, compute leftGain and rightGain (ignore negatives).\n3. Update global answer with leftGain + node.val + rightGain.\n4. Return node.val + max(leftGain, rightGain).",
          "explanation": "This separates the path-to-parent (one side only) from the best path through a node (both sides). The global maximum is updated at every node.",
          "code": "func maxPathSum(_ root: TreeNode?) -> Int {\n    var best = Int.min\n\n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = max(0, dfs(node.left))\n        let right = max(0, dfs(node.right))\n        best = max(best, left + node.val + right)\n        return node.val + max(left, right)\n    }\n\n    _ = dfs(root)\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "01213095-ad3e-45dc-9ef2-a463c884ef88",
              "input": "root = [1,2,3]",
              "expectedOutput": "6",
              "explanation": "Best path is 2 -> 1 -> 3 with sum 6."
            },
            {
              "id": "bc57200e-8fb6-44ce-a318-49381be2bb4c",
              "input": "root = [-10,9,20,null,null,15,7]",
              "expectedOutput": "42",
              "explanation": "Best path is 15 -> 20 -> 7 with sum 42."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "binary-tree-maximum-path-sum-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "5631cebc-4b66-43d6-b7a3-e5cceade37a0",
      "problemSlug": "implement-trie-prefix-tree",
      "summary": "Store characters in a trie so insert/search/startsWith all run in time proportional to the word length.",
      "approaches": [
        {
          "id": "d23ec3a2-765a-4364-9cac-9fe8c9c8b47f",
          "name": "Array-Backed Trie",
          "order": 1,
          "intuition": "Each node keeps 26 children for a-z. Walking characters from the root visits the prefix path.",
          "approach": "1. Insert: create missing children for each character, then mark end.\n2. Search: walk characters and ensure end marker.\n3. StartsWith: walk characters and ensure path exists.",
          "explanation": "All operations traverse at most L nodes where L is the word length.",
          "code": "class Trie {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func insert(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        guard let node = walk(word) else { return false }\n        return node.isEnd\n    }\n\n    func startsWith(_ prefix: String) -> Bool {\n        return walk(prefix) != nil\n    }\n\n    private func walk(_ word: String) -> Node? {\n        var node: Node? = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            node = node?.children[index]\n            if node == nil { return nil }\n        }\n        return node\n    }\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(total chars)",
            "timeExplanation": "Each operation scans L characters",
            "spaceExplanation": "Trie stores one node per character inserted"
          },
          "testCases": [
            {
              "id": "d5b74d5e-0be1-4a54-9b51-b831e8f9a06b",
              "input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]",
              "expectedOutput": "[null,null,true,false,true,null,true]",
              "explanation": "search(\"app\") is false before inserting \"app\" and true afterward."
            }
          ]
        }
      ],
      "relatedProblems": [
        "design-add-and-search-words-data-structure",
        "word-search-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "5c72dc35-6d92-4233-8cab-5483ab374461",
      "problemSlug": "design-add-and-search-words-data-structure",
      "summary": "Use a trie with DFS to support wildcard dots in search while keeping addWord efficient.",
      "approaches": [
        {
          "id": "1439dfbb-c19a-451d-a4df-44f0ed92869e",
          "name": "Trie + DFS Wildcard",
          "order": 1,
          "intuition": "A dot can match any child, so search must branch when encountering a dot.",
          "approach": "1. addWord inserts into a trie.\n2. search uses DFS: if char is dot, try all children; otherwise follow the matching child.\n3. If end of word, require node.isEnd.",
          "explanation": "The trie compresses shared prefixes, and DFS handles the wildcard branching only when needed.",
          "code": "class WordDictionary {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func addWord(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        let chars = Array(word)\n        func dfs(_ node: Node?, _ i: Int) -> Bool {\n            guard let node = node else { return false }\n            if i == chars.count { return node.isEnd }\n            let c = chars[i]\n            if c == \".\" {\n                for child in node.children {\n                    if dfs(child, i + 1) { return true }\n                }\n                return false\n            }\n            let index = Int(c.asciiValue! - Character(\"a\").asciiValue!)\n            return dfs(node.children[index], i + 1)\n        }\n        return dfs(root, 0)\n    }\n}",
          "complexity": {
            "time": "O(L) average, O(26^L) worst",
            "space": "O(total chars)",
            "timeExplanation": "Wildcards can branch across children in the worst case",
            "spaceExplanation": "Trie stores all inserted characters"
          },
          "testCases": [
            {
              "id": "528c7f9f-bd8d-46d8-8e95-c313e0b4b2e1",
              "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
              "expectedOutput": "[null,null,null,null,false,true,true,true]",
              "explanation": "Wildcards match any letter (\".ad\" matches bad/dad/mad)."
            }
          ]
        }
      ],
      "relatedProblems": [
        "implement-trie-prefix-tree",
        "word-search-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "d90f3c15-1512-4eab-8c4d-7da3267a3264",
      "problemSlug": "word-search-ii",
      "summary": "Build a trie of all words, then DFS the board to find any paths that match trie prefixes.",
      "approaches": [
        {
          "id": "104fbf07-a53f-4c54-a1d8-f574d1b2edfd",
          "name": "Trie + DFS",
          "order": 1,
          "intuition": "A trie lets us prune searches early when a prefix does not exist. DFS explores valid paths on the board.",
          "approach": "1. Insert all words into a trie.\n2. For each board cell, DFS while tracking trie nodes.\n3. When a trie node contains a word, add it to results and mark as used.\n4. Mark cells as visited during DFS to avoid reuse.",
          "explanation": "The trie avoids checking every word separately, and DFS explores only viable prefixes from each cell.",
          "code": "func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\n    class TrieNode {\n        var children: [TrieNode?] = Array(repeating: nil, count: 26)\n        var word: String? = nil\n    }\n\n    let root = TrieNode()\n    for word in words {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil { node.children[index] = TrieNode() }\n            node = node.children[index]!\n        }\n        node.word = word\n    }\n\n    var board = board\n    let rows = board.count\n    let cols = board.first?.count ?? 0\n    var results: [String] = []\n    let dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    func dfs(_ r: Int, _ c: Int, _ node: TrieNode) {\n        let char = board[r][c]\n        let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n        guard let next = node.children[index] else { return }\n\n        if let word = next.word {\n            results.append(word)\n            next.word = nil\n        }\n\n        board[r][c] = \"#\"\n        for (dr, dc) in dirs {\n            let nr = r + dr\n            let nc = c + dc\n            if nr >= 0, nr < rows, nc >= 0, nc < cols, board[nr][nc] != \"#\" {\n                dfs(nr, nc, next)\n            }\n        }\n        board[r][c] = char\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            dfs(r, c, root)\n        }\n    }\n    return results\n}",
          "complexity": {
            "time": "O(m * n * 4^L)",
            "space": "O(total chars + L)",
            "timeExplanation": "Worst-case DFS from each cell with pruning by trie",
            "spaceExplanation": "Trie plus recursion depth up to max word length"
          },
          "testCases": [
            {
              "id": "8134f717-85dc-4975-a0e3-7659b08d15a1",
              "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
              "expectedOutput": "[\"eat\",\"oath\"]",
              "explanation": "Only \"eat\" and \"oath\" can be formed by adjacent cells."
            },
            {
              "id": "061876ba-28aa-4184-b735-8db3209332ed",
              "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
              "expectedOutput": "[]",
              "explanation": "Cannot reuse the same cell twice to form \"abcb\"."
            }
          ]
        }
      ],
      "relatedProblems": [
        "word-search",
        "implement-trie-prefix-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "089040a5-891d-4aa8-8015-eec25ac45f8e",
      "problemSlug": "count-good-nodes-in-binary-tree",
      "summary": "Track the maximum value along the path from the root to each node; a node is good if it is at least that maximum.",
      "approaches": [
        {
          "id": "8c3fe2b2-84c5-446c-8794-99ae762f95e0",
          "name": "DFS with Path Maximum",
          "order": 1,
          "intuition": "A node is good if its value is greater than or equal to all values seen so far on the path.",
          "approach": "1. DFS from the root with current max value.\n2. If node.val >= max, count it as good.\n3. Update max and recurse on children.",
          "explanation": "The max value on the path fully determines whether a node is good.",
          "code": "func goodNodes(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?, _ currentMax: Int) -> Int {\n        guard let node = node else { return 0 }\n        let isGood = node.val >= currentMax ? 1 : 0\n        let nextMax = max(currentMax, node.val)\n        return isGood + dfs(node.left, nextMax) + dfs(node.right, nextMax)\n    }\n    guard let root = root else { return 0 }\n    return dfs(root, root.val)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "e37487e8-c61c-4bdf-ab6c-e62ce931337a",
              "input": "root = [3,1,4,3,null,1,5]",
              "expectedOutput": "4",
              "explanation": "Good nodes are 3,4,5,3 (left grandchild)."
            },
            {
              "id": "68ad95d2-659d-4f24-b8f1-eed1d5fa6459",
              "input": "root = [3,3,null,4,2]",
              "expectedOutput": "3",
              "explanation": "All except node 2 are good."
            },
            {
              "id": "954e0167-f0a8-4e0f-9a59-d47c51cd61fc",
              "input": "root = [1]",
              "expectedOutput": "1",
              "explanation": "Root is always good."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "9dc90726-ad7b-42b7-bbf9-4f34ef32ba8c",
      "problemSlug": "serialize-and-deserialize-binary-tree",
      "summary": "Use preorder traversal with null markers to serialize, then rebuild the tree by consuming the token list in order.",
      "approaches": [
        {
          "id": "296bba88-9dd2-4f56-bce6-600215ee37fc",
          "name": "Preorder with Null Markers",
          "order": 1,
          "intuition": "Preorder with explicit nulls uniquely represents the tree structure.",
          "approach": "1. Serialize by DFS preorder, output value or \"#\" for nil.\n2. Deserialize by reading tokens in order and rebuilding nodes recursively.",
          "explanation": "Null markers make the structure unambiguous, so a single pass over tokens can reconstruct the original tree.",
          "code": "class Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var result: [String] = []\n        func dfs(_ node: TreeNode?) {\n            guard let node = node else {\n                result.append(\"#\")\n                return\n            }\n            result.append(String(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        }\n        dfs(root)\n        return result.joined(separator: \",\")\n    }\n\n    func deserialize(_ data: String) -> TreeNode? {\n        let tokens = data.split(separator: \",\").map(String.init)\n        var index = 0\n\n        func dfs() -> TreeNode? {\n            if index >= tokens.count { return nil }\n            let token = tokens[index]\n            index += 1\n            if token == \"#\" { return nil }\n            let node = TreeNode(Int(token) ?? 0)\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        }\n\n        return dfs()\n    }\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is visited once in both serialize and deserialize",
            "spaceExplanation": "Tokens plus recursion stack"
          },
          "testCases": [
            {
              "id": "bac9f4b5-62ce-43dd-8019-472f11c5deb1",
              "input": "root = [1,2,3,null,null,4,5]",
              "expectedOutput": "[1,2,3,null,null,4,5]",
              "explanation": "Serialization and deserialization preserve the same shape and values."
            },
            {
              "id": "9d538869-272a-4bd4-97b7-e8d55f231969",
              "input": "root = []",
              "expectedOutput": "[]",
              "explanation": "Empty tree serializes to a null marker and deserializes to nil."
            }
          ]
        }
      ],
      "relatedProblems": [
        "serialize-and-deserialize-bst",
        "construct-binary-tree-from-preorder-and-inorder-traversal"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "b6205791-50c7-4360-819a-607401b4f57a",
      "problemSlug": "two-sum",
      "summary": "Find two indices whose values add up to the target by tracking seen numbers in a hash map.",
      "approaches": [
        {
          "id": "5609529b-e80d-4064-b4df-b5cda6084880",
          "name": "Hash Map",
          "order": 1,
          "intuition": "As we scan the array, if we already saw a value equal to (target - current), we can return that index immediately.\nStoring value -> index lets us find the complement in O(1) time.",
          "approach": "1. Create an empty dictionary valueToIndex.\n2. For each number in nums:\n   - Let complement = target - num.\n   - If complement exists in the dictionary, return [indexOfComplement, currentIndex].\n   - Otherwise store num -> currentIndex.\n3. If no pair found, return an empty array (not expected per constraints).",
          "explanation": "The key is to decide in one pass whether the current number completes a previously seen pair.\nThis avoids the O(n^2) brute-force check and keeps time linear.",
          "code": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    var valueToIndex: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        let complement = target - num\n        if let j = valueToIndex[complement] {\n            return [j, i]\n        }\n        valueToIndex[num] = i\n    }\n    return []\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each number is processed once with O(1) hash lookups.",
            "spaceExplanation": "The hash map can store up to n elements."
          },
          "testCases": [
            {
              "id": "3d3717cb-c805-47a5-923f-5819a87a6b52",
              "input": "nums = [2,7,11,15], target = 9",
              "expectedOutput": "[0,1]",
              "explanation": "2 + 7 = 9, so indices 0 and 1."
            },
            {
              "id": "6c706226-e832-445c-8206-154a288fe2d9",
              "input": "nums = [3,2,4], target = 6",
              "expectedOutput": "[1,2]",
              "explanation": "2 + 4 = 6."
            },
            {
              "id": "0c8fd92c-84f2-4eb9-84b3-1206d534bc08",
              "input": "nums = [3,3], target = 6",
              "expectedOutput": "[0,1]",
              "explanation": "Same value used twice at different indices."
            }
          ]
        }
      ],
      "relatedProblems": [
        "two-sum-ii-input-array-is-sorted",
        "3sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "4aacfe82-e270-4dce-9d65-712c0250a335",
      "problemSlug": "valid-parentheses",
      "summary": "Use a stack to match opening and closing brackets in the correct order.",
      "approaches": [
        {
          "id": "a36e7d66-0c0d-4795-aa09-af72c4b1f241",
          "name": "Stack",
          "order": 1,
          "intuition": "Every closing bracket must match the most recent unmatched opening bracket.\nA stack naturally models this last-in-first-out requirement.",
          "approach": "1. Initialize an empty stack.\n2. For each character:\n   - If it's an opening bracket, push it.\n   - If it's a closing bracket, pop and ensure types match.\n3. The string is valid only if the stack is empty at the end.",
          "explanation": "Any mismatch or premature closing bracket invalidates the string immediately.\nRemaining items in the stack after processing mean unmatched openings.",
          "code": "func isValid(_ s: String) -> Bool {\n    var stack: [Character] = []\n    for ch in s {\n        switch ch {\n        case \"(\", \"{\", \"[\":\n            stack.append(ch)\n        case \")\":\n            if stack.popLast() != \"(\" { return false }\n        case \"}\":\n            if stack.popLast() != \"{\" { return false }\n        case \"]\":\n            if stack.popLast() != \"[\" { return false }\n        default:\n            break\n        }\n    }\n    return stack.isEmpty\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each character is processed once.",
            "spaceExplanation": "The stack can hold up to n opening brackets."
          },
          "testCases": [
            {
              "id": "ba1346c7-9119-4061-b157-8f689e073a07",
              "input": "s = \"()\"",
              "expectedOutput": "true",
              "explanation": "Simple matching pair."
            },
            {
              "id": "809050df-90a2-4163-b33d-7ae30b99c763",
              "input": "s = \"()[]{}\"",
              "expectedOutput": "true",
              "explanation": "All bracket types match in order."
            },
            {
              "id": "236a46f7-4902-4e31-a0fe-37019eb89f6f",
              "input": "s = \"(]\"",
              "expectedOutput": "false",
              "explanation": "Mismatched bracket types."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-remove-to-make-valid-parentheses",
        "generate-parentheses"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "23f4748b-97c7-48ee-b352-423fbcbfd2b2",
      "problemSlug": "contains-duplicate",
      "summary": "Track seen values in a set; a repeat indicates a duplicate.",
      "approaches": [
        {
          "id": "6966b214-f4ce-4778-886f-94a0b3f47720",
          "name": "Hash Set",
          "order": 1,
          "intuition": "If any number appears twice, it will already exist in the set when we see it again.",
          "approach": "1. Create an empty set.\n2. For each number:\n   - If it is in the set, return true.\n   - Otherwise insert it.\n3. Return false if no duplicates are found.",
          "explanation": "Sets provide O(1) average lookup/insert, making this linear time.",
          "code": "func containsDuplicate(_ nums: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) { return true }\n        seen.insert(num)\n    }\n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass with O(1) set checks.",
            "spaceExplanation": "The set can store all unique elements."
          },
          "testCases": [
            {
              "id": "fb1e2b00-0d16-47e1-853d-2eaefef9fa8a",
              "input": "nums = [1,2,3,1]",
              "expectedOutput": "true",
              "explanation": "1 appears twice."
            },
            {
              "id": "6f11889d-5920-43a0-8b23-d5d19a5d5770",
              "input": "nums = [1,2,3,4]",
              "expectedOutput": "false",
              "explanation": "All elements are unique."
            },
            {
              "id": "fa7882d8-0b93-4cab-931b-8029e5c5b4cb",
              "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
              "expectedOutput": "true",
              "explanation": "Multiple duplicates present."
            }
          ]
        }
      ],
      "relatedProblems": [
        "contains-duplicate-ii",
        "contains-duplicate-iii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "22650355-1394-4a7f-8415-15cfe774ea97",
      "problemSlug": "best-time-to-buy-and-sell-stock",
      "summary": "Track the minimum price so far and update the max profit as you scan.",
      "approaches": [
        {
          "id": "c9cfb94b-b023-477e-9e26-9c69c36ae2c1",
          "name": "One Pass",
          "order": 1,
          "intuition": "The best profit ending today is today's price minus the minimum price seen before today.",
          "approach": "1. Initialize minPrice to a large value and bestProfit = 0.\n2. For each price:\n   - Update minPrice = min(minPrice, price).\n   - Update bestProfit = max(bestProfit, price - minPrice).\n3. Return bestProfit.",
          "explanation": "This ensures the buy happens before the sell because minPrice is computed from earlier elements.",
          "code": "func maxProfit(_ prices: [Int]) -> Int {\n    var minPrice = Int.max\n    var best = 0\n    for price in prices {\n        minPrice = min(minPrice, price)\n        best = max(best, price - minPrice)\n    }\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass through the prices.",
            "spaceExplanation": "Only two tracking variables are used."
          },
          "testCases": [
            {
              "id": "5953fc34-b62c-4575-8b2a-b399f798db13",
              "input": "prices = [7,1,5,3,6,4]",
              "expectedOutput": "5",
              "explanation": "Buy at 1, sell at 6."
            },
            {
              "id": "2ad31b7a-6363-4ec5-b36c-a17bb1b55e57",
              "input": "prices = [7,6,4,3,1]",
              "expectedOutput": "0",
              "explanation": "No profitable transaction."
            }
          ]
        }
      ],
      "relatedProblems": [
        "best-time-to-buy-and-sell-stock-ii",
        "best-time-to-buy-and-sell-stock-with-cooldown"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "d9518775-be8b-4eee-a812-7c426fa80106",
      "problemSlug": "valid-anagram",
      "summary": "Count characters in the first string and subtract counts using the second.",
      "approaches": [
        {
          "id": "aa408334-2951-4317-85bb-dae695cb3ac7",
          "name": "Frequency Map",
          "order": 1,
          "intuition": "Two strings are anagrams if every character appears the same number of times in both.",
          "approach": "1. If lengths differ, return false.\n2. Count each character in s.\n3. Decrement for each character in t; if any count becomes negative, return false.\n4. If all counts are zero, return true.",
          "explanation": "Using a dictionary keeps the solution clean and works for any character set.",
          "code": "func isAnagram(_ s: String, _ t: String) -> Bool {\n    if s.count != t.count { return false }\n    var counts: [Character: Int] = [:]\n    for ch in s { counts[ch, default: 0] += 1 }\n    for ch in t {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each string is scanned once.",
            "spaceExplanation": "The map stores counts for distinct characters."
          },
          "testCases": [
            {
              "id": "a82a4a86-78fe-4b64-ae62-2e098816859c",
              "input": "s = \"anagram\", t = \"nagaram\"",
              "expectedOutput": "true",
              "explanation": "All letters match counts."
            },
            {
              "id": "fce32cc3-1f00-4d32-b058-648e801addaf",
              "input": "s = \"rat\", t = \"car\"",
              "expectedOutput": "false",
              "explanation": "Different letters."
            }
          ]
        }
      ],
      "relatedProblems": [
        "group-anagrams",
        "find-all-anagrams-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "751df843-f7df-4040-a033-b2fd1cfc0050",
      "problemSlug": "ransom-note",
      "summary": "Count available letters in the magazine and consume them for the ransom note.",
      "approaches": [
        {
          "id": "8d6b33ea-7830-4e29-a0d6-56d6ea03ab6b",
          "name": "Frequency Map",
          "order": 1,
          "intuition": "Each letter in the ransom note must be supplied by the magazine. If any count is insufficient, it fails.",
          "approach": "1. Count each character in magazine.\n2. For each character in ransomNote, decrement its count.\n3. If any count goes negative, return false. Otherwise return true.",
          "explanation": "This is a direct application of a frequency map: availability vs. demand.",
          "code": "func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {\n    var counts: [Character: Int] = [:]\n    for ch in magazine { counts[ch, default: 0] += 1 }\n    for ch in ransomNote {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "time": "O(m + n)",
            "space": "O(1)",
            "timeExplanation": "Scan magazine and ransom note once.",
            "spaceExplanation": "Character counts are bounded by alphabet size."
          },
          "testCases": [
            {
              "id": "aa950b65-3fb0-478f-8048-cb5ddc162234",
              "input": "ransomNote = \"a\", magazine = \"b\"",
              "expectedOutput": "false",
              "explanation": "Missing letter a."
            },
            {
              "id": "07eea518-2a35-467d-adaf-87edaf1b9eb2",
              "input": "ransomNote = \"aa\", magazine = \"aab\"",
              "expectedOutput": "true",
              "explanation": "Magazine has enough a's."
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-anagram",
        "first-unique-character-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "77394785-c09e-47cc-b524-b42c90507419",
      "problemSlug": "binary-search",
      "summary": "Use classic binary search to find the target in a sorted array.",
      "approaches": [
        {
          "id": "42f5fcff-d6d3-416c-811c-91910896d0c2",
          "name": "Binary Search",
          "order": 1,
          "intuition": "The array is sorted, so we can eliminate half the search space each step.",
          "approach": "1. Set left = 0 and right = n - 1.\n2. While left <= right:\n   - mid = (left + right) / 2\n   - If nums[mid] == target, return mid.\n   - If nums[mid] < target, search the right half; else search the left half.\n3. Return -1 if not found.",
          "explanation": "Binary search guarantees O(log n) time by halving the range each iteration.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "The search range halves each step.",
            "spaceExplanation": "Only constant extra space is used."
          },
          "testCases": [
            {
              "id": "d4c9f72b-8f48-43d1-971d-2b39cdc33656",
              "input": "nums = [-1,0,3,5,9,12], target = 9",
              "expectedOutput": "4",
              "explanation": "9 is at index 4."
            },
            {
              "id": "0fc7cc73-24c8-4531-814c-542ecdb498c2",
              "input": "nums = [-1,0,3,5,9,12], target = 2",
              "expectedOutput": "-1",
              "explanation": "2 is not in the array."
            }
          ]
        }
      ],
      "relatedProblems": [
        "search-in-rotated-sorted-array",
        "first-bad-version"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "e3586dfa-a556-4688-8b3e-7c988f871267",
      "problemSlug": "climbing-stairs",
      "summary": "Each step can be reached from the previous two steps; this forms a Fibonacci sequence.",
      "approaches": [
        {
          "id": "718a7245-392c-498d-82a2-cc018254ba43",
          "name": "DP (Fibonacci)",
          "order": 1,
          "intuition": "The number of ways to reach step i equals ways(i-1) + ways(i-2).",
          "approach": "1. Handle small n (1 or 2) directly.\n2. Iterate from 3 to n, keeping only the last two values.\n3. Return the final value.",
          "explanation": "This is a classic DP problem that collapses to a constant-space Fibonacci computation.",
          "code": "func climbStairs(_ n: Int) -> Int {\n    if n <= 2 { return n }\n    var a = 1\n    var b = 2\n    for _ in 3...n {\n        let c = a + b\n        a = b\n        b = c\n    }\n    return b\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We compute each step once.",
            "spaceExplanation": "Only two integers are stored."
          },
          "testCases": [
            {
              "id": "f9a175ed-00a1-4238-a6cd-94f239da68e7",
              "input": "n = 2",
              "expectedOutput": "2",
              "explanation": "(1+1), (2)."
            },
            {
              "id": "3f2247d4-81b4-488b-9f66-e2db963edaf6",
              "input": "n = 3",
              "expectedOutput": "3",
              "explanation": "(1+1+1), (1+2), (2+1)."
            },
            {
              "id": "f33c3263-9025-4305-81f6-7e0c92dd5514",
              "input": "n = 5",
              "expectedOutput": "8",
              "explanation": "Fibonacci growth."
            }
          ]
        }
      ],
      "relatedProblems": [
        "min-cost-climbing-stairs",
        "house-robber"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "5c11fa1e-3d2c-48ba-b657-8147f2306374",
      "problemSlug": "longest-substring-without-repeating-characters",
      "summary": "Use a moving window and last-seen indices to keep all characters unique.",
      "approaches": [
        {
          "id": "27c88a35-bf8d-4b65-932f-ef95acdc2481",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "When a repeat appears, move the left boundary just past the previous occurrence.",
          "approach": "1. Convert the string to an array of characters for indexing.\n2. Track last seen index of each character in a dictionary.\n3. Maintain a left pointer for the start of the current window.\n4. Update the best window length as you iterate.",
          "explanation": "The left pointer only moves forward, so each character is processed at most twice.",
          "code": "func lengthOfLongestSubstring(_ s: String) -> Int {\n    let chars = Array(s)\n    var lastIndex: [Character: Int] = [:]\n    var left = 0\n    var best = 0\n    for (right, ch) in chars.enumerated() {\n        if let prev = lastIndex[ch], prev >= left {\n            left = prev + 1\n        }\n        lastIndex[ch] = right\n        best = max(best, right - left + 1)\n    }\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(min(n, k))",
            "timeExplanation": "Each index moves forward at most once.",
            "spaceExplanation": "Map stores last index per distinct character."
          },
          "testCases": [
            {
              "id": "857fc085-7360-4555-9c7d-d324eb1a4c03",
              "input": "s = \"abcabcbb\"",
              "expectedOutput": "3",
              "explanation": "Longest substring is \"abc\"."
            },
            {
              "id": "d75e0eb2-181f-4052-92f3-16d6d6f774fa",
              "input": "s = \"bbbbb\"",
              "expectedOutput": "1",
              "explanation": "Only one unique character."
            },
            {
              "id": "0460080e-0b23-4245-ab89-72bdc20b8121",
              "input": "s = \"pwwkew\"",
              "expectedOutput": "3",
              "explanation": "Longest substring is \"wke\"."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-window-substring",
        "longest-substring-with-at-most-k-distinct-characters"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "8003a7c4-b302-40f5-a143-6e9006052256",
      "problemSlug": "group-anagrams",
      "summary": "Group strings by their sorted characters (anagram signature).",
      "approaches": [
        {
          "id": "01f071e5-54c6-44da-86f1-bad42a893aa6",
          "name": "Hash by Sorted Key",
          "order": 1,
          "intuition": "Anagrams share the same multiset of letters, so sorting makes identical keys for the group.",
          "approach": "1. For each string, sort its characters to form a key.\n2. Append the string to the bucket for that key.\n3. Return all buckets.",
          "explanation": "Sorting each word is the dominant cost, but it keeps the implementation simple and reliable.",
          "code": "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups: [String: [String]] = [:]\n    for s in strs {\n        let key = String(s.sorted())\n        groups[key, default: []].append(s)\n    }\n    return Array(groups.values)\n}",
          "complexity": {
            "time": "O(n * k log k)",
            "space": "O(n * k)",
            "timeExplanation": "Sorting each of n strings of length k dominates.",
            "spaceExplanation": "All strings are stored in grouped buckets."
          },
          "testCases": [
            {
              "id": "cf59af36-fcff-4d7c-b446-f32138d0f4e9",
              "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
              "expectedOutput": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
              "explanation": "Strings with the same sorted key are grouped (order may vary)."
            },
            {
              "id": "ff99e033-fb51-4eb3-972b-18a4a8c5acef",
              "input": "strs = [\"\"]",
              "expectedOutput": "[[\"\"]]",
              "explanation": "Single empty string forms one group."
            },
            {
              "id": "a4399698-b4e5-43f4-99f5-223620ca26be",
              "input": "strs = [\"a\"]",
              "expectedOutput": "[[\"a\"]]",
              "explanation": "Single string forms one group."
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-anagram",
        "find-all-anagrams-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "51f4815d-a558-4057-b255-58209dea4db8",
      "problemSlug": "top-k-frequent-elements",
      "summary": "Count frequencies and collect elements from high to low frequency buckets.",
      "approaches": [
        {
          "id": "2e212fcc-957a-4b1d-a01d-2694e9b90bd9",
          "name": "Bucket Sort",
          "order": 1,
          "intuition": "If we bucket elements by frequency, we can gather the k most frequent without full sorting.",
          "approach": "1. Count occurrences of each number in a dictionary.\n2. Create buckets where index = frequency.\n3. Iterate buckets from high to low, collecting elements until k are gathered.",
          "explanation": "This avoids O(n log n) sorting and stays linear on average.",
          "code": "func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var counts: [Int: Int] = [:]\n    for num in nums { counts[num, default: 0] += 1 }\n    var buckets = Array(repeating: [Int](), count: nums.count + 1)\n    for (num, count) in counts {\n        buckets[count].append(num)\n    }\n    var result: [Int] = []\n    for freq in stride(from: buckets.count - 1, through: 1, by: -1) {\n        for num in buckets[freq] {\n            result.append(num)\n            if result.count == k { return result }\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Counting plus bucket traversal is linear.",
            "spaceExplanation": "Buckets and map store up to n items."
          },
          "testCases": [
            {
              "id": "25771fef-0ab3-4b28-a731-fa97a89188d5",
              "input": "nums = [1,1,1,2,2,3], k = 2",
              "expectedOutput": "[1,2]",
              "explanation": "1 appears 3 times, 2 appears 2 times."
            },
            {
              "id": "0779a404-ce3f-4756-916f-5d20b5106742",
              "input": "nums = [1], k = 1",
              "expectedOutput": "[1]",
              "explanation": "Single element is the answer."
            }
          ]
        }
      ],
      "relatedProblems": [
        "top-k-frequent-words",
        "kth-largest-element-in-an-array"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "ce775cc2-53fd-4963-bb91-9c8f6b5dcb4c",
      "problemSlug": "product-of-array-except-self",
      "summary": "Compute prefix products and suffix products to avoid division.",
      "approaches": [
        {
          "id": "cad14ea0-646e-49fd-bc22-69e4b5e08203",
          "name": "Prefix/Suffix",
          "order": 1,
          "intuition": "The product for index i is (product of all elements before i) * (product of all elements after i).",
          "approach": "1. Build result where result[i] is the product of all elements before i.\n2. Traverse from right, maintaining a suffix product and multiply into result[i].",
          "explanation": "This keeps O(1) extra space besides the output array and handles zeros correctly.",
          "code": "func productExceptSelf(_ nums: [Int]) -> [Int] {\n    var result = Array(repeating: 1, count: nums.count)\n    var prefix = 1\n    for i in 0..<nums.count {\n        result[i] = prefix\n        prefix *= nums[i]\n    }\n    var suffix = 1\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        result[i] *= suffix\n        suffix *= nums[i]\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Two linear passes.",
            "spaceExplanation": "Only constant extra space besides the output."
          },
          "testCases": [
            {
              "id": "ea2462d9-4c77-4f66-a78a-0882e8eeed6c",
              "input": "nums = [1,2,3,4]",
              "expectedOutput": "[24,12,8,6]",
              "explanation": "Products excluding each index."
            },
            {
              "id": "c2ddebb8-39b4-494d-9b47-e5c6da74e2bc",
              "input": "nums = [-1,1,0,-3,3]",
              "expectedOutput": "[0,0,9,0,0]",
              "explanation": "Handles zeros correctly."
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximum-product-subarray",
        "subarray-product-less-than-k"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "09218b74-9f9a-490a-ae70-c1ac4dec5ca8",
      "problemSlug": "subarray-sum-equals-k",
      "summary": "Count how often each prefix sum appears to find subarrays summing to k.",
      "approaches": [
        {
          "id": "8fdde843-fc09-448d-bf2e-00ec0b0885c5",
          "name": "Prefix Sum + Map",
          "order": 1,
          "intuition": "If currentSum - k has been seen before, each occurrence defines a subarray ending here with sum k.",
          "approach": "1. Keep a dictionary of prefixSum -> count (start with 0 -> 1).\n2. Iterate nums, updating currentSum.\n3. Add counts of (currentSum - k) to the answer.\n4. Increment the count for currentSum.",
          "explanation": "This avoids O(n^2) enumeration by using prefix sums and frequencies.",
          "code": "func subarraySum(_ nums: [Int], _ k: Int) -> Int {\n    var count = 0\n    var sum = 0\n    var freq: [Int: Int] = [0: 1]\n    for num in nums {\n        sum += num\n        if let c = freq[sum - k] { count += c }\n        freq[sum, default: 0] += 1\n    }\n    return count\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass with O(1) hash operations.",
            "spaceExplanation": "Prefix sums stored in the map."
          },
          "testCases": [
            {
              "id": "36b9d5fd-4a58-46fb-ae4f-6fb5cfb8a641",
              "input": "nums = [1,1,1], k = 2",
              "expectedOutput": "2",
              "explanation": "Subarrays [1,1] at indices (0,1) and (1,2)."
            },
            {
              "id": "b9c9fbd2-7155-46a9-8270-792727582b7c",
              "input": "nums = [1,2,3], k = 3",
              "expectedOutput": "2",
              "explanation": "Subarrays [1,2] and [3]."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-size-subarray-sum",
        "continuous-subarray-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "f94dfe99-f818-417f-b555-81d2d78b2212",
      "problemSlug": "permutation-in-string",
      "summary": "Use a fixed-size sliding window and compare character counts to detect a permutation.",
      "approaches": [
        {
          "id": "82f82071-c8e4-4992-8de8-e36f7d88d1d8",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "Any permutation of s1 has the same character counts, so we just need a window in s2 with matching counts.",
          "approach": "1. Build a frequency array for s1 and for the first window in s2.\n2. Track how many of the 26 counts match.\n3. Slide the window, updating counts and matches.\n4. If all 26 counts match, return true.",
          "explanation": "The matching-counts trick avoids comparing full arrays on each step.",
          "code": "func checkInclusion(_ s1: String, _ s2: String) -> Bool {\n    let a = Array(s1)\n    let b = Array(s2)\n    if a.count > b.count { return false }\n\n    var count1 = Array(repeating: 0, count: 26)\n    var count2 = Array(repeating: 0, count: 26)\n\n    for ch in a {\n        let idx = Int(ch.asciiValue! - 97)\n        count1[idx] += 1\n    }\n    for i in 0..<a.count {\n        let idx = Int(b[i].asciiValue! - 97)\n        count2[idx] += 1\n    }\n\n    var matches = 0\n    for i in 0..<26 {\n        if count1[i] == count2[i] { matches += 1 }\n    }\n\n    var left = 0\n    for right in a.count..<b.count {\n        if matches == 26 { return true }\n\n        let rIndex = Int(b[right].asciiValue! - 97)\n        count2[rIndex] += 1\n        if count2[rIndex] == count1[rIndex] { matches += 1 }\n        else if count2[rIndex] == count1[rIndex] + 1 { matches -= 1 }\n\n        let lIndex = Int(b[left].asciiValue! - 97)\n        count2[lIndex] -= 1\n        if count2[lIndex] == count1[lIndex] { matches += 1 }\n        else if count2[lIndex] == count1[lIndex] - 1 { matches -= 1 }\n\n        left += 1\n    }\n\n    return matches == 26\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each index is processed once in the sliding window.",
            "spaceExplanation": "Two fixed-size arrays of length 26."
          },
          "testCases": [
            {
              "id": "2708a68f-d53b-49fe-9227-b4884fd084ce",
              "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
              "expectedOutput": "true",
              "explanation": "Substring \"ba\" is a permutation of \"ab\"."
            },
            {
              "id": "7e0e6c56-3a13-4d0c-a138-83d2f21fe73d",
              "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
              "expectedOutput": "false",
              "explanation": "No permutation appears in s2."
            }
          ]
        }
      ],
      "relatedProblems": [
        "find-all-anagrams-in-a-string",
        "check-if-a-string-contains-all-binary-codes-of-size-k"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "82ca8435-3b76-41f5-9985-8646f575a687",
      "problemSlug": "3sum",
      "summary": "Sort the array and fix one element, then use two pointers to find pairs that sum to the negative.",
      "approaches": [
        {
          "id": "fa457d53-4a83-48c1-970e-eaf8ac79fa61",
          "name": "Sort + Two Pointers",
          "order": 1,
          "intuition": "Sorting allows us to skip duplicates and adjust pointers based on the sum.",
          "approach": "1. Sort the array.\n2. For each index i, use two pointers (l, r) to find pairs where nums[i] + nums[l] + nums[r] == 0.\n3. Skip duplicate values for i, l, and r.",
          "explanation": "Sorting enables a linear scan for each fixed i, resulting in O(n^2) time.",
          "code": "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let nums = nums.sorted()\n    var result: [[Int]] = []\n    if nums.count < 3 { return result }\n\n    for i in 0..<(nums.count - 2) {\n        if i > 0 && nums[i] == nums[i - 1] { continue }\n        var left = i + 1\n        var right = nums.count - 1\n        while left < right {\n            let sum = nums[i] + nums[left] + nums[right]\n            if sum == 0 {\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right && nums[left] == nums[left - 1] { left += 1 }\n                while left < right && nums[right] == nums[right + 1] { right -= 1 }\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n^2)",
            "space": "O(1)",
            "timeExplanation": "For each i, two pointers scan the rest of the array.",
            "spaceExplanation": "Sorting is in-place; extra space is constant (excluding output)."
          },
          "testCases": [
            {
              "id": "6952a73f-5e39-4a3c-b7e4-212d9d10d643",
              "input": "nums = [-1,0,1,2,-1,-4]",
              "expectedOutput": "[[-1,-1,2],[-1,0,1]]",
              "explanation": "Two unique triplets sum to 0."
            },
            {
              "id": "e88c71f1-6f39-4502-a988-d62d817a8e42",
              "input": "nums = [0,1,1]",
              "expectedOutput": "[]",
              "explanation": "No triplet sums to 0."
            },
            {
              "id": "1caf588c-d8b4-4469-9a6d-a8f0c0dcc42b",
              "input": "nums = [0,0,0]",
              "expectedOutput": "[[0,0,0]]",
              "explanation": "Single unique triplet."
            }
          ]
        }
      ],
      "relatedProblems": [
        "two-sum",
        "4sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "f4aa35fd-22bb-466c-8dae-e6567cb0141a",
      "problemSlug": "search-in-rotated-sorted-array",
      "summary": "Binary search while determining which half is sorted at each step.",
      "approaches": [
        {
          "id": "43e27307-58c2-4a0e-a8b9-75238275fb4a",
          "name": "Modified Binary Search",
          "order": 1,
          "intuition": "In a rotated array, at least one half of the current range is sorted. We can use that to decide where the target may lie.",
          "approach": "1. Use left and right pointers.\n2. Find mid; if it's the target, return it.\n3. Determine which half is sorted and adjust the search range accordingly.",
          "explanation": "This preserves O(log n) time because each step discards half the range.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if nums[mid] == target { return mid }\n        if nums[left] <= nums[mid] {\n            if nums[left] <= target && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "Binary search halves the range each step.",
            "spaceExplanation": "Constant extra space."
          },
          "testCases": [
            {
              "id": "3399773a-ab67-467e-8fe0-059e42126ffe",
              "input": "nums = [4,5,6,7,0,1,2], target = 0",
              "expectedOutput": "4",
              "explanation": "Target found at index 4."
            },
            {
              "id": "800110ec-ac97-4755-971f-6d84cc314656",
              "input": "nums = [4,5,6,7,0,1,2], target = 3",
              "expectedOutput": "-1",
              "explanation": "Target not present."
            },
            {
              "id": "192471d2-017f-4ff5-8035-74cea4b4674a",
              "input": "nums = [1], target = 0",
              "expectedOutput": "-1",
              "explanation": "Single element not equal to target."
            }
          ]
        }
      ],
      "relatedProblems": [
        "search-in-rotated-sorted-array-ii",
        "find-minimum-in-rotated-sorted-array"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "0562ba51-0891-44cc-8ef8-e9d3dd5be2e0",
      "problemSlug": "merge-intervals",
      "summary": "Sort intervals by start and merge overlapping ranges in one pass.",
      "approaches": [
        {
          "id": "804d61a0-ef94-4021-a081-82fa69522244",
          "name": "Sort + Merge",
          "order": 1,
          "intuition": "After sorting by start, any overlap can only occur with the most recent merged interval.",
          "approach": "1. Sort intervals by start.\n2. Initialize result with the first interval.\n3. For each subsequent interval, either merge it into the last or append it.",
          "explanation": "Sorting ensures overlaps are adjacent, so we only compare with the last merged interval.",
          "code": "func merge(_ intervals: [[Int]]) -> [[Int]] {\n    if intervals.isEmpty { return [] }\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var result: [[Int]] = [sorted[0]]\n    for interval in sorted.dropFirst() {\n        if interval[0] <= result[result.count - 1][1] {\n            result[result.count - 1][1] = max(result[result.count - 1][1], interval[1])\n        } else {\n            result.append(interval)\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "Sorting dominates the time cost.",
            "spaceExplanation": "Result list can store up to n intervals."
          },
          "testCases": [
            {
              "id": "e1a38ac4-6f16-43f9-8eae-772092c14f3b",
              "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
              "expectedOutput": "[[1,6],[8,10],[15,18]]",
              "explanation": "[1,3] and [2,6] merge into [1,6]."
            },
            {
              "id": "f70a956c-ec5b-4b71-bf26-526b1ad92c3f",
              "input": "intervals = [[1,4],[4,5]]",
              "expectedOutput": "[[1,5]]",
              "explanation": "Touching intervals also merge."
            }
          ]
        }
      ],
      "relatedProblems": [
        "insert-interval",
        "meeting-rooms-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "3d011264-1955-48cf-99a3-28cb75d173a0",
      "problemSlug": "spiral-matrix",
      "summary": "Walk the matrix in layers by shrinking the top, bottom, left, and right boundaries.",
      "approaches": [
        {
          "id": "3cc9ef2e-fea5-401a-aa0a-595369e016c9",
          "name": "Boundary Traversal",
          "order": 1,
          "intuition": "Each spiral layer is a rectangle. After traversing its edges, we move the boundaries inward.",
          "approach": "1. Initialize top, bottom, left, right bounds.\n2. Traverse right, down, left, and up while bounds are valid.\n3. Shrink bounds after each side.",
          "explanation": "This orderly boundary scan avoids revisiting cells and handles non-square matrices.",
          "code": "func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n    guard !matrix.isEmpty else { return [] }\n    var top = 0\n    var bottom = matrix.count - 1\n    var left = 0\n    var right = matrix[0].count - 1\n    var result: [Int] = []\n\n    while top <= bottom && left <= right {\n        for col in left...right { result.append(matrix[top][col]) }\n        top += 1\n        if top > bottom { break }\n\n        for row in top...bottom { result.append(matrix[row][right]) }\n        right -= 1\n        if left > right { break }\n\n        for col in stride(from: right, through: left, by: -1) { result.append(matrix[bottom][col]) }\n        bottom -= 1\n        if top > bottom { break }\n\n        for row in stride(from: bottom, through: top, by: -1) { result.append(matrix[row][left]) }\n        left += 1\n    }\n\n    return result\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(1)",
            "timeExplanation": "Each cell is visited exactly once.",
            "spaceExplanation": "No extra space besides the output array."
          },
          "testCases": [
            {
              "id": "40d28244-749c-499c-8684-5141ef7ad57b",
              "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
              "expectedOutput": "[1,2,3,6,9,8,7,4,5]",
              "explanation": "Classic 3x3 spiral."
            },
            {
              "id": "1794fb06-b57a-4d9a-ae73-8323c7c50b14",
              "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
              "expectedOutput": "[1,2,3,4,8,12,11,10,9,5,6,7]",
              "explanation": "Spiral for rectangular matrix."
            }
          ]
        }
      ],
      "relatedProblems": [
        "spiral-matrix-ii",
        "rotate-image"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "6f18a7ea-1f71-41c6-ad8a-91f28173bbb2",
      "problemSlug": "number-of-islands",
      "summary": "Count islands by flooding each discovered land cell with DFS.",
      "approaches": [
        {
          "id": "623b0613-cf2f-476d-b645-283a712a2085",
          "name": "DFS Flood Fill",
          "order": 1,
          "intuition": "Each island is a connected component of '1's. Marking a component prevents double counting.",
          "approach": "1. Iterate all cells.\n2. When you find land, increment count and DFS to mark the entire island as water.",
          "explanation": "DFS visits all connected land cells, so each island is counted once.",
          "code": "func numIslands(_ grid: [[Character]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var count = 0\n\n    func dfs(_ r: Int, _ c: Int) {\n        if r < 0 || r >= rows || c < 0 || c >= cols { return }\n        if grid[r][c] != \"1\" { return }\n        grid[r][c] = \"0\"\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == \"1\" {\n                count += 1\n                dfs(r, c)\n            }\n        }\n    }\n    return count\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(m * n)",
            "timeExplanation": "Every cell is visited at most once.",
            "spaceExplanation": "DFS recursion stack can reach all cells in the worst case."
          },
          "testCases": [
            {
              "id": "fa57d4ea-0dec-463a-8a3b-e5d06b3fb13e",
              "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
              "expectedOutput": "1",
              "explanation": "All land is connected."
            },
            {
              "id": "5164b72d-7171-48da-aa64-47e45e594562",
              "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
              "expectedOutput": "3",
              "explanation": "Three separate islands."
            }
          ]
        }
      ],
      "relatedProblems": [
        "max-area-of-island",
        "surrounded-regions"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "ad4417ac-7912-43ec-b99c-b98060877efe",
      "problemSlug": "rotting-oranges",
      "summary": "Use BFS from all rotten oranges to simulate minute-by-minute spread.",
      "approaches": [
        {
          "id": "33f1b3ba-ac87-4e04-8610-23e61eb07e5d",
          "name": "BFS Multi-Source",
          "order": 1,
          "intuition": "Each minute, all currently rotten oranges infect adjacent fresh ones. BFS levels model this time expansion.",
          "approach": "1. Add all rotten oranges to a queue; count fresh oranges.\n2. Process the queue level by level, rotting adjacent fresh oranges.\n3. Increment minutes after each level.\n4. If fresh oranges remain, return -1; otherwise return minutes.",
          "explanation": "BFS naturally tracks the minimum time to reach each orange because it expands in waves.",
          "code": "func orangesRotting(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var queue: [(Int, Int)] = []\n    var fresh = 0\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == 2 { queue.append((r, c)) }\n            else if grid[r][c] == 1 { fresh += 1 }\n        }\n    }\n\n    let directions = [(1,0),(-1,0),(0,1),(0,-1)]\n    var minutes = 0\n    var head = 0\n\n    while head < queue.count && fresh > 0 {\n        let levelCount = queue.count - head\n        for _ in 0..<levelCount {\n            let (r, c) = queue[head]\n            head += 1\n            for (dr, dc) in directions {\n                let nr = r + dr\n                let nc = c + dc\n                if nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1 {\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n                }\n            }\n        }\n        minutes += 1\n    }\n\n    return fresh == 0 ? minutes : -1\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(m * n)",
            "timeExplanation": "Each cell is processed at most once.",
            "spaceExplanation": "Queue may hold all cells in the grid."
          },
          "testCases": [
            {
              "id": "963f04ce-46ca-4f77-84ee-f13640cb6a5a",
              "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
              "expectedOutput": "4",
              "explanation": "All oranges rot in 4 minutes."
            },
            {
              "id": "8e19da01-63c9-42cb-a384-85cbb69562de",
              "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
              "expectedOutput": "-1",
              "explanation": "Some oranges are unreachable."
            },
            {
              "id": "2efd6748-b2da-4ee7-aeac-9dbe9e4071a8",
              "input": "grid = [[0,2]]",
              "expectedOutput": "0",
              "explanation": "No fresh oranges to rot."
            }
          ]
        }
      ],
      "relatedProblems": [
        "01-matrix",
        "shortest-path-in-binary-matrix"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "b5852c33-2b98-45c6-8c16-c292beb01185",
      "problemSlug": "reverse-linked-list-ii",
      "summary": "Reverse the nodes between two positions using head insertion within the sublist.",
      "approaches": [
        {
          "id": "1b727499-28ed-4e69-ae36-0d335a4f4c55",
          "name": "Sublist Reversal",
          "order": 1,
          "intuition": "If we fix the node before the sublist, we can repeatedly move the next node to the front of that sublist.",
          "approach": "1. Use a dummy node and move `pre` to the node just before `left`.\n2. Let `start` be the first node in the sublist and `then` be start.next.\n3. For each step, move `then` to the front of the sublist.",
          "explanation": "This reverses the sublist in-place without touching nodes outside the range.",
          "code": "func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n    if head == nil || left == right { return head }\n    let dummy = ListNode(0)\n    dummy.next = head\n    var pre: ListNode? = dummy\n\n    var pos = 1\n    while pos < left {\n        pre = pre?.next\n        pos += 1\n    }\n\n    let start = pre?.next\n    var then = start?.next\n    var i = 0\n    while i < right - left {\n        start?.next = then?.next\n        then?.next = pre?.next\n        pre?.next = then\n        then = start?.next\n        i += 1\n    }\n\n    return dummy.next\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We traverse the list once and reverse the sublist in place.",
            "spaceExplanation": "Only a few pointers are used."
          },
          "testCases": [
            {
              "id": "1272d27f-24bc-4442-bf9a-626f1fe6c565",
              "input": "head = [1,2,3,4,5], left = 2, right = 4",
              "expectedOutput": "[1,4,3,2,5]",
              "explanation": "Sublist 2..4 is reversed."
            },
            {
              "id": "e8309d6a-9f8f-49ce-b125-1afc3423b163",
              "input": "head = [5], left = 1, right = 1",
              "expectedOutput": "[5]",
              "explanation": "Single node remains unchanged."
            }
          ]
        }
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "reorder-list"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "c4d3ba80-256e-421e-a8cd-00902e73d355",
      "problemSlug": "coin-change",
      "summary": "Compute the minimum coins needed for every amount up to target.",
      "approaches": [
        {
          "id": "b55a038f-25b6-43b9-a7b6-8b9c281971f8",
          "name": "DP (Unbounded)",
          "order": 1,
          "intuition": "The optimal way to make amount A depends on the optimal way to make A - coin for each coin.",
          "approach": "1. Initialize dp[0] = 0 and dp[i] = amount + 1 as infinity.\n2. For each amount from 1 to target, try each coin.\n3. If coin <= amount, dp[amount] = min(dp[amount], dp[amount - coin] + 1).\n4. Return dp[amount] if reachable, else -1.",
          "explanation": "This is a classic unbounded knapsack: each coin can be used multiple times.",
          "code": "func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n    if amount == 0 { return 0 }\n    var dp = Array(repeating: amount + 1, count: amount + 1)\n    dp[0] = 0\n\n    if amount > 0 {\n        for a in 1...amount {\n            for coin in coins where coin <= a {\n                dp[a] = min(dp[a], dp[a - coin] + 1)\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount]\n}",
          "complexity": {
            "time": "O(amount * coins)",
            "space": "O(amount)",
            "timeExplanation": "For each amount we test all coins.",
            "spaceExplanation": "DP array of size amount + 1."
          },
          "testCases": [
            {
              "id": "02761a1e-687a-443d-ad55-42ec7bfee4be",
              "input": "coins = [1,2,5], amount = 11",
              "expectedOutput": "3",
              "explanation": "11 = 5 + 5 + 1."
            },
            {
              "id": "722491b7-e337-4740-b52c-143a5b9af547",
              "input": "coins = [2], amount = 3",
              "expectedOutput": "-1",
              "explanation": "Cannot make 3 with only 2s."
            },
            {
              "id": "f4c25e0b-fd8f-40bf-a433-ce41c17606e9",
              "input": "coins = [1], amount = 0",
              "expectedOutput": "0",
              "explanation": "Zero amount needs zero coins."
            }
          ]
        }
      ],
      "relatedProblems": [
        "coin-change-2",
        "minimum-cost-for-tickets"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440018",
      "problemSlug": "find-median-from-data-stream",
      "summary": "Maintain median using two heaps: max-heap for lower half, min-heap for upper half. Median is from top of heaps.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440129",
          "name": "Two Heaps",
          "order": 1,
          "intuition": "Keep lower half in max-heap, upper half in min-heap. Balance sizes so median is accessible at heap tops.",
          "approach": "1. Add to max-heap (lower), move max to min-heap (upper)\n2. If min-heap larger, move its min back to max-heap\n3. Median: if equal sizes, average of tops; else max-heap top",
          "explanation": "Max-heap gives largest of smaller half, min-heap gives smallest of larger half. Keep sizes within 1.",
          "code": "class MedianFinder {\n    private var lower: [Int] = []  // max-heap (negate values)\n    private var upper: [Int] = []  // min-heap\n    \n    func addNum(_ num: Int) {\n        // Add to lower (max-heap)\n        lower.append(-num)\n        lower.sort()\n        \n        // Move largest from lower to upper\n        upper.append(-lower.removeFirst())\n        upper.sort()\n        \n        // Balance: upper can't be larger\n        if upper.count > lower.count {\n            lower.append(-upper.removeFirst())\n            lower.sort()\n        }\n    }\n    \n    func findMedian() -> Double {\n        if lower.count > upper.count {\n            return Double(-lower.first!)\n        }\n        return Double(-lower.first! + upper.first!) / 2.0\n    }\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "Each add is O(n log n) with array sort (O(log n) with real heap)",
            "spaceExplanation": "Store all n numbers"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440235",
              "input": "addNum(1), addNum(2), findMedian(), addNum(3), findMedian()",
              "expectedOutput": "1.5, 2.0",
              "explanation": "[1,2] median=1.5, [1,2,3] median=2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "sliding-window-median"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440019",
      "problemSlug": "subsets",
      "summary": "Generate all subsets using backtracking or iterative bit manipulation. Each element is either included or not.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440130",
          "name": "Backtracking",
          "order": 1,
          "intuition": "For each element, make two choices: include it or skip it. This creates a binary tree of decisions.",
          "approach": "1. Start with empty subset\n2. At each index, branch: include nums[i] or not\n3. When index reaches end, add current subset to result",
          "explanation": "Backtracking explores all 2^n combinations. Add element, recurse, remove (backtrack), recurse again.",
          "code": "func subsets(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    \n    func backtrack(_ index: Int) {\n        if index == nums.count {\n            result.append(current)\n            return\n        }\n        // Include nums[index]\n        current.append(nums[index])\n        backtrack(index + 1)\n        current.removeLast()\n        // Exclude nums[index]\n        backtrack(index + 1)\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "time": "O(n * 2^n)",
            "space": "O(n)",
            "timeExplanation": "2^n subsets, O(n) to copy each",
            "spaceExplanation": "Recursion depth n"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440236",
              "input": "[1,2,3]",
              "expectedOutput": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
              "explanation": "All 8 subsets of 3 elements"
            }
          ]
        }
      ],
      "relatedProblems": [
        "subsets-ii",
        "combinations"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440020",
      "problemSlug": "combination-sum",
      "summary": "Find combinations that sum to target. Use backtracking, allowing same element multiple times.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440131",
          "name": "Backtracking",
          "order": 1,
          "intuition": "Try adding each candidate repeatedly until sum >= target, then backtrack to try other candidates.",
          "approach": "1. Sort candidates (optional, for pruning)\n2. Backtrack: if sum==target, save; if sum>target, return\n3. For each candidate from current index, add and recurse (same index for reuse)",
          "explanation": "Key: pass same index to allow reuse of element. Advance index to avoid duplicate combinations.",
          "code": "func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    \n    func backtrack(_ index: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        if remaining < 0 { return }\n        \n        for i in index..<candidates.count {\n            current.append(candidates[i])\n            backtrack(i, remaining - candidates[i])  // same i for reuse\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
          "complexity": {
            "time": "O(n^(T/M))",
            "space": "O(T/M)",
            "timeExplanation": "T=target, M=min candidate. Branching factor n, depth T/M",
            "spaceExplanation": "Max recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440237",
              "input": "candidates = [2,3,6,7], target = 7",
              "expectedOutput": "[[2,2,3],[7]]",
              "explanation": "2+2+3=7 and 7=7"
            }
          ]
        }
      ],
      "relatedProblems": [
        "combination-sum-ii",
        "combination-sum-iii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440021",
      "problemSlug": "permutations",
      "summary": "Generate all permutations using backtracking. Swap elements or track used indices.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440132",
          "name": "Backtracking with Used Set",
          "order": 1,
          "intuition": "Build permutation one element at a time, skipping already-used elements.",
          "approach": "1. Track used indices with boolean array\n2. At each position, try each unused element\n3. When length == n, save permutation",
          "explanation": "For n elements, n! permutations. Each position has decreasing choices: n, n-1, ..., 1.",
          "code": "func permute(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    var used = [Bool](repeating: false, count: nums.count)\n    \n    func backtrack() {\n        if current.count == nums.count {\n            result.append(current)\n            return\n        }\n        for i in 0..<nums.count {\n            if used[i] { continue }\n            used[i] = true\n            current.append(nums[i])\n            backtrack()\n            current.removeLast()\n            used[i] = false\n        }\n    }\n    \n    backtrack()\n    return result\n}",
          "complexity": {
            "time": "O(n * n!)",
            "space": "O(n)",
            "timeExplanation": "n! permutations, O(n) to copy each",
            "spaceExplanation": "Recursion depth and used array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440238",
              "input": "[1,2,3]",
              "expectedOutput": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
              "explanation": "All 6 permutations"
            }
          ]
        }
      ],
      "relatedProblems": [
        "permutations-ii",
        "next-permutation"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440022",
      "problemSlug": "subsets-ii",
      "summary": "Generate unique subsets from array with duplicates. Sort first, skip consecutive duplicates.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440133",
          "name": "Backtracking with Duplicate Skip",
          "order": 1,
          "intuition": "Sort array so duplicates are adjacent. When iterating, skip if same as previous (at same level).",
          "approach": "1. Sort nums\n2. Backtrack: add current subset, then try each remaining element\n3. Skip if nums[i] == nums[i-1] at same recursion level",
          "explanation": "Sorting groups duplicates. Skip condition prevents same value being chosen twice for same position.",
          "code": "func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = nums.sorted()\n    \n    func backtrack(_ start: Int) {\n        result.append(current)\n        for i in start..<sorted.count {\n            // Skip duplicates at same level\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "time": "O(n * 2^n)",
            "space": "O(n)",
            "timeExplanation": "At most 2^n subsets",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440239",
              "input": "[1,2,2]",
              "expectedOutput": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
              "explanation": "No duplicate subsets like [2] appearing twice"
            }
          ]
        }
      ],
      "relatedProblems": [
        "subsets"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440023",
      "problemSlug": "combination-sum-ii",
      "summary": "Find unique combinations summing to target, each element used once. Sort and skip duplicates.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440134",
          "name": "Backtracking",
          "order": 1,
          "intuition": "Like combination-sum but: 1) move to next index after use, 2) skip duplicate values at same level.",
          "approach": "1. Sort candidates\n2. Backtrack from index, skip if same as previous at same level\n3. Move to i+1 after using element (no reuse)",
          "explanation": "i > start ensures we only skip duplicates at same recursion level, not first occurrence.",
          "code": "func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = candidates.sorted()\n    \n    func backtrack(_ start: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        for i in start..<sorted.count {\n            if sorted[i] > remaining { break }\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1, remaining - sorted[i])\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
          "complexity": {
            "time": "O(2^n)",
            "space": "O(n)",
            "timeExplanation": "Each element included or not",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440240",
              "input": "candidates = [10,1,2,7,6,1,5], target = 8",
              "expectedOutput": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
              "explanation": "Unique combinations, each element used at most once"
            }
          ]
        }
      ],
      "relatedProblems": [
        "combination-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440024",
      "problemSlug": "letter-combinations-of-a-phone-number",
      "summary": "Generate all letter combinations for phone digits. Map digits to letters, backtrack through all combinations.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440135",
          "name": "Backtracking",
          "order": 1,
          "intuition": "Each digit maps to 3-4 letters. For each digit, try each mapped letter and recurse to next digit.",
          "approach": "1. Create digit-to-letters mapping\n2. Backtrack: at each digit position, try each letter\n3. When index == digits.length, add to result",
          "explanation": "Branching factor is 3-4 per digit, total combinations is product of letter counts.",
          "code": "func letterCombinations(_ digits: String) -> [String] {\n    guard !digits.isEmpty else { return [] }\n    \n    let map: [Character: String] = [\n        \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n        \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"\n    ]\n    let digitsArray = Array(digits)\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ index: Int) {\n        if index == digitsArray.count {\n            result.append(current)\n            return\n        }\n        let letters = map[digitsArray[index]]!\n        for letter in letters {\n            current.append(letter)\n            backtrack(index + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "time": "O(4^n)",
            "space": "O(n)",
            "timeExplanation": "At most 4 letters per digit, n digits",
            "spaceExplanation": "Recursion depth n"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440241",
              "input": "\"23\"",
              "expectedOutput": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
              "explanation": "2->abc, 3->def, 3*3=9 combinations"
            }
          ]
        }
      ],
      "relatedProblems": [
        "generate-parentheses",
        "combination-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440025",
      "problemSlug": "palindrome-partitioning",
      "summary": "Partition string into all palindromic substrings. Backtrack, checking if each prefix is palindrome.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440136",
          "name": "Backtracking",
          "order": 1,
          "intuition": "At each position, try all possible prefixes. If prefix is palindrome, recurse on remainder.",
          "approach": "1. At index i, try substrings s[i...j] for all j >= i\n2. If s[i...j] is palindrome, add to current, recurse from j+1\n3. When index reaches end, save partition",
          "explanation": "Only extend partition if current substring is valid palindrome.",
          "code": "func partition(_ s: String) -> [[String]] {\n    let chars = Array(s)\n    var result: [[String]] = []\n    var current: [String] = []\n    \n    func isPalindrome(_ start: Int, _ end: Int) -> Bool {\n        var l = start, r = end\n        while l < r {\n            if chars[l] != chars[r] { return false }\n            l += 1; r -= 1\n        }\n        return true\n    }\n    \n    func backtrack(_ start: Int) {\n        if start == chars.count {\n            result.append(current)\n            return\n        }\n        for end in start..<chars.count {\n            if isPalindrome(start, end) {\n                current.append(String(chars[start...end]))\n                backtrack(end + 1)\n                current.removeLast()\n            }\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "time": "O(n * 2^n)",
            "space": "O(n)",
            "timeExplanation": "2^n partitions possible, O(n) palindrome check",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440242",
              "input": "\"aab\"",
              "expectedOutput": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
              "explanation": "Two valid palindromic partitions"
            }
          ]
        }
      ],
      "relatedProblems": [
        "palindrome-partitioning-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440026",
      "problemSlug": "n-queens",
      "summary": "Place n queens on n\u00d7n board. Backtrack row by row, checking column/diagonal conflicts.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440137",
          "name": "Backtracking",
          "order": 1,
          "intuition": "Place one queen per row. Track attacked columns and diagonals. Backtrack if no valid position.",
          "approach": "1. Track used columns, diagonals (row-col), anti-diagonals (row+col)\n2. For each row, try each column if not attacked\n3. When row == n, save board configuration",
          "explanation": "Diagonals identified by row-col (same for all cells), anti-diagonals by row+col.",
          "code": "func solveNQueens(_ n: Int) -> [[String]] {\n    var result: [[String]] = []\n    var board = [[Character]](repeating: [Character](repeating: \".\", count: n), count: n)\n    var cols = Set<Int>()\n    var diags = Set<Int>()  // row - col\n    var antiDiags = Set<Int>()  // row + col\n    \n    func backtrack(_ row: Int) {\n        if row == n {\n            result.append(board.map { String($0) })\n            return\n        }\n        for col in 0..<n {\n            let diag = row - col, antiDiag = row + col\n            if cols.contains(col) || diags.contains(diag) || antiDiags.contains(antiDiag) {\n                continue\n            }\n            board[row][col] = \"Q\"\n            cols.insert(col); diags.insert(diag); antiDiags.insert(antiDiag)\n            backtrack(row + 1)\n            board[row][col] = \".\"\n            cols.remove(col); diags.remove(diag); antiDiags.remove(antiDiag)\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "time": "O(n!)",
            "space": "O(n\u00b2)",
            "timeExplanation": "~n! valid placements to explore",
            "spaceExplanation": "Board storage"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440243",
              "input": "n = 4",
              "expectedOutput": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
              "explanation": "Two distinct solutions for 4-queens"
            }
          ]
        }
      ],
      "relatedProblems": [
        "n-queens-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440027",
      "problemSlug": "course-schedule",
      "summary": "Detect if courses can be completed (no cycle in prerequisite graph). Use DFS with visited states or topological sort.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440138",
          "name": "DFS Cycle Detection",
          "order": 1,
          "intuition": "Build graph of prerequisites. Detect cycle using DFS with three states: unvisited, visiting, visited.",
          "approach": "1. Build adjacency list from prerequisites\n2. DFS from each node, mark as 'visiting'\n3. If encounter 'visiting' node, cycle found\n4. Mark 'visited' when done with all neighbors",
          "explanation": "'Visiting' means in current DFS path. If we see it again, we've found a back edge (cycle).",
          "code": "func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    for pre in prerequisites {\n        graph[pre[1]].append(pre[0])\n    }\n    \n    var state = [Int](repeating: 0, count: numCourses)  // 0=unvisited, 1=visiting, 2=visited\n    \n    func hasCycle(_ node: Int) -> Bool {\n        if state[node] == 1 { return true }  // Cycle\n        if state[node] == 2 { return false }  // Already done\n        \n        state[node] = 1\n        for neighbor in graph[node] {\n            if hasCycle(neighbor) { return true }\n        }\n        state[node] = 2\n        return false\n    }\n    \n    for i in 0..<numCourses {\n        if hasCycle(i) { return false }\n    }\n    return true\n}",
          "complexity": {
            "time": "O(V + E)",
            "space": "O(V + E)",
            "timeExplanation": "Visit each node and edge once",
            "spaceExplanation": "Graph storage and recursion"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440244",
              "input": "numCourses = 2, prerequisites = [[1,0]]",
              "expectedOutput": "true",
              "explanation": "Take course 0, then course 1"
            }
          ]
        }
      ],
      "relatedProblems": [
        "course-schedule-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440028",
      "problemSlug": "course-schedule-ii",
      "summary": "Return course order (topological sort). Use Kahn's algorithm (BFS) or DFS with post-order.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440139",
          "name": "Kahn's Algorithm (BFS)",
          "order": 1,
          "intuition": "Start with courses having no prerequisites (in-degree 0). Process them, reduce neighbors' in-degrees, repeat.",
          "approach": "1. Build graph and in-degree array\n2. Add all nodes with in-degree 0 to queue\n3. Process queue: add to result, decrement neighbors' in-degrees\n4. If result size != numCourses, cycle exists",
          "explanation": "Topological sort using BFS. In-degree 0 means all prerequisites satisfied.",
          "code": "func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    var inDegree = [Int](repeating: 0, count: numCourses)\n    \n    for pre in prerequisites {\n        graph[pre[1]].append(pre[0])\n        inDegree[pre[0]] += 1\n    }\n    \n    var queue = (0..<numCourses).filter { inDegree[$0] == 0 }\n    var result: [Int] = []\n    \n    while !queue.isEmpty {\n        let course = queue.removeFirst()\n        result.append(course)\n        for next in graph[course] {\n            inDegree[next] -= 1\n            if inDegree[next] == 0 {\n                queue.append(next)\n            }\n        }\n    }\n    \n    return result.count == numCourses ? result : []\n}",
          "complexity": {
            "time": "O(V + E)",
            "space": "O(V + E)",
            "timeExplanation": "Process each node and edge once",
            "spaceExplanation": "Graph and queue storage"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440245",
              "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
              "expectedOutput": "[0,1,2,3] or [0,2,1,3]",
              "explanation": "Valid topological orderings"
            }
          ]
        }
      ],
      "relatedProblems": [
        "course-schedule",
        "alien-dictionary"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440029",
      "problemSlug": "house-robber",
      "summary": "Max money without robbing adjacent houses. DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440140",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "At each house, choose: skip it (take prev max) or rob it (take prev-prev max + current).",
          "approach": "1. dp[i] = max money robbing houses 0..i\n2. dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n3. Optimize to O(1) space with two variables",
          "explanation": "Can't rob adjacent, so if we rob house i, previous robbed must be i-2 or earlier.",
          "code": "func rob(_ nums: [Int]) -> Int {\n    var prev2 = 0  // max from 2 houses back\n    var prev1 = 0  // max from previous house\n    \n    for num in nums {\n        let curr = max(prev1, prev2 + num)\n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Two variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440246",
              "input": "[2,7,9,3,1]",
              "expectedOutput": "12",
              "explanation": "Rob houses 0,2,4: 2+9+1=12"
            }
          ]
        }
      ],
      "relatedProblems": [
        "house-robber-ii",
        "house-robber-iii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440030",
      "problemSlug": "house-robber-ii",
      "summary": "Circular houses (first and last adjacent). Run house robber twice: exclude first or exclude last.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440141",
          "name": "Two Passes DP",
          "order": 1,
          "intuition": "Can't rob both first and last. Solve twice: houses[0..n-2] and houses[1..n-1], take max.",
          "approach": "1. If n==1, return nums[0]\n2. Run house robber on nums[0..<n-1]\n3. Run house robber on nums[1..<n]\n4. Return max of both",
          "explanation": "Breaking the circle by ensuring first and last aren't both included.",
          "code": "func rob(_ nums: [Int]) -> Int {\n    if nums.count == 1 { return nums[0] }\n    \n    func robRange(_ start: Int, _ end: Int) -> Int {\n        var prev2 = 0, prev1 = 0\n        for i in start..<end {\n            let curr = max(prev1, prev2 + nums[i])\n            prev2 = prev1\n            prev1 = curr\n        }\n        return prev1\n    }\n    \n    return max(robRange(0, nums.count - 1), robRange(1, nums.count))\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Two passes through array",
            "spaceExplanation": "Constant space"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440247",
              "input": "[2,3,2]",
              "expectedOutput": "3",
              "explanation": "Can't rob 2 and 2 (adjacent in circle), rob 3"
            }
          ]
        }
      ],
      "relatedProblems": [
        "house-robber",
        "house-robber-iii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440031",
      "problemSlug": "longest-palindromic-substring",
      "summary": "Find longest palindrome substring. Expand from center for each position (and between positions).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440142",
          "name": "Expand Around Center",
          "order": 1,
          "intuition": "A palindrome has a center. Try each index as center, expand while characters match.",
          "approach": "1. For each index i, expand for odd-length (center i) and even-length (center i,i+1)\n2. Track longest palindrome found\n3. Return substring",
          "explanation": "2n-1 potential centers (n single chars, n-1 pairs). Each expansion is O(n) worst case.",
          "code": "func longestPalindrome(_ s: String) -> String {\n    let chars = Array(s)\n    var start = 0, maxLen = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            l -= 1; r += 1\n        }\n        return r - l - 1\n    }\n    \n    for i in 0..<chars.count {\n        let len1 = expand(i, i)      // Odd length\n        let len2 = expand(i, i + 1)  // Even length\n        let len = max(len1, len2)\n        if len > maxLen {\n            maxLen = len\n            start = i - (len - 1) / 2\n        }\n    }\n    \n    return String(chars[start..<start + maxLen])\n}",
          "complexity": {
            "time": "O(n\u00b2)",
            "space": "O(n)",
            "timeExplanation": "n centers, O(n) expansion each",
            "spaceExplanation": "String conversion"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440248",
              "input": "\"babad\"",
              "expectedOutput": "\"bab\" or \"aba\"",
              "explanation": "Both are valid longest palindromes"
            }
          ]
        }
      ],
      "relatedProblems": [
        "palindromic-substrings",
        "longest-palindromic-subsequence"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440032",
      "problemSlug": "palindromic-substrings",
      "summary": "Count all palindromic substrings. Expand from each center, count valid expansions.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440143",
          "name": "Expand Around Center",
          "order": 1,
          "intuition": "Same as longest palindrome, but count each successful expansion instead of tracking max.",
          "approach": "1. For each center (single char and pairs), expand outward\n2. Count each position where chars match\n3. Sum all counts",
          "explanation": "Each valid expansion is a palindrome. Total count includes all lengths.",
          "code": "func countSubstrings(_ s: String) -> Int {\n    let chars = Array(s)\n    var count = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right, cnt = 0\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            cnt += 1\n            l -= 1; r += 1\n        }\n        return cnt\n    }\n    \n    for i in 0..<chars.count {\n        count += expand(i, i)      // Odd\n        count += expand(i, i + 1)  // Even\n    }\n    \n    return count\n}",
          "complexity": {
            "time": "O(n\u00b2)",
            "space": "O(n)",
            "timeExplanation": "n centers, O(n) expansion",
            "spaceExplanation": "String to array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440249",
              "input": "\"aaa\"",
              "expectedOutput": "6",
              "explanation": "a,a,a,aa,aa,aaa = 6 palindromes"
            }
          ]
        }
      ],
      "relatedProblems": [
        "longest-palindromic-substring"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440033",
      "problemSlug": "decode-ways",
      "summary": "Count ways to decode digit string to letters. DP: check single digit (1-9) and double digit (10-26).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440144",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "At each position, can decode 1 digit (if valid) or 2 digits (if valid). Sum the ways.",
          "approach": "1. dp[i] = ways to decode s[0..i-1]\n2. If s[i-1] != '0': dp[i] += dp[i-1] (single digit)\n3. If s[i-2..i-1] in 10-26: dp[i] += dp[i-2] (double digit)",
          "explanation": "'0' can't be decoded alone. '06' is invalid. Only '10'-'26' valid as two digits.",
          "code": "func numDecodings(_ s: String) -> Int {\n    let chars = Array(s)\n    let n = chars.count\n    if chars[0] == \"0\" { return 0 }\n    \n    var prev2 = 1  // dp[i-2]\n    var prev1 = 1  // dp[i-1]\n    \n    for i in 1..<n {\n        var curr = 0\n        let oneDigit = Int(String(chars[i]))!\n        let twoDigit = Int(String(chars[i-1...i]))!\n        \n        if oneDigit >= 1 { curr += prev1 }\n        if twoDigit >= 10 && twoDigit <= 26 { curr += prev2 }\n        \n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Two variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440250",
              "input": "\"226\"",
              "expectedOutput": "3",
              "explanation": "BZ (2,26), VF (22,6), BBF (2,2,6)"
            }
          ]
        }
      ],
      "relatedProblems": [
        "decode-ways-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440034",
      "problemSlug": "word-break",
      "summary": "Check if string can be segmented into dictionary words. DP: dp[i] = can segment s[0..i-1].",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440145",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "dp[i] is true if some dp[j] is true and s[j..i-1] is a word. Check all split points.",
          "approach": "1. dp[0] = true (empty string)\n2. For each i, check all j < i\n3. If dp[j] && s[j..i-1] in dict: dp[i] = true",
          "explanation": "Build up: if we can segment up to j, and j..i is a word, we can segment up to i.",
          "code": "func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n    let words = Set(wordDict)\n    let chars = Array(s)\n    let n = chars.count\n    var dp = [Bool](repeating: false, count: n + 1)\n    dp[0] = true\n    \n    for i in 1...n {\n        for j in 0..<i {\n            if dp[j] && words.contains(String(chars[j..<i])) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    \n    return dp[n]\n}",
          "complexity": {
            "time": "O(n\u00b2 * m)",
            "space": "O(n)",
            "timeExplanation": "n\u00b2 pairs, O(m) string comparison",
            "spaceExplanation": "DP array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440251",
              "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
              "expectedOutput": "true",
              "explanation": "leet + code"
            }
          ]
        }
      ],
      "relatedProblems": [
        "word-break-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440035",
      "problemSlug": "longest-increasing-subsequence",
      "summary": "Find length of LIS. DP O(n\u00b2) or binary search O(n log n) with patience sorting.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440146",
          "name": "Binary Search (Patience Sort)",
          "order": 1,
          "intuition": "Maintain array of smallest tail for each length. Binary search for position to update.",
          "approach": "1. tails[i] = smallest ending element of LIS of length i+1\n2. For each num: binary search for position in tails\n3. Replace or extend tails array\n4. Return tails.count",
          "explanation": "tails is always sorted. We find where num fits and either replace (better ending) or extend.",
          "code": "func lengthOfLIS(_ nums: [Int]) -> Int {\n    var tails: [Int] = []\n    \n    for num in nums {\n        var left = 0, right = tails.count\n        while left < right {\n            let mid = (left + right) / 2\n            if tails[mid] < num {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n        if left == tails.count {\n            tails.append(num)\n        } else {\n            tails[left] = num\n        }\n    }\n    \n    return tails.count\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "n elements, O(log n) binary search each",
            "spaceExplanation": "tails array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440252",
              "input": "[10,9,2,5,3,7,101,18]",
              "expectedOutput": "4",
              "explanation": "[2,3,7,101] or [2,3,7,18]"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-longest-increasing-subsequence",
        "increasing-triplet-subsequence"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440036",
      "problemSlug": "maximum-subarray",
      "summary": "Find contiguous subarray with maximum sum. Kadane's algorithm: track current sum, reset if negative.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440147",
          "name": "Kadane's Algorithm",
          "order": 1,
          "intuition": "At each position, decide: extend current subarray or start fresh. If current sum is negative, starting fresh is better.",
          "approach": "1. Track currentSum and maxSum\n2. For each num: currentSum = max(num, currentSum + num)\n3. Update maxSum = max(maxSum, currentSum)\n4. Return maxSum",
          "explanation": "If currentSum < 0, adding it to next element makes it smaller. So reset to just the next element.",
          "code": "func maxSubArray(_ nums: [Int]) -> Int {\n    var currentSum = nums[0]\n    var maxSum = nums[0]\n    \n    for i in 1..<nums.count {\n        currentSum = max(nums[i], currentSum + nums[i])\n        maxSum = max(maxSum, currentSum)\n    }\n    \n    return maxSum\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Two variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440253",
              "input": "[-2,1,-3,4,-1,2,1,-5,4]",
              "expectedOutput": "6",
              "explanation": "[4,-1,2,1] has sum 6"
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximum-product-subarray",
        "maximum-sum-circular-subarray"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440037",
      "problemSlug": "container-with-most-water",
      "summary": "Find two lines that hold most water. Two pointers from ends, move the shorter one inward.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440148",
          "name": "Two Pointers",
          "order": 1,
          "intuition": "Water limited by shorter line. Moving shorter line might find taller one; moving taller never helps.",
          "approach": "1. left = 0, right = n-1\n2. Calculate area = min(height[left], height[right]) * (right - left)\n3. Move pointer with smaller height inward\n4. Track max area",
          "explanation": "Width decreases as we move inward, so we need taller lines. Moving shorter line is only way to potentially increase area.",
          "code": "func maxArea(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxArea = 0\n    \n    while left < right {\n        let area = min(height[left], height[right]) * (right - left)\n        maxArea = max(maxArea, area)\n        \n        if height[left] < height[right] {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    \n    return maxArea\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass with two pointers",
            "spaceExplanation": "Constant space"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440254",
              "input": "[1,8,6,2,5,4,8,3,7]",
              "expectedOutput": "49",
              "explanation": "Lines at index 1 and 8 (heights 8,7) give area 7*7=49"
            }
          ]
        }
      ],
      "relatedProblems": [
        "trapping-rain-water"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440038",
      "problemSlug": "trapping-rain-water",
      "summary": "Calculate trapped rainwater. At each position, water = min(maxLeft, maxRight) - height.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440149",
          "name": "Two Pointers",
          "order": 1,
          "intuition": "Water at position depends on min of max heights on left and right. Use two pointers to track.",
          "approach": "1. Track maxLeft, maxRight, left, right pointers\n2. Process smaller side (we know its constraint)\n3. Water = max - current height\n4. Move pointer inward, update max",
          "explanation": "If maxLeft < maxRight, left side is the constraint. Water at left = maxLeft - height[left].",
          "code": "func trap(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxLeft = 0, maxRight = 0\n    var water = 0\n    \n    while left < right {\n        if height[left] < height[right] {\n            if height[left] >= maxLeft {\n                maxLeft = height[left]\n            } else {\n                water += maxLeft - height[left]\n            }\n            left += 1\n        } else {\n            if height[right] >= maxRight {\n                maxRight = height[right]\n            } else {\n                water += maxRight - height[right]\n            }\n            right -= 1\n        }\n    }\n    \n    return water\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Constant space"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440255",
              "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
              "expectedOutput": "6",
              "explanation": "Water fills gaps between bars"
            }
          ]
        }
      ],
      "relatedProblems": [
        "container-with-most-water"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440039",
      "problemSlug": "jump-game",
      "summary": "Can reach last index from first? Track maximum reachable index, update as you go.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440150",
          "name": "Greedy",
          "order": 1,
          "intuition": "Track farthest reachable position. If current index exceeds it, we're stuck.",
          "approach": "1. maxReach = 0\n2. For each index i:\n   - If i > maxReach: return false\n   - maxReach = max(maxReach, i + nums[i])\n3. Return true if loop completes",
          "explanation": "At each step, extend reach if possible. If we can't reach current position, we fail.",
          "code": "func canJump(_ nums: [Int]) -> Bool {\n    var maxReach = 0\n    \n    for i in 0..<nums.count {\n        if i > maxReach { return false }\n        maxReach = max(maxReach, i + nums[i])\n    }\n    \n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "One variable"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440256",
              "input": "[2,3,1,1,4]",
              "expectedOutput": "true",
              "explanation": "Jump 1->2->4 or 1->3->4"
            }
          ]
        }
      ],
      "relatedProblems": [
        "jump-game-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440040",
      "problemSlug": "unique-paths",
      "summary": "Count paths in grid moving only right/down. DP or combinatorics: C(m+n-2, m-1).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440151",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "Paths to (i,j) = paths to (i-1,j) + paths to (i,j-1). Fill grid row by row.",
          "approach": "1. dp[i][j] = number of paths to reach (i,j)\n2. First row and column are all 1s\n3. dp[i][j] = dp[i-1][j] + dp[i][j-1]\n4. Return dp[m-1][n-1]",
          "explanation": "Can only come from above or left. Sum both possibilities. Optimize to O(n) space with single row.",
          "code": "func uniquePaths(_ m: Int, _ n: Int) -> Int {\n    var dp = [Int](repeating: 1, count: n)\n    \n    for _ in 1..<m {\n        for j in 1..<n {\n            dp[j] += dp[j-1]\n        }\n    }\n    \n    return dp[n-1]\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(n)",
            "timeExplanation": "Fill m*n cells",
            "spaceExplanation": "Single row DP"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440257",
              "input": "m = 3, n = 7",
              "expectedOutput": "28",
              "explanation": "28 unique paths"
            }
          ]
        }
      ],
      "relatedProblems": [
        "unique-paths-ii",
        "minimum-path-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440041",
      "problemSlug": "valid-palindrome",
      "summary": "Check if string is palindrome ignoring non-alphanumeric. Two pointers from ends.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440152",
          "name": "Two Pointers",
          "order": 1,
          "intuition": "Compare characters from both ends, skip non-alphanumeric, ignore case.",
          "approach": "1. left = 0, right = n-1\n2. Skip non-alphanumeric from both ends\n3. Compare lowercase versions\n4. Return false if mismatch",
          "explanation": "Filter and compare in one pass without creating new string.",
          "code": "func isPalindrome(_ s: String) -> Bool {\n    let chars = Array(s.lowercased())\n    var left = 0, right = chars.count - 1\n    \n    while left < right {\n        while left < right && !chars[left].isLetter && !chars[left].isNumber {\n            left += 1\n        }\n        while left < right && !chars[right].isLetter && !chars[right].isNumber {\n            right -= 1\n        }\n        if chars[left] != chars[right] { return false }\n        left += 1\n        right -= 1\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Array conversion"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440258",
              "input": "\"A man, a plan, a canal: Panama\"",
              "expectedOutput": "true",
              "explanation": "amanaplanacanalpanama is palindrome"
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-palindrome-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440042",
      "problemSlug": "longest-consecutive-sequence",
      "summary": "Find longest consecutive sequence in O(n). Use set, only start counting from sequence starts.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440153",
          "name": "Hash Set",
          "order": 1,
          "intuition": "Put all in set. For each number, if n-1 not in set, it's a sequence start. Count forward.",
          "approach": "1. Create set from nums\n2. For each num: if num-1 not in set, count consecutive\n3. Track max length",
          "explanation": "Only counting from sequence starts ensures O(n) - each element visited at most twice.",
          "code": "func longestConsecutive(_ nums: [Int]) -> Int {\n    let numSet = Set(nums)\n    var maxLength = 0\n    \n    for num in numSet {\n        // Only start if this is beginning of sequence\n        if !numSet.contains(num - 1) {\n            var current = num\n            var length = 1\n            while numSet.contains(current + 1) {\n                current += 1\n                length += 1\n            }\n            maxLength = max(maxLength, length)\n        }\n    }\n    \n    return maxLength\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each element visited at most twice",
            "spaceExplanation": "Set storage"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440259",
              "input": "[100,4,200,1,3,2]",
              "expectedOutput": "4",
              "explanation": "Sequence [1,2,3,4]"
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-longest-consecutive-sequence"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440043",
      "problemSlug": "generate-parentheses",
      "summary": "Generate all valid n pairs of parentheses. Backtrack, ensuring open >= close.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440154",
          "name": "Backtracking",
          "order": 1,
          "intuition": "Add '(' if openCount < n. Add ')' if closeCount < openCount. Ensures validity.",
          "approach": "1. Track open and close counts\n2. Add '(' if open < n\n3. Add ')' if close < open\n4. When length == 2n, save result",
          "explanation": "Never more ')' than '(' ensures every prefix is valid. Stop when counts reach n.",
          "code": "func generateParenthesis(_ n: Int) -> [String] {\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ open: Int, _ close: Int) {\n        if current.count == 2 * n {\n            result.append(current)\n            return\n        }\n        if open < n {\n            current.append(\"(\")\n            backtrack(open + 1, close)\n            current.removeLast()\n        }\n        if close < open {\n            current.append(\")\")\n            backtrack(open, close + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, 0)\n    return result\n}",
          "complexity": {
            "time": "O(4^n / \u221an)",
            "space": "O(n)",
            "timeExplanation": "Catalan number complexity",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440260",
              "input": "n = 3",
              "expectedOutput": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
              "explanation": "All 5 valid combinations"
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-parentheses",
        "letter-combinations-of-a-phone-number"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440044",
      "problemSlug": "daily-temperatures",
      "summary": "Days until warmer temperature. Use monotonic decreasing stack.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440155",
          "name": "Monotonic Stack",
          "order": 1,
          "intuition": "Stack holds indices of decreasing temps. When warmer found, pop and calculate days.",
          "approach": "1. Stack stores indices of unresolved days\n2. For each day: pop while current > stack top\n3. For popped index, answer = current index - popped index\n4. Push current index",
          "explanation": "Stack maintains indices waiting for warmer day. Pop when found, difference is wait time.",
          "code": "func dailyTemperatures(_ temperatures: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: temperatures.count)\n    var stack: [Int] = []  // indices\n    \n    for i in 0..<temperatures.count {\n        while !stack.isEmpty && temperatures[i] > temperatures[stack.last!] {\n            let j = stack.removeLast()\n            result[j] = i - j\n        }\n        stack.append(i)\n    }\n    \n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each element pushed/popped once",
            "spaceExplanation": "Stack size"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440261",
              "input": "[73,74,75,71,69,72,76,73]",
              "expectedOutput": "[1,1,4,2,1,1,0,0]",
              "explanation": "Days until next warmer temp"
            }
          ]
        }
      ],
      "relatedProblems": [
        "next-greater-element-i"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440045",
      "problemSlug": "evaluate-reverse-polish-notation",
      "summary": "Evaluate RPN expression. Stack: push numbers, pop two for operators, push result.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440156",
          "name": "Stack",
          "order": 1,
          "intuition": "Numbers go on stack. Operators pop two, compute, push result.",
          "approach": "1. For each token:\n   - If number: push to stack\n   - If operator: pop b, pop a, push a op b\n2. Return stack top",
          "explanation": "Order matters for - and /: second popped is left operand.",
          "code": "func evalRPN(_ tokens: [String]) -> Int {\n    var stack: [Int] = []\n    \n    for token in tokens {\n        switch token {\n        case \"+\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a + b)\n        case \"-\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a - b)\n        case \"*\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a * b)\n        case \"/\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a / b)\n        default:\n            stack.append(Int(token)!)\n        }\n    }\n    \n    return stack[0]\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Process each token once",
            "spaceExplanation": "Stack for operands"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440262",
              "input": "[\"2\",\"1\",\"+\",\"3\",\"*\"]",
              "expectedOutput": "9",
              "explanation": "((2+1)*3) = 9"
            }
          ]
        }
      ],
      "relatedProblems": [
        "basic-calculator"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440046",
      "problemSlug": "clone-graph",
      "summary": "Deep copy a graph. Use hash map to track cloned nodes, BFS or DFS.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440157",
          "name": "DFS with Hash Map",
          "order": 1,
          "intuition": "Map original nodes to clones. When visiting, create clone if not exists, recurse for neighbors.",
          "approach": "1. Map: original -> clone\n2. DFS: if node in map, return clone\n3. Create clone, add to map\n4. Recursively clone neighbors",
          "explanation": "Hash map prevents infinite loops by tracking visited nodes.",
          "code": "func cloneGraph(_ node: Node?) -> Node? {\n    guard let node = node else { return nil }\n    \n    var cloned: [Int: Node] = [:]\n    \n    func dfs(_ node: Node) -> Node {\n        if let clone = cloned[node.val] { return clone }\n        \n        let clone = Node(node.val)\n        cloned[node.val] = clone\n        \n        for neighbor in node.neighbors {\n            if let n = neighbor {\n                clone.neighbors.append(dfs(n))\n            }\n        }\n        \n        return clone\n    }\n    \n    return dfs(node)\n}",
          "complexity": {
            "time": "O(V + E)",
            "space": "O(V)",
            "timeExplanation": "Visit each node and edge",
            "spaceExplanation": "Hash map stores V nodes"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440263",
              "input": "[[2,4],[1,3],[2,4],[1,3]]",
              "expectedOutput": "[[2,4],[1,3],[2,4],[1,3]]",
              "explanation": "Deep copy preserves structure"
            }
          ]
        }
      ],
      "relatedProblems": [
        "copy-list-with-random-pointer"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440047",
      "problemSlug": "max-area-of-island",
      "summary": "Find largest island area. DFS/BFS from each land cell, mark visited, count area.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440158",
          "name": "DFS",
          "order": 1,
          "intuition": "For each unvisited land cell, DFS to count connected land. Track max area.",
          "approach": "1. For each cell (i,j) with value 1:\n2. DFS: mark visited (set to 0), count 1 + area of 4 neighbors\n3. Track maximum area",
          "explanation": "Marking as 0 prevents revisiting. Each cell visited once.",
          "code": "func maxAreaOfIsland(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let m = grid.count, n = grid[0].count\n    var maxArea = 0\n    \n    func dfs(_ i: Int, _ j: Int) -> Int {\n        guard i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1 else { return 0 }\n        grid[i][j] = 0\n        return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                maxArea = max(maxArea, dfs(i, j))\n            }\n        }\n    }\n    \n    return maxArea\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(m*n)",
            "timeExplanation": "Visit each cell once",
            "spaceExplanation": "Recursion stack worst case"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440264",
              "input": "[[0,0,1,0],[1,1,1,0],[0,1,0,0]]",
              "expectedOutput": "5",
              "explanation": "Connected 1s form island of size 5"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-islands",
        "island-perimeter"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440048",
      "problemSlug": "surrounded-regions",
      "summary": "Capture surrounded O's. Border-connected O's survive; mark them, then flip rest.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440159",
          "name": "DFS from Border",
          "order": 1,
          "intuition": "O's connected to border can't be surrounded. Mark them, flip remaining O's to X.",
          "approach": "1. DFS from all border O's, mark as 'S' (safe)\n2. Scan grid: O -> X, S -> O",
          "explanation": "Reverse thinking: instead of finding surrounded, find NOT surrounded from borders.",
          "code": "func solve(_ board: inout [[Character]]) {\n    guard !board.isEmpty else { return }\n    let m = board.count, n = board[0].count\n    \n    func dfs(_ i: Int, _ j: Int) {\n        guard i >= 0 && i < m && j >= 0 && j < n && board[i][j] == \"O\" else { return }\n        board[i][j] = \"S\"\n        dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)\n    }\n    \n    // Mark border-connected O's\n    for i in 0..<m {\n        dfs(i, 0); dfs(i, n-1)\n    }\n    for j in 0..<n {\n        dfs(0, j); dfs(m-1, j)\n    }\n    \n    // Flip: O->X, S->O\n    for i in 0..<m {\n        for j in 0..<n {\n            if board[i][j] == \"O\" { board[i][j] = \"X\" }\n            else if board[i][j] == \"S\" { board[i][j] = \"O\" }\n        }\n    }\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(m*n)",
            "timeExplanation": "Visit each cell",
            "spaceExplanation": "Recursion stack"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440265",
              "input": "[[\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\"]]",
              "expectedOutput": "[[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]",
              "explanation": "Center O is surrounded and captured"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-islands"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440049",
      "problemSlug": "longest-common-subsequence",
      "summary": "LCS of two strings. DP: if chars match, 1 + LCS of rest; else max of skipping either.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440160",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "dp[i][j] = LCS of text1[0..i-1] and text2[0..j-1]. If match, extend; else take max.",
          "approach": "1. If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n2. Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n3. Return dp[m][n]",
          "explanation": "Match extends previous LCS. No match means we must skip one character.",
          "code": "func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n    let s1 = Array(text1), s2 = Array(text2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1] + 1\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(m*n)",
            "timeExplanation": "Fill m*n table",
            "spaceExplanation": "2D DP array (can optimize to O(n))"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440266",
              "input": "text1 = \"abcde\", text2 = \"ace\"",
              "expectedOutput": "3",
              "explanation": "LCS is \"ace\""
            }
          ]
        }
      ],
      "relatedProblems": [
        "edit-distance",
        "longest-palindromic-subsequence"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440050",
      "problemSlug": "edit-distance",
      "summary": "Min operations (insert/delete/replace) to transform word1 to word2. Classic 2D DP.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440161",
          "name": "Dynamic Programming",
          "order": 1,
          "intuition": "dp[i][j] = min ops for word1[0..i-1] to word2[0..j-1]. If match, no op; else try all three.",
          "approach": "1. Base: dp[i][0] = i (delete all), dp[0][j] = j (insert all)\n2. If match: dp[i][j] = dp[i-1][j-1]\n3. Else: 1 + min(replace, insert, delete)",
          "explanation": "Three choices: replace (i-1,j-1), insert (i,j-1), delete (i-1,j). Take minimum.",
          "code": "func minDistance(_ word1: String, _ word2: String) -> Int {\n    let s1 = Array(word1), s2 = Array(word2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 0...m { dp[i][0] = i }\n    for j in 0...n { dp[0][j] = j }\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(m*n)",
            "timeExplanation": "Fill m*n table",
            "spaceExplanation": "2D DP array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440267",
              "input": "word1 = \"horse\", word2 = \"ros\"",
              "expectedOutput": "3",
              "explanation": "horse -> rorse -> rose -> ros"
            }
          ]
        }
      ],
      "relatedProblems": [
        "one-edit-distance",
        "delete-operation-for-two-strings"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440051",
      "problemSlug": "diameter-of-binary-tree",
      "summary": "Longest path between any two nodes. For each node, diameter through it = leftHeight + rightHeight.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440162",
          "name": "DFS Height",
          "order": 1,
          "intuition": "Diameter through node = left height + right height. Track max while computing heights.",
          "approach": "1. DFS returns height of subtree\n2. At each node: update diameter = left + right\n3. Return 1 + max(left, right) as height",
          "explanation": "Height is longest path to leaf. Diameter uses both sides.",
          "code": "func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\n    var diameter = 0\n    \n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        let right = height(node.right)\n        diameter = max(diameter, left + right)\n        return 1 + max(left, right)\n    }\n    \n    _ = height(root)\n    return diameter\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Recursion depth = height"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440268",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "3",
              "explanation": "Path 4->2->1->3 or 5->2->1->3"
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-maximum-path-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440052",
      "problemSlug": "balanced-binary-tree",
      "summary": "Check if height-balanced. At each node, heights of subtrees differ by at most 1.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440163",
          "name": "DFS Height Check",
          "order": 1,
          "intuition": "Compute height bottom-up. Return -1 if unbalanced, propagate up.",
          "approach": "1. DFS returns height or -1 if unbalanced\n2. If left or right is -1, return -1\n3. If |left - right| > 1, return -1\n4. Else return 1 + max(left, right)",
          "explanation": "Single pass: check balance while computing height.",
          "code": "func isBalanced(_ root: TreeNode?) -> Bool {\n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        if left == -1 { return -1 }\n        let right = height(node.right)\n        if right == -1 { return -1 }\n        if abs(left - right) > 1 { return -1 }\n        return 1 + max(left, right)\n    }\n    return height(root) != -1\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440269",
              "input": "[3,9,20,null,null,15,7]",
              "expectedOutput": "true",
              "explanation": "Heights differ by at most 1 at each node"
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximum-depth-of-binary-tree"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440053",
      "problemSlug": "kth-largest-element-in-an-array",
      "summary": "Find kth largest. Use min-heap of size k, or QuickSelect for O(n) average.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440164",
          "name": "QuickSelect",
          "order": 1,
          "intuition": "Partition like QuickSort, but only recurse into the half containing k.",
          "approach": "1. Pick pivot, partition array\n2. If pivot position == k-1, found it\n3. Else recurse into correct half",
          "explanation": "Average O(n) because we halve search space each time.",
          "code": "func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n    var nums = nums\n    let target = nums.count - k\n    \n    func partition(_ left: Int, _ right: Int) -> Int {\n        let pivot = nums[right]\n        var i = left\n        for j in left..<right {\n            if nums[j] < pivot {\n                nums.swapAt(i, j)\n                i += 1\n            }\n        }\n        nums.swapAt(i, right)\n        return i\n    }\n    \n    var left = 0, right = nums.count - 1\n    while true {\n        let p = partition(left, right)\n        if p == target { return nums[p] }\n        if p < target { left = p + 1 }\n        else { right = p - 1 }\n    }\n}",
          "complexity": {
            "time": "O(n) average",
            "space": "O(1)",
            "timeExplanation": "Average case, O(n\u00b2) worst",
            "spaceExplanation": "In-place"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440270",
              "input": "nums = [3,2,1,5,6,4], k = 2",
              "expectedOutput": "5",
              "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5"
            }
          ]
        }
      ],
      "relatedProblems": [
        "kth-largest-element-in-a-stream"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440054",
      "problemSlug": "task-scheduler",
      "summary": "Min time to execute tasks with cooldown. Most frequent task defines structure.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440165",
          "name": "Math/Greedy",
          "order": 1,
          "intuition": "Most frequent task needs (count-1) gaps of size n. Fill gaps with other tasks.",
          "approach": "1. Count frequencies, find max freq and how many tasks have it\n2. Minimum = (maxFreq - 1) * (n + 1) + numMaxTasks\n3. Answer = max(above, total tasks)",
          "explanation": "Frame built by most frequent task. Other tasks fill gaps or extend if needed.",
          "code": "func leastInterval(_ tasks: [Character], _ n: Int) -> Int {\n    var freq = [Int](repeating: 0, count: 26)\n    for task in tasks {\n        freq[Int(task.asciiValue!) - 65] += 1\n    }\n    \n    let maxFreq = freq.max()!\n    let numMaxTasks = freq.filter { $0 == maxFreq }.count\n    \n    let minTime = (maxFreq - 1) * (n + 1) + numMaxTasks\n    return max(minTime, tasks.count)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Count frequencies once",
            "spaceExplanation": "Fixed 26-char array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440271",
              "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
              "expectedOutput": "8",
              "explanation": "A_B_A_B_A_B or similar"
            }
          ]
        }
      ],
      "relatedProblems": [
        "reorganize-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440055",
      "problemSlug": "maximum-product-subarray",
      "summary": "Max product subarray. Track both max and min (negative * negative = positive).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440166",
          "name": "DP with Min/Max",
          "order": 1,
          "intuition": "Negative number flips max and min. Track both to handle sign changes.",
          "approach": "1. Track currentMax, currentMin, result\n2. For each num: newMax = max(num, num*currentMax, num*currentMin)\n3. newMin = min of same\n4. Update result",
          "explanation": "A negative times the most negative gives largest. Hence track both.",
          "code": "func maxProduct(_ nums: [Int]) -> Int {\n    var maxProd = nums[0]\n    var minProd = nums[0]\n    var result = nums[0]\n    \n    for i in 1..<nums.count {\n        let candidates = [nums[i], nums[i] * maxProd, nums[i] * minProd]\n        maxProd = candidates.max()!\n        minProd = candidates.min()!\n        result = max(result, maxProd)\n    }\n    \n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Three variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440272",
              "input": "[2,3,-2,4]",
              "expectedOutput": "6",
              "explanation": "[2,3] has product 6"
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximum-subarray",
        "product-of-array-except-self"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440056",
      "problemSlug": "pacific-atlantic-water-flow",
      "summary": "Find cells that can flow to both Pacific and Atlantic oceans. Use reverse BFS/DFS from ocean edges.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440167",
          "name": "Reverse BFS from Oceans",
          "order": 1,
          "intuition": "Instead of checking each cell, work backwards from oceans. A cell can reach ocean if water can flow TO it from ocean edge (going uphill).",
          "approach": "1. BFS from Pacific edges (top, left)\n2. BFS from Atlantic edges (bottom, right)\n3. Cells in both sets can reach both oceans",
          "explanation": "Reverse the problem: find which cells are reachable going uphill from each ocean. Intersection gives answer.",
          "code": "func pacificAtlantic(_ heights: [[Int]]) -> [[Int]] {\n    guard !heights.isEmpty else { return [] }\n    let m = heights.count, n = heights[0].count\n    var pacific = Set<[Int]>()\n    var atlantic = Set<[Int]>()\n    \n    func bfs(_ starts: [[Int]], _ reachable: inout Set<[Int]>) {\n        var queue = starts\n        for s in starts { reachable.insert(s) }\n        let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n        \n        while !queue.isEmpty {\n            let curr = queue.removeFirst()\n            for (dr, dc) in dirs {\n                let nr = curr[0] + dr, nc = curr[1] + dc\n                if nr >= 0 && nr < m && nc >= 0 && nc < n &&\n                   !reachable.contains([nr, nc]) &&\n                   heights[nr][nc] >= heights[curr[0]][curr[1]] {\n                    reachable.insert([nr, nc])\n                    queue.append([nr, nc])\n                }\n            }\n        }\n    }\n    \n    var pacificStarts = [[Int]]()\n    var atlanticStarts = [[Int]]()\n    for i in 0..<m {\n        pacificStarts.append([i, 0])\n        atlanticStarts.append([i, n-1])\n    }\n    for j in 0..<n {\n        pacificStarts.append([0, j])\n        atlanticStarts.append([m-1, j])\n    }\n    \n    bfs(pacificStarts, &pacific)\n    bfs(atlanticStarts, &atlantic)\n    \n    return Array(pacific.intersection(atlantic))\n}",
          "complexity": {
            "time": "O(m*n)",
            "space": "O(m*n)",
            "timeExplanation": "Visit each cell at most twice",
            "spaceExplanation": "Two sets storing cells"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440273",
              "input": "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
              "expectedOutput": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
              "explanation": "These cells can flow to both oceans"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-islands",
        "surrounded-regions"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440057",
      "problemSlug": "number-of-connected-components-in-an-undirected-graph",
      "summary": "Count connected components using Union-Find or DFS.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440168",
          "name": "Union-Find",
          "order": 1,
          "intuition": "Each edge connects two nodes. Union-Find efficiently tracks which nodes are connected.",
          "approach": "1. Initialize n components (each node is its own component)\n2. For each edge, union the two nodes\n3. Each successful union decreases component count by 1",
          "explanation": "Union-Find with path compression and union by rank gives near O(1) operations.",
          "code": "func countComponents(_ n: Int, _ edges: [[Int]]) -> Int {\n    var parent = Array(0..<n)\n    var rank = [Int](repeating: 0, count: n)\n    var components = n\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    func union(_ x: Int, _ y: Int) {\n        let px = find(x), py = find(y)\n        if px == py { return }\n        if rank[px] < rank[py] {\n            parent[px] = py\n        } else if rank[px] > rank[py] {\n            parent[py] = px\n        } else {\n            parent[py] = px\n            rank[px] += 1\n        }\n        components -= 1\n    }\n    \n    for edge in edges {\n        union(edge[0], edge[1])\n    }\n    \n    return components\n}",
          "complexity": {
            "time": "O(E * (n))",
            "space": "O(n)",
            "timeExplanation": " is inverse Ackermann, nearly constant",
            "spaceExplanation": "Parent and rank arrays"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440274",
              "input": "n=5, edges=[[0,1],[1,2],[3,4]]",
              "expectedOutput": "2",
              "explanation": "Components: {0,1,2} and {3,4}"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-islands",
        "graph-valid-tree"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440058",
      "problemSlug": "graph-valid-tree",
      "summary": "A valid tree has n-1 edges and is fully connected (no cycles).",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440169",
          "name": "Union-Find Cycle Detection",
          "order": 1,
          "intuition": "Tree = connected graph with no cycles. If union finds same root, there's a cycle.",
          "approach": "1. Check if edges == n-1 (required for tree)\n2. Union-Find: if two nodes already connected, cycle exists\n3. After all unions, check if single component",
          "explanation": "Adding an edge between already-connected nodes creates a cycle. Tree must have exactly n-1 edges.",
          "code": "func validTree(_ n: Int, _ edges: [[Int]]) -> Bool {\n    if edges.count != n - 1 { return false }\n    \n    var parent = Array(0..<n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let p1 = find(edge[0]), p2 = find(edge[1])\n        if p1 == p2 { return false }  // Cycle detected\n        parent[p1] = p2\n    }\n    \n    return true\n}",
          "complexity": {
            "time": "O(E * (n))",
            "space": "O(n)",
            "timeExplanation": "Process each edge with near-constant union-find",
            "spaceExplanation": "Parent array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440275",
              "input": "n=5, edges=[[0,1],[0,2],[0,3],[1,4]]",
              "expectedOutput": "true",
              "explanation": "4 edges for 5 nodes, no cycles, connected"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-connected-components-in-an-undirected-graph",
        "redundant-connection"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440059",
      "problemSlug": "redundant-connection",
      "summary": "Find edge that creates cycle in undirected graph. Last edge that connects already-connected nodes.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440170",
          "name": "Union-Find",
          "order": 1,
          "intuition": "Process edges in order. When union fails (same component), that's the redundant edge.",
          "approach": "1. Union-Find with each edge\n2. If two nodes already in same component, return this edge\n3. This gives the last edge forming a cycle",
          "explanation": "The problem guarantees exactly one redundant edge. First edge that creates cycle (when processing in order) is the answer.",
          "code": "func findRedundantConnection(_ edges: [[Int]]) -> [Int] {\n    let n = edges.count\n    var parent = Array(0...n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let p1 = find(edge[0]), p2 = find(edge[1])\n        if p1 == p2 {\n            return edge\n        }\n        parent[p1] = p2\n    }\n    \n    return []\n}",
          "complexity": {
            "time": "O(n * (n))",
            "space": "O(n)",
            "timeExplanation": "Process n edges with near-constant find",
            "spaceExplanation": "Parent array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440276",
              "input": "[[1,2],[1,3],[2,3]]",
              "expectedOutput": "[2,3]",
              "explanation": "[2,3] creates cycle 1-2-3-1"
            }
          ]
        }
      ],
      "relatedProblems": [
        "graph-valid-tree",
        "redundant-connection-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440060",
      "problemSlug": "word-ladder",
      "summary": "Transform word to target changing one letter at a time. BFS finds shortest path.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440171",
          "name": "BFS with Pattern Matching",
          "order": 1,
          "intuition": "Each word connects to words differing by one letter. BFS explores level by level for shortest path.",
          "approach": "1. Build pattern map: 'hot' -> ['*ot', 'h*t', 'ho*']\n2. BFS from beginWord\n3. For each word, find neighbors via pattern\n4. First time reaching endWord is shortest",
          "explanation": "Pattern matching avoids O(26*L) letter substitutions. Map each word to wildcard patterns for O(1) neighbor lookup.",
          "code": "func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n    var wordSet = Set(wordList)\n    if !wordSet.contains(endWord) { return 0 }\n    \n    var queue = [(beginWord, 1)]\n    var visited = Set([beginWord])\n    \n    while !queue.isEmpty {\n        let (word, level) = queue.removeFirst()\n        var chars = Array(word)\n        \n        for i in 0..<chars.count {\n            let original = chars[i]\n            for c in \"abcdefghijklmnopqrstuvwxyz\" {\n                chars[i] = c\n                let newWord = String(chars)\n                if newWord == endWord { return level + 1 }\n                if wordSet.contains(newWord) && !visited.contains(newWord) {\n                    visited.insert(newWord)\n                    queue.append((newWord, level + 1))\n                }\n            }\n            chars[i] = original\n        }\n    }\n    \n    return 0\n}",
          "complexity": {
            "time": "O(M * N)",
            "space": "O(M * N)",
            "timeExplanation": "M = word length, N = word count. Check 26*M neighbors for N words",
            "spaceExplanation": "Queue and visited set"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440277",
              "input": "beginWord=\"hit\", endWord=\"cog\", wordList=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
              "expectedOutput": "5",
              "explanation": "hit -> hot -> dot -> dog -> cog"
            }
          ]
        }
      ],
      "relatedProblems": [
        "word-ladder-ii",
        "minimum-genetic-mutation"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440061",
      "problemSlug": "min-cost-to-connect-all-points",
      "summary": "Minimum spanning tree of points using Manhattan distance. Use Prim's or Kruskal's.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440172",
          "name": "Prim's Algorithm",
          "order": 1,
          "intuition": "Greedily add cheapest edge connecting MST to a new node.",
          "approach": "1. Start from any node\n2. Use min-heap to track cheapest edges to unvisited nodes\n3. Add cheapest edge, mark node visited\n4. Add all edges from new node to heap\n5. Repeat until all nodes connected",
          "explanation": "Prim's builds MST by always picking minimum weight edge to expand the tree.",
          "code": "func minCostConnectPoints(_ points: [[Int]]) -> Int {\n    let n = points.count\n    var visited = [Bool](repeating: false, count: n)\n    var minCost = [Int](repeating: Int.max, count: n)\n    minCost[0] = 0\n    var totalCost = 0\n    \n    for _ in 0..<n {\n        var minIdx = -1\n        var minVal = Int.max\n        for j in 0..<n {\n            if !visited[j] && minCost[j] < minVal {\n                minVal = minCost[j]\n                minIdx = j\n            }\n        }\n        \n        visited[minIdx] = true\n        totalCost += minVal\n        \n        for j in 0..<n {\n            if !visited[j] {\n                let dist = abs(points[minIdx][0] - points[j][0]) + \n                           abs(points[minIdx][1] - points[j][1])\n                minCost[j] = min(minCost[j], dist)\n            }\n        }\n    }\n    \n    return totalCost\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "n iterations, each scans n nodes",
            "spaceExplanation": "Visited and minCost arrays"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440278",
              "input": "[[0,0],[2,2],[3,10],[5,2],[7,0]]",
              "expectedOutput": "20",
              "explanation": "Connect points with minimum total Manhattan distance"
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-spanning-tree",
        "connecting-cities-with-minimum-cost"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440062",
      "problemSlug": "network-delay-time",
      "summary": "Shortest path from source to all nodes. Classic Dijkstra's algorithm.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440173",
          "name": "Dijkstra's Algorithm",
          "order": 1,
          "intuition": "Greedily process nodes in order of distance from source. Once processed, distance is final.",
          "approach": "1. Build adjacency list\n2. Min-heap with (distance, node), start with (0, source)\n3. Pop minimum, skip if visited\n4. Update neighbors if shorter path found\n5. Return max distance (time for all to receive)",
          "explanation": "Dijkstra's works because we always process the closest unvisited node, so its distance is optimal.",
          "code": "func networkDelayTime(_ times: [[Int]], _ n: Int, _ k: Int) -> Int {\n    var graph = [Int: [(Int, Int)]]()\n    for t in times {\n        graph[t[0], default: []].append((t[1], t[2]))\n    }\n    \n    var dist = [Int: Int]()\n    var heap = [(0, k)]  // (distance, node)\n    \n    while !heap.isEmpty {\n        heap.sort { $0.0 > $1.0 }  // Simple heap simulation\n        let (d, node) = heap.removeLast()\n        \n        if dist[node] != nil { continue }\n        dist[node] = d\n        \n        for (neighbor, weight) in graph[node] ?? [] {\n            if dist[neighbor] == nil {\n                heap.append((d + weight, neighbor))\n            }\n        }\n    }\n    \n    if dist.count != n { return -1 }\n    return dist.values.max()!\n}",
          "complexity": {
            "time": "O(E log V)",
            "space": "O(V + E)",
            "timeExplanation": "Each edge processed once, heap operations O(log V)",
            "spaceExplanation": "Graph and distance storage"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440279",
              "input": "times=[[2,1,1],[2,3,1],[3,4,1]], n=4, k=2",
              "expectedOutput": "2",
              "explanation": "From node 2: node 1 and 3 at time 1, node 4 at time 2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "cheapest-flights-within-k-stops",
        "path-with-minimum-effort"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440063",
      "problemSlug": "cheapest-flights-within-k-stops",
      "summary": "Shortest path with at most K stops. Modified Bellman-Ford or BFS with pruning.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440174",
          "name": "Bellman-Ford with K iterations",
          "order": 1,
          "intuition": "Bellman-Ford relaxes all edges. K+1 iterations gives paths with at most K stops.",
          "approach": "1. Initialize distances (source = 0, others = infinity)\n2. Repeat K+1 times:\n   - Copy current distances\n   - Relax all edges using previous distances\n3. Return destination distance",
          "explanation": "Each iteration adds one more edge to paths. K+1 edges = K intermediate stops.",
          "code": "func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\n    var dist = [Int](repeating: Int.max, count: n)\n    dist[src] = 0\n    \n    for _ in 0...k {\n        let prev = dist\n        for f in flights {\n            let from = f[0], to = f[1], price = f[2]\n            if prev[from] != Int.max {\n                dist[to] = min(dist[to], prev[from] + price)\n            }\n        }\n    }\n    \n    return dist[dst] == Int.max ? -1 : dist[dst]\n}",
          "complexity": {
            "time": "O(K * E)",
            "space": "O(n)",
            "timeExplanation": "K+1 iterations over E edges",
            "spaceExplanation": "Distance array"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440280",
              "input": "n=4, flights=[[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src=0, dst=3, k=1",
              "expectedOutput": "700",
              "explanation": "0->1->3 costs 700 with 1 stop"
            }
          ]
        }
      ],
      "relatedProblems": [
        "network-delay-time",
        "minimum-cost-to-reach-destination-in-time"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440064",
      "problemSlug": "swim-in-rising-water",
      "summary": "Find minimum time to swim from top-left to bottom-right. Binary search + BFS or modified Dijkstra.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440175",
          "name": "Binary Search + BFS",
          "order": 1,
          "intuition": "Binary search on time T. Check if path exists using only cells with elevation <= T.",
          "approach": "1. Binary search on T from 0 to max elevation\n2. For each T, BFS to check if path exists\n3. Find minimum T where path is possible",
          "explanation": "At time T, all cells with elevation <= T are accessible. Binary search finds minimum viable T.",
          "code": "func swimInWater(_ grid: [[Int]]) -> Int {\n    let n = grid.count\n    let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    \n    func canReach(_ t: Int) -> Bool {\n        if grid[0][0] > t { return false }\n        var visited = Set<[Int]>()\n        var queue = [[0, 0]]\n        visited.insert([0, 0])\n        \n        while !queue.isEmpty {\n            let curr = queue.removeFirst()\n            if curr == [n-1, n-1] { return true }\n            \n            for (dr, dc) in dirs {\n                let nr = curr[0] + dr, nc = curr[1] + dc\n                if nr >= 0 && nr < n && nc >= 0 && nc < n &&\n                   !visited.contains([nr, nc]) && grid[nr][nc] <= t {\n                    visited.insert([nr, nc])\n                    queue.append([nr, nc])\n                }\n            }\n        }\n        return false\n    }\n    \n    var lo = grid[0][0], hi = n * n - 1\n    while lo < hi {\n        let mid = (lo + hi) / 2\n        if canReach(mid) {\n            hi = mid\n        } else {\n            lo = mid + 1\n        }\n    }\n    \n    return lo\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "Binary search O(log n), BFS O(n) each",
            "spaceExplanation": "Visited set"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440281",
              "input": "[[0,2],[1,3]]",
              "expectedOutput": "3",
              "explanation": "At t=3, path 0->2->3 or 0->1->3 possible"
            }
          ]
        }
      ],
      "relatedProblems": [
        "path-with-minimum-effort",
        "trapping-rain-water-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440065",
      "problemSlug": "reconstruct-itinerary",
      "summary": "Find Eulerian path visiting all edges. Use Hierholzer's algorithm with lexical ordering.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440176",
          "name": "Hierholzer's Algorithm",
          "order": 1,
          "intuition": "Build itinerary by DFS, adding airports in reverse post-order. Sorted adjacency ensures lexical order.",
          "approach": "1. Build adjacency list, sort destinations\n2. DFS from 'JFK', greedily visit smallest destination\n3. Add to result in reverse (post-order)\n4. Reverse final result",
          "explanation": "Hierholzer's visits each edge exactly once. Sorting ensures lexicographically smallest path.",
          "code": "func findItinerary(_ tickets: [[String]]) -> [String] {\n    var graph = [String: [String]]()\n    for t in tickets {\n        graph[t[0], default: []].append(t[1])\n    }\n    for key in graph.keys {\n        graph[key]?.sort(by: >)  // Reverse sort for pop efficiency\n    }\n    \n    var result = [String]()\n    \n    func dfs(_ airport: String) {\n        while !(graph[airport]?.isEmpty ?? true) {\n            let next = graph[airport]!.removeLast()\n            dfs(next)\n        }\n        result.append(airport)\n    }\n    \n    dfs(\"JFK\")\n    return result.reversed()\n}",
          "complexity": {
            "time": "O(E log E)",
            "space": "O(E)",
            "timeExplanation": "Sorting edges dominates",
            "spaceExplanation": "Graph and result storage"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440282",
              "input": "[[\"MU\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
              "expectedOutput": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
              "explanation": "Visit all tickets starting from JFK"
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-arrangement-of-pairs",
        "cracking-the-safe"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440066",
      "problemSlug": "word-search",
      "summary": "Find if word exists in grid by traversing adjacent cells. Use DFS with backtracking.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440177",
          "name": "DFS Backtracking",
          "order": 1,
          "intuition": "Start from each cell matching first letter. Explore all 4 directions, marking visited cells to avoid cycles.",
          "approach": "1. For each cell matching word[0], start DFS\n2. At each step, check if current cell matches current char\n3. Mark cell visited (modify to special char)\n4. Recurse to 4 neighbors for next char\n5. Backtrack: restore cell value\n6. Return true if word fully matched",
          "explanation": "Backtracking is key: we temporarily mark cells as visited during exploration, then restore them when backtracking. This allows the same cell to be used in different paths.",
          "code": "func exist(_ board: [[Character]], _ word: String) -> Bool {\n    var board = board\n    let m = board.count, n = board[0].count\n    let word = Array(word)\n    \n    func dfs(_ i: Int, _ j: Int, _ k: Int) -> Bool {\n        if k == word.count { return true }\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k] {\n            return false\n        }\n        \n        let temp = board[i][j]\n        board[i][j] = \"#\"  // Mark visited\n        \n        let found = dfs(i+1, j, k+1) || dfs(i-1, j, k+1) ||\n                    dfs(i, j+1, k+1) || dfs(i, j-1, k+1)\n        \n        board[i][j] = temp  // Backtrack\n        return found\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if dfs(i, j, 0) { return true }\n        }\n    }\n    return false\n}",
          "complexity": {
            "time": "O(m * n * 4^L)",
            "space": "O(L)",
            "timeExplanation": "Try each cell, DFS explores up to 4^L paths where L = word length",
            "spaceExplanation": "Recursion stack depth equals word length"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440283",
              "input": "board=[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word=\"ABCCED\"",
              "expectedOutput": "true",
              "explanation": "Path: A(0,0)->B(0,1)->C(0,2)->C(1,2)->E(2,2)->D(2,1)"
            }
          ]
        }
      ],
      "relatedProblems": [
        "word-search-ii",
        "number-of-islands"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440067",
      "problemSlug": "alien-dictionary",
      "summary": "Derive character ordering from sorted alien words. Build graph from adjacent word comparisons, then topological sort.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440178",
          "name": "Topological Sort (BFS)",
          "order": 1,
          "intuition": "Compare adjacent words to find ordering rules (edges). Build directed graph where edge a->b means a comes before b. Topological sort gives valid ordering.",
          "approach": "1. Compare adjacent words pairwise\n2. First differing char gives edge: words[i][k] -> words[i+1][k]\n3. Build graph and in-degree count\n4. BFS from chars with in-degree 0\n5. If result has all chars, return it; else cycle exists",
          "explanation": "Adjacent sorted words reveal ordering: 'wrt' before 'wrf' means t < f. Edge case: 'abc' before 'ab' is invalid (longer word can't come after prefix).",
          "code": "func alienOrder(_ words: [String]) -> String {\n    var graph = [Character: Set<Character>]()\n    var inDegree = [Character: Int]()\n    \n    // Initialize all characters\n    for word in words {\n        for c in word {\n            graph[c] = graph[c] ?? Set()\n            inDegree[c] = inDegree[c] ?? 0\n        }\n    }\n    \n    // Build graph from adjacent word pairs\n    for i in 0..<words.count - 1 {\n        let w1 = Array(words[i]), w2 = Array(words[i+1])\n        \n        // Check invalid case: prefix comes after longer word\n        if w1.count > w2.count && w1.starts(with: w2) {\n            return \"\"\n        }\n        \n        // Find first differing character\n        for j in 0..<min(w1.count, w2.count) {\n            if w1[j] != w2[j] {\n                if !graph[w1[j]]!.contains(w2[j]) {\n                    graph[w1[j]]!.insert(w2[j])\n                    inDegree[w2[j]]! += 1\n                }\n                break\n            }\n        }\n    }\n    \n    // BFS topological sort\n    var queue = inDegree.filter { $0.value == 0 }.map { $0.key }\n    var result = \"\"\n    \n    while !queue.isEmpty {\n        let c = queue.removeFirst()\n        result.append(c)\n        \n        for next in graph[c]! {\n            inDegree[next]! -= 1\n            if inDegree[next] == 0 {\n                queue.append(next)\n            }\n        }\n    }\n    \n    return result.count == inDegree.count ? result : \"\"\n}",
          "complexity": {
            "time": "O(C)",
            "space": "O(1)",
            "timeExplanation": "C = total chars across all words. Process each char once.",
            "spaceExplanation": "Graph has at most 26 nodes (alphabet size)"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440284",
              "input": "[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
              "expectedOutput": "\"wertf\"",
              "explanation": "From comparisons: t<f, w<e, r<t, e<r. Order: w->e->r->t->f"
            }
          ]
        }
      ],
      "relatedProblems": [
        "course-schedule",
        "course-schedule-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    }
  ]
}
