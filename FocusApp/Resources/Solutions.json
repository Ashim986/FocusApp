{
  "solutions": [
    {
      "approaches": [
        {
          "approach": "1. Initialize prev as nil and curr as head\n2. While curr is not nil:\n   - Store next = curr.next (save reference)\n   - Set curr.next = prev (reverse pointer)\n   - Move prev = curr\n   - Move curr = next\n3. Return prev (the new head)",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    \n    while curr != nil {\n        let next = curr?.next  // Save next\n        curr?.next = prev      // Reverse pointer\n        prev = curr            // Move prev forward\n        curr = next            // Move curr forward\n    }\n    \n    return prev\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use three pointers regardless of list size",
            "time": "O(n)",
            "timeExplanation": "We visit each node exactly once"
          },
          "explanation": "The trick is maintaining three pointers:\n- prev: the node we just processed\n- curr: the node we're currently processing\n- next: the node we'll process next\n\nBefore reversing curr's pointer, we must save curr.next, otherwise we lose access to the rest of the list. After the loop, prev points to what was the last node, which is now the new head.",
          "id": "550e8400-e29b-41d4-a716-446655440101",
          "intuition": "We traverse the list once, reversing each pointer as we go. At each step, we need to:\n1. Save the next node (before we lose the reference)\n2. Point current node backwards to previous\n3. Move both pointers forward",
          "name": "Iterative",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[5,4,3,2,1]",
              "explanation": "Each arrow reverses: 1→2→3→4→5 becomes 5→4→3→2→1",
              "id": "550e8400-e29b-41d4-a716-446655440201",
              "input": "[1,2,3,4,5]"
            },
            {
              "expectedOutput": "[2,1]",
              "explanation": "Simple case: 1→2 becomes 2→1",
              "id": "550e8400-e29b-41d4-a716-446655440202",
              "input": "[1,2]"
            }
          ]
        },
        {
          "approach": "1. Base case: if head is nil or head.next is nil, return head\n2. Recursively reverse the rest: newHead = reverseList(head.next)\n3. Make the next node point back: head.next.next = head\n4. Clear current node's next: head.next = nil\n5. Return newHead (propagate through all calls)",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    // Base case: empty or single node\n    guard let head = head, let next = head.next else {\n        return head\n    }\n    \n    // Recursively reverse the rest\n    let newHead = reverseList(next)\n    \n    // Fix pointers\n    next.next = head  // Make next point back to us\n    head.next = nil   // Clear our forward pointer\n    \n    return newHead\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursive call stack uses O(n) space",
            "time": "O(n)",
            "timeExplanation": "Visit each node once via recursion"
          },
          "explanation": "The recursion reaches the end of the list first, then as it unwinds:\n- At each step, head.next still points to the last node we processed\n- We make that node point back to us (head.next.next = head)\n- We clear our own next pointer (will be set by the previous recursive call)\n\nThe newHead is returned unchanged through all recursive calls.",
          "id": "550e8400-e29b-41d4-a716-446655440102",
          "intuition": "Recursively reverse the rest of the list, then fix up the current node's pointers. The base case is when we reach the last node (which becomes our new head).",
          "name": "Recursive",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[5,4,3,2,1]",
              "explanation": "Each arrow reverses: 1→2→3→4→5 becomes 5→4→3→2→1",
              "id": "43a1a8c3-f3fb-4fe3-bf9a-8189cc5cb527",
              "input": "[1,2,3,4,5]"
            },
            {
              "expectedOutput": "[2,1]",
              "explanation": "Simple case: 1→2 becomes 2→1",
              "id": "2d0da5ea-6d28-44fd-b808-a39626c48eb6",
              "input": "[1,2]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "reverse-linked-list",
      "relatedProblems": [
        "reverse-linked-list-ii",
        "palindrome-linked-list"
      ],
      "summary": "Reverse the direction of pointers in a linked list. The key insight is that you need to track three nodes at once: previous, current, and next."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a dummy node to serve as the start\n2. Use a tail pointer to build the result\n3. While both lists have nodes:\n   - Compare values, append smaller to tail\n   - Advance the list we took from\n4. Append remaining nodes from non-empty list\n5. Return dummy.next",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = list1\n    var l2 = list2\n    \n    while let node1 = l1, let node2 = l2 {\n        if node1.val <= node2.val {\n            tail.next = node1\n            l1 = node1.next\n        } else {\n            tail.next = node2\n            l2 = node2.next\n        }\n        tail = tail.next!\n    }\n    \n    // Append remaining nodes\n    tail.next = l1 ?? l2\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use a few pointers, reuse existing nodes",
            "time": "O(n + m)",
            "timeExplanation": "Visit each node in both lists once"
          },
          "explanation": "The dummy node trick is powerful: instead of tracking whether we've added the first node, we always have a valid tail to append to. At the end, dummy.next is our actual head.\n\nWhen one list is exhausted, we can directly link the remainder since it's already sorted.",
          "id": "550e8400-e29b-41d4-a716-446655440103",
          "intuition": "Compare the heads of both lists, take the smaller one, and advance that list's pointer. A dummy node avoids special-casing the first node.",
          "name": "Iterative with Dummy",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,1,2,3,4,4]",
              "explanation": "Compare 1≤1, take l1. Compare 2>1, take l2. Continue...",
              "id": "550e8400-e29b-41d4-a716-446655440203",
              "input": "list1 = [1,2,4], list2 = [1,3,4]"
            }
          ]
        },
        {
          "approach": "1. Base case: if either list is empty, return the other\n2. Compare heads, take the smaller one as current head\n3. Recursively merge the rest\n4. Return the current head",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    guard let l1 = list1 else { return list2 }\n    guard let l2 = list2 else { return list1 }\n    \n    if l1.val <= l2.val {\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}",
          "complexity": {
            "space": "O(n + m)",
            "spaceExplanation": "Recursive stack depth equals total nodes",
            "time": "O(n + m)",
            "timeExplanation": "Each node processed once"
          },
          "explanation": "Each recursive call handles one node, choosing the smaller of the two heads. The recursion naturally unwinds to build the complete list.",
          "id": "550e8400-e29b-41d4-a716-446655440104",
          "intuition": "The merged list starts with the smaller head, followed by the merge of the remaining elements.",
          "name": "Recursive",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,1,2,3,4,4]",
              "explanation": "Compare 1≤1, take l1. Compare 2>1, take l2. Continue...",
              "id": "06fb4471-f767-41e7-a90c-0268d3289e67",
              "input": "list1 = [1,2,4], list2 = [1,3,4]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440002",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "merge-two-sorted-lists",
      "relatedProblems": [
        "merge-k-sorted-lists",
        "sort-list"
      ],
      "summary": "Merge two sorted linked lists by comparing nodes one at a time and building a new list. Use a dummy head to simplify edge cases."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize slow and fast to head\n2. While fast and fast.next exist:\n   - Move slow one step\n   - Move fast two steps\n   - If they meet, return true\n3. Return false (fast reached end)",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var slow = head\n    var fast = head\n    \n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        \n        if slow === fast {\n            return true\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only two pointers used",
            "time": "O(n)",
            "timeExplanation": "At most 2n iterations before detection or end"
          },
          "explanation": "Why does this work? In a cycle, the fast pointer gains one position on slow each iteration. Eventually they must meet.\n\nMathematically: if cycle length is C, fast catches up by 1 each step, so they meet within C steps after slow enters the cycle.",
          "id": "550e8400-e29b-41d4-a716-446655440105",
          "intuition": "Use two pointers: slow moves 1 step, fast moves 2 steps. If there's a cycle, fast will eventually catch up to slow. If no cycle, fast will reach the end.",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Tail connects to node at index 1 (value 2)",
              "id": "550e8400-e29b-41d4-a716-446655440204",
              "input": "[3,2,0,-4], pos = 1"
            },
            {
              "expectedOutput": "false",
              "explanation": "Single node with no cycle",
              "id": "550e8400-e29b-41d4-a716-446655440205",
              "input": "[1], pos = -1"
            }
          ]
        },
        {
          "approach": "1. Create an empty set of visited nodes\n2. Traverse the list:\n   - If current node is in set, return true\n   - Add current node to set\n3. Return false if we reach the end",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var visited = Set<ObjectIdentifier>()\n    var current = head\n    \n    while let node = current {\n        let id = ObjectIdentifier(node)\n        if visited.contains(id) {\n            return true\n        }\n        visited.insert(id)\n        current = node.next\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Store up to n node references",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Simple but uses extra space. We store node references (not values) to handle duplicate values correctly.",
          "id": "550e8400-e29b-41d4-a716-446655440106",
          "intuition": "Track visited nodes in a set. If we see a node twice, there's a cycle.",
          "name": "Hash Set",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Tail connects to node at index 1 (value 2)",
              "id": "9fd46a1c-2ddb-440d-afc1-203146fb93d8",
              "input": "[3,2,0,-4], pos = 1"
            },
            {
              "expectedOutput": "false",
              "explanation": "Single node with no cycle",
              "id": "e845366a-2c77-4687-8f65-d182a1d39c7c",
              "input": "[1], pos = -1"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440003",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "linked-list-cycle",
      "relatedProblems": [
        "linked-list-cycle-ii",
        "happy-number"
      ],
      "summary": "Detect if a linked list has a cycle using Floyd's Tortoise and Hare algorithm. Two pointers moving at different speeds will meet if there's a cycle."
    },
    {
      "approaches": [
        {
          "approach": "1. Find the middle using slow/fast pointers\n2. Split the list at the middle\n3. Reverse the second half\n4. Merge by alternating: take from first, then second, repeat",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head, head.next != nil else { return }\n    \n    // Step 1: Find middle\n    var slow = head\n    var fast = head\n    while fast.next != nil && fast.next?.next != nil {\n        slow = slow.next!\n        fast = fast.next!.next!\n    }\n    \n    // Step 2: Split and reverse second half\n    var second = slow.next\n    slow.next = nil  // Cut the list\n    second = reverseList(second)\n    \n    // Step 3: Merge alternately\n    var first: ListNode? = head\n    while second != nil {\n        let tmp1 = first?.next\n        let tmp2 = second?.next\n        first?.next = second\n        second?.next = tmp1\n        first = tmp1\n        second = tmp2\n    }\n}\n\nprivate func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    while curr != nil {\n        let next = curr?.next\n        curr?.next = prev\n        prev = curr\n        curr = next\n    }\n    return prev\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use pointer variables, no extra data structures",
            "time": "O(n)",
            "timeExplanation": "Each step (find middle, reverse, merge) is O(n), total is O(n)"
          },
          "explanation": "This approach transforms the problem into three simpler sub-problems we already know how to solve:\n\n- Finding middle: slow/fast pointer technique (slow moves 1 step, fast moves 2)\n- Reversing: standard iterative reversal with prev/curr/next pointers\n- Merging: similar to merge two lists, but we alternate instead of comparing\n\nKey insight: after reversing the second half, both halves are the same length (±1), so we can interleave them directly.",
          "id": "550e8400-e29b-41d4-a716-446655440107",
          "intuition": "The reordered list alternates between taking from the start and end. We can achieve this by:\n1. Split the list into two halves\n2. Reverse the second half\n3. Merge both halves by alternating nodes",
          "name": "Three-Step Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,4,2,3]",
              "explanation": "Split: [1,2] and [3,4]. Reverse second: [4,3]. Merge: 1→4→2→3",
              "id": "550e8400-e29b-41d4-a716-446655440206",
              "input": "[1,2,3,4]"
            },
            {
              "expectedOutput": "[1,5,2,4,3]",
              "explanation": "Split: [1,2,3] and [4,5]. Reverse second: [5,4]. Merge: 1→5→2→4→3",
              "id": "550e8400-e29b-41d4-a716-446655440207",
              "input": "[1,2,3,4,5]"
            }
          ]
        },
        {
          "approach": "1. Push all nodes onto a stack\n2. Calculate how many nodes to interleave (n/2)\n3. Traverse from head, pop from stack, insert popped nodes between current nodes\n4. Handle the final next pointer",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head else { return }\n    \n    // Push all nodes to stack\n    var stack: [ListNode] = []\n    var node: ListNode? = head\n    while let n = node {\n        stack.append(n)\n        node = n.next\n    }\n    \n    let count = stack.count\n    var curr: ListNode? = head\n    \n    // Interleave n/2 nodes from the end\n    for _ in 0..<(count / 2) {\n        let end = stack.removeLast()\n        let next = curr?.next\n        curr?.next = end\n        end.next = next\n        curr = next\n    }\n    \n    // Terminate the list\n    curr?.next = nil\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack stores all n nodes",
            "time": "O(n)",
            "timeExplanation": "Push n nodes, then interleave n/2 times"
          },
          "explanation": "The stack gives us O(1) access to the 'end' of the list. By pushing all nodes, the top of the stack is the last node, second-to-top is second-to-last, etc.\n\nWe only need to interleave n/2 nodes from the end, where n is the total count. After interleaving, we must set the final node's next to nil to avoid a cycle.",
          "id": "550e8400-e29b-41d4-a716-446655440108",
          "intuition": "Use a stack to access nodes from the end. Push all nodes, then pop half while traversing from the front to interleave.",
          "name": "Stack-Based",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,4,2,3]",
              "explanation": "Split: [1,2] and [3,4]. Reverse second: [4,3]. Merge: 1→4→2→3",
              "id": "e48a96f1-4799-4953-b142-e51275392ee2",
              "input": "[1,2,3,4]"
            },
            {
              "expectedOutput": "[1,5,2,4,3]",
              "explanation": "Split: [1,2,3] and [4,5]. Reverse second: [5,4]. Merge: 1→5→2→4→3",
              "id": "ea5de1fc-6fd2-4e3c-9647-4c7cb9ebc787",
              "input": "[1,2,3,4,5]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440004",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "reorder-list",
      "relatedProblems": [
        "reverse-linked-list",
        "palindrome-linked-list"
      ],
      "summary": "Reorder list from L0→L1→...→Ln to L0→Ln→L1→Ln-1→... by finding middle, reversing second half, then merging alternately."
    },
    {
      "approaches": [
        {
          "approach": "1. Create dummy node pointing to head\n2. Initialize both pointers at dummy\n3. Move ahead pointer n+1 steps (creates gap of n)\n4. Move both pointers until ahead reaches nil\n5. Skip the target: behind.next = behind.next.next\n6. Return dummy.next",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    var behind: ListNode? = dummy\n    var ahead: ListNode? = dummy\n    \n    // Create gap of n+1\n    for _ in 0...n {\n        ahead = ahead?.next\n    }\n    \n    // Move both until ahead reaches end\n    while ahead != nil {\n        behind = behind?.next\n        ahead = ahead?.next\n    }\n    \n    // Skip the nth node from end\n    behind?.next = behind?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use two pointer variables plus dummy",
            "time": "O(L)",
            "timeExplanation": "Single pass through the list where L is list length"
          },
          "explanation": "The key insight is the gap. If ahead is n+1 nodes ahead of behind, when ahead is nil (past the end), behind is at the node BEFORE the one we want to remove.\n\nWhy n+1 instead of n? Because we need behind to point to the predecessor of the target node so we can update its next pointer.\n\nThe dummy node elegantly handles removing the head: if n equals the list length, behind stays at dummy, and behind.next becomes the original head (which we skip).",
          "id": "550e8400-e29b-41d4-a716-446655440109",
          "intuition": "If we maintain a gap of n nodes between two pointers, when the front pointer reaches the end, the back pointer will be exactly n nodes from the end.\n\nA dummy node handles edge cases like removing the head.",
          "name": "Two Pointers with Gap",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2,3,5]",
              "explanation": "Remove 4 (2nd from end). Gap of 2 means when ahead=nil, behind points to 3",
              "id": "550e8400-e29b-41d4-a716-446655440208",
              "input": "head = [1,2,3,4,5], n = 2"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Remove only node. Dummy handles this: behind stays at dummy, skips head",
              "id": "550e8400-e29b-41d4-a716-446655440209",
              "input": "head = [1], n = 1"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "Remove 2 (last node). behind ends at node 1, skips node 2",
              "id": "550e8400-e29b-41d4-a716-446655440210",
              "input": "head = [1,2], n = 1"
            }
          ]
        },
        {
          "approach": "1. First pass: count total nodes (length)\n2. Calculate target index: length - n\n3. Use dummy node for edge case handling\n4. Second pass: traverse to node at index (target - 1)\n5. Skip the target node",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    // First pass: count length\n    var length = 0\n    var node = head\n    while node != nil {\n        length += 1\n        node = node?.next\n    }\n    \n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    // Find predecessor of target (at position length - n - 1 from dummy)\n    var curr: ListNode? = dummy\n    for _ in 0..<(length - n) {\n        curr = curr?.next\n    }\n    \n    // Skip target\n    curr?.next = curr?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use counter and pointer variables",
            "time": "O(L)",
            "timeExplanation": "Two passes: first counts L nodes, second traverses L-n nodes"
          },
          "explanation": "Converting 'nth from end' to 'kth from start' simplifies the problem. If list has L nodes, the nth from end is the (L-n)th from start (0-indexed).\n\nWe traverse to position (L-n-1) to reach the predecessor, then update its next pointer.\n\nLess elegant than one-pass but easier to understand and implement correctly.",
          "id": "550e8400-e29b-41d4-a716-446655440110",
          "intuition": "First pass counts the total length. Second pass removes the (length - n)th node from the beginning.",
          "name": "Two Pass",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,2,3,5]",
              "explanation": "Remove 4 (2nd from end). Gap of 2 means when ahead=nil, behind points to 3",
              "id": "07741670-29e9-4437-97a3-b9248a20d0b8",
              "input": "head = [1,2,3,4,5], n = 2"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Remove only node. Dummy handles this: behind stays at dummy, skips head",
              "id": "f7d85690-5bd8-4aaa-b02c-b147e516d951",
              "input": "head = [1], n = 1"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "Remove 2 (last node). behind ends at node 1, skips node 2",
              "id": "f2e7c630-351b-44a7-a1d2-b14362eea4cb",
              "input": "head = [1,2], n = 1"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440005",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "remove-nth-node-from-end-of-list",
      "relatedProblems": [
        "delete-the-middle-node-of-a-linked-list",
        "swapping-nodes-in-a-linked-list"
      ],
      "summary": "Remove the nth node from the end using two pointers with a gap of n. When the ahead pointer reaches the end, the behind pointer is at the node before the target."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a min-heap ordered by node value\n2. Add the head of each non-empty list to the heap\n3. While heap is not empty:\n   - Pop the minimum node\n   - Append it to the result\n   - If that node has a next, push next to heap\n4. Return the merged list",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    // Simple approach using sorted array (for interview, explain heap would be better)\n    var nodes: [ListNode] = []\n    \n    // Collect all nodes\n    for list in lists {\n        var node = list\n        while let n = node {\n            nodes.append(n)\n            node = n.next\n        }\n    }\n    \n    // Sort by value\n    nodes.sort { $0.val < $1.val }\n    \n    // Rebuild list\n    let dummy = ListNode(0)\n    var tail = dummy\n    for node in nodes {\n        tail.next = node\n        tail = node\n    }\n    tail.next = nil\n    \n    return dummy.next\n}\n\n// Optimal with custom min-heap\nfunc mergeKListsHeap(_ lists: [ListNode?]) -> ListNode? {\n    var heap: [ListNode] = lists.compactMap { $0 }\n    \n    func heapifyUp(_ i: Int) {\n        var i = i\n        while i > 0 && heap[(i-1)/2].val > heap[i].val {\n            heap.swapAt(i, (i-1)/2)\n            i = (i-1)/2\n        }\n    }\n    \n    func heapifyDown(_ i: Int) {\n        var i = i\n        while 2*i + 1 < heap.count {\n            var smallest = 2*i + 1\n            if smallest + 1 < heap.count && heap[smallest+1].val < heap[smallest].val {\n                smallest += 1\n            }\n            if heap[i].val <= heap[smallest].val { break }\n            heap.swapAt(i, smallest)\n            i = smallest\n        }\n    }\n    \n    // Build heap\n    for i in (0..<heap.count).reversed() { heapifyDown(i) }\n    \n    let dummy = ListNode(0)\n    var tail = dummy\n    \n    while !heap.isEmpty {\n        let min = heap[0]\n        tail.next = min\n        tail = min\n        \n        if let next = min.next {\n            heap[0] = next\n            heapifyDown(0)\n        } else {\n            heap[0] = heap[heap.count - 1]\n            heap.removeLast()\n            if !heap.isEmpty { heapifyDown(0) }\n        }\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(k)",
            "spaceExplanation": "Heap stores at most k nodes (one per list)",
            "time": "O(N log k)",
            "timeExplanation": "N total nodes, each pushed/popped once with O(log k) heap operations"
          },
          "explanation": "The heap maintains the 'frontier' of each list - the next candidate node from each list. By always extracting the minimum, we build the sorted result.\n\nSwift doesn't have a built-in heap, so we implement a simple one or use an array with manual sorting (less efficient but simpler).\n\nKey insight: each node is pushed and popped exactly once, and each operation is O(log k).",
          "id": "550e8400-e29b-41d4-a716-446655440111",
          "intuition": "Always pick the smallest available node across all k lists. A min-heap gives us O(log k) access to the minimum among k candidates.\n\nAt any time, the heap contains at most one node from each list (the current head).",
          "name": "Min-Heap (Priority Queue)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,1,2,3,4,4,5,6]",
              "explanation": "Heap starts with [1,1,2]. Pop 1, push 4. Pop 1, push 3. Continue...",
              "id": "550e8400-e29b-41d4-a716-446655440211",
              "input": "lists = [[1,4,5],[1,3,4],[2,6]]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Empty input returns empty list",
              "id": "550e8400-e29b-41d4-a716-446655440212",
              "input": "lists = []"
            }
          ]
        },
        {
          "approach": "1. If lists is empty, return nil\n2. While we have more than one list:\n   - Pair up lists and merge each pair\n   - Replace lists with merged results\n3. Return the single remaining list",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    var lists = lists.compactMap { $0 }  // Remove nils\n    if lists.isEmpty { return nil }\n    \n    while lists.count > 1 {\n        var merged: [ListNode] = []\n        for i in stride(from: 0, to: lists.count, by: 2) {\n            let l1 = lists[i]\n            let l2 = i + 1 < lists.count ? lists[i + 1] : nil\n            if let m = mergeTwoLists(l1, l2) {\n                merged.append(m)\n            }\n        }\n        lists = merged\n    }\n    \n    return lists.first\n}\n\nprivate func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = l1, l2 = l2\n    \n    while let n1 = l1, let n2 = l2 {\n        if n1.val <= n2.val {\n            tail.next = n1\n            l1 = n1.next\n        } else {\n            tail.next = n2\n            l2 = n2.next\n        }\n        tail = tail.next!\n    }\n    tail.next = l1 ?? l2\n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Merge is done in-place, only using pointers",
            "time": "O(N log k)",
            "timeExplanation": "log k rounds, each processing all N nodes"
          },
          "explanation": "Each 'round' halves the number of lists: k → k/2 → k/4 → ... → 1.\n\nThere are O(log k) rounds, and each round processes all N nodes once (spread across the merges). Total: O(N log k).\n\nThis approach reuses our merge-two-lists solution and is often easier to implement correctly than a heap.",
          "id": "550e8400-e29b-41d4-a716-446655440112",
          "intuition": "Pair up the k lists and merge each pair. After one round, we have k/2 lists. Repeat until one list remains.\n\nThis is like merge sort's merge step, applied to lists instead of arrays.",
          "name": "Divide and Conquer",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,1,2,3,4,4,5,6]",
              "explanation": "Heap starts with [1,1,2]. Pop 1, push 4. Pop 1, push 3. Continue...",
              "id": "aca770ac-ad74-4d56-b4ff-39cf7ce6cfdc",
              "input": "lists = [[1,4,5],[1,3,4],[2,6]]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Empty input returns empty list",
              "id": "ec03a1f2-96d3-4167-8fd7-9db96420f515",
              "input": "lists = []"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440006",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "merge-k-sorted-lists",
      "relatedProblems": [
        "merge-two-sorted-lists",
        "ugly-number-ii"
      ],
      "summary": "Merge k sorted linked lists into one sorted list. Use a min-heap for O(n log k) efficiency, or divide and conquer by repeatedly merging pairs."
    },
    {
      "approaches": [
        {
          "approach": "1. First pass: create a copy of each node, store original→copy mapping\n2. Second pass: for each original node:\n   - Set copy.next = map[original.next]\n   - Set copy.random = map[original.random]\n3. Return map[head]",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard let head = head else { return nil }\n    \n    var map: [ObjectIdentifier: Node] = [:]\n    \n    // First pass: create all nodes\n    var curr: Node? = head\n    while let node = curr {\n        map[ObjectIdentifier(node)] = Node(node.val)\n        curr = node.next\n    }\n    \n    // Second pass: wire up pointers\n    curr = head\n    while let node = curr {\n        let copy = map[ObjectIdentifier(node)]!\n        if let next = node.next {\n            copy.next = map[ObjectIdentifier(next)]\n        }\n        if let random = node.random {\n            copy.random = map[ObjectIdentifier(random)]\n        }\n        curr = node.next\n    }\n    \n    return map[ObjectIdentifier(head)]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Hash map stores n node mappings",
            "time": "O(n)",
            "timeExplanation": "Two passes through n nodes, O(1) per node"
          },
          "explanation": "The hash map is the key insight. When we encounter original.random pointing to some node X, we need to find the copy of X. The map gives us this in O(1).\n\nFirst pass creates all nodes (values only). Second pass wires up both next and random pointers using the map.\n\nNote: we handle nil by checking before map lookup.",
          "id": "550e8400-e29b-41d4-a716-446655440113",
          "intuition": "The challenge is that random pointers can point to nodes we haven't created yet. Solution: first create all nodes, then wire up the pointers.\n\nA hash map lets us find the copy of any original node in O(1).",
          "name": "Hash Map (Two Pass)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "explanation": "Deep copy with same structure. Node 1's random points to node 0, etc.",
              "id": "550e8400-e29b-41d4-a716-446655440213",
              "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
            }
          ]
        },
        {
          "approach": "1. Insert copy after each original: A→A'→B→B'→...\n2. Set random pointers: copy.random = original.random?.next\n3. Separate the two lists: restore original, extract copies",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard head != nil else { return nil }\n    \n    // Phase 1: Insert copies after originals\n    var curr = head\n    while let node = curr {\n        let copy = Node(node.val)\n        copy.next = node.next\n        node.next = copy\n        curr = copy.next\n    }\n    \n    // Phase 2: Set random pointers\n    curr = head\n    while let node = curr {\n        let copy = node.next\n        copy?.random = node.random?.next  // Random's copy is right after random\n        curr = copy?.next\n    }\n    \n    // Phase 3: Separate lists\n    let dummy = Node(0)\n    var copyTail = dummy\n    curr = head\n    while let node = curr {\n        let copy = node.next!\n        let nextOrig = copy.next\n        \n        // Extract copy\n        copyTail.next = copy\n        copyTail = copy\n        \n        // Restore original\n        node.next = nextOrig\n        curr = nextOrig\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "No extra data structures, only pointers (output doesn't count)",
            "time": "O(n)",
            "timeExplanation": "Three passes, each O(n)"
          },
          "explanation": "The interleaving trick embeds the 'map' in the list structure itself. Original.next always points to its copy.\n\nPhase 1: Create copies, insert after originals.\nPhase 2: Wire random pointers using the interleaved structure.\nPhase 3: Carefully unweave the two lists.\n\nThe separation step is tricky - we must restore the original list while extracting the copy list.",
          "id": "550e8400-e29b-41d4-a716-446655440114",
          "intuition": "Avoid the hash map by interleaving copies with originals: A→A'→B→B'→C→C'. Now A'.random = A.random.next (the copy is right after the original).",
          "name": "Interleaving (O(1) Space)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "explanation": "Deep copy with same structure. Node 1's random points to node 0, etc.",
              "id": "cad77c55-2607-4df0-8ce4-3298730bda9d",
              "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440007",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "copy-list-with-random-pointer",
      "relatedProblems": [
        "clone-graph",
        "clone-binary-tree-with-random-pointer"
      ],
      "summary": "Create a deep copy of a linked list where each node has a random pointer. Use a hash map to map original nodes to copies, enabling O(1) lookup for random pointers."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize carry = 0 and result with dummy head\n2. While either list has nodes OR carry > 0:\n   - Get digits (0 if list exhausted)\n   - sum = digit1 + digit2 + carry\n   - Create node with sum % 10\n   - Update carry = sum / 10\n3. Return dummy.next",
          "code": "func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var p1 = l1\n    var p2 = l2\n    var carry = 0\n    \n    while p1 != nil || p2 != nil || carry > 0 {\n        let val1 = p1?.val ?? 0\n        let val2 = p2?.val ?? 0\n        let sum = val1 + val2 + carry\n        \n        carry = sum / 10\n        tail.next = ListNode(sum % 10)\n        tail = tail.next!\n        \n        p1 = p1?.next\n        p2 = p2?.next\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "space": "O(max(m, n))",
            "spaceExplanation": "Result list has at most max(m,n)+1 nodes",
            "time": "O(max(m, n))",
            "timeExplanation": "Process max(m,n) digits where m and n are list lengths"
          },
          "explanation": "The reverse order is a gift - it means we process from least significant to most significant, exactly as in manual addition.\n\nHandling unequal lengths: treat exhausted list as contributing 0.\n\nDon't forget the final carry! If sum of last digits produces a carry, we need one more node (e.g., 5+5=10 needs [0,1]).\n\nThe dummy node simplifies appending the first result node.",
          "id": "550e8400-e29b-41d4-a716-446655440115",
          "intuition": "Since digits are in reverse order (ones place first), we can add them directly left-to-right, just like manual addition.\n\nKeep track of the carry: if sum >= 10, carry 1 to the next digit.",
          "name": "Elementary Math Simulation",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[7,0,8]",
              "explanation": "342 + 465 = 807. Process: 2+5=7, 4+6=10 (carry 1), 3+4+1=8",
              "id": "550e8400-e29b-41d4-a716-446655440214",
              "input": "l1 = [2,4,3], l2 = [5,6,4]"
            },
            {
              "expectedOutput": "[0,0,0,1]",
              "explanation": "999 + 1 = 1000. Final carry creates extra digit",
              "id": "550e8400-e29b-41d4-a716-446655440215",
              "input": "l1 = [9,9,9], l2 = [1]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440008",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "add-two-numbers",
      "relatedProblems": [
        "add-two-numbers-ii",
        "multiply-strings"
      ],
      "summary": "Add two numbers represented as reversed linked lists. Simulate digit-by-digit addition with carry, building the result list as you go."
    },
    {
      "approaches": [
        {
          "approach": "1. Phase 1 - Find intersection:\n   - slow = nums[slow], fast = nums[nums[fast]]\n   - Continue until they meet (inside cycle)\n2. Phase 2 - Find entry point:\n   - Reset slow to start (index 0)\n   - Move both one step at a time\n   - They meet at the duplicate",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    // Phase 1: Find intersection point\n    var slow = nums[0]\n    var fast = nums[0]\n    \n    repeat {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    } while slow != fast\n    \n    // Phase 2: Find cycle entry (the duplicate)\n    slow = nums[0]\n    while slow != fast {\n        slow = nums[slow]\n        fast = nums[fast]\n    }\n    \n    return slow\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use two pointer variables",
            "time": "O(n)",
            "timeExplanation": "Each phase traverses at most n elements"
          },
          "explanation": "Why does this work? Consider the array as a graph where index i has an edge to index nums[i].\n\nSince values are in [1,n] and we start at index 0, we never revisit 0. But since there's a duplicate value, some index is pointed to by two different indices - that's our cycle entry.\n\nThe math for why phase 2 works: if slow traveled distance d to the meeting point, and cycle length is C, then fast traveled 2d. The meeting point is d mod C steps into the cycle. The entry point is exactly d mod C steps back, which equals the distance from start.",
          "id": "550e8400-e29b-41d4-a716-446655440116",
          "intuition": "Treat the array as a linked list where nums[i] points to index nums[i]. Since there's a duplicate, two indices point to the same location, creating a cycle.\n\nThe cycle's entry point is the duplicate value.",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Graph: 0→1→3→2→4→2 (cycle at 2). Duplicate is 2",
              "id": "550e8400-e29b-41d4-a716-446655440216",
              "input": "[1,3,4,2,2]"
            },
            {
              "expectedOutput": "3",
              "explanation": "Graph: 0→3→4→2→3 (cycle at 3). Duplicate is 3",
              "id": "550e8400-e29b-41d4-a716-446655440217",
              "input": "[3,1,3,4,2]"
            }
          ]
        },
        {
          "approach": "1. Set lo = 1, hi = n\n2. While lo < hi:\n   - mid = (lo + hi) / 2\n   - Count elements ≤ mid\n   - If count > mid: hi = mid (duplicate in lower half)\n   - Else: lo = mid + 1\n3. Return lo",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    var lo = 1\n    var hi = nums.count - 1\n    \n    while lo < hi {\n        let mid = lo + (hi - lo) / 2\n        let count = nums.filter { $0 <= mid }.count\n        \n        if count > mid {\n            hi = mid  // Duplicate in lower half\n        } else {\n            lo = mid + 1  // Duplicate in upper half\n        }\n    }\n    \n    return lo\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only use a few variables",
            "time": "O(n log n)",
            "timeExplanation": "O(log n) binary search iterations, each counting O(n) elements"
          },
          "explanation": "The pigeonhole principle: if we have more than mid numbers in [1,mid], at least one must be duplicated.\n\nThis doesn't find which number is duplicated directly - it narrows down the range until lo == hi, which is the duplicate.\n\nExample: [1,3,4,2,2]. Count ≤ 2 is 3 (elements 1,2,2). Since 3 > 2, duplicate is in [1,2]. Count ≤ 1 is 1. So duplicate is 2.",
          "id": "550e8400-e29b-41d4-a716-446655440117",
          "intuition": "Binary search on the answer space [1,n]. For a candidate mid, count numbers ≤ mid. If count > mid, duplicate is in [1,mid].",
          "name": "Binary Search on Value Range",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Graph: 0→1→3→2→4→2 (cycle at 2). Duplicate is 2",
              "id": "fd27b3e5-0357-434a-9355-315ceac2264f",
              "input": "[1,3,4,2,2]"
            },
            {
              "expectedOutput": "3",
              "explanation": "Graph: 0→3→4→2→3 (cycle at 3). Duplicate is 3",
              "id": "6e592fc3-d3f0-4a1e-9cc1-e6c4951a19db",
              "input": "[3,1,3,4,2]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440009",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "find-the-duplicate-number",
      "relatedProblems": [
        "linked-list-cycle-ii",
        "missing-number"
      ],
      "summary": "Find the duplicate in array of n+1 integers where each is in [1,n]. Use Floyd's cycle detection - treat values as pointers to create a linked list with a cycle at the duplicate."
    },
    {
      "approaches": [
        {
          "approach": "1. Doubly linked list with dummy head/tail\n2. Hash map: key → node reference\n3. get(key): if exists, move to head, return value\n4. put(key, value):\n   - If exists: update value, move to head\n   - If new: create node, add to head, add to map\n   - If over capacity: remove tail node, remove from map",
          "code": "class LRUCache {\n    private class Node {\n        let key: Int\n        var value: Int\n        var prev: Node?\n        var next: Node?\n        \n        init(_ key: Int, _ value: Int) {\n            self.key = key\n            self.value = value\n        }\n    }\n    \n    private let capacity: Int\n    private var cache: [Int: Node] = [:]\n    private let head = Node(0, 0)  // Dummy head\n    private let tail = Node(0, 0)  // Dummy tail\n    \n    init(_ capacity: Int) {\n        self.capacity = capacity\n        head.next = tail\n        tail.prev = head\n    }\n    \n    func get(_ key: Int) -> Int {\n        guard let node = cache[key] else { return -1 }\n        moveToHead(node)\n        return node.value\n    }\n    \n    func put(_ key: Int, _ value: Int) {\n        if let node = cache[key] {\n            node.value = value\n            moveToHead(node)\n        } else {\n            let node = Node(key, value)\n            cache[key] = node\n            addToHead(node)\n            \n            if cache.count > capacity {\n                let removed = removeTail()\n                cache.removeValue(forKey: removed.key)\n            }\n        }\n    }\n    \n    private func addToHead(_ node: Node) {\n        node.prev = head\n        node.next = head.next\n        head.next?.prev = node\n        head.next = node\n    }\n    \n    private func removeNode(_ node: Node) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n    }\n    \n    private func moveToHead(_ node: Node) {\n        removeNode(node)\n        addToHead(node)\n    }\n    \n    private func removeTail() -> Node {\n        let node = tail.prev!\n        removeNode(node)\n        return node\n    }\n}",
          "complexity": {
            "space": "O(capacity)",
            "spaceExplanation": "Store at most 'capacity' nodes in map and list",
            "time": "O(1)",
            "timeExplanation": "Both get and put are O(1) - hash lookup and list operations are constant time"
          },
          "explanation": "The doubly linked list maintains order by recency. The hash map provides O(1) access to any node.\n\nWhy doubly linked? We need to remove a node from the middle in O(1). With a doubly linked list, given a node reference, we can update prev.next and next.prev directly.\n\nDummy head and tail simplify edge cases (empty list, single element). The actual nodes are always between these dummies.",
          "id": "550e8400-e29b-41d4-a716-446655440118",
          "intuition": "We need two operations in O(1):\n1. Find a key → hash map\n2. Track/update recency → doubly linked list\n\nMost recently used at head, least recently used at tail. On access, move node to head.",
          "name": "Hash Map + Doubly Linked List",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[null,null,null,1,null,-1,null,-1,3,4]",
              "explanation": "After put(3,3), cache is [1,3]. get(2) returns -1 (evicted). After put(4,4), cache is [3,4].",
              "id": "550e8400-e29b-41d4-a716-446655440218",
              "input": "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440010",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "lru-cache",
      "relatedProblems": [
        "lfu-cache",
        "design-in-memory-file-system"
      ],
      "summary": "Implement an LRU cache with O(1) get and put. Combine a hash map (O(1) lookup) with a doubly linked list (O(1) insertion/deletion) to track recency."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return nil.\n2. Swap root.left and root.right.\n3. Recursively invert the left subtree.\n4. Recursively invert the right subtree.\n5. Return root.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    let temp = root.left\n    root.left = root.right\n    root.right = temp\n    _ = invertTree(root.left)\n    _ = invertTree(root.right)\n    return root\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height h",
            "time": "O(n)",
            "timeExplanation": "Every node is visited exactly once"
          },
          "explanation": "Each node is visited once. Swapping children at each node creates the mirror image. The recursion unwinds after reaching leaves.",
          "id": "0d68f729-008b-4c44-a14b-5db7877db5b5",
          "intuition": "If you swap a node's left and right children, and then do the same for its children, the entire tree becomes its mirror image.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap.",
              "id": "0f14dc66-108b-4b35-b924-5eff2f49797c",
              "input": "root = [4,2,7,1,3,6,9]"
            },
            {
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root.",
              "id": "67919ef7-73d2-44f6-bf81-ae8463aacbbb",
              "input": "root = [2,1,3]"
            }
          ]
        },
        {
          "approach": "1. If root is nil, return nil.\n2. Push root to a queue.\n3. While queue not empty: pop a node, swap its children, push non-nil children.\n4. Return root.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    var queue: [TreeNode] = [root]\n    var index = 0\n    while index < queue.count {\n        let node = queue[index]\n        index += 1\n        let temp = node.left\n        node.left = node.right\n        node.right = temp\n        if let left = node.left { queue.append(left) }\n        if let right = node.right { queue.append(right) }\n    }\n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue can hold up to a full level of nodes",
            "time": "O(n)",
            "timeExplanation": "Each node is processed once"
          },
          "explanation": "The queue visits nodes level by level. Swapping children during the visit yields the same mirror as the recursive solution.",
          "id": "f3ccd674-5539-4a80-a251-444b32df5cb2",
          "intuition": "A level-order traversal lets us swap children for every node without recursion.",
          "name": "Iterative BFS",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap.",
              "id": "767e9de1-fc09-4605-a387-6d912b18d09e",
              "input": "root = [4,2,7,1,3,6,9]"
            },
            {
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root.",
              "id": "3c6e8be9-43d9-414c-a712-a69d865ef0c9",
              "input": "root = [2,1,3]"
            }
          ]
        }
      ],
      "id": "113bd68d-ec6b-40ce-b8d5-e276ed1a6f55",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "invert-binary-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "same-tree"
      ],
      "summary": "Invert a binary tree by swapping every node's left and right child. The simplest way is a DFS that swaps then recurses."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return 0.\n2. Recursively compute leftDepth and rightDepth.\n3. Return 1 + max(leftDepth, rightDepth).",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height h",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once"
          },
          "explanation": "The recursion bottoms out at empty subtrees (depth 0). Each call returns the depth of that subtree.",
          "id": "050c5512-9554-480c-99ec-4fb2c0986636",
          "intuition": "The depth of a node is 1 plus the maximum depth of its children.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3 → 20 → 15 (or 7).",
              "id": "d8ea7529-25a9-46df-a1d5-ad66d281758e",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1 → 2.",
              "id": "b57d4658-6b70-4a70-a4c2-e6cc4d34e311",
              "input": "root = [1,null,2]"
            }
          ]
        },
        {
          "approach": "1. If root is nil, return 0.\n2. Push root to a queue.\n3. For each level, process all nodes in the queue, enqueue their children.\n4. Count levels.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    var queue: [TreeNode] = [root]\n    var depth = 0\n    var index = 0\n    while index < queue.count {\n        let levelCount = queue.count - index\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        depth += 1\n    }\n    return depth\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue stores up to one full level",
            "time": "O(n)",
            "timeExplanation": "Each node enqueued and dequeued once"
          },
          "explanation": "BFS processes nodes level by level, so the number of levels processed equals the maximum depth.",
          "id": "4a6e14d7-b155-4d01-86fd-0e782f6bb436",
          "intuition": "Each BFS layer corresponds to one depth level.",
          "name": "BFS Level Order",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3 → 20 → 15 (or 7).",
              "id": "dee370ca-5d8a-4bcc-a79e-b26b97d6a914",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1 → 2.",
              "id": "3b21e6da-d0f6-4fc0-8c1a-15c60d6c92bc",
              "input": "root = [1,null,2]"
            }
          ]
        }
      ],
      "id": "d60edf13-e40b-4234-9de4-80e19e97ae9d",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "maximum-depth-of-binary-tree",
      "relatedProblems": [
        "invert-binary-tree",
        "minimum-depth-of-binary-tree"
      ],
      "summary": "Maximum depth is the length of the longest root-to-leaf path. Compute it via DFS recursion or BFS level counting."
    },
    {
      "approaches": [
        {
          "approach": "1. If both nodes are nil, return true.\n2. If only one is nil, return false.\n3. If values differ, return false.\n4. Recursively compare left and right children.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node is visited at most once"
          },
          "explanation": "The recursion enforces structural equality and value equality at every position.",
          "id": "67ad78db-e53d-41e1-bfb6-fc5d00c078c7",
          "intuition": "Both trees are equal if the current values match and both left subtrees and right subtrees are equal.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same structure and values.",
              "id": "122dfbc8-09a4-45e0-a5f3-409788a05360",
              "input": "p = [1,2,3], q = [1,2,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child).",
              "id": "d32e933d-3be7-4018-887f-a9570607ba37",
              "input": "p = [1,2], q = [1,null,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes.",
              "id": "2dbb90c1-24c7-4b23-bd27-a3af1e8dd072",
              "input": "p = [1,2,1], q = [1,1,2]"
            }
          ]
        },
        {
          "approach": "1. Push (p, q) onto a stack.\n2. While stack not empty: pop, compare nodes similarly to recursion.\n3. Push child pairs.\n4. If any mismatch, return false; otherwise true.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    var stack: [(TreeNode?, TreeNode?)] = [(p, q)]\n    while let (left, right) = stack.popLast() {\n        if left == nil && right == nil { continue }\n        guard let l = left, let r = right else { return false }\n        if l.val != r.val { return false }\n        stack.append((l.left, r.left))\n        stack.append((l.right, r.right))\n    }\n    return true\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds nodes along a path",
            "time": "O(n)",
            "timeExplanation": "Each node pair processed once"
          },
          "explanation": "This mirrors DFS recursion but uses an explicit stack to avoid call stack usage.",
          "id": "9901b309-c7f0-4a01-9f62-cb632648a7d1",
          "intuition": "Use a stack to compare nodes in lockstep without recursion.",
          "name": "Iterative Stack",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same structure and values.",
              "id": "cdce0610-8b45-4976-8230-234089e4baa2",
              "input": "p = [1,2,3], q = [1,2,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child).",
              "id": "e0937fa7-f39e-4d9f-a516-76f2d6f8705c",
              "input": "p = [1,2], q = [1,null,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes.",
              "id": "892beb28-be41-45c2-bc40-ad9a8b6b5e02",
              "input": "p = [1,2,1], q = [1,1,2]"
            }
          ]
        }
      ],
      "id": "e0d239e6-12c6-431f-881c-d362768f9b11",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "same-tree",
      "relatedProblems": [
        "subtree-of-another-tree",
        "same-tree"
      ],
      "summary": "Two trees are the same if their structures match and all corresponding node values are equal. Compare them node by node."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return false (subRoot is non-nil).\n2. If isSameTree(root, subRoot) return true.\n3. Otherwise, recurse on root.left and root.right.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    guard let root = root else { return false }\n    if isSameTree(root, subRoot) { return true }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}\n\nprivate func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack height of root tree",
            "time": "O(n * m)",
            "timeExplanation": "In the worst case, compare subRoot at every node"
          },
          "explanation": "We reuse a same-tree check. The first match we find proves subRoot is a subtree.",
          "id": "3b0434af-e80d-47ad-985c-7923e0154acd",
          "intuition": "If two trees are identical, then subRoot matches the subtree at that node. Try this at every node in root.",
          "name": "DFS + Same Tree",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot.",
              "id": "20a2a01b-f130-4d94-b320-438eca23093b",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality.",
              "id": "e9aba558-e4fa-4d94-8296-6cbd49810888",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]"
            }
          ]
        },
        {
          "approach": "1. Serialize root with preorder + null markers.\n2. Serialize subRoot similarly.\n3. Check if subRoot serialization is contained in root serialization.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    let rootStr = serialize(root)\n    let subStr = serialize(subRoot)\n    return rootStr.contains(subStr)\n}\n\nprivate func serialize(_ node: TreeNode?) -> String {\n    guard let node = node else { return \"#\" }\n    return \"(\\(node.val)),\\(serialize(node.left)),\\(serialize(node.right))\"\n}",
          "complexity": {
            "space": "O(n + m)",
            "spaceExplanation": "Serialized strings store all nodes and nulls",
            "time": "O(n + m)",
            "timeExplanation": "Serialize both trees once"
          },
          "explanation": "Null markers prevent false matches where different structures have the same value sequence.",
          "id": "2c55fff8-4140-49a2-b3c2-053861a7769e",
          "intuition": "Serialize both trees with null markers; subRoot is a subtree if its serialization is a substring of root's serialization.",
          "name": "Serialization",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot.",
              "id": "2f684a5a-5464-487d-8ba1-3336934d1556",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality.",
              "id": "b0965db6-21f3-405c-a06f-7a1eb4a0f0fd",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]"
            }
          ]
        }
      ],
      "id": "39b75eb0-0ce6-46cd-a8d0-18e7f882b767",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "subtree-of-another-tree",
      "relatedProblems": [
        "same-tree",
        "find-duplicate-subtrees"
      ],
      "summary": "Check every node in the main tree as a potential root and compare subtrees for equality."
    },
    {
      "approaches": [
        {
          "approach": "1. Start at root.\n2. If both p and q are smaller, move left.\n3. If both larger, move right.\n4. Otherwise, current node is the LCA.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    var node = root\n    guard let p = p, let q = q else { return nil }\n    while let current = node {\n        if p.val < current.val && q.val < current.val {\n            node = current.left\n        } else if p.val > current.val && q.val > current.val {\n            node = current.right\n        } else {\n            return current\n        }\n    }\n    return nil\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Iterative, constant extra space",
            "time": "O(h)",
            "timeExplanation": "Walks down one path of height h"
          },
          "explanation": "The LCA is the node where the paths to p and q diverge (or where one equals the current node).",
          "id": "153d1e3d-75a6-4b8e-86bc-81ea9dbc1dba",
          "intuition": "In a BST, all left values are smaller and all right values are larger. The first split point is the LCA.",
          "name": "Iterative BST Walk",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "p and q split at 6, so 6 is the LCA.",
              "id": "38f1a9a5-13a3-4905-a7d9-bd93b2027500",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8"
            },
            {
              "expectedOutput": "2",
              "explanation": "p is an ancestor of q, so LCA is 2.",
              "id": "812c7249-8f40-4310-978c-f8f10b0a8f6f",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4"
            }
          ]
        },
        {
          "approach": "1. If both values are less than root, recurse left.\n2. If both greater, recurse right.\n3. Otherwise, root is the LCA.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root, let p = p, let q = q else { return nil }\n    if p.val < root.val && q.val < root.val {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if p.val > root.val && q.val > root.val {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(h)",
            "timeExplanation": "Traverses one root-to-leaf path"
          },
          "explanation": "Same logic as the iterative approach, but expressed recursively.",
          "id": "25e41dd6-c040-42ec-83e3-965baa348c08",
          "intuition": "The BST property lets us eliminate half the tree at each step using recursion.",
          "name": "Recursive BST",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Root is the ancestor of both nodes.",
              "id": "56d579d8-24d9-4502-8d47-d9c3bf6a0301",
              "input": "root = [2,1], p = 2, q = 1"
            }
          ]
        }
      ],
      "id": "32841a93-64e4-40c2-8f8a-bee6d4c5f666",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "lowest-common-ancestor-of-a-binary-search-tree",
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-tree",
        "validate-binary-search-tree"
      ],
      "summary": "Use the BST ordering: if both targets are less than the current node, go left; if greater, go right; otherwise current is the LCA."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return [].\n2. Initialize a queue with root.\n3. While queue not empty: record current queue size, pop that many nodes, collect values, and enqueue children.\n4. Append each level list to the result.",
          "code": "func levelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var index = 0\n\n    while index < queue.count {\n        let levelCount = queue.count - index\n        var level: [Int] = []\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(level)\n    }\n\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue can hold up to one full level of nodes",
            "time": "O(n)",
            "timeExplanation": "Each node is enqueued and dequeued exactly once"
          },
          "explanation": "The queue holds nodes in the next level to process. Capturing the queue size before processing ensures each iteration only handles one level at a time.",
          "id": "25312294-5031-458e-90c6-4c8cab60dacb",
          "intuition": "Breadth-first search naturally visits nodes in level order. If we process nodes in fixed-size batches per level, we can build the result list of lists.",
          "name": "BFS by Level",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[3],[9,20],[15,7]]",
              "explanation": "Level 0: [3], level 1: [9,20], level 2: [15,7].",
              "id": "9f2e77b8-7e7f-4d6b-a5d4-7655d72ac176",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[[1]]",
              "explanation": "Single node forms one level.",
              "id": "4151eab9-a595-48a9-8e25-859a8941a9c3",
              "input": "root = [1]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Empty tree produces empty result.",
              "id": "21a31bc5-894f-494f-85d1-1d21f0008299",
              "input": "root = []"
            }
          ]
        }
      ],
      "id": "bf8d33be-a2fd-469f-9a92-9dee92c4d0fe",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "binary-tree-level-order-traversal",
      "relatedProblems": [
        "binary-tree-level-order-traversal-ii",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "Traverse the tree level by level using a queue, collecting values for each level as you go."
    },
    {
      "approaches": [
        {
          "approach": "1. Recurse with optional min and max bounds.\n2. If node.val <= min or node.val >= max, return false.\n3. Recurse left with max = node.val, right with min = node.val.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    func dfs(_ node: TreeNode?, _ minVal: Int?, _ maxVal: Int?) -> Bool {\n        guard let node = node else { return true }\n        if let minVal = minVal, node.val <= minVal { return false }\n        if let maxVal = maxVal, node.val >= maxVal { return false }\n        return dfs(node.left, minVal, node.val) && dfs(node.right, node.val, maxVal)\n    }\n    return dfs(root, nil, nil)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once"
          },
          "explanation": "Bounds carry the valid range down the tree, enforcing the BST rule at every node, not just locally.",
          "id": "89f02580-9ff3-4722-84a5-5c0266733222",
          "intuition": "Each node must be greater than all values in its left ancestors and less than all values in its right ancestors.",
          "name": "DFS with Bounds",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "All nodes satisfy BST ordering.",
              "id": "c2954d68-4c67-4523-88eb-70976739d27b",
              "input": "root = [2,1,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Right subtree contains 3 which is less than 5.",
              "id": "dd924f21-6113-4c2b-8b02-b135313db87f",
              "input": "root = [5,1,4,null,null,3,6]"
            }
          ]
        },
        {
          "approach": "1. Traverse inorder while tracking previous value.\n2. If current value <= previous, return false.\n3. Otherwise continue.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    var prev: Int? = nil\n    var stack: [TreeNode] = []\n    var node = root\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        if let prev = prev, current.val <= prev { return false }\n        prev = current.val\n        node = current.right\n    }\n    return true\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most one root-to-leaf path",
            "time": "O(n)",
            "timeExplanation": "Each node is pushed/popped once"
          },
          "explanation": "A single pass through the inorder sequence is enough to verify strict ordering.",
          "id": "b33d33bc-0d11-40c8-8325-73ad89c9a61a",
          "intuition": "Inorder traversal of a BST yields a strictly increasing sequence.",
          "name": "Inorder Traversal",
          "order": 2,
          "testCases": []
        }
      ],
      "id": "0353cc5c-702e-4d1a-a450-1ccb23ae4ff3",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "validate-binary-search-tree",
      "relatedProblems": [
        "validate-binary-search-tree",
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "summary": "A BST is valid if every node value lies within allowed bounds and both subtrees are valid. Use DFS with min/max bounds."
    },
    {
      "approaches": [
        {
          "approach": "1. Use a stack to simulate inorder traversal.\n2. Pop nodes and count visits.\n3. When count reaches k, return the node value.",
          "code": "func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n    var stack: [TreeNode] = []\n    var node = root\n    var remaining = k\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        remaining -= 1\n        if remaining == 0 { return current.val }\n        node = current.right\n    }\n    return 0\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most h nodes",
            "time": "O(h + k)",
            "timeExplanation": "Walk down height h, then visit k nodes"
          },
          "explanation": "The stack walks left as far as possible, then processes nodes in ascending order.",
          "id": "a4188ae4-1591-4141-a97d-54be7ab95628",
          "intuition": "Inorder traversal returns values in increasing order, so the kth visited node is the answer.",
          "name": "Iterative Inorder",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Inorder sequence is [1,2,3,4], kth=1.",
              "id": "e1c24e01-a57c-4661-a5bc-5c2f02f2a718",
              "input": "root = [3,1,4,null,2], k = 1"
            },
            {
              "expectedOutput": "3",
              "explanation": "Inorder sequence is [1,2,3,4,5,6], kth=3.",
              "id": "5796f1a9-8de9-4dfc-8d34-dea87d368c27",
              "input": "root = [5,3,6,2,4,null,null,1], k = 3"
            }
          ]
        }
      ],
      "id": "8caca365-f1ea-4ee1-9d57-18b73d6ffa78",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "kth-smallest-element-in-a-bst",
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-search-tree-iterator"
      ],
      "summary": "The inorder traversal of a BST is sorted. Walk inorder and stop at the kth value."
    },
    {
      "approaches": [
        {
          "approach": "1. Build a map from inorder value to index.\n2. Use a preorder index pointer.\n3. Recurse on inorder ranges to construct left and right subtrees.",
          "code": "func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n    var indexMap: [Int: Int] = [:]\n    for (i, val) in inorder.enumerated() { indexMap[val] = i }\n    var preIndex = 0\n\n    func helper(_ left: Int, _ right: Int) -> TreeNode? {\n        if left > right { return nil }\n        let rootVal = preorder[preIndex]\n        preIndex += 1\n        let root = TreeNode(rootVal)\n        let mid = indexMap[rootVal] ?? 0\n        root.left = helper(left, mid - 1)\n        root.right = helper(mid + 1, right)\n        return root\n    }\n\n    return helper(0, inorder.count - 1)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Index map plus recursion stack",
            "time": "O(n)",
            "timeExplanation": "Each node is created once"
          },
          "explanation": "The map gives O(1) splits. The preorder index advances as we create nodes, preserving root-left-right ordering.",
          "id": "e371a4eb-53b2-4d10-96d8-2c3844972ffa",
          "intuition": "The first preorder value is always the root. In inorder, everything left of the root belongs to the left subtree, and everything right belongs to the right subtree.",
          "name": "Recursive with Index Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3,9,20,null,null,15,7]",
              "explanation": "Root 3 splits inorder into [9] and [15,20,7].",
              "id": "9769abcb-30d8-4e89-b038-dfa6aa7917c4",
              "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]"
            },
            {
              "expectedOutput": "[-1]",
              "explanation": "Single node tree.",
              "id": "7b95b045-a63f-444a-8fe5-3117532115f5",
              "input": "preorder = [-1], inorder = [-1]"
            }
          ]
        }
      ],
      "id": "0f6835b4-c6b9-4e33-9ea7-7652f64e3434",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "relatedProblems": [
        "construct-binary-tree-from-inorder-and-postorder-traversal",
        "serialize-and-deserialize-binary-tree"
      ],
      "summary": "Preorder gives the root, inorder splits left and right subtrees. Rebuild recursively using index boundaries."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS returns max gain from a node to its parent.\n2. At each node, compute leftGain and rightGain (ignore negatives).\n3. Update global answer with leftGain + node.val + rightGain.\n4. Return node.val + max(leftGain, rightGain).",
          "code": "func maxPathSum(_ root: TreeNode?) -> Int {\n    var best = Int.min\n\n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = max(0, dfs(node.left))\n        let right = max(0, dfs(node.right))\n        best = max(best, left + node.val + right)\n        return node.val + max(left, right)\n    }\n\n    _ = dfs(root)\n    return best\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once"
          },
          "explanation": "This separates the path-to-parent (one side only) from the best path through a node (both sides). The global maximum is updated at every node.",
          "id": "d9d42e75-cc17-4b5e-bfd9-711ee17cc498",
          "intuition": "For each node, the best path going up can include only one child. But the best path overall might use both children plus the node.",
          "name": "DFS with Max Gain",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "Best path is 2 -> 1 -> 3 with sum 6.",
              "id": "01213095-ad3e-45dc-9ef2-a463c884ef88",
              "input": "root = [1,2,3]"
            },
            {
              "expectedOutput": "42",
              "explanation": "Best path is 15 -> 20 -> 7 with sum 42.",
              "id": "bc57200e-8fb6-44ce-a318-49381be2bb4c",
              "input": "root = [-10,9,20,null,null,15,7]"
            }
          ]
        }
      ],
      "id": "cd5da6fc-1d62-4a2a-860f-36786c25a511",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "binary-tree-maximum-path-sum",
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "binary-tree-maximum-path-sum-ii"
      ],
      "summary": "Compute the maximum path sum by tracking the best gain from each node and updating a global maximum for paths that pass through the node."
    },
    {
      "approaches": [
        {
          "approach": "1. Insert: create missing children for each character, then mark end.\n2. Search: walk characters and ensure end marker.\n3. StartsWith: walk characters and ensure path exists.",
          "code": "class Trie {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func insert(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        guard let node = walk(word) else { return false }\n        return node.isEnd\n    }\n\n    func startsWith(_ prefix: String) -> Bool {\n        return walk(prefix) != nil\n    }\n\n    private func walk(_ word: String) -> Node? {\n        var node: Node? = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            node = node?.children[index]\n            if node == nil { return nil }\n        }\n        return node\n    }\n}",
          "complexity": {
            "space": "O(total chars)",
            "spaceExplanation": "Trie stores one node per character inserted",
            "time": "O(L)",
            "timeExplanation": "Each operation scans L characters"
          },
          "explanation": "All operations traverse at most L nodes where L is the word length.",
          "id": "d23ec3a2-765a-4364-9cac-9fe8c9c8b47f",
          "intuition": "Each node keeps 26 children for a-z. Walking characters from the root visits the prefix path.",
          "name": "Array-Backed Trie",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[null,null,true,false,true,null,true]",
              "explanation": "search(\"app\") is false before inserting \"app\" and true afterward.",
              "id": "d5b74d5e-0be1-4a54-9b51-b831e8f9a06b",
              "input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]"
            }
          ]
        }
      ],
      "id": "5631cebc-4b66-43d6-b7a3-e5cceade37a0",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "implement-trie-prefix-tree",
      "relatedProblems": [
        "design-add-and-search-words-data-structure",
        "word-search-ii"
      ],
      "summary": "Store characters in a trie so insert/search/startsWith all run in time proportional to the word length."
    },
    {
      "approaches": [
        {
          "approach": "1. addWord inserts into a trie.\n2. search uses DFS: if char is dot, try all children; otherwise follow the matching child.\n3. If end of word, require node.isEnd.",
          "code": "class WordDictionary {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func addWord(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        let chars = Array(word)\n        func dfs(_ node: Node?, _ i: Int) -> Bool {\n            guard let node = node else { return false }\n            if i == chars.count { return node.isEnd }\n            let c = chars[i]\n            if c == \".\" {\n                for child in node.children {\n                    if dfs(child, i + 1) { return true }\n                }\n                return false\n            }\n            let index = Int(c.asciiValue! - Character(\"a\").asciiValue!)\n            return dfs(node.children[index], i + 1)\n        }\n        return dfs(root, 0)\n    }\n}",
          "complexity": {
            "space": "O(total chars)",
            "spaceExplanation": "Trie stores all inserted characters",
            "time": "O(L) average, O(26^L) worst",
            "timeExplanation": "Wildcards can branch across children in the worst case"
          },
          "explanation": "The trie compresses shared prefixes, and DFS handles the wildcard branching only when needed.",
          "id": "1439dfbb-c19a-451d-a4df-44f0ed92869e",
          "intuition": "A dot can match any child, so search must branch when encountering a dot.",
          "name": "Trie + DFS Wildcard",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[null,null,null,null,false,true,true,true]",
              "explanation": "Wildcards match any letter (\".ad\" matches bad/dad/mad).",
              "id": "528c7f9f-bd8d-46d8-8e95-c313e0b4b2e1",
              "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]"
            }
          ]
        }
      ],
      "id": "5c72dc35-6d92-4233-8cab-5483ab374461",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "design-add-and-search-words-data-structure",
      "relatedProblems": [
        "implement-trie-prefix-tree",
        "word-search-ii"
      ],
      "summary": "Use a trie with DFS to support wildcard dots in search while keeping addWord efficient."
    },
    {
      "approaches": [
        {
          "approach": "1. Insert all words into a trie.\n2. For each board cell, DFS while tracking trie nodes.\n3. When a trie node contains a word, add it to results and mark as used.\n4. Mark cells as visited during DFS to avoid reuse.",
          "code": "func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\n    class TrieNode {\n        var children: [TrieNode?] = Array(repeating: nil, count: 26)\n        var word: String? = nil\n    }\n\n    let root = TrieNode()\n    for word in words {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil { node.children[index] = TrieNode() }\n            node = node.children[index]!\n        }\n        node.word = word\n    }\n\n    var board = board\n    let rows = board.count\n    let cols = board.first?.count ?? 0\n    var results: [String] = []\n    let dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    func dfs(_ r: Int, _ c: Int, _ node: TrieNode) {\n        let char = board[r][c]\n        let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n        guard let next = node.children[index] else { return }\n\n        if let word = next.word {\n            results.append(word)\n            next.word = nil\n        }\n\n        board[r][c] = \"#\"\n        for (dr, dc) in dirs {\n            let nr = r + dr\n            let nc = c + dc\n            if nr >= 0, nr < rows, nc >= 0, nc < cols, board[nr][nc] != \"#\" {\n                dfs(nr, nc, next)\n            }\n        }\n        board[r][c] = char\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            dfs(r, c, root)\n        }\n    }\n    return results\n}",
          "complexity": {
            "space": "O(total chars + L)",
            "spaceExplanation": "Trie plus recursion depth up to max word length",
            "time": "O(m * n * 4^L)",
            "timeExplanation": "Worst-case DFS from each cell with pruning by trie"
          },
          "explanation": "The trie avoids checking every word separately, and DFS explores only viable prefixes from each cell.",
          "id": "104fbf07-a53f-4c54-a1d8-f574d1b2edfd",
          "intuition": "A trie lets us prune searches early when a prefix does not exist. DFS explores valid paths on the board.",
          "name": "Trie + DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[\"eat\",\"oath\"]",
              "explanation": "Only \"eat\" and \"oath\" can be formed by adjacent cells.",
              "id": "8134f717-85dc-4975-a0e3-7659b08d15a1",
              "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Cannot reuse the same cell twice to form \"abcb\".",
              "id": "061876ba-28aa-4184-b735-8db3209332ed",
              "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]"
            }
          ]
        }
      ],
      "id": "d90f3c15-1512-4eab-8c4d-7da3267a3264",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "word-search-ii",
      "relatedProblems": [
        "word-search",
        "implement-trie-prefix-tree"
      ],
      "summary": "Build a trie of all words, then DFS the board to find any paths that match trie prefixes."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS from the root with current max value.\n2. If node.val >= max, count it as good.\n3. Update max and recurse on children.",
          "code": "func goodNodes(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?, _ currentMax: Int) -> Int {\n        guard let node = node else { return 0 }\n        let isGood = node.val >= currentMax ? 1 : 0\n        let nextMax = max(currentMax, node.val)\n        return isGood + dfs(node.left, nextMax) + dfs(node.right, nextMax)\n    }\n    guard let root = root else { return 0 }\n    return dfs(root, root.val)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node visited once"
          },
          "explanation": "The max value on the path fully determines whether a node is good.",
          "id": "8c3fe2b2-84c5-446c-8794-99ae762f95e0",
          "intuition": "A node is good if its value is greater than or equal to all values seen so far on the path.",
          "name": "DFS with Path Maximum",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Good nodes are 3,4,5,3 (left grandchild).",
              "id": "e37487e8-c61c-4bdf-ab6c-e62ce931337a",
              "input": "root = [3,1,4,3,null,1,5]"
            },
            {
              "expectedOutput": "3",
              "explanation": "All except node 2 are good.",
              "id": "68ad95d2-659d-4f24-b8f1-eed1d5fa6459",
              "input": "root = [3,3,null,4,2]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Root is always good.",
              "id": "954e0167-f0a8-4e0f-9a59-d47c51cd61fc",
              "input": "root = [1]"
            }
          ]
        }
      ],
      "id": "089040a5-891d-4aa8-8015-eec25ac45f8e",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "count-good-nodes-in-binary-tree",
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "same-tree"
      ],
      "summary": "Track the maximum value along the path from the root to each node; a node is good if it is at least that maximum."
    },
    {
      "approaches": [
        {
          "approach": "1. Serialize by DFS preorder, output value or \"#\" for nil.\n2. Deserialize by reading tokens in order and rebuilding nodes recursively.",
          "code": "class Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var result: [String] = []\n        func dfs(_ node: TreeNode?) {\n            guard let node = node else {\n                result.append(\"#\")\n                return\n            }\n            result.append(String(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        }\n        dfs(root)\n        return result.joined(separator: \",\")\n    }\n\n    func deserialize(_ data: String) -> TreeNode? {\n        let tokens = data.split(separator: \",\").map(String.init)\n        var index = 0\n\n        func dfs() -> TreeNode? {\n            if index >= tokens.count { return nil }\n            let token = tokens[index]\n            index += 1\n            if token == \"#\" { return nil }\n            let node = TreeNode(Int(token) ?? 0)\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        }\n\n        return dfs()\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Tokens plus recursion stack",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once in both serialize and deserialize"
          },
          "explanation": "Null markers make the structure unambiguous, so a single pass over tokens can reconstruct the original tree.",
          "id": "296bba88-9dd2-4f56-bce6-600215ee37fc",
          "intuition": "Preorder with explicit nulls uniquely represents the tree structure.",
          "name": "Preorder with Null Markers",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2,3,null,null,4,5]",
              "explanation": "Serialization and deserialization preserve the same shape and values.",
              "id": "bac9f4b5-62ce-43dd-8019-472f11c5deb1",
              "input": "root = [1,2,3,null,null,4,5]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Empty tree serializes to a null marker and deserializes to nil.",
              "id": "9d538869-272a-4bd4-97b7-e8d55f231969",
              "input": "root = []"
            }
          ]
        }
      ],
      "id": "9dc90726-ad7b-42b7-bbf9-4f34ef32ba8c",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "serialize-and-deserialize-binary-tree",
      "relatedProblems": [
        "serialize-and-deserialize-bst",
        "construct-binary-tree-from-preorder-and-inorder-traversal"
      ],
      "summary": "Use preorder traversal with null markers to serialize, then rebuild the tree by consuming the token list in order."
    },
    {
      "approaches": [
        {
          "approach": "1. Create an empty dictionary valueToIndex.\n2. For each number in nums:\n   - Let complement = target - num.\n   - If complement exists in the dictionary, return [indexOfComplement, currentIndex].\n   - Otherwise store num -> currentIndex.\n3. If no pair found, return an empty array (not expected per constraints).",
          "code": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    var valueToIndex: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        let complement = target - num\n        if let j = valueToIndex[complement] {\n            return [j, i]\n        }\n        valueToIndex[num] = i\n    }\n    return []\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The hash map can store up to n elements.",
            "time": "O(n)",
            "timeExplanation": "Each number is processed once with O(1) hash lookups."
          },
          "explanation": "The key is to decide in one pass whether the current number completes a previously seen pair.\nThis avoids the O(n^2) brute-force check and keeps time linear.",
          "id": "5609529b-e80d-4064-b4df-b5cda6084880",
          "intuition": "As we scan the array, if we already saw a value equal to (target - current), we can return that index immediately.\nStoring value -> index lets us find the complement in O(1) time.",
          "name": "Hash Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,1]",
              "explanation": "2 + 7 = 9, so indices 0 and 1.",
              "id": "3d3717cb-c805-47a5-923f-5819a87a6b52",
              "input": "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput": "[1,2]",
              "explanation": "2 + 4 = 6.",
              "id": "6c706226-e832-445c-8206-154a288fe2d9",
              "input": "nums = [3,2,4], target = 6"
            },
            {
              "expectedOutput": "[0,1]",
              "explanation": "Same value used twice at different indices.",
              "id": "0c8fd92c-84f2-4eb9-84b3-1206d534bc08",
              "input": "nums = [3,3], target = 6"
            }
          ]
        }
      ],
      "id": "b6205791-50c7-4360-819a-607401b4f57a",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "two-sum",
      "relatedProblems": [
        "two-sum-ii-input-array-is-sorted",
        "3sum"
      ],
      "summary": "Find two indices whose values add up to the target by tracking seen numbers in a hash map."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize an empty stack.\n2. For each character:\n   - If it's an opening bracket, push it.\n   - If it's a closing bracket, pop and ensure types match.\n3. The string is valid only if the stack is empty at the end.",
          "code": "func isValid(_ s: String) -> Bool {\n    var stack: [Character] = []\n    for ch in s {\n        switch ch {\n        case \"(\", \"{\", \"[\":\n            stack.append(ch)\n        case \")\":\n            if stack.popLast() != \"(\" { return false }\n        case \"}\":\n            if stack.popLast() != \"{\" { return false }\n        case \"]\":\n            if stack.popLast() != \"[\" { return false }\n        default:\n            break\n        }\n    }\n    return stack.isEmpty\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The stack can hold up to n opening brackets.",
            "time": "O(n)",
            "timeExplanation": "Each character is processed once."
          },
          "explanation": "Any mismatch or premature closing bracket invalidates the string immediately.\nRemaining items in the stack after processing mean unmatched openings.",
          "id": "a36e7d66-0c0d-4795-aa09-af72c4b1f241",
          "intuition": "Every closing bracket must match the most recent unmatched opening bracket.\nA stack naturally models this last-in-first-out requirement.",
          "name": "Stack",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Simple matching pair.",
              "id": "ba1346c7-9119-4061-b157-8f689e073a07",
              "input": "s = \"()\""
            },
            {
              "expectedOutput": "true",
              "explanation": "All bracket types match in order.",
              "id": "809050df-90a2-4163-b33d-7ae30b99c763",
              "input": "s = \"()[]{}\""
            },
            {
              "expectedOutput": "false",
              "explanation": "Mismatched bracket types.",
              "id": "236a46f7-4902-4e31-a0fe-37019eb89f6f",
              "input": "s = \"(]\""
            }
          ]
        }
      ],
      "id": "4aacfe82-e270-4dce-9d65-712c0250a335",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "valid-parentheses",
      "relatedProblems": [
        "minimum-remove-to-make-valid-parentheses",
        "generate-parentheses"
      ],
      "summary": "Use a stack to match opening and closing brackets in the correct order."
    },
    {
      "approaches": [
        {
          "approach": "1. Create an empty set.\n2. For each number:\n   - If it is in the set, return true.\n   - Otherwise insert it.\n3. Return false if no duplicates are found.",
          "code": "func containsDuplicate(_ nums: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) { return true }\n        seen.insert(num)\n    }\n    return false\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The set can store all unique elements.",
            "time": "O(n)",
            "timeExplanation": "Single pass with O(1) set checks."
          },
          "explanation": "Sets provide O(1) average lookup/insert, making this linear time.",
          "id": "6966b214-f4ce-4778-886f-94a0b3f47720",
          "intuition": "If any number appears twice, it will already exist in the set when we see it again.",
          "name": "Hash Set",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "1 appears twice.",
              "id": "fb1e2b00-0d16-47e1-853d-2eaefef9fa8a",
              "input": "nums = [1,2,3,1]"
            },
            {
              "expectedOutput": "false",
              "explanation": "All elements are unique.",
              "id": "6f11889d-5920-43a0-8b23-d5d19a5d5770",
              "input": "nums = [1,2,3,4]"
            },
            {
              "expectedOutput": "true",
              "explanation": "Multiple duplicates present.",
              "id": "fa7882d8-0b93-4cab-931b-8029e5c5b4cb",
              "input": "nums = [1,1,1,3,3,4,3,2,4,2]"
            }
          ]
        }
      ],
      "id": "23f4748b-97c7-48ee-b352-423fbcbfd2b2",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "contains-duplicate",
      "relatedProblems": [
        "contains-duplicate-ii",
        "contains-duplicate-iii"
      ],
      "summary": "Track seen values in a set; a repeat indicates a duplicate."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize minPrice to a large value and bestProfit = 0.\n2. For each price:\n   - Update minPrice = min(minPrice, price).\n   - Update bestProfit = max(bestProfit, price - minPrice).\n3. Return bestProfit.",
          "code": "func maxProfit(_ prices: [Int]) -> Int {\n    var minPrice = Int.max\n    var best = 0\n    for price in prices {\n        minPrice = min(minPrice, price)\n        best = max(best, price - minPrice)\n    }\n    return best\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only two tracking variables are used.",
            "time": "O(n)",
            "timeExplanation": "Single pass through the prices."
          },
          "explanation": "This ensures the buy happens before the sell because minPrice is computed from earlier elements.",
          "id": "c9cfb94b-b023-477e-9e26-9c69c36ae2c1",
          "intuition": "The best profit ending today is today's price minus the minimum price seen before today.",
          "name": "One Pass",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "Buy at 1, sell at 6.",
              "id": "5953fc34-b62c-4575-8b2a-b399f798db13",
              "input": "prices = [7,1,5,3,6,4]"
            },
            {
              "expectedOutput": "0",
              "explanation": "No profitable transaction.",
              "id": "2ad31b7a-6363-4ec5-b36c-a17bb1b55e57",
              "input": "prices = [7,6,4,3,1]"
            }
          ]
        }
      ],
      "id": "22650355-1394-4a7f-8415-15cfe774ea97",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "best-time-to-buy-and-sell-stock",
      "relatedProblems": [
        "best-time-to-buy-and-sell-stock-ii",
        "best-time-to-buy-and-sell-stock-with-cooldown"
      ],
      "summary": "Track the minimum price so far and update the max profit as you scan."
    },
    {
      "approaches": [
        {
          "approach": "1. If lengths differ, return false.\n2. Count each character in s.\n3. Decrement for each character in t; if any count becomes negative, return false.\n4. If all counts are zero, return true.",
          "code": "func isAnagram(_ s: String, _ t: String) -> Bool {\n    if s.count != t.count { return false }\n    var counts: [Character: Int] = [:]\n    for ch in s { counts[ch, default: 0] += 1 }\n    for ch in t {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The map stores counts for distinct characters.",
            "time": "O(n)",
            "timeExplanation": "Each string is scanned once."
          },
          "explanation": "Using a dictionary keeps the solution clean and works for any character set.",
          "id": "aa408334-2951-4317-85bb-dae695cb3ac7",
          "intuition": "Two strings are anagrams if every character appears the same number of times in both.",
          "name": "Frequency Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "All letters match counts.",
              "id": "a82a4a86-78fe-4b64-ae62-2e098816859c",
              "input": "s = \"anagram\", t = \"nagaram\""
            },
            {
              "expectedOutput": "false",
              "explanation": "Different letters.",
              "id": "fce32cc3-1f00-4d32-b058-648e801addaf",
              "input": "s = \"rat\", t = \"car\""
            }
          ]
        }
      ],
      "id": "d9518775-be8b-4eee-a812-7c426fa80106",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "valid-anagram",
      "relatedProblems": [
        "group-anagrams",
        "find-all-anagrams-in-a-string"
      ],
      "summary": "Count characters in the first string and subtract counts using the second."
    },
    {
      "approaches": [
        {
          "approach": "1. Count each character in magazine.\n2. For each character in ransomNote, decrement its count.\n3. If any count goes negative, return false. Otherwise return true.",
          "code": "func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {\n    var counts: [Character: Int] = [:]\n    for ch in magazine { counts[ch, default: 0] += 1 }\n    for ch in ransomNote {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Character counts are bounded by alphabet size.",
            "time": "O(m + n)",
            "timeExplanation": "Scan magazine and ransom note once."
          },
          "explanation": "This is a direct application of a frequency map: availability vs. demand.",
          "id": "8d6b33ea-7830-4e29-a0d6-56d6ea03ab6b",
          "intuition": "Each letter in the ransom note must be supplied by the magazine. If any count is insufficient, it fails.",
          "name": "Frequency Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "Missing letter a.",
              "id": "aa950b65-3fb0-478f-8048-cb5ddc162234",
              "input": "ransomNote = \"a\", magazine = \"b\""
            },
            {
              "expectedOutput": "true",
              "explanation": "Magazine has enough a's.",
              "id": "07eea518-2a35-467d-adaf-87edaf1b9eb2",
              "input": "ransomNote = \"aa\", magazine = \"aab\""
            }
          ]
        }
      ],
      "id": "751df843-f7df-4040-a033-b2fd1cfc0050",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "ransom-note",
      "relatedProblems": [
        "valid-anagram",
        "first-unique-character-in-a-string"
      ],
      "summary": "Count available letters in the magazine and consume them for the ransom note."
    },
    {
      "approaches": [
        {
          "approach": "1. Set left = 0 and right = n - 1.\n2. While left <= right:\n   - mid = (left + right) / 2\n   - If nums[mid] == target, return mid.\n   - If nums[mid] < target, search the right half; else search the left half.\n3. Return -1 if not found.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only constant extra space is used.",
            "time": "O(log n)",
            "timeExplanation": "The search range halves each step."
          },
          "explanation": "Binary search guarantees O(log n) time by halving the range each iteration.",
          "id": "42f5fcff-d6d3-416c-811c-91910896d0c2",
          "intuition": "The array is sorted, so we can eliminate half the search space each step.",
          "name": "Binary Search",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "9 is at index 4.",
              "id": "d4c9f72b-8f48-43d1-971d-2b39cdc33656",
              "input": "nums = [-1,0,3,5,9,12], target = 9"
            },
            {
              "expectedOutput": "-1",
              "explanation": "2 is not in the array.",
              "id": "0fc7cc73-24c8-4531-814c-542ecdb498c2",
              "input": "nums = [-1,0,3,5,9,12], target = 2"
            }
          ]
        }
      ],
      "id": "77394785-c09e-47cc-b524-b42c90507419",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "binary-search",
      "relatedProblems": [
        "search-in-rotated-sorted-array",
        "first-bad-version"
      ],
      "summary": "Use classic binary search to find the target in a sorted array."
    },
    {
      "approaches": [
        {
          "approach": "1. Handle small n (1 or 2) directly.\n2. Iterate from 3 to n, keeping only the last two values.\n3. Return the final value.",
          "code": "func climbStairs(_ n: Int) -> Int {\n    if n <= 2 { return n }\n    var a = 1\n    var b = 2\n    for _ in 3...n {\n        let c = a + b\n        a = b\n        b = c\n    }\n    return b\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only two integers are stored.",
            "time": "O(n)",
            "timeExplanation": "We compute each step once."
          },
          "explanation": "This is a classic DP problem that collapses to a constant-space Fibonacci computation.",
          "id": "718a7245-392c-498d-82a2-cc018254ba43",
          "intuition": "The number of ways to reach step i equals ways(i-1) + ways(i-2).",
          "name": "DP (Fibonacci)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "(1+1), (2).",
              "id": "f9a175ed-00a1-4238-a6cd-94f239da68e7",
              "input": "n = 2"
            },
            {
              "expectedOutput": "3",
              "explanation": "(1+1+1), (1+2), (2+1).",
              "id": "3f2247d4-81b4-488b-9f66-e2db963edaf6",
              "input": "n = 3"
            },
            {
              "expectedOutput": "8",
              "explanation": "Fibonacci growth.",
              "id": "f33c3263-9025-4305-81f6-7e0c92dd5514",
              "input": "n = 5"
            }
          ]
        }
      ],
      "id": "e3586dfa-a556-4688-8b3e-7c988f871267",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "climbing-stairs",
      "relatedProblems": [
        "min-cost-climbing-stairs",
        "house-robber"
      ],
      "summary": "Each step can be reached from the previous two steps; this forms a Fibonacci sequence."
    },
    {
      "approaches": [
        {
          "approach": "1. Convert the string to an array of characters for indexing.\n2. Track last seen index of each character in a dictionary.\n3. Maintain a left pointer for the start of the current window.\n4. Update the best window length as you iterate.",
          "code": "func lengthOfLongestSubstring(_ s: String) -> Int {\n    let chars = Array(s)\n    var lastIndex: [Character: Int] = [:]\n    var left = 0\n    var best = 0\n    for (right, ch) in chars.enumerated() {\n        if let prev = lastIndex[ch], prev >= left {\n            left = prev + 1\n        }\n        lastIndex[ch] = right\n        best = max(best, right - left + 1)\n    }\n    return best\n}",
          "complexity": {
            "space": "O(min(n, k))",
            "spaceExplanation": "Map stores last index per distinct character.",
            "time": "O(n)",
            "timeExplanation": "Each index moves forward at most once."
          },
          "explanation": "The left pointer only moves forward, so each character is processed at most twice.",
          "id": "27c88a35-bf8d-4b65-932f-ef95acdc2481",
          "intuition": "When a repeat appears, move the left boundary just past the previous occurrence.",
          "name": "Sliding Window",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Longest substring is \"abc\".",
              "id": "857fc085-7360-4555-9c7d-d324eb1a4c03",
              "input": "s = \"abcabcbb\""
            },
            {
              "expectedOutput": "1",
              "explanation": "Only one unique character.",
              "id": "d75e0eb2-181f-4052-92f3-16d6d6f774fa",
              "input": "s = \"bbbbb\""
            },
            {
              "expectedOutput": "3",
              "explanation": "Longest substring is \"wke\".",
              "id": "0460080e-0b23-4245-ab89-72bdc20b8121",
              "input": "s = \"pwwkew\""
            }
          ]
        }
      ],
      "id": "5c11fa1e-3d2c-48ba-b657-8147f2306374",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "longest-substring-without-repeating-characters",
      "relatedProblems": [
        "minimum-window-substring",
        "longest-substring-with-at-most-k-distinct-characters"
      ],
      "summary": "Use a moving window and last-seen indices to keep all characters unique."
    },
    {
      "approaches": [
        {
          "approach": "1. For each string, sort its characters to form a key.\n2. Append the string to the bucket for that key.\n3. Return all buckets.",
          "code": "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups: [String: [String]] = [:]\n    for s in strs {\n        let key = String(s.sorted())\n        groups[key, default: []].append(s)\n    }\n    return Array(groups.values)\n}",
          "complexity": {
            "space": "O(n * k)",
            "spaceExplanation": "All strings are stored in grouped buckets.",
            "time": "O(n * k log k)",
            "timeExplanation": "Sorting each of n strings of length k dominates."
          },
          "explanation": "Sorting each word is the dominant cost, but it keeps the implementation simple and reliable.",
          "id": "01f071e5-54c6-44da-86f1-bad42a893aa6",
          "intuition": "Anagrams share the same multiset of letters, so sorting makes identical keys for the group.",
          "name": "Hash by Sorted Key",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
              "explanation": "Strings with the same sorted key are grouped (order may vary).",
              "id": "cf59af36-fcff-4d7c-b446-f32138d0f4e9",
              "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]"
            },
            {
              "expectedOutput": "[[\"\"]]",
              "explanation": "Single empty string forms one group.",
              "id": "ff99e033-fb51-4eb3-972b-18a4a8c5acef",
              "input": "strs = [\"\"]"
            },
            {
              "expectedOutput": "[[\"a\"]]",
              "explanation": "Single string forms one group.",
              "id": "a4399698-b4e5-43f4-99f5-223620ca26be",
              "input": "strs = [\"a\"]"
            }
          ]
        }
      ],
      "id": "8003a7c4-b302-40f5-a143-6e9006052256",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "group-anagrams",
      "relatedProblems": [
        "valid-anagram",
        "find-all-anagrams-in-a-string"
      ],
      "summary": "Group strings by their sorted characters (anagram signature)."
    },
    {
      "approaches": [
        {
          "approach": "1. Count occurrences of each number in a dictionary.\n2. Create buckets where index = frequency.\n3. Iterate buckets from high to low, collecting elements until k are gathered.",
          "code": "func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var counts: [Int: Int] = [:]\n    for num in nums { counts[num, default: 0] += 1 }\n    var buckets = Array(repeating: [Int](), count: nums.count + 1)\n    for (num, count) in counts {\n        buckets[count].append(num)\n    }\n    var result: [Int] = []\n    for freq in stride(from: buckets.count - 1, through: 1, by: -1) {\n        for num in buckets[freq] {\n            result.append(num)\n            if result.count == k { return result }\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Buckets and map store up to n items.",
            "time": "O(n)",
            "timeExplanation": "Counting plus bucket traversal is linear."
          },
          "explanation": "This avoids O(n log n) sorting and stays linear on average.",
          "id": "2e212fcc-957a-4b1d-a01d-2694e9b90bd9",
          "intuition": "If we bucket elements by frequency, we can gather the k most frequent without full sorting.",
          "name": "Bucket Sort",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2]",
              "explanation": "1 appears 3 times, 2 appears 2 times.",
              "id": "25771fef-0ab3-4b28-a731-fa97a89188d5",
              "input": "nums = [1,1,1,2,2,3], k = 2"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "Single element is the answer.",
              "id": "0779a404-ce3f-4756-916f-5d20b5106742",
              "input": "nums = [1], k = 1"
            }
          ]
        }
      ],
      "id": "51f4815d-a558-4057-b255-58209dea4db8",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "top-k-frequent-elements",
      "relatedProblems": [
        "top-k-frequent-words",
        "kth-largest-element-in-an-array"
      ],
      "summary": "Count frequencies and collect elements from high to low frequency buckets."
    },
    {
      "approaches": [
        {
          "approach": "1. Build result where result[i] is the product of all elements before i.\n2. Traverse from right, maintaining a suffix product and multiply into result[i].",
          "code": "func productExceptSelf(_ nums: [Int]) -> [Int] {\n    var result = Array(repeating: 1, count: nums.count)\n    var prefix = 1\n    for i in 0..<nums.count {\n        result[i] = prefix\n        prefix *= nums[i]\n    }\n    var suffix = 1\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        result[i] *= suffix\n        suffix *= nums[i]\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only constant extra space besides the output.",
            "time": "O(n)",
            "timeExplanation": "Two linear passes."
          },
          "explanation": "This keeps O(1) extra space besides the output array and handles zeros correctly.",
          "id": "cad14ea0-646e-49fd-bc22-69e4b5e08203",
          "intuition": "The product for index i is (product of all elements before i) * (product of all elements after i).",
          "name": "Prefix/Suffix",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[24,12,8,6]",
              "explanation": "Products excluding each index.",
              "id": "ea2462d9-4c77-4f66-a78a-0882e8eeed6c",
              "input": "nums = [1,2,3,4]"
            },
            {
              "expectedOutput": "[0,0,9,0,0]",
              "explanation": "Handles zeros correctly.",
              "id": "c2ddebb8-39b4-494d-9b47-e5c6da74e2bc",
              "input": "nums = [-1,1,0,-3,3]"
            }
          ]
        }
      ],
      "id": "ce775cc2-53fd-4963-bb91-9c8f6b5dcb4c",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "product-of-array-except-self",
      "relatedProblems": [
        "maximum-product-subarray",
        "subarray-product-less-than-k"
      ],
      "summary": "Compute prefix products and suffix products to avoid division."
    },
    {
      "approaches": [
        {
          "approach": "1. Keep a dictionary of prefixSum -> count (start with 0 -> 1).\n2. Iterate nums, updating currentSum.\n3. Add counts of (currentSum - k) to the answer.\n4. Increment the count for currentSum.",
          "code": "func subarraySum(_ nums: [Int], _ k: Int) -> Int {\n    var count = 0\n    var sum = 0\n    var freq: [Int: Int] = [0: 1]\n    for num in nums {\n        sum += num\n        if let c = freq[sum - k] { count += c }\n        freq[sum, default: 0] += 1\n    }\n    return count\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Prefix sums stored in the map.",
            "time": "O(n)",
            "timeExplanation": "Single pass with O(1) hash operations."
          },
          "explanation": "This avoids O(n^2) enumeration by using prefix sums and frequencies.",
          "id": "8fdde843-fc09-448d-bf2e-00ec0b0885c5",
          "intuition": "If currentSum - k has been seen before, each occurrence defines a subarray ending here with sum k.",
          "name": "Prefix Sum + Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Subarrays [1,1] at indices (0,1) and (1,2).",
              "id": "36b9d5fd-4a58-46fb-ae4f-6fb5cfb8a641",
              "input": "nums = [1,1,1], k = 2"
            },
            {
              "expectedOutput": "2",
              "explanation": "Subarrays [1,2] and [3].",
              "id": "b9c9fbd2-7155-46a9-8270-792727582b7c",
              "input": "nums = [1,2,3], k = 3"
            }
          ]
        }
      ],
      "id": "09218b74-9f9a-490a-ae70-c1ac4dec5ca8",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "subarray-sum-equals-k",
      "relatedProblems": [
        "minimum-size-subarray-sum",
        "continuous-subarray-sum"
      ],
      "summary": "Count how often each prefix sum appears to find subarrays summing to k."
    },
    {
      "approaches": [
        {
          "approach": "1. Build a frequency array for s1 and for the first window in s2.\n2. Track how many of the 26 counts match.\n3. Slide the window, updating counts and matches.\n4. If all 26 counts match, return true.",
          "code": "func checkInclusion(_ s1: String, _ s2: String) -> Bool {\n    let a = Array(s1)\n    let b = Array(s2)\n    if a.count > b.count { return false }\n\n    var count1 = Array(repeating: 0, count: 26)\n    var count2 = Array(repeating: 0, count: 26)\n\n    for ch in a {\n        let idx = Int(ch.asciiValue! - 97)\n        count1[idx] += 1\n    }\n    for i in 0..<a.count {\n        let idx = Int(b[i].asciiValue! - 97)\n        count2[idx] += 1\n    }\n\n    var matches = 0\n    for i in 0..<26 {\n        if count1[i] == count2[i] { matches += 1 }\n    }\n\n    var left = 0\n    for right in a.count..<b.count {\n        if matches == 26 { return true }\n\n        let rIndex = Int(b[right].asciiValue! - 97)\n        count2[rIndex] += 1\n        if count2[rIndex] == count1[rIndex] { matches += 1 }\n        else if count2[rIndex] == count1[rIndex] + 1 { matches -= 1 }\n\n        let lIndex = Int(b[left].asciiValue! - 97)\n        count2[lIndex] -= 1\n        if count2[lIndex] == count1[lIndex] { matches += 1 }\n        else if count2[lIndex] == count1[lIndex] - 1 { matches -= 1 }\n\n        left += 1\n    }\n\n    return matches == 26\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Two fixed-size arrays of length 26.",
            "time": "O(n)",
            "timeExplanation": "Each index is processed once in the sliding window."
          },
          "explanation": "The matching-counts trick avoids comparing full arrays on each step.",
          "id": "82f82071-c8e4-4992-8de8-e36f7d88d1d8",
          "intuition": "Any permutation of s1 has the same character counts, so we just need a window in s2 with matching counts.",
          "name": "Sliding Window",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Substring \"ba\" is a permutation of \"ab\".",
              "id": "2708a68f-d53b-49fe-9227-b4884fd084ce",
              "input": "s1 = \"ab\", s2 = \"eidbaooo\""
            },
            {
              "expectedOutput": "false",
              "explanation": "No permutation appears in s2.",
              "id": "7e0e6c56-3a13-4d0c-a138-83d2f21fe73d",
              "input": "s1 = \"ab\", s2 = \"eidboaoo\""
            }
          ]
        }
      ],
      "id": "f94dfe99-f818-417f-b555-81d2d78b2212",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "permutation-in-string",
      "relatedProblems": [
        "find-all-anagrams-in-a-string",
        "check-if-a-string-contains-all-binary-codes-of-size-k"
      ],
      "summary": "Use a fixed-size sliding window and compare character counts to detect a permutation."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort the array.\n2. For each index i, use two pointers (l, r) to find pairs where nums[i] + nums[l] + nums[r] == 0.\n3. Skip duplicate values for i, l, and r.",
          "code": "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let nums = nums.sorted()\n    var result: [[Int]] = []\n    if nums.count < 3 { return result }\n\n    for i in 0..<(nums.count - 2) {\n        if i > 0 && nums[i] == nums[i - 1] { continue }\n        var left = i + 1\n        var right = nums.count - 1\n        while left < right {\n            let sum = nums[i] + nums[left] + nums[right]\n            if sum == 0 {\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right && nums[left] == nums[left - 1] { left += 1 }\n                while left < right && nums[right] == nums[right + 1] { right -= 1 }\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Sorting is in-place; extra space is constant (excluding output).",
            "time": "O(n^2)",
            "timeExplanation": "For each i, two pointers scan the rest of the array."
          },
          "explanation": "Sorting enables a linear scan for each fixed i, resulting in O(n^2) time.",
          "id": "fa457d53-4a83-48c1-970e-eaf8ac79fa61",
          "intuition": "Sorting allows us to skip duplicates and adjust pointers based on the sum.",
          "name": "Sort + Two Pointers",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[-1,-1,2],[-1,0,1]]",
              "explanation": "Two unique triplets sum to 0.",
              "id": "6952a73f-5e39-4a3c-b7e4-212d9d10d643",
              "input": "nums = [-1,0,1,2,-1,-4]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "No triplet sums to 0.",
              "id": "e88c71f1-6f39-4502-a988-d62d817a8e42",
              "input": "nums = [0,1,1]"
            },
            {
              "expectedOutput": "[[0,0,0]]",
              "explanation": "Single unique triplet.",
              "id": "1caf588c-d8b4-4469-9a6d-a8f0c0dcc42b",
              "input": "nums = [0,0,0]"
            }
          ]
        }
      ],
      "id": "82ca8435-3b76-41f5-9985-8646f575a687",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "3sum",
      "relatedProblems": [
        "two-sum",
        "4sum"
      ],
      "summary": "Sort the array and fix one element, then use two pointers to find pairs that sum to the negative."
    },
    {
      "approaches": [
        {
          "approach": "1. Use left and right pointers.\n2. Find mid; if it's the target, return it.\n3. Determine which half is sorted and adjust the search range accordingly.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if nums[mid] == target { return mid }\n        if nums[left] <= nums[mid] {\n            if nums[left] <= target && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant extra space.",
            "time": "O(log n)",
            "timeExplanation": "Binary search halves the range each step."
          },
          "explanation": "This preserves O(log n) time because each step discards half the range.",
          "id": "43e27307-58c2-4a0e-a8b9-75238275fb4a",
          "intuition": "In a rotated array, at least one half of the current range is sorted. We can use that to decide where the target may lie.",
          "name": "Modified Binary Search",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Target found at index 4.",
              "id": "3399773a-ab67-467e-8fe0-059e42126ffe",
              "input": "nums = [4,5,6,7,0,1,2], target = 0"
            },
            {
              "expectedOutput": "-1",
              "explanation": "Target not present.",
              "id": "800110ec-ac97-4755-971f-6d84cc314656",
              "input": "nums = [4,5,6,7,0,1,2], target = 3"
            },
            {
              "expectedOutput": "-1",
              "explanation": "Single element not equal to target.",
              "id": "192471d2-017f-4ff5-8035-74cea4b4674a",
              "input": "nums = [1], target = 0"
            }
          ]
        }
      ],
      "id": "f4aa35fd-22bb-466c-8dae-e6567cb0141a",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "search-in-rotated-sorted-array",
      "relatedProblems": [
        "search-in-rotated-sorted-array-ii",
        "find-minimum-in-rotated-sorted-array"
      ],
      "summary": "Binary search while determining which half is sorted at each step."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort intervals by start.\n2. Initialize result with the first interval.\n3. For each subsequent interval, either merge it into the last or append it.",
          "code": "func merge(_ intervals: [[Int]]) -> [[Int]] {\n    if intervals.isEmpty { return [] }\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var result: [[Int]] = [sorted[0]]\n    for interval in sorted.dropFirst() {\n        if interval[0] <= result[result.count - 1][1] {\n            result[result.count - 1][1] = max(result[result.count - 1][1], interval[1])\n        } else {\n            result.append(interval)\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Result list can store up to n intervals.",
            "time": "O(n log n)",
            "timeExplanation": "Sorting dominates the time cost."
          },
          "explanation": "Sorting ensures overlaps are adjacent, so we only compare with the last merged interval.",
          "id": "804d61a0-ef94-4021-a081-82fa69522244",
          "intuition": "After sorting by start, any overlap can only occur with the most recent merged interval.",
          "name": "Sort + Merge",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1,6],[8,10],[15,18]]",
              "explanation": "[1,3] and [2,6] merge into [1,6].",
              "id": "e1a38ac4-6f16-43f9-8eae-772092c14f3b",
              "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]"
            },
            {
              "expectedOutput": "[[1,5]]",
              "explanation": "Touching intervals also merge.",
              "id": "f70a956c-ec5b-4b71-bf26-526b1ad92c3f",
              "input": "intervals = [[1,4],[4,5]]"
            }
          ]
        }
      ],
      "id": "0562ba51-0891-44cc-8ef8-e9d3dd5be2e0",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "merge-intervals",
      "relatedProblems": [
        "insert-interval",
        "meeting-rooms-ii"
      ],
      "summary": "Sort intervals by start and merge overlapping ranges in one pass."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize top, bottom, left, right bounds.\n2. Traverse right, down, left, and up while bounds are valid.\n3. Shrink bounds after each side.",
          "code": "func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n    guard !matrix.isEmpty else { return [] }\n    var top = 0\n    var bottom = matrix.count - 1\n    var left = 0\n    var right = matrix[0].count - 1\n    var result: [Int] = []\n\n    while top <= bottom && left <= right {\n        for col in left...right { result.append(matrix[top][col]) }\n        top += 1\n        if top > bottom { break }\n\n        for row in top...bottom { result.append(matrix[row][right]) }\n        right -= 1\n        if left > right { break }\n\n        for col in stride(from: right, through: left, by: -1) { result.append(matrix[bottom][col]) }\n        bottom -= 1\n        if top > bottom { break }\n\n        for row in stride(from: bottom, through: top, by: -1) { result.append(matrix[row][left]) }\n        left += 1\n    }\n\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "No extra space besides the output array.",
            "time": "O(m * n)",
            "timeExplanation": "Each cell is visited exactly once."
          },
          "explanation": "This orderly boundary scan avoids revisiting cells and handles non-square matrices.",
          "id": "3cc9ef2e-fea5-401a-aa0a-595369e016c9",
          "intuition": "Each spiral layer is a rectangle. After traversing its edges, we move the boundaries inward.",
          "name": "Boundary Traversal",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2,3,6,9,8,7,4,5]",
              "explanation": "Classic 3x3 spiral.",
              "id": "40d28244-749c-499c-8684-5141ef7ad57b",
              "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput": "[1,2,3,4,8,12,11,10,9,5,6,7]",
              "explanation": "Spiral for rectangular matrix.",
              "id": "1794fb06-b57a-4d9a-ae73-8323c7c50b14",
              "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]"
            }
          ]
        }
      ],
      "id": "3d011264-1955-48cf-99a3-28cb75d173a0",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "spiral-matrix",
      "relatedProblems": [
        "spiral-matrix-ii",
        "rotate-image"
      ],
      "summary": "Walk the matrix in layers by shrinking the top, bottom, left, and right boundaries."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate all cells.\n2. When you find land, increment count and DFS to mark the entire island as water.",
          "code": "func numIslands(_ grid: [[Character]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var count = 0\n\n    func dfs(_ r: Int, _ c: Int) {\n        if r < 0 || r >= rows || c < 0 || c >= cols { return }\n        if grid[r][c] != \"1\" { return }\n        grid[r][c] = \"0\"\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == \"1\" {\n                count += 1\n                dfs(r, c)\n            }\n        }\n    }\n    return count\n}",
          "complexity": {
            "space": "O(m * n)",
            "spaceExplanation": "DFS recursion stack can reach all cells in the worst case.",
            "time": "O(m * n)",
            "timeExplanation": "Every cell is visited at most once."
          },
          "explanation": "DFS visits all connected land cells, so each island is counted once.",
          "id": "623b0613-cf2f-476d-b645-283a712a2085",
          "intuition": "Each island is a connected component of '1's. Marking a component prevents double counting.",
          "name": "DFS Flood Fill",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "All land is connected.",
              "id": "fa57d4ea-0dec-463a-8a3b-e5d06b3fb13e",
              "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]"
            },
            {
              "expectedOutput": "3",
              "explanation": "Three separate islands.",
              "id": "5164b72d-7171-48da-aa64-47e45e594562",
              "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]"
            }
          ]
        }
      ],
      "id": "6f18a7ea-1f71-41c6-ad8a-91f28173bbb2",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "number-of-islands",
      "relatedProblems": [
        "max-area-of-island",
        "surrounded-regions"
      ],
      "summary": "Count islands by flooding each discovered land cell with DFS."
    },
    {
      "approaches": [
        {
          "approach": "1. Add all rotten oranges to a queue; count fresh oranges.\n2. Process the queue level by level, rotting adjacent fresh oranges.\n3. Increment minutes after each level.\n4. If fresh oranges remain, return -1; otherwise return minutes.",
          "code": "func orangesRotting(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var queue: [(Int, Int)] = []\n    var fresh = 0\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == 2 { queue.append((r, c)) }\n            else if grid[r][c] == 1 { fresh += 1 }\n        }\n    }\n\n    let directions = [(1,0),(-1,0),(0,1),(0,-1)]\n    var minutes = 0\n    var head = 0\n\n    while head < queue.count && fresh > 0 {\n        let levelCount = queue.count - head\n        for _ in 0..<levelCount {\n            let (r, c) = queue[head]\n            head += 1\n            for (dr, dc) in directions {\n                let nr = r + dr\n                let nc = c + dc\n                if nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1 {\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n                }\n            }\n        }\n        minutes += 1\n    }\n\n    return fresh == 0 ? minutes : -1\n}",
          "complexity": {
            "space": "O(m * n)",
            "spaceExplanation": "Queue may hold all cells in the grid.",
            "time": "O(m * n)",
            "timeExplanation": "Each cell is processed at most once."
          },
          "explanation": "BFS naturally tracks the minimum time to reach each orange because it expands in waves.",
          "id": "33f1b3ba-ac87-4e04-8610-23e61eb07e5d",
          "intuition": "Each minute, all currently rotten oranges infect adjacent fresh ones. BFS levels model this time expansion.",
          "name": "BFS Multi-Source",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "All oranges rot in 4 minutes.",
              "id": "963f04ce-46ca-4f77-84ee-f13640cb6a5a",
              "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]"
            },
            {
              "expectedOutput": "-1",
              "explanation": "Some oranges are unreachable.",
              "id": "8e19da01-63c9-42cb-a384-85cbb69562de",
              "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "No fresh oranges to rot.",
              "id": "2efd6748-b2da-4ee7-aeac-9dbe9e4071a8",
              "input": "grid = [[0,2]]"
            }
          ]
        }
      ],
      "id": "ad4417ac-7912-43ec-b99c-b98060877efe",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "rotting-oranges",
      "relatedProblems": [
        "01-matrix",
        "shortest-path-in-binary-matrix"
      ],
      "summary": "Use BFS from all rotten oranges to simulate minute-by-minute spread."
    },
    {
      "approaches": [
        {
          "approach": "1. Use a dummy node and move `pre` to the node just before `left`.\n2. Let `start` be the first node in the sublist and `then` be start.next.\n3. For each step, move `then` to the front of the sublist.",
          "code": "func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n    if head == nil || left == right { return head }\n    let dummy = ListNode(0)\n    dummy.next = head\n    var pre: ListNode? = dummy\n\n    var pos = 1\n    while pos < left {\n        pre = pre?.next\n        pos += 1\n    }\n\n    let start = pre?.next\n    var then = start?.next\n    var i = 0\n    while i < right - left {\n        start?.next = then?.next\n        then?.next = pre?.next\n        pre?.next = then\n        then = start?.next\n        i += 1\n    }\n\n    return dummy.next\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only a few pointers are used.",
            "time": "O(n)",
            "timeExplanation": "We traverse the list once and reverse the sublist in place."
          },
          "explanation": "This reverses the sublist in-place without touching nodes outside the range.",
          "id": "1b727499-28ed-4e69-ae36-0d335a4f4c55",
          "intuition": "If we fix the node before the sublist, we can repeatedly move the next node to the front of that sublist.",
          "name": "Sublist Reversal",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,4,3,2,5]",
              "explanation": "Sublist 2..4 is reversed.",
              "id": "1272d27f-24bc-4442-bf9a-626f1fe6c565",
              "input": "head = [1,2,3,4,5], left = 2, right = 4"
            },
            {
              "expectedOutput": "[5]",
              "explanation": "Single node remains unchanged.",
              "id": "e8309d6a-9f8f-49ce-b125-1afc3423b163",
              "input": "head = [5], left = 1, right = 1"
            }
          ]
        }
      ],
      "id": "b5852c33-2b98-45c6-8c16-c292beb01185",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "reverse-linked-list-ii",
      "relatedProblems": [
        "reverse-linked-list",
        "reorder-list"
      ],
      "summary": "Reverse the nodes between two positions using head insertion within the sublist."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize dp[0] = 0 and dp[i] = amount + 1 as infinity.\n2. For each amount from 1 to target, try each coin.\n3. If coin <= amount, dp[amount] = min(dp[amount], dp[amount - coin] + 1).\n4. Return dp[amount] if reachable, else -1.",
          "code": "func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n    if amount == 0 { return 0 }\n    var dp = Array(repeating: amount + 1, count: amount + 1)\n    dp[0] = 0\n\n    if amount > 0 {\n        for a in 1...amount {\n            for coin in coins where coin <= a {\n                dp[a] = min(dp[a], dp[a - coin] + 1)\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount]\n}",
          "complexity": {
            "space": "O(amount)",
            "spaceExplanation": "DP array of size amount + 1.",
            "time": "O(amount * coins)",
            "timeExplanation": "For each amount we test all coins."
          },
          "explanation": "This is a classic unbounded knapsack: each coin can be used multiple times.",
          "id": "b55a038f-25b6-43b9-a7b6-8b9c281971f8",
          "intuition": "The optimal way to make amount A depends on the optimal way to make A - coin for each coin.",
          "name": "DP (Unbounded)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "11 = 5 + 5 + 1.",
              "id": "02761a1e-687a-443d-ad55-42ec7bfee4be",
              "input": "coins = [1,2,5], amount = 11"
            },
            {
              "expectedOutput": "-1",
              "explanation": "Cannot make 3 with only 2s.",
              "id": "722491b7-e337-4740-b52c-143a5b9af547",
              "input": "coins = [2], amount = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "Zero amount needs zero coins.",
              "id": "f4c25e0b-fd8f-40bf-a433-ce41c17606e9",
              "input": "coins = [1], amount = 0"
            }
          ]
        }
      ],
      "id": "c4d3ba80-256e-421e-a8cd-00902e73d355",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "coin-change",
      "relatedProblems": [
        "coin-change-2",
        "minimum-cost-for-tickets"
      ],
      "summary": "Compute the minimum coins needed for every amount up to target."
    },
    {
      "approaches": [
        {
          "approach": "1. Add to max-heap (lower), move max to min-heap (upper)\n2. If min-heap larger, move its min back to max-heap\n3. Median: if equal sizes, average of tops; else max-heap top",
          "code": "class MedianFinder {\n    private var lower: [Int] = []  // max-heap (negate values)\n    private var upper: [Int] = []  // min-heap\n    \n    func addNum(_ num: Int) {\n        // Add to lower (max-heap)\n        lower.append(-num)\n        lower.sort()\n        \n        // Move largest from lower to upper\n        upper.append(-lower.removeFirst())\n        upper.sort()\n        \n        // Balance: upper can't be larger\n        if upper.count > lower.count {\n            lower.append(-upper.removeFirst())\n            lower.sort()\n        }\n    }\n    \n    func findMedian() -> Double {\n        if lower.count > upper.count {\n            return Double(-lower.first!)\n        }\n        return Double(-lower.first! + upper.first!) / 2.0\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Store all n numbers",
            "time": "O(n log n)",
            "timeExplanation": "Each add is O(n log n) with array sort (O(log n) with real heap)"
          },
          "explanation": "Max-heap gives largest of smaller half, min-heap gives smallest of larger half. Keep sizes within 1.",
          "id": "550e8400-e29b-41d4-a716-446655440129",
          "intuition": "Keep lower half in max-heap, upper half in min-heap. Balance sizes so median is accessible at heap tops.",
          "name": "Two Heaps",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1.5, 2.0",
              "explanation": "[1,2] median=1.5, [1,2,3] median=2",
              "id": "550e8400-e29b-41d4-a716-446655440235",
              "input": "addNum(1), addNum(2), findMedian(), addNum(3), findMedian()"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440018",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "find-median-from-data-stream",
      "relatedProblems": [
        "sliding-window-median"
      ],
      "summary": "Maintain median using two heaps: max-heap for lower half, min-heap for upper half. Median is from top of heaps."
    },
    {
      "approaches": [
        {
          "approach": "1. Start with empty subset\n2. At each index, branch: include nums[i] or not\n3. When index reaches end, add current subset to result",
          "code": "func subsets(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    \n    func backtrack(_ index: Int) {\n        if index == nums.count {\n            result.append(current)\n            return\n        }\n        // Include nums[index]\n        current.append(nums[index])\n        backtrack(index + 1)\n        current.removeLast()\n        // Exclude nums[index]\n        backtrack(index + 1)\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth n",
            "time": "O(n * 2^n)",
            "timeExplanation": "2^n subsets, O(n) to copy each"
          },
          "explanation": "Backtracking explores all 2^n combinations. Add element, recurse, remove (backtrack), recurse again.",
          "id": "550e8400-e29b-41d4-a716-446655440130",
          "intuition": "For each element, make two choices: include it or skip it. This creates a binary tree of decisions.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
              "explanation": "All 8 subsets of 3 elements",
              "id": "550e8400-e29b-41d4-a716-446655440236",
              "input": "[1,2,3]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440019",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "subsets",
      "relatedProblems": [
        "subsets-ii",
        "combinations"
      ],
      "summary": "Generate all subsets using backtracking or iterative bit manipulation. Each element is either included or not."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort candidates (optional, for pruning)\n2. Backtrack: if sum==target, save; if sum>target, return\n3. For each candidate from current index, add and recurse (same index for reuse)",
          "code": "func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    \n    func backtrack(_ index: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        if remaining < 0 { return }\n        \n        for i in index..<candidates.count {\n            current.append(candidates[i])\n            backtrack(i, remaining - candidates[i])  // same i for reuse\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
          "complexity": {
            "space": "O(T/M)",
            "spaceExplanation": "Max recursion depth",
            "time": "O(n^(T/M))",
            "timeExplanation": "T=target, M=min candidate. Branching factor n, depth T/M"
          },
          "explanation": "Key: pass same index to allow reuse of element. Advance index to avoid duplicate combinations.",
          "id": "550e8400-e29b-41d4-a716-446655440131",
          "intuition": "Try adding each candidate repeatedly until sum >= target, then backtrack to try other candidates.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[2,2,3],[7]]",
              "explanation": "2+2+3=7 and 7=7",
              "id": "550e8400-e29b-41d4-a716-446655440237",
              "input": "candidates = [2,3,6,7], target = 7"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440020",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "combination-sum",
      "relatedProblems": [
        "combination-sum-ii",
        "combination-sum-iii"
      ],
      "summary": "Find combinations that sum to target. Use backtracking, allowing same element multiple times."
    },
    {
      "approaches": [
        {
          "approach": "1. Track used indices with boolean array\n2. At each position, try each unused element\n3. When length == n, save permutation",
          "code": "func permute(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    var used = [Bool](repeating: false, count: nums.count)\n    \n    func backtrack() {\n        if current.count == nums.count {\n            result.append(current)\n            return\n        }\n        for i in 0..<nums.count {\n            if used[i] { continue }\n            used[i] = true\n            current.append(nums[i])\n            backtrack()\n            current.removeLast()\n            used[i] = false\n        }\n    }\n    \n    backtrack()\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth and used array",
            "time": "O(n * n!)",
            "timeExplanation": "n! permutations, O(n) to copy each"
          },
          "explanation": "For n elements, n! permutations. Each position has decreasing choices: n, n-1, ..., 1.",
          "id": "550e8400-e29b-41d4-a716-446655440132",
          "intuition": "Build permutation one element at a time, skipping already-used elements.",
          "name": "Backtracking with Used Set",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
              "explanation": "All 6 permutations",
              "id": "550e8400-e29b-41d4-a716-446655440238",
              "input": "[1,2,3]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440021",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "permutations",
      "relatedProblems": [
        "permutations-ii",
        "next-permutation"
      ],
      "summary": "Generate all permutations using backtracking. Swap elements or track used indices."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort nums\n2. Backtrack: add current subset, then try each remaining element\n3. Skip if nums[i] == nums[i-1] at same recursion level",
          "code": "func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = nums.sorted()\n    \n    func backtrack(_ start: Int) {\n        result.append(current)\n        for i in start..<sorted.count {\n            // Skip duplicates at same level\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n * 2^n)",
            "timeExplanation": "At most 2^n subsets"
          },
          "explanation": "Sorting groups duplicates. Skip condition prevents same value being chosen twice for same position.",
          "id": "550e8400-e29b-41d4-a716-446655440133",
          "intuition": "Sort array so duplicates are adjacent. When iterating, skip if same as previous (at same level).",
          "name": "Backtracking with Duplicate Skip",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
              "explanation": "No duplicate subsets like [2] appearing twice",
              "id": "550e8400-e29b-41d4-a716-446655440239",
              "input": "[1,2,2]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440022",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "subsets-ii",
      "relatedProblems": [
        "subsets"
      ],
      "summary": "Generate unique subsets from array with duplicates. Sort first, skip consecutive duplicates."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort candidates\n2. Backtrack from index, skip if same as previous at same level\n3. Move to i+1 after using element (no reuse)",
          "code": "func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = candidates.sorted()\n    \n    func backtrack(_ start: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        for i in start..<sorted.count {\n            if sorted[i] > remaining { break }\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1, remaining - sorted[i])\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth",
            "time": "O(2^n)",
            "timeExplanation": "Each element included or not"
          },
          "explanation": "i > start ensures we only skip duplicates at same recursion level, not first occurrence.",
          "id": "550e8400-e29b-41d4-a716-446655440134",
          "intuition": "Like combination-sum but: 1) move to next index after use, 2) skip duplicate values at same level.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
              "explanation": "Unique combinations, each element used at most once",
              "id": "550e8400-e29b-41d4-a716-446655440240",
              "input": "candidates = [10,1,2,7,6,1,5], target = 8"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440023",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "combination-sum-ii",
      "relatedProblems": [
        "combination-sum"
      ],
      "summary": "Find unique combinations summing to target, each element used once. Sort and skip duplicates."
    },
    {
      "approaches": [
        {
          "approach": "1. Create digit-to-letters mapping\n2. Backtrack: at each digit position, try each letter\n3. When index == digits.length, add to result",
          "code": "func letterCombinations(_ digits: String) -> [String] {\n    guard !digits.isEmpty else { return [] }\n    \n    let map: [Character: String] = [\n        \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n        \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"\n    ]\n    let digitsArray = Array(digits)\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ index: Int) {\n        if index == digitsArray.count {\n            result.append(current)\n            return\n        }\n        let letters = map[digitsArray[index]]!\n        for letter in letters {\n            current.append(letter)\n            backtrack(index + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth n",
            "time": "O(4^n)",
            "timeExplanation": "At most 4 letters per digit, n digits"
          },
          "explanation": "Branching factor is 3-4 per digit, total combinations is product of letter counts.",
          "id": "550e8400-e29b-41d4-a716-446655440135",
          "intuition": "Each digit maps to 3-4 letters. For each digit, try each mapped letter and recurse to next digit.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
              "explanation": "2->abc, 3->def, 3*3=9 combinations",
              "id": "550e8400-e29b-41d4-a716-446655440241",
              "input": "\"23\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440024",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "letter-combinations-of-a-phone-number",
      "relatedProblems": [
        "generate-parentheses",
        "combination-sum"
      ],
      "summary": "Generate all letter combinations for phone digits. Map digits to letters, backtrack through all combinations."
    },
    {
      "approaches": [
        {
          "approach": "1. At index i, try substrings s[i...j] for all j >= i\n2. If s[i...j] is palindrome, add to current, recurse from j+1\n3. When index reaches end, save partition",
          "code": "func partition(_ s: String) -> [[String]] {\n    let chars = Array(s)\n    var result: [[String]] = []\n    var current: [String] = []\n    \n    func isPalindrome(_ start: Int, _ end: Int) -> Bool {\n        var l = start, r = end\n        while l < r {\n            if chars[l] != chars[r] { return false }\n            l += 1; r -= 1\n        }\n        return true\n    }\n    \n    func backtrack(_ start: Int) {\n        if start == chars.count {\n            result.append(current)\n            return\n        }\n        for end in start..<chars.count {\n            if isPalindrome(start, end) {\n                current.append(String(chars[start...end]))\n                backtrack(end + 1)\n                current.removeLast()\n            }\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n * 2^n)",
            "timeExplanation": "2^n partitions possible, O(n) palindrome check"
          },
          "explanation": "Only extend partition if current substring is valid palindrome.",
          "id": "550e8400-e29b-41d4-a716-446655440136",
          "intuition": "At each position, try all possible prefixes. If prefix is palindrome, recurse on remainder.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
              "explanation": "Two valid palindromic partitions",
              "id": "550e8400-e29b-41d4-a716-446655440242",
              "input": "\"aab\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440025",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "palindrome-partitioning",
      "relatedProblems": [
        "palindrome-partitioning-ii"
      ],
      "summary": "Partition string into all palindromic substrings. Backtrack, checking if each prefix is palindrome."
    },
    {
      "approaches": [
        {
          "approach": "1. Track used columns, diagonals (row-col), anti-diagonals (row+col)\n2. For each row, try each column if not attacked\n3. When row == n, save board configuration",
          "code": "func solveNQueens(_ n: Int) -> [[String]] {\n    var result: [[String]] = []\n    var board = [[Character]](repeating: [Character](repeating: \".\", count: n), count: n)\n    var cols = Set<Int>()\n    var diags = Set<Int>()  // row - col\n    var antiDiags = Set<Int>()  // row + col\n    \n    func backtrack(_ row: Int) {\n        if row == n {\n            result.append(board.map { String($0) })\n            return\n        }\n        for col in 0..<n {\n            let diag = row - col, antiDiag = row + col\n            if cols.contains(col) || diags.contains(diag) || antiDiags.contains(antiDiag) {\n                continue\n            }\n            board[row][col] = \"Q\"\n            cols.insert(col); diags.insert(diag); antiDiags.insert(antiDiag)\n            backtrack(row + 1)\n            board[row][col] = \".\"\n            cols.remove(col); diags.remove(diag); antiDiags.remove(antiDiag)\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
          "complexity": {
            "space": "O(n²)",
            "spaceExplanation": "Board storage",
            "time": "O(n!)",
            "timeExplanation": "~n! valid placements to explore"
          },
          "explanation": "Diagonals identified by row-col (same for all cells), anti-diagonals by row+col.",
          "id": "550e8400-e29b-41d4-a716-446655440137",
          "intuition": "Place one queen per row. Track attacked columns and diagonals. Backtrack if no valid position.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
              "explanation": "Two distinct solutions for 4-queens",
              "id": "550e8400-e29b-41d4-a716-446655440243",
              "input": "n = 4"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440026",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "n-queens",
      "relatedProblems": [
        "n-queens-ii"
      ],
      "summary": "Place n queens on n×n board. Backtrack row by row, checking column/diagonal conflicts."
    },
    {
      "approaches": [
        {
          "approach": "1. Build adjacency list from prerequisites\n2. DFS from each node, mark as 'visiting'\n3. If encounter 'visiting' node, cycle found\n4. Mark 'visited' when done with all neighbors",
          "code": "func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    for pre in prerequisites {\n        graph[pre[1]].append(pre[0])\n    }\n    \n    var state = [Int](repeating: 0, count: numCourses)  // 0=unvisited, 1=visiting, 2=visited\n    \n    func hasCycle(_ node: Int) -> Bool {\n        if state[node] == 1 { return true }  // Cycle\n        if state[node] == 2 { return false }  // Already done\n        \n        state[node] = 1\n        for neighbor in graph[node] {\n            if hasCycle(neighbor) { return true }\n        }\n        state[node] = 2\n        return false\n    }\n    \n    for i in 0..<numCourses {\n        if hasCycle(i) { return false }\n    }\n    return true\n}",
          "complexity": {
            "space": "O(V + E)",
            "spaceExplanation": "Graph storage and recursion",
            "time": "O(V + E)",
            "timeExplanation": "Visit each node and edge once"
          },
          "explanation": "'Visiting' means in current DFS path. If we see it again, we've found a back edge (cycle).",
          "id": "550e8400-e29b-41d4-a716-446655440138",
          "intuition": "Build graph of prerequisites. Detect cycle using DFS with three states: unvisited, visiting, visited.",
          "name": "DFS Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Take course 0, then course 1",
              "id": "550e8400-e29b-41d4-a716-446655440244",
              "input": "numCourses = 2, prerequisites = [[1,0]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440027",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "course-schedule",
      "relatedProblems": [
        "course-schedule-ii"
      ],
      "summary": "Detect if courses can be completed (no cycle in prerequisite graph). Use DFS with visited states or topological sort."
    },
    {
      "approaches": [
        {
          "approach": "1. Build graph and in-degree array\n2. Add all nodes with in-degree 0 to queue\n3. Process queue: add to result, decrement neighbors' in-degrees\n4. If result size != numCourses, cycle exists",
          "code": "func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    var inDegree = [Int](repeating: 0, count: numCourses)\n    \n    for pre in prerequisites {\n        graph[pre[1]].append(pre[0])\n        inDegree[pre[0]] += 1\n    }\n    \n    var queue = (0..<numCourses).filter { inDegree[$0] == 0 }\n    var result: [Int] = []\n    \n    while !queue.isEmpty {\n        let course = queue.removeFirst()\n        result.append(course)\n        for next in graph[course] {\n            inDegree[next] -= 1\n            if inDegree[next] == 0 {\n                queue.append(next)\n            }\n        }\n    }\n    \n    return result.count == numCourses ? result : []\n}",
          "complexity": {
            "space": "O(V + E)",
            "spaceExplanation": "Graph and queue storage",
            "time": "O(V + E)",
            "timeExplanation": "Process each node and edge once"
          },
          "explanation": "Topological sort using BFS. In-degree 0 means all prerequisites satisfied.",
          "id": "550e8400-e29b-41d4-a716-446655440139",
          "intuition": "Start with courses having no prerequisites (in-degree 0). Process them, reduce neighbors' in-degrees, repeat.",
          "name": "Kahn's Algorithm (BFS)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,1,2,3] or [0,2,1,3]",
              "explanation": "Valid topological orderings",
              "id": "550e8400-e29b-41d4-a716-446655440245",
              "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440028",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "course-schedule-ii",
      "relatedProblems": [
        "course-schedule",
        "alien-dictionary"
      ],
      "summary": "Return course order (topological sort). Use Kahn's algorithm (BFS) or DFS with post-order."
    },
    {
      "approaches": [
        {
          "approach": "1. dp[i] = max money robbing houses 0..i\n2. dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n3. Optimize to O(1) space with two variables",
          "code": "func rob(_ nums: [Int]) -> Int {\n    var prev2 = 0  // max from 2 houses back\n    var prev1 = 0  // max from previous house\n    \n    for num in nums {\n        let curr = max(prev1, prev2 + num)\n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Two variables",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "Can't rob adjacent, so if we rob house i, previous robbed must be i-2 or earlier.",
          "id": "550e8400-e29b-41d4-a716-446655440140",
          "intuition": "At each house, choose: skip it (take prev max) or rob it (take prev-prev max + current).",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "12",
              "explanation": "Rob houses 0,2,4: 2+9+1=12",
              "id": "550e8400-e29b-41d4-a716-446655440246",
              "input": "[2,7,9,3,1]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440029",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "house-robber",
      "relatedProblems": [
        "house-robber-ii",
        "house-robber-iii"
      ],
      "summary": "Max money without robbing adjacent houses. DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i])."
    },
    {
      "approaches": [
        {
          "approach": "1. If n==1, return nums[0]\n2. Run house robber on nums[0..<n-1]\n3. Run house robber on nums[1..<n]\n4. Return max of both",
          "code": "func rob(_ nums: [Int]) -> Int {\n    if nums.count == 1 { return nums[0] }\n    \n    func robRange(_ start: Int, _ end: Int) -> Int {\n        var prev2 = 0, prev1 = 0\n        for i in start..<end {\n            let curr = max(prev1, prev2 + nums[i])\n            prev2 = prev1\n            prev1 = curr\n        }\n        return prev1\n    }\n    \n    return max(robRange(0, nums.count - 1), robRange(1, nums.count))\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant space",
            "time": "O(n)",
            "timeExplanation": "Two passes through array"
          },
          "explanation": "Breaking the circle by ensuring first and last aren't both included.",
          "id": "550e8400-e29b-41d4-a716-446655440141",
          "intuition": "Can't rob both first and last. Solve twice: houses[0..n-2] and houses[1..n-1], take max.",
          "name": "Two Passes DP",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Can't rob 2 and 2 (adjacent in circle), rob 3",
              "id": "550e8400-e29b-41d4-a716-446655440247",
              "input": "[2,3,2]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440030",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "house-robber-ii",
      "relatedProblems": [
        "house-robber",
        "house-robber-iii"
      ],
      "summary": "Circular houses (first and last adjacent). Run house robber twice: exclude first or exclude last."
    },
    {
      "approaches": [
        {
          "approach": "1. For each index i, expand for odd-length (center i) and even-length (center i,i+1)\n2. Track longest palindrome found\n3. Return substring",
          "code": "func longestPalindrome(_ s: String) -> String {\n    let chars = Array(s)\n    var start = 0, maxLen = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            l -= 1; r += 1\n        }\n        return r - l - 1\n    }\n    \n    for i in 0..<chars.count {\n        let len1 = expand(i, i)      // Odd length\n        let len2 = expand(i, i + 1)  // Even length\n        let len = max(len1, len2)\n        if len > maxLen {\n            maxLen = len\n            start = i - (len - 1) / 2\n        }\n    }\n    \n    return String(chars[start..<start + maxLen])\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "String conversion",
            "time": "O(n²)",
            "timeExplanation": "n centers, O(n) expansion each"
          },
          "explanation": "2n-1 potential centers (n single chars, n-1 pairs). Each expansion is O(n) worst case.",
          "id": "550e8400-e29b-41d4-a716-446655440142",
          "intuition": "A palindrome has a center. Try each index as center, expand while characters match.",
          "name": "Expand Around Center",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"bab\" or \"aba\"",
              "explanation": "Both are valid longest palindromes",
              "id": "550e8400-e29b-41d4-a716-446655440248",
              "input": "\"babad\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440031",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "longest-palindromic-substring",
      "relatedProblems": [
        "palindromic-substrings",
        "longest-palindromic-subsequence"
      ],
      "summary": "Find longest palindrome substring. Expand from center for each position (and between positions)."
    },
    {
      "approaches": [
        {
          "approach": "1. For each center (single char and pairs), expand outward\n2. Count each position where chars match\n3. Sum all counts",
          "code": "func countSubstrings(_ s: String) -> Int {\n    let chars = Array(s)\n    var count = 0\n    \n    func expand(_ left: Int, _ right: Int) -> Int {\n        var l = left, r = right, cnt = 0\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            cnt += 1\n            l -= 1; r += 1\n        }\n        return cnt\n    }\n    \n    for i in 0..<chars.count {\n        count += expand(i, i)      // Odd\n        count += expand(i, i + 1)  // Even\n    }\n    \n    return count\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "String to array",
            "time": "O(n²)",
            "timeExplanation": "n centers, O(n) expansion"
          },
          "explanation": "Each valid expansion is a palindrome. Total count includes all lengths.",
          "id": "550e8400-e29b-41d4-a716-446655440143",
          "intuition": "Same as longest palindrome, but count each successful expansion instead of tracking max.",
          "name": "Expand Around Center",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "a,a,a,aa,aa,aaa = 6 palindromes",
              "id": "550e8400-e29b-41d4-a716-446655440249",
              "input": "\"aaa\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440032",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "palindromic-substrings",
      "relatedProblems": [
        "longest-palindromic-substring"
      ],
      "summary": "Count all palindromic substrings. Expand from each center, count valid expansions."
    },
    {
      "approaches": [
        {
          "approach": "1. dp[i] = ways to decode s[0..i-1]\n2. If s[i-1] != '0': dp[i] += dp[i-1] (single digit)\n3. If s[i-2..i-1] in 10-26: dp[i] += dp[i-2] (double digit)",
          "code": "func numDecodings(_ s: String) -> Int {\n    let chars = Array(s)\n    let n = chars.count\n    if chars[0] == \"0\" { return 0 }\n    \n    var prev2 = 1  // dp[i-2]\n    var prev1 = 1  // dp[i-1]\n    \n    for i in 1..<n {\n        var curr = 0\n        let oneDigit = Int(String(chars[i]))!\n        let twoDigit = Int(String(chars[i-1...i]))!\n        \n        if oneDigit >= 1 { curr += prev1 }\n        if twoDigit >= 10 && twoDigit <= 26 { curr += prev2 }\n        \n        prev2 = prev1\n        prev1 = curr\n    }\n    \n    return prev1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Two variables",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "'0' can't be decoded alone. '06' is invalid. Only '10'-'26' valid as two digits.",
          "id": "550e8400-e29b-41d4-a716-446655440144",
          "intuition": "At each position, can decode 1 digit (if valid) or 2 digits (if valid). Sum the ways.",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "BZ (2,26), VF (22,6), BBF (2,2,6)",
              "id": "550e8400-e29b-41d4-a716-446655440250",
              "input": "\"226\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440033",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "decode-ways",
      "relatedProblems": [
        "decode-ways-ii"
      ],
      "summary": "Count ways to decode digit string to letters. DP: check single digit (1-9) and double digit (10-26)."
    },
    {
      "approaches": [
        {
          "approach": "1. dp[0] = true (empty string)\n2. For each i, check all j < i\n3. If dp[j] && s[j..i-1] in dict: dp[i] = true",
          "code": "func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n    let words = Set(wordDict)\n    let chars = Array(s)\n    let n = chars.count\n    var dp = [Bool](repeating: false, count: n + 1)\n    dp[0] = true\n    \n    for i in 1...n {\n        for j in 0..<i {\n            if dp[j] && words.contains(String(chars[j..<i])) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    \n    return dp[n]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "DP array",
            "time": "O(n² * m)",
            "timeExplanation": "n² pairs, O(m) string comparison"
          },
          "explanation": "Build up: if we can segment up to j, and j..i is a word, we can segment up to i.",
          "id": "550e8400-e29b-41d4-a716-446655440145",
          "intuition": "dp[i] is true if some dp[j] is true and s[j..i-1] is a word. Check all split points.",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "leet + code",
              "id": "550e8400-e29b-41d4-a716-446655440251",
              "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440034",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "word-break",
      "relatedProblems": [
        "word-break-ii"
      ],
      "summary": "Check if string can be segmented into dictionary words. DP: dp[i] = can segment s[0..i-1]."
    },
    {
      "approaches": [
        {
          "approach": "1. tails[i] = smallest ending element of LIS of length i+1\n2. For each num: binary search for position in tails\n3. Replace or extend tails array\n4. Return tails.count",
          "code": "func lengthOfLIS(_ nums: [Int]) -> Int {\n    var tails: [Int] = []\n    \n    for num in nums {\n        var left = 0, right = tails.count\n        while left < right {\n            let mid = (left + right) / 2\n            if tails[mid] < num {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n        if left == tails.count {\n            tails.append(num)\n        } else {\n            tails[left] = num\n        }\n    }\n    \n    return tails.count\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "tails array",
            "time": "O(n log n)",
            "timeExplanation": "n elements, O(log n) binary search each"
          },
          "explanation": "tails is always sorted. We find where num fits and either replace (better ending) or extend.",
          "id": "550e8400-e29b-41d4-a716-446655440146",
          "intuition": "Maintain array of smallest tail for each length. Binary search for position to update.",
          "name": "Binary Search (Patience Sort)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "[2,3,7,101] or [2,3,7,18]",
              "id": "550e8400-e29b-41d4-a716-446655440252",
              "input": "[10,9,2,5,3,7,101,18]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440035",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "longest-increasing-subsequence",
      "relatedProblems": [
        "number-of-longest-increasing-subsequence",
        "increasing-triplet-subsequence"
      ],
      "summary": "Find length of LIS. DP O(n²) or binary search O(n log n) with patience sorting."
    },
    {
      "approaches": [
        {
          "approach": "1. Track currentSum and maxSum\n2. For each num: currentSum = max(num, currentSum + num)\n3. Update maxSum = max(maxSum, currentSum)\n4. Return maxSum",
          "code": "func maxSubArray(_ nums: [Int]) -> Int {\n    var currentSum = nums[0]\n    var maxSum = nums[0]\n    \n    for i in 1..<nums.count {\n        currentSum = max(nums[i], currentSum + nums[i])\n        maxSum = max(maxSum, currentSum)\n    }\n    \n    return maxSum\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Two variables",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "If currentSum < 0, adding it to next element makes it smaller. So reset to just the next element.",
          "id": "550e8400-e29b-41d4-a716-446655440147",
          "intuition": "At each position, decide: extend current subarray or start fresh. If current sum is negative, starting fresh is better.",
          "name": "Kadane's Algorithm",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "[4,-1,2,1] has sum 6",
              "id": "550e8400-e29b-41d4-a716-446655440253",
              "input": "[-2,1,-3,4,-1,2,1,-5,4]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440036",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "maximum-subarray",
      "relatedProblems": [
        "maximum-product-subarray",
        "maximum-sum-circular-subarray"
      ],
      "summary": "Find contiguous subarray with maximum sum. Kadane's algorithm: track current sum, reset if negative."
    },
    {
      "approaches": [
        {
          "approach": "1. left = 0, right = n-1\n2. Calculate area = min(height[left], height[right]) * (right - left)\n3. Move pointer with smaller height inward\n4. Track max area",
          "code": "func maxArea(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxArea = 0\n    \n    while left < right {\n        let area = min(height[left], height[right]) * (right - left)\n        maxArea = max(maxArea, area)\n        \n        if height[left] < height[right] {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    \n    return maxArea\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant space",
            "time": "O(n)",
            "timeExplanation": "Single pass with two pointers"
          },
          "explanation": "Width decreases as we move inward, so we need taller lines. Moving shorter line is only way to potentially increase area.",
          "id": "550e8400-e29b-41d4-a716-446655440148",
          "intuition": "Water limited by shorter line. Moving shorter line might find taller one; moving taller never helps.",
          "name": "Two Pointers",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "49",
              "explanation": "Lines at index 1 and 8 (heights 8,7) give area 7*7=49",
              "id": "550e8400-e29b-41d4-a716-446655440254",
              "input": "[1,8,6,2,5,4,8,3,7]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440037",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "container-with-most-water",
      "relatedProblems": [
        "trapping-rain-water"
      ],
      "summary": "Find two lines that hold most water. Two pointers from ends, move the shorter one inward."
    },
    {
      "approaches": [
        {
          "approach": "1. Track maxLeft, maxRight, left, right pointers\n2. Process smaller side (we know its constraint)\n3. Water = max - current height\n4. Move pointer inward, update max",
          "code": "func trap(_ height: [Int]) -> Int {\n    var left = 0, right = height.count - 1\n    var maxLeft = 0, maxRight = 0\n    var water = 0\n    \n    while left < right {\n        if height[left] < height[right] {\n            if height[left] >= maxLeft {\n                maxLeft = height[left]\n            } else {\n                water += maxLeft - height[left]\n            }\n            left += 1\n        } else {\n            if height[right] >= maxRight {\n                maxRight = height[right]\n            } else {\n                water += maxRight - height[right]\n            }\n            right -= 1\n        }\n    }\n    \n    return water\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant space",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "If maxLeft < maxRight, left side is the constraint. Water at left = maxLeft - height[left].",
          "id": "550e8400-e29b-41d4-a716-446655440149",
          "intuition": "Water at position depends on min of max heights on left and right. Use two pointers to track.",
          "name": "Two Pointers",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "Water fills gaps between bars",
              "id": "550e8400-e29b-41d4-a716-446655440255",
              "input": "[0,1,0,2,1,0,1,3,2,1,2,1]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440038",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "trapping-rain-water",
      "relatedProblems": [
        "container-with-most-water"
      ],
      "summary": "Calculate trapped rainwater. At each position, water = min(maxLeft, maxRight) - height."
    },
    {
      "approaches": [
        {
          "approach": "1. maxReach = 0\n2. For each index i:\n   - If i > maxReach: return false\n   - maxReach = max(maxReach, i + nums[i])\n3. Return true if loop completes",
          "code": "func canJump(_ nums: [Int]) -> Bool {\n    var maxReach = 0\n    \n    for i in 0..<nums.count {\n        if i > maxReach { return false }\n        maxReach = max(maxReach, i + nums[i])\n    }\n    \n    return true\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "One variable",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "At each step, extend reach if possible. If we can't reach current position, we fail.",
          "id": "550e8400-e29b-41d4-a716-446655440150",
          "intuition": "Track farthest reachable position. If current index exceeds it, we're stuck.",
          "name": "Greedy",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Jump 1->2->4 or 1->3->4",
              "id": "550e8400-e29b-41d4-a716-446655440256",
              "input": "[2,3,1,1,4]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440039",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "jump-game",
      "relatedProblems": [
        "jump-game-ii"
      ],
      "summary": "Can reach last index from first? Track maximum reachable index, update as you go."
    },
    {
      "approaches": [
        {
          "approach": "1. dp[i][j] = number of paths to reach (i,j)\n2. First row and column are all 1s\n3. dp[i][j] = dp[i-1][j] + dp[i][j-1]\n4. Return dp[m-1][n-1]",
          "code": "func uniquePaths(_ m: Int, _ n: Int) -> Int {\n    var dp = [Int](repeating: 1, count: n)\n    \n    for _ in 1..<m {\n        for j in 1..<n {\n            dp[j] += dp[j-1]\n        }\n    }\n    \n    return dp[n-1]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Single row DP",
            "time": "O(m*n)",
            "timeExplanation": "Fill m*n cells"
          },
          "explanation": "Can only come from above or left. Sum both possibilities. Optimize to O(n) space with single row.",
          "id": "550e8400-e29b-41d4-a716-446655440151",
          "intuition": "Paths to (i,j) = paths to (i-1,j) + paths to (i,j-1). Fill grid row by row.",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "28",
              "explanation": "28 unique paths",
              "id": "550e8400-e29b-41d4-a716-446655440257",
              "input": "m = 3, n = 7"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440040",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "unique-paths",
      "relatedProblems": [
        "unique-paths-ii",
        "minimum-path-sum"
      ],
      "summary": "Count paths in grid moving only right/down. DP or combinatorics: C(m+n-2, m-1)."
    },
    {
      "approaches": [
        {
          "approach": "1. left = 0, right = n-1\n2. Skip non-alphanumeric from both ends\n3. Compare lowercase versions\n4. Return false if mismatch",
          "code": "func isPalindrome(_ s: String) -> Bool {\n    let chars = Array(s.lowercased())\n    var left = 0, right = chars.count - 1\n    \n    while left < right {\n        while left < right && !chars[left].isLetter && !chars[left].isNumber {\n            left += 1\n        }\n        while left < right && !chars[right].isLetter && !chars[right].isNumber {\n            right -= 1\n        }\n        if chars[left] != chars[right] { return false }\n        left += 1\n        right -= 1\n    }\n    return true\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Array conversion",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "Filter and compare in one pass without creating new string.",
          "id": "550e8400-e29b-41d4-a716-446655440152",
          "intuition": "Compare characters from both ends, skip non-alphanumeric, ignore case.",
          "name": "Two Pointers",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "amanaplanacanalpanama is palindrome",
              "id": "550e8400-e29b-41d4-a716-446655440258",
              "input": "\"A man, a plan, a canal: Panama\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440041",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "valid-palindrome",
      "relatedProblems": [
        "valid-palindrome-ii"
      ],
      "summary": "Check if string is palindrome ignoring non-alphanumeric. Two pointers from ends."
    },
    {
      "approaches": [
        {
          "approach": "1. Create set from nums\n2. For each num: if num-1 not in set, count consecutive\n3. Track max length",
          "code": "func longestConsecutive(_ nums: [Int]) -> Int {\n    let numSet = Set(nums)\n    var maxLength = 0\n    \n    for num in numSet {\n        // Only start if this is beginning of sequence\n        if !numSet.contains(num - 1) {\n            var current = num\n            var length = 1\n            while numSet.contains(current + 1) {\n                current += 1\n                length += 1\n            }\n            maxLength = max(maxLength, length)\n        }\n    }\n    \n    return maxLength\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Set storage",
            "time": "O(n)",
            "timeExplanation": "Each element visited at most twice"
          },
          "explanation": "Only counting from sequence starts ensures O(n) - each element visited at most twice.",
          "id": "550e8400-e29b-41d4-a716-446655440153",
          "intuition": "Put all in set. For each number, if n-1 not in set, it's a sequence start. Count forward.",
          "name": "Hash Set",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Sequence [1,2,3,4]",
              "id": "550e8400-e29b-41d4-a716-446655440259",
              "input": "[100,4,200,1,3,2]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440042",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "longest-consecutive-sequence",
      "relatedProblems": [
        "binary-tree-longest-consecutive-sequence"
      ],
      "summary": "Find longest consecutive sequence in O(n). Use set, only start counting from sequence starts."
    },
    {
      "approaches": [
        {
          "approach": "1. Track open and close counts\n2. Add '(' if open < n\n3. Add ')' if close < open\n4. When length == 2n, save result",
          "code": "func generateParenthesis(_ n: Int) -> [String] {\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ open: Int, _ close: Int) {\n        if current.count == 2 * n {\n            result.append(current)\n            return\n        }\n        if open < n {\n            current.append(\"(\")\n            backtrack(open + 1, close)\n            current.removeLast()\n        }\n        if close < open {\n            current.append(\")\")\n            backtrack(open, close + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, 0)\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Recursion depth",
            "time": "O(4^n / √n)",
            "timeExplanation": "Catalan number complexity"
          },
          "explanation": "Never more ')' than '(' ensures every prefix is valid. Stop when counts reach n.",
          "id": "550e8400-e29b-41d4-a716-446655440154",
          "intuition": "Add '(' if openCount < n. Add ')' if closeCount < openCount. Ensures validity.",
          "name": "Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
              "explanation": "All 5 valid combinations",
              "id": "550e8400-e29b-41d4-a716-446655440260",
              "input": "n = 3"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440043",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "generate-parentheses",
      "relatedProblems": [
        "valid-parentheses",
        "letter-combinations-of-a-phone-number"
      ],
      "summary": "Generate all valid n pairs of parentheses. Backtrack, ensuring open >= close."
    },
    {
      "approaches": [
        {
          "approach": "1. Stack stores indices of unresolved days\n2. For each day: pop while current > stack top\n3. For popped index, answer = current index - popped index\n4. Push current index",
          "code": "func dailyTemperatures(_ temperatures: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: temperatures.count)\n    var stack: [Int] = []  // indices\n    \n    for i in 0..<temperatures.count {\n        while !stack.isEmpty && temperatures[i] > temperatures[stack.last!] {\n            let j = stack.removeLast()\n            result[j] = i - j\n        }\n        stack.append(i)\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack size",
            "time": "O(n)",
            "timeExplanation": "Each element pushed/popped once"
          },
          "explanation": "Stack maintains indices waiting for warmer day. Pop when found, difference is wait time.",
          "id": "550e8400-e29b-41d4-a716-446655440155",
          "intuition": "Stack holds indices of decreasing temps. When warmer found, pop and calculate days.",
          "name": "Monotonic Stack",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,1,4,2,1,1,0,0]",
              "explanation": "Days until next warmer temp",
              "id": "550e8400-e29b-41d4-a716-446655440261",
              "input": "[73,74,75,71,69,72,76,73]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440044",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "daily-temperatures",
      "relatedProblems": [
        "next-greater-element-i"
      ],
      "summary": "Days until warmer temperature. Use monotonic decreasing stack."
    },
    {
      "approaches": [
        {
          "approach": "1. For each token:\n   - If number: push to stack\n   - If operator: pop b, pop a, push a op b\n2. Return stack top",
          "code": "func evalRPN(_ tokens: [String]) -> Int {\n    var stack: [Int] = []\n    \n    for token in tokens {\n        switch token {\n        case \"+\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a + b)\n        case \"-\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a - b)\n        case \"*\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a * b)\n        case \"/\":\n            let b = stack.removeLast(), a = stack.removeLast()\n            stack.append(a / b)\n        default:\n            stack.append(Int(token)!)\n        }\n    }\n    \n    return stack[0]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack for operands",
            "time": "O(n)",
            "timeExplanation": "Process each token once"
          },
          "explanation": "Order matters for - and /: second popped is left operand.",
          "id": "550e8400-e29b-41d4-a716-446655440156",
          "intuition": "Numbers go on stack. Operators pop two, compute, push result.",
          "name": "Stack",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "9",
              "explanation": "((2+1)*3) = 9",
              "id": "550e8400-e29b-41d4-a716-446655440262",
              "input": "[\"2\",\"1\",\"+\",\"3\",\"*\"]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440045",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "evaluate-reverse-polish-notation",
      "relatedProblems": [
        "basic-calculator"
      ],
      "summary": "Evaluate RPN expression. Stack: push numbers, pop two for operators, push result."
    },
    {
      "approaches": [
        {
          "approach": "1. Map: original -> clone\n2. DFS: if node in map, return clone\n3. Create clone, add to map\n4. Recursively clone neighbors",
          "code": "func cloneGraph(_ node: Node?) -> Node? {\n    guard let node = node else { return nil }\n    \n    var cloned: [Int: Node] = [:]\n    \n    func dfs(_ node: Node) -> Node {\n        if let clone = cloned[node.val] { return clone }\n        \n        let clone = Node(node.val)\n        cloned[node.val] = clone\n        \n        for neighbor in node.neighbors {\n            if let n = neighbor {\n                clone.neighbors.append(dfs(n))\n            }\n        }\n        \n        return clone\n    }\n    \n    return dfs(node)\n}",
          "complexity": {
            "space": "O(V)",
            "spaceExplanation": "Hash map stores V nodes",
            "time": "O(V + E)",
            "timeExplanation": "Visit each node and edge"
          },
          "explanation": "Hash map prevents infinite loops by tracking visited nodes.",
          "id": "550e8400-e29b-41d4-a716-446655440157",
          "intuition": "Map original nodes to clones. When visiting, create clone if not exists, recurse for neighbors.",
          "name": "DFS with Hash Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[2,4],[1,3],[2,4],[1,3]]",
              "explanation": "Deep copy preserves structure",
              "id": "550e8400-e29b-41d4-a716-446655440263",
              "input": "[[2,4],[1,3],[2,4],[1,3]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440046",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "clone-graph",
      "relatedProblems": [
        "copy-list-with-random-pointer"
      ],
      "summary": "Deep copy a graph. Use hash map to track cloned nodes, BFS or DFS."
    },
    {
      "approaches": [
        {
          "approach": "1. For each cell (i,j) with value 1:\n2. DFS: mark visited (set to 0), count 1 + area of 4 neighbors\n3. Track maximum area",
          "code": "func maxAreaOfIsland(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let m = grid.count, n = grid[0].count\n    var maxArea = 0\n    \n    func dfs(_ i: Int, _ j: Int) -> Int {\n        guard i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1 else { return 0 }\n        grid[i][j] = 0\n        return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                maxArea = max(maxArea, dfs(i, j))\n            }\n        }\n    }\n    \n    return maxArea\n}",
          "complexity": {
            "space": "O(m*n)",
            "spaceExplanation": "Recursion stack worst case",
            "time": "O(m*n)",
            "timeExplanation": "Visit each cell once"
          },
          "explanation": "Marking as 0 prevents revisiting. Each cell visited once.",
          "id": "550e8400-e29b-41d4-a716-446655440158",
          "intuition": "For each unvisited land cell, DFS to count connected land. Track max area.",
          "name": "DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "Connected 1s form island of size 5",
              "id": "550e8400-e29b-41d4-a716-446655440264",
              "input": "[[0,0,1,0],[1,1,1,0],[0,1,0,0]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440047",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "max-area-of-island",
      "relatedProblems": [
        "number-of-islands",
        "island-perimeter"
      ],
      "summary": "Find largest island area. DFS/BFS from each land cell, mark visited, count area."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS from all border O's, mark as 'S' (safe)\n2. Scan grid: O -> X, S -> O",
          "code": "func solve(_ board: inout [[Character]]) {\n    guard !board.isEmpty else { return }\n    let m = board.count, n = board[0].count\n    \n    func dfs(_ i: Int, _ j: Int) {\n        guard i >= 0 && i < m && j >= 0 && j < n && board[i][j] == \"O\" else { return }\n        board[i][j] = \"S\"\n        dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)\n    }\n    \n    // Mark border-connected O's\n    for i in 0..<m {\n        dfs(i, 0); dfs(i, n-1)\n    }\n    for j in 0..<n {\n        dfs(0, j); dfs(m-1, j)\n    }\n    \n    // Flip: O->X, S->O\n    for i in 0..<m {\n        for j in 0..<n {\n            if board[i][j] == \"O\" { board[i][j] = \"X\" }\n            else if board[i][j] == \"S\" { board[i][j] = \"O\" }\n        }\n    }\n}",
          "complexity": {
            "space": "O(m*n)",
            "spaceExplanation": "Recursion stack",
            "time": "O(m*n)",
            "timeExplanation": "Visit each cell"
          },
          "explanation": "Reverse thinking: instead of finding surrounded, find NOT surrounded from borders.",
          "id": "550e8400-e29b-41d4-a716-446655440159",
          "intuition": "O's connected to border can't be surrounded. Mark them, flip remaining O's to X.",
          "name": "DFS from Border",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]",
              "explanation": "Center O is surrounded and captured",
              "id": "550e8400-e29b-41d4-a716-446655440265",
              "input": "[[\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\"]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440048",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "surrounded-regions",
      "relatedProblems": [
        "number-of-islands"
      ],
      "summary": "Capture surrounded O's. Border-connected O's survive; mark them, then flip rest."
    },
    {
      "approaches": [
        {
          "approach": "1. If text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n2. Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n3. Return dp[m][n]",
          "code": "func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n    let s1 = Array(text1), s2 = Array(text2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1] + 1\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity": {
            "space": "O(m*n)",
            "spaceExplanation": "2D DP array (can optimize to O(n))",
            "time": "O(m*n)",
            "timeExplanation": "Fill m*n table"
          },
          "explanation": "Match extends previous LCS. No match means we must skip one character.",
          "id": "550e8400-e29b-41d4-a716-446655440160",
          "intuition": "dp[i][j] = LCS of text1[0..i-1] and text2[0..j-1]. If match, extend; else take max.",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "LCS is \"ace\"",
              "id": "550e8400-e29b-41d4-a716-446655440266",
              "input": "text1 = \"abcde\", text2 = \"ace\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440049",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "longest-common-subsequence",
      "relatedProblems": [
        "edit-distance",
        "longest-palindromic-subsequence"
      ],
      "summary": "LCS of two strings. DP: if chars match, 1 + LCS of rest; else max of skipping either."
    },
    {
      "approaches": [
        {
          "approach": "1. Base: dp[i][0] = i (delete all), dp[0][j] = j (insert all)\n2. If match: dp[i][j] = dp[i-1][j-1]\n3. Else: 1 + min(replace, insert, delete)",
          "code": "func minDistance(_ word1: String, _ word2: String) -> Int {\n    let s1 = Array(word1), s2 = Array(word2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 0...m { dp[i][0] = i }\n    for j in 0...n { dp[0][j] = j }\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n            }\n        }\n    }\n    \n    return dp[m][n]\n}",
          "complexity": {
            "space": "O(m*n)",
            "spaceExplanation": "2D DP array",
            "time": "O(m*n)",
            "timeExplanation": "Fill m*n table"
          },
          "explanation": "Three choices: replace (i-1,j-1), insert (i,j-1), delete (i-1,j). Take minimum.",
          "id": "550e8400-e29b-41d4-a716-446655440161",
          "intuition": "dp[i][j] = min ops for word1[0..i-1] to word2[0..j-1]. If match, no op; else try all three.",
          "name": "Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "horse -> rorse -> rose -> ros",
              "id": "550e8400-e29b-41d4-a716-446655440267",
              "input": "word1 = \"horse\", word2 = \"ros\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440050",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "edit-distance",
      "relatedProblems": [
        "one-edit-distance",
        "delete-operation-for-two-strings"
      ],
      "summary": "Min operations (insert/delete/replace) to transform word1 to word2. Classic 2D DP."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS returns height of subtree\n2. At each node: update diameter = left + right\n3. Return 1 + max(left, right) as height",
          "code": "func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\n    var diameter = 0\n    \n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        let right = height(node.right)\n        diameter = max(diameter, left + right)\n        return 1 + max(left, right)\n    }\n    \n    _ = height(root)\n    return diameter\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth = height",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Height is longest path to leaf. Diameter uses both sides.",
          "id": "550e8400-e29b-41d4-a716-446655440162",
          "intuition": "Diameter through node = left height + right height. Track max while computing heights.",
          "name": "DFS Height",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Path 4->2->1->3 or 5->2->1->3",
              "id": "550e8400-e29b-41d4-a716-446655440268",
              "input": "[1,2,3,4,5]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440051",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "diameter-of-binary-tree",
      "relatedProblems": [
        "binary-tree-maximum-path-sum"
      ],
      "summary": "Longest path between any two nodes. For each node, diameter through it = leftHeight + rightHeight."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS returns height or -1 if unbalanced\n2. If left or right is -1, return -1\n3. If |left - right| > 1, return -1\n4. Else return 1 + max(left, right)",
          "code": "func isBalanced(_ root: TreeNode?) -> Bool {\n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        if left == -1 { return -1 }\n        let right = height(node.right)\n        if right == -1 { return -1 }\n        if abs(left - right) > 1 { return -1 }\n        return 1 + max(left, right)\n    }\n    return height(root) != -1\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Single pass: check balance while computing height.",
          "id": "550e8400-e29b-41d4-a716-446655440163",
          "intuition": "Compute height bottom-up. Return -1 if unbalanced, propagate up.",
          "name": "DFS Height Check",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Heights differ by at most 1 at each node",
              "id": "550e8400-e29b-41d4-a716-446655440269",
              "input": "[3,9,20,null,null,15,7]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440052",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "balanced-binary-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree"
      ],
      "summary": "Check if height-balanced. At each node, heights of subtrees differ by at most 1."
    },
    {
      "approaches": [
        {
          "approach": "1. Pick pivot, partition array\n2. If pivot position == k-1, found it\n3. Else recurse into correct half",
          "code": "func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n    var nums = nums\n    let target = nums.count - k\n    \n    func partition(_ left: Int, _ right: Int) -> Int {\n        let pivot = nums[right]\n        var i = left\n        for j in left..<right {\n            if nums[j] < pivot {\n                nums.swapAt(i, j)\n                i += 1\n            }\n        }\n        nums.swapAt(i, right)\n        return i\n    }\n    \n    var left = 0, right = nums.count - 1\n    while true {\n        let p = partition(left, right)\n        if p == target { return nums[p] }\n        if p < target { left = p + 1 }\n        else { right = p - 1 }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "In-place",
            "time": "O(n) average",
            "timeExplanation": "Average case, O(n²) worst"
          },
          "explanation": "Average O(n) because we halve search space each time.",
          "id": "550e8400-e29b-41d4-a716-446655440164",
          "intuition": "Partition like QuickSort, but only recurse into the half containing k.",
          "name": "QuickSelect",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5",
              "id": "550e8400-e29b-41d4-a716-446655440270",
              "input": "nums = [3,2,1,5,6,4], k = 2"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440053",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "kth-largest-element-in-an-array",
      "relatedProblems": [
        "kth-largest-element-in-a-stream"
      ],
      "summary": "Find kth largest. Use min-heap of size k, or QuickSelect for O(n) average."
    },
    {
      "approaches": [
        {
          "approach": "1. Count frequencies, find max freq and how many tasks have it\n2. Minimum = (maxFreq - 1) * (n + 1) + numMaxTasks\n3. Answer = max(above, total tasks)",
          "code": "func leastInterval(_ tasks: [Character], _ n: Int) -> Int {\n    var freq = [Int](repeating: 0, count: 26)\n    for task in tasks {\n        freq[Int(task.asciiValue!) - 65] += 1\n    }\n    \n    let maxFreq = freq.max()!\n    let numMaxTasks = freq.filter { $0 == maxFreq }.count\n    \n    let minTime = (maxFreq - 1) * (n + 1) + numMaxTasks\n    return max(minTime, tasks.count)\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Fixed 26-char array",
            "time": "O(n)",
            "timeExplanation": "Count frequencies once"
          },
          "explanation": "Frame built by most frequent task. Other tasks fill gaps or extend if needed.",
          "id": "550e8400-e29b-41d4-a716-446655440165",
          "intuition": "Most frequent task needs (count-1) gaps of size n. Fill gaps with other tasks.",
          "name": "Math/Greedy",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "8",
              "explanation": "A_B_A_B_A_B or similar",
              "id": "550e8400-e29b-41d4-a716-446655440271",
              "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440054",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "task-scheduler",
      "relatedProblems": [
        "reorganize-string"
      ],
      "summary": "Min time to execute tasks with cooldown. Most frequent task defines structure."
    },
    {
      "approaches": [
        {
          "approach": "1. Track currentMax, currentMin, result\n2. For each num: newMax = max(num, num*currentMax, num*currentMin)\n3. newMin = min of same\n4. Update result",
          "code": "func maxProduct(_ nums: [Int]) -> Int {\n    var maxProd = nums[0]\n    var minProd = nums[0]\n    var result = nums[0]\n    \n    for i in 1..<nums.count {\n        let candidates = [nums[i], nums[i] * maxProd, nums[i] * minProd]\n        maxProd = candidates.max()!\n        minProd = candidates.min()!\n        result = max(result, maxProd)\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Three variables",
            "time": "O(n)",
            "timeExplanation": "Single pass"
          },
          "explanation": "A negative times the most negative gives largest. Hence track both.",
          "id": "550e8400-e29b-41d4-a716-446655440166",
          "intuition": "Negative number flips max and min. Track both to handle sign changes.",
          "name": "DP with Min/Max",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "[2,3] has product 6",
              "id": "550e8400-e29b-41d4-a716-446655440272",
              "input": "[2,3,-2,4]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440055",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "maximum-product-subarray",
      "relatedProblems": [
        "maximum-subarray",
        "product-of-array-except-self"
      ],
      "summary": "Max product subarray. Track both max and min (negative * negative = positive)."
    },
    {
      "approaches": [
        {
          "approach": "1. BFS from Pacific edges (top, left)\n2. BFS from Atlantic edges (bottom, right)\n3. Cells in both sets can reach both oceans",
          "code": "func pacificAtlantic(_ heights: [[Int]]) -> [[Int]] {\n    guard !heights.isEmpty else { return [] }\n    let m = heights.count, n = heights[0].count\n    var pacific = Set<[Int]>()\n    var atlantic = Set<[Int]>()\n    \n    func bfs(_ starts: [[Int]], _ reachable: inout Set<[Int]>) {\n        var queue = starts\n        for s in starts { reachable.insert(s) }\n        let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n        \n        while !queue.isEmpty {\n            let curr = queue.removeFirst()\n            for (dr, dc) in dirs {\n                let nr = curr[0] + dr, nc = curr[1] + dc\n                if nr >= 0 && nr < m && nc >= 0 && nc < n &&\n                   !reachable.contains([nr, nc]) &&\n                   heights[nr][nc] >= heights[curr[0]][curr[1]] {\n                    reachable.insert([nr, nc])\n                    queue.append([nr, nc])\n                }\n            }\n        }\n    }\n    \n    var pacificStarts = [[Int]]()\n    var atlanticStarts = [[Int]]()\n    for i in 0..<m {\n        pacificStarts.append([i, 0])\n        atlanticStarts.append([i, n-1])\n    }\n    for j in 0..<n {\n        pacificStarts.append([0, j])\n        atlanticStarts.append([m-1, j])\n    }\n    \n    bfs(pacificStarts, &pacific)\n    bfs(atlanticStarts, &atlantic)\n    \n    return Array(pacific.intersection(atlantic))\n}",
          "complexity": {
            "space": "O(m*n)",
            "spaceExplanation": "Two sets storing cells",
            "time": "O(m*n)",
            "timeExplanation": "Visit each cell at most twice"
          },
          "explanation": "Reverse the problem: find which cells are reachable going uphill from each ocean. Intersection gives answer.",
          "id": "550e8400-e29b-41d4-a716-446655440167",
          "intuition": "Instead of checking each cell, work backwards from oceans. A cell can reach ocean if water can flow TO it from ocean edge (going uphill).",
          "name": "Reverse BFS from Oceans",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
              "explanation": "These cells can flow to both oceans",
              "id": "550e8400-e29b-41d4-a716-446655440273",
              "input": "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440056",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "pacific-atlantic-water-flow",
      "relatedProblems": [
        "number-of-islands",
        "surrounded-regions"
      ],
      "summary": "Find cells that can flow to both Pacific and Atlantic oceans. Use reverse BFS/DFS from ocean edges."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize n components (each node is its own component)\n2. For each edge, union the two nodes\n3. Each successful union decreases component count by 1",
          "code": "func countComponents(_ n: Int, _ edges: [[Int]]) -> Int {\n    var parent = Array(0..<n)\n    var rank = [Int](repeating: 0, count: n)\n    var components = n\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    func union(_ x: Int, _ y: Int) {\n        let px = find(x), py = find(y)\n        if px == py { return }\n        if rank[px] < rank[py] {\n            parent[px] = py\n        } else if rank[px] > rank[py] {\n            parent[py] = px\n        } else {\n            parent[py] = px\n            rank[px] += 1\n        }\n        components -= 1\n    }\n    \n    for edge in edges {\n        union(edge[0], edge[1])\n    }\n    \n    return components\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Parent and rank arrays",
            "time": "O(E * α(n))",
            "timeExplanation": "α is inverse Ackermann, nearly constant"
          },
          "explanation": "Union-Find with path compression and union by rank gives near O(1) operations.",
          "id": "550e8400-e29b-41d4-a716-446655440168",
          "intuition": "Each edge connects two nodes. Union-Find efficiently tracks which nodes are connected.",
          "name": "Union-Find",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Components: {0,1,2} and {3,4}",
              "id": "550e8400-e29b-41d4-a716-446655440274",
              "input": "n=5, edges=[[0,1],[1,2],[3,4]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440057",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "number-of-connected-components-in-an-undirected-graph",
      "relatedProblems": [
        "number-of-islands",
        "graph-valid-tree"
      ],
      "summary": "Count connected components using Union-Find or DFS."
    },
    {
      "approaches": [
        {
          "approach": "1. Check if edges == n-1 (required for tree)\n2. Union-Find: if two nodes already connected, cycle exists\n3. After all unions, check if single component",
          "code": "func validTree(_ n: Int, _ edges: [[Int]]) -> Bool {\n    if edges.count != n - 1 { return false }\n    \n    var parent = Array(0..<n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let p1 = find(edge[0]), p2 = find(edge[1])\n        if p1 == p2 { return false }  // Cycle detected\n        parent[p1] = p2\n    }\n    \n    return true\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Parent array",
            "time": "O(E * α(n))",
            "timeExplanation": "Process each edge with near-constant union-find"
          },
          "explanation": "Adding an edge between already-connected nodes creates a cycle. Tree must have exactly n-1 edges.",
          "id": "550e8400-e29b-41d4-a716-446655440169",
          "intuition": "Tree = connected graph with no cycles. If union finds same root, there's a cycle.",
          "name": "Union-Find Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "4 edges for 5 nodes, no cycles, connected",
              "id": "550e8400-e29b-41d4-a716-446655440275",
              "input": "n=5, edges=[[0,1],[0,2],[0,3],[1,4]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440058",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "graph-valid-tree",
      "relatedProblems": [
        "number-of-connected-components-in-an-undirected-graph",
        "redundant-connection"
      ],
      "summary": "A valid tree has n-1 edges and is fully connected (no cycles)."
    },
    {
      "approaches": [
        {
          "approach": "1. Union-Find with each edge\n2. If two nodes already in same component, return this edge\n3. This gives the last edge forming a cycle",
          "code": "func findRedundantConnection(_ edges: [[Int]]) -> [Int] {\n    let n = edges.count\n    var parent = Array(0...n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let p1 = find(edge[0]), p2 = find(edge[1])\n        if p1 == p2 {\n            return edge\n        }\n        parent[p1] = p2\n    }\n    \n    return []\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Parent array",
            "time": "O(n * α(n))",
            "timeExplanation": "Process n edges with near-constant find"
          },
          "explanation": "The problem guarantees exactly one redundant edge. First edge that creates cycle (when processing in order) is the answer.",
          "id": "550e8400-e29b-41d4-a716-446655440170",
          "intuition": "Process edges in order. When union fails (same component), that's the redundant edge.",
          "name": "Union-Find",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,3]",
              "explanation": "[2,3] creates cycle 1-2-3-1",
              "id": "550e8400-e29b-41d4-a716-446655440276",
              "input": "[[1,2],[1,3],[2,3]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440059",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "redundant-connection",
      "relatedProblems": [
        "graph-valid-tree",
        "redundant-connection-ii"
      ],
      "summary": "Find edge that creates cycle in undirected graph. Last edge that connects already-connected nodes."
    },
    {
      "approaches": [
        {
          "approach": "1. Build pattern map: 'hot' -> ['*ot', 'h*t', 'ho*']\n2. BFS from beginWord\n3. For each word, find neighbors via pattern\n4. First time reaching endWord is shortest",
          "code": "func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n    var wordSet = Set(wordList)\n    if !wordSet.contains(endWord) { return 0 }\n    \n    var queue = [(beginWord, 1)]\n    var visited = Set([beginWord])\n    \n    while !queue.isEmpty {\n        let (word, level) = queue.removeFirst()\n        var chars = Array(word)\n        \n        for i in 0..<chars.count {\n            let original = chars[i]\n            for c in \"abcdefghijklmnopqrstuvwxyz\" {\n                chars[i] = c\n                let newWord = String(chars)\n                if newWord == endWord { return level + 1 }\n                if wordSet.contains(newWord) && !visited.contains(newWord) {\n                    visited.insert(newWord)\n                    queue.append((newWord, level + 1))\n                }\n            }\n            chars[i] = original\n        }\n    }\n    \n    return 0\n}",
          "complexity": {
            "space": "O(M * N)",
            "spaceExplanation": "Queue and visited set",
            "time": "O(M² * N)",
            "timeExplanation": "M = word length, N = word count. Check 26*M neighbors for N words"
          },
          "explanation": "Pattern matching avoids O(26*L) letter substitutions. Map each word to wildcard patterns for O(1) neighbor lookup.",
          "id": "550e8400-e29b-41d4-a716-446655440171",
          "intuition": "Each word connects to words differing by one letter. BFS explores level by level for shortest path.",
          "name": "BFS with Pattern Matching",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "hit -> hot -> dot -> dog -> cog",
              "id": "550e8400-e29b-41d4-a716-446655440277",
              "input": "beginWord=\"hit\", endWord=\"cog\", wordList=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440060",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "word-ladder",
      "relatedProblems": [
        "word-ladder-ii",
        "minimum-genetic-mutation"
      ],
      "summary": "Transform word to target changing one letter at a time. BFS finds shortest path."
    },
    {
      "approaches": [
        {
          "approach": "1. Start from any node\n2. Use min-heap to track cheapest edges to unvisited nodes\n3. Add cheapest edge, mark node visited\n4. Add all edges from new node to heap\n5. Repeat until all nodes connected",
          "code": "func minCostConnectPoints(_ points: [[Int]]) -> Int {\n    let n = points.count\n    var visited = [Bool](repeating: false, count: n)\n    var minCost = [Int](repeating: Int.max, count: n)\n    minCost[0] = 0\n    var totalCost = 0\n    \n    for _ in 0..<n {\n        var minIdx = -1\n        var minVal = Int.max\n        for j in 0..<n {\n            if !visited[j] && minCost[j] < minVal {\n                minVal = minCost[j]\n                minIdx = j\n            }\n        }\n        \n        visited[minIdx] = true\n        totalCost += minVal\n        \n        for j in 0..<n {\n            if !visited[j] {\n                let dist = abs(points[minIdx][0] - points[j][0]) + \n                           abs(points[minIdx][1] - points[j][1])\n                minCost[j] = min(minCost[j], dist)\n            }\n        }\n    }\n    \n    return totalCost\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Visited and minCost arrays",
            "time": "O(n²)",
            "timeExplanation": "n iterations, each scans n nodes"
          },
          "explanation": "Prim's builds MST by always picking minimum weight edge to expand the tree.",
          "id": "550e8400-e29b-41d4-a716-446655440172",
          "intuition": "Greedily add cheapest edge connecting MST to a new node.",
          "name": "Prim's Algorithm",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "20",
              "explanation": "Connect points with minimum total Manhattan distance",
              "id": "550e8400-e29b-41d4-a716-446655440278",
              "input": "[[0,0],[2,2],[3,10],[5,2],[7,0]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440061",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "min-cost-to-connect-all-points",
      "relatedProblems": [
        "minimum-spanning-tree",
        "connecting-cities-with-minimum-cost"
      ],
      "summary": "Minimum spanning tree of points using Manhattan distance. Use Prim's or Kruskal's."
    },
    {
      "approaches": [
        {
          "approach": "1. Build adjacency list\n2. Min-heap with (distance, node), start with (0, source)\n3. Pop minimum, skip if visited\n4. Update neighbors if shorter path found\n5. Return max distance (time for all to receive)",
          "code": "func networkDelayTime(_ times: [[Int]], _ n: Int, _ k: Int) -> Int {\n    var graph = [Int: [(Int, Int)]]()\n    for t in times {\n        graph[t[0], default: []].append((t[1], t[2]))\n    }\n    \n    var dist = [Int: Int]()\n    var heap = [(0, k)]  // (distance, node)\n    \n    while !heap.isEmpty {\n        heap.sort { $0.0 > $1.0 }  // Simple heap simulation\n        let (d, node) = heap.removeLast()\n        \n        if dist[node] != nil { continue }\n        dist[node] = d\n        \n        for (neighbor, weight) in graph[node] ?? [] {\n            if dist[neighbor] == nil {\n                heap.append((d + weight, neighbor))\n            }\n        }\n    }\n    \n    if dist.count != n { return -1 }\n    return dist.values.max()!\n}",
          "complexity": {
            "space": "O(V + E)",
            "spaceExplanation": "Graph and distance storage",
            "time": "O(E log V)",
            "timeExplanation": "Each edge processed once, heap operations O(log V)"
          },
          "explanation": "Dijkstra's works because we always process the closest unvisited node, so its distance is optimal.",
          "id": "550e8400-e29b-41d4-a716-446655440173",
          "intuition": "Greedily process nodes in order of distance from source. Once processed, distance is final.",
          "name": "Dijkstra's Algorithm",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "From node 2: node 1 and 3 at time 1, node 4 at time 2",
              "id": "550e8400-e29b-41d4-a716-446655440279",
              "input": "times=[[2,1,1],[2,3,1],[3,4,1]], n=4, k=2"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440062",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "network-delay-time",
      "relatedProblems": [
        "cheapest-flights-within-k-stops",
        "path-with-minimum-effort"
      ],
      "summary": "Shortest path from source to all nodes. Classic Dijkstra's algorithm."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize distances (source = 0, others = infinity)\n2. Repeat K+1 times:\n   - Copy current distances\n   - Relax all edges using previous distances\n3. Return destination distance",
          "code": "func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\n    var dist = [Int](repeating: Int.max, count: n)\n    dist[src] = 0\n    \n    for _ in 0...k {\n        let prev = dist\n        for f in flights {\n            let from = f[0], to = f[1], price = f[2]\n            if prev[from] != Int.max {\n                dist[to] = min(dist[to], prev[from] + price)\n            }\n        }\n    }\n    \n    return dist[dst] == Int.max ? -1 : dist[dst]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Distance array",
            "time": "O(K * E)",
            "timeExplanation": "K+1 iterations over E edges"
          },
          "explanation": "Each iteration adds one more edge to paths. K+1 edges = K intermediate stops.",
          "id": "550e8400-e29b-41d4-a716-446655440174",
          "intuition": "Bellman-Ford relaxes all edges. K+1 iterations gives paths with at most K stops.",
          "name": "Bellman-Ford with K iterations",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "700",
              "explanation": "0->1->3 costs 700 with 1 stop",
              "id": "550e8400-e29b-41d4-a716-446655440280",
              "input": "n=4, flights=[[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src=0, dst=3, k=1"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440063",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "cheapest-flights-within-k-stops",
      "relatedProblems": [
        "network-delay-time",
        "minimum-cost-to-reach-destination-in-time"
      ],
      "summary": "Shortest path with at most K stops. Modified Bellman-Ford or BFS with pruning."
    },
    {
      "approaches": [
        {
          "approach": "1. Binary search on T from 0 to max elevation\n2. For each T, BFS to check if path exists\n3. Find minimum T where path is possible",
          "code": "func swimInWater(_ grid: [[Int]]) -> Int {\n    let n = grid.count\n    let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    \n    func canReach(_ t: Int) -> Bool {\n        if grid[0][0] > t { return false }\n        var visited = Set<[Int]>()\n        var queue = [[0, 0]]\n        visited.insert([0, 0])\n        \n        while !queue.isEmpty {\n            let curr = queue.removeFirst()\n            if curr == [n-1, n-1] { return true }\n            \n            for (dr, dc) in dirs {\n                let nr = curr[0] + dr, nc = curr[1] + dc\n                if nr >= 0 && nr < n && nc >= 0 && nc < n &&\n                   !visited.contains([nr, nc]) && grid[nr][nc] <= t {\n                    visited.insert([nr, nc])\n                    queue.append([nr, nc])\n                }\n            }\n        }\n        return false\n    }\n    \n    var lo = grid[0][0], hi = n * n - 1\n    while lo < hi {\n        let mid = (lo + hi) / 2\n        if canReach(mid) {\n            hi = mid\n        } else {\n            lo = mid + 1\n        }\n    }\n    \n    return lo\n}",
          "complexity": {
            "space": "O(n²)",
            "spaceExplanation": "Visited set",
            "time": "O(n² log n²)",
            "timeExplanation": "Binary search O(log n²), BFS O(n²) each"
          },
          "explanation": "At time T, all cells with elevation <= T are accessible. Binary search finds minimum viable T.",
          "id": "550e8400-e29b-41d4-a716-446655440175",
          "intuition": "Binary search on time T. Check if path exists using only cells with elevation <= T.",
          "name": "Binary Search + BFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "At t=3, path 0->2->3 or 0->1->3 possible",
              "id": "550e8400-e29b-41d4-a716-446655440281",
              "input": "[[0,2],[1,3]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440064",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "swim-in-rising-water",
      "relatedProblems": [
        "path-with-minimum-effort",
        "trapping-rain-water-ii"
      ],
      "summary": "Find minimum time to swim from top-left to bottom-right. Binary search + BFS or modified Dijkstra."
    },
    {
      "approaches": [
        {
          "approach": "1. Build adjacency list, sort destinations\n2. DFS from 'JFK', greedily visit smallest destination\n3. Add to result in reverse (post-order)\n4. Reverse final result",
          "code": "func findItinerary(_ tickets: [[String]]) -> [String] {\n    var graph = [String: [String]]()\n    for t in tickets {\n        graph[t[0], default: []].append(t[1])\n    }\n    for key in graph.keys {\n        graph[key]?.sort(by: >)  // Reverse sort for pop efficiency\n    }\n    \n    var result = [String]()\n    \n    func dfs(_ airport: String) {\n        while !(graph[airport]?.isEmpty ?? true) {\n            let next = graph[airport]!.removeLast()\n            dfs(next)\n        }\n        result.append(airport)\n    }\n    \n    dfs(\"JFK\")\n    return result.reversed()\n}",
          "complexity": {
            "space": "O(E)",
            "spaceExplanation": "Graph and result storage",
            "time": "O(E log E)",
            "timeExplanation": "Sorting edges dominates"
          },
          "explanation": "Hierholzer's visits each edge exactly once. Sorting ensures lexicographically smallest path.",
          "id": "550e8400-e29b-41d4-a716-446655440176",
          "intuition": "Build itinerary by DFS, adding airports in reverse post-order. Sorted adjacency ensures lexical order.",
          "name": "Hierholzer's Algorithm",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
              "explanation": "Visit all tickets starting from JFK",
              "id": "550e8400-e29b-41d4-a716-446655440282",
              "input": "[[\"MU\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440065",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "reconstruct-itinerary",
      "relatedProblems": [
        "valid-arrangement-of-pairs",
        "cracking-the-safe"
      ],
      "summary": "Find Eulerian path visiting all edges. Use Hierholzer's algorithm with lexical ordering."
    },
    {
      "approaches": [
        {
          "approach": "1. For each cell matching word[0], start DFS\n2. At each step, check if current cell matches current char\n3. Mark cell visited (modify to special char)\n4. Recurse to 4 neighbors for next char\n5. Backtrack: restore cell value\n6. Return true if word fully matched",
          "code": "func exist(_ board: [[Character]], _ word: String) -> Bool {\n    var board = board\n    let m = board.count, n = board[0].count\n    let word = Array(word)\n    \n    func dfs(_ i: Int, _ j: Int, _ k: Int) -> Bool {\n        if k == word.count { return true }\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k] {\n            return false\n        }\n        \n        let temp = board[i][j]\n        board[i][j] = \"#\"  // Mark visited\n        \n        let found = dfs(i+1, j, k+1) || dfs(i-1, j, k+1) ||\n                    dfs(i, j+1, k+1) || dfs(i, j-1, k+1)\n        \n        board[i][j] = temp  // Backtrack\n        return found\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if dfs(i, j, 0) { return true }\n        }\n    }\n    return false\n}",
          "complexity": {
            "space": "O(L)",
            "spaceExplanation": "Recursion stack depth equals word length",
            "time": "O(m * n * 4^L)",
            "timeExplanation": "Try each cell, DFS explores up to 4^L paths where L = word length"
          },
          "explanation": "Backtracking is key: we temporarily mark cells as visited during exploration, then restore them when backtracking. This allows the same cell to be used in different paths.",
          "id": "550e8400-e29b-41d4-a716-446655440177",
          "intuition": "Start from each cell matching first letter. Explore all 4 directions, marking visited cells to avoid cycles.",
          "name": "DFS Backtracking",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Path: A(0,0)->B(0,1)->C(0,2)->C(1,2)->E(2,2)->D(2,1)",
              "id": "550e8400-e29b-41d4-a716-446655440283",
              "input": "board=[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word=\"ABCCED\""
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440066",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "word-search",
      "relatedProblems": [
        "word-search-ii",
        "number-of-islands"
      ],
      "summary": "Find if word exists in grid by traversing adjacent cells. Use DFS with backtracking."
    },
    {
      "approaches": [
        {
          "approach": "1. Compare adjacent words pairwise\n2. First differing char gives edge: words[i][k] -> words[i+1][k]\n3. Build graph and in-degree count\n4. BFS from chars with in-degree 0\n5. If result has all chars, return it; else cycle exists",
          "code": "func alienOrder(_ words: [String]) -> String {\n    var graph = [Character: Set<Character>]()\n    var inDegree = [Character: Int]()\n    \n    // Initialize all characters\n    for word in words {\n        for c in word {\n            graph[c] = graph[c] ?? Set()\n            inDegree[c] = inDegree[c] ?? 0\n        }\n    }\n    \n    // Build graph from adjacent word pairs\n    for i in 0..<words.count - 1 {\n        let w1 = Array(words[i]), w2 = Array(words[i+1])\n        \n        // Check invalid case: prefix comes after longer word\n        if w1.count > w2.count && w1.starts(with: w2) {\n            return \"\"\n        }\n        \n        // Find first differing character\n        for j in 0..<min(w1.count, w2.count) {\n            if w1[j] != w2[j] {\n                if !graph[w1[j]]!.contains(w2[j]) {\n                    graph[w1[j]]!.insert(w2[j])\n                    inDegree[w2[j]]! += 1\n                }\n                break\n            }\n        }\n    }\n    \n    // BFS topological sort\n    var queue = inDegree.filter { $0.value == 0 }.map { $0.key }\n    var result = \"\"\n    \n    while !queue.isEmpty {\n        let c = queue.removeFirst()\n        result.append(c)\n        \n        for next in graph[c]! {\n            inDegree[next]! -= 1\n            if inDegree[next] == 0 {\n                queue.append(next)\n            }\n        }\n    }\n    \n    return result.count == inDegree.count ? result : \"\"\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Graph has at most 26 nodes (alphabet size)",
            "time": "O(C)",
            "timeExplanation": "C = total chars across all words. Process each char once."
          },
          "explanation": "Adjacent sorted words reveal ordering: 'wrt' before 'wrf' means t < f. Edge case: 'abc' before 'ab' is invalid (longer word can't come after prefix).",
          "id": "550e8400-e29b-41d4-a716-446655440178",
          "intuition": "Compare adjacent words to find ordering rules (edges). Build directed graph where edge a->b means a comes before b. Topological sort gives valid ordering.",
          "name": "Topological Sort (BFS)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"wertf\"",
              "explanation": "From comparisons: t<f, w<e, r<t, e<r. Order: w->e->r->t->f",
              "id": "550e8400-e29b-41d4-a716-446655440284",
              "input": "[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440067",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "alien-dictionary",
      "relatedProblems": [
        "course-schedule",
        "course-schedule-ii"
      ],
      "summary": "Derive character ordering from sorted alien words. Build graph from adjacent word comparisons, then topological sort."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize minimum as the first element\n2. Iterate through each element in the array\n3. Update minimum if current element is smaller\n4. Return the minimum value",
          "code": "func findMin(_ nums: [Int]) -> Int {\n    var minVal = nums[0]\n    for num in nums {\n        minVal = min(minVal, num)\n    }\n    return minVal\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using a single variable to track minimum",
            "time": "O(n)",
            "timeExplanation": "We iterate through all n elements once"
          },
          "explanation": "This brute force approach ignores the sorted and rotated properties of the array. While it always finds the correct answer, it's inefficient for large arrays since we check every element. The sorted nature of the array allows for a much faster binary search solution.",
          "id": "40bf4c2b-75e1-454d-a3d4-5916ee3447b7",
          "intuition": "Simply iterate through the array and track the minimum value. This works but doesn't leverage the sorted property of the array.",
          "name": "Linear Scan",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Original sorted array [1,2,3,4,5] was rotated 3 times. Minimum is 1.",
              "id": "dc8d8c94-11b0-4153-ac45-fac7ed400572",
              "input": "nums = [3,4,5,1,2]"
            },
            {
              "expectedOutput": "0",
              "explanation": "Original sorted array [0,1,2,4,5,6,7] was rotated 4 times. Minimum is 0.",
              "id": "abeb6e67-9c81-47df-85e5-f22e8659bc0d",
              "input": "nums = [4,5,6,7,0,1,2]"
            }
          ]
        },
        {
          "approach": "1. Initialize left = 0 and right = nums.count - 1\n2. While left < right:\n   a. Calculate mid = left + (right - left) / 2\n   b. If nums[mid] > nums[right], minimum is in right half: left = mid + 1\n   c. Else, minimum is in left half (including mid): right = mid\n3. Return nums[left] - this is the minimum",
          "code": "func findMin(_ nums: [Int]) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        \n        if nums[mid] > nums[right] {\n            // Minimum is in the right half\n            left = mid + 1\n        } else {\n            // Minimum is in the left half (including mid)\n            right = mid\n        }\n    }\n    \n    return nums[left]\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using a few pointer variables, constant extra space",
            "time": "O(log n)",
            "timeExplanation": "Binary search halves the search space each iteration, giving logarithmic time"
          },
          "explanation": "The key observation is that in a rotated sorted array, one half is always properly sorted. If nums[mid] > nums[right], the rotation pivot (minimum) must be in the right half because the left half is sorted but wraps around. If nums[mid] <= nums[right], the right half is sorted, so the minimum is in the left half or at mid. We keep narrowing until left equals right, pointing to the minimum.",
          "id": "d00b0db8-ab9e-426f-8fe9-ab001db8c3c0",
          "intuition": "In a rotated sorted array, the minimum element is at the pivot point where the rotation happened. We can use binary search: if the middle element is greater than the rightmost element, the minimum must be in the right half (the pivot is there). Otherwise, it's in the left half including middle.",
          "name": "Binary Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "mid=2 (value 5) > right value 2, so search right. mid=3 (value 1) <= right value 2, narrow to left=right=3. Return nums[3]=1.",
              "id": "e208782f-9974-4f4d-9fb7-ba5a78fb4920",
              "input": "nums = [3,4,5,1,2]"
            },
            {
              "expectedOutput": "0",
              "explanation": "Binary search finds pivot at index 4 where value drops from 7 to 0.",
              "id": "51176458-db68-4792-b782-cd3659e978d3",
              "input": "nums = [4,5,6,7,0,1,2]"
            },
            {
              "expectedOutput": "11",
              "explanation": "Array not rotated (or rotated n times). nums[mid] <= nums[right] always, converges to index 0.",
              "id": "8b6880ea-660a-4d8b-806f-7f65ece839a2",
              "input": "nums = [11,13,15,17]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Small array rotated once. nums[0]=2 > nums[1]=1, so left becomes 1, return nums[1]=1.",
              "id": "bfa3764d-9edf-43bb-8e8a-5e030a5de1e4",
              "input": "nums = [2,1]"
            }
          ]
        }
      ],
      "id": "aa1da3de-604d-4d1c-ae02-2f686cde5f5e",
      "lastUpdated": "2026-02-06T08:21:29Z",
      "problemSlug": "find-minimum-in-rotated-sorted-array",
      "relatedProblems": [
        "find-minimum-in-rotated-sorted-array-ii",
        "search-in-rotated-sorted-array",
        "search-in-rotated-sorted-array-ii"
      ],
      "summary": "Find the minimum element in a sorted array that has been rotated. The key insight is that the minimum is at the rotation pivot point, and we can use binary search to find it in O(log n) time by checking which half is sorted."
    },
    {
      "approaches": [
        {
          "approach": "1. Handle negative numbers (always false - minus sign)\n2. Convert number to string\n3. Compare string with its reverse\n4. Return true if equal",
          "code": "func isPalindrome(_ x: Int) -> Bool {\n    if x < 0 { return false }\n    let str = String(x)\n    return str == String(str.reversed())\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "String representation requires O(n) space for n digits",
            "time": "O(n)",
            "timeExplanation": "Where n is the number of digits. String conversion and reversal are O(n)"
          },
          "explanation": "This approach leverages string manipulation to easily reverse and compare. While intuitive, it requires O(n) extra space for the string representation and is slower due to string operations.",
          "id": "2609cabd-f74e-42da-8898-cdd74fa64ee8",
          "intuition": "Convert the number to a string and check if it equals its reverse. Simple but uses extra space for the string.",
          "name": "String Conversion",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "121 reads as 121 from left to right and from right to left",
              "id": "f91595b0-f627-43d6-bbad-deb874124a20",
              "input": "x = 121"
            },
            {
              "expectedOutput": "false",
              "explanation": "From left to right it reads -121, from right to left it's 121-. Not a palindrome.",
              "id": "7ee1455f-2207-4316-b3a3-ec0d5d758abe",
              "input": "x = -121"
            }
          ]
        },
        {
          "approach": "1. Return false for negative numbers\n2. Return false if number ends in 0 (except 0 itself)\n3. Reverse digits until reversed >= remaining\n4. Compare: for even digits, they should be equal; for odd digits, ignore middle digit",
          "code": "func isPalindrome(_ x: Int) -> Bool {\n    // Negative numbers and numbers ending in 0 (except 0) aren't palindromes\n    if x < 0 || (x % 10 == 0 && x != 0) {\n        return false\n    }\n    \n    var num = x\n    var reversed = 0\n    \n    // Reverse half of the number\n    while num > reversed {\n        reversed = reversed * 10 + num % 10\n        num /= 10\n    }\n    \n    // For even length: num == reversed\n    // For odd length: num == reversed / 10 (skip middle digit)\n    return num == reversed || num == reversed / 10\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using a few integer variables",
            "time": "O(log n)",
            "timeExplanation": "We process half the digits, and number of digits is log10(n)"
          },
          "explanation": "We reverse the second half of the number by repeatedly taking the last digit (x % 10) and building the reversed number. We stop when the reversed number is >= the remaining original. For even-length palindromes, they're equal. For odd-length, we divide reversed by 10 to skip the middle digit.",
          "id": "b5146218-4809-42d9-8647-fbdc114878ef",
          "intuition": "Instead of reversing the entire number (which could overflow), reverse only half. If it's a palindrome, the first half equals the reversed second half.",
          "name": "Reverse Half Number",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "After loop: num=1, reversed=12. num == reversed/10 (1 == 1). True.",
              "id": "5718997d-f710-45de-b838-64e2db415d31",
              "input": "x = 121"
            },
            {
              "expectedOutput": "true",
              "explanation": "After loop: num=12, reversed=12. num == reversed. True.",
              "id": "2d930f56-c792-4a13-8f8a-e038405f6f9a",
              "input": "x = 1221"
            },
            {
              "expectedOutput": "false",
              "explanation": "Ends in 0 but isn't 0, so immediately return false.",
              "id": "d189e09c-1659-4ff1-9c5d-69f1a6d4c8dc",
              "input": "x = 10"
            },
            {
              "expectedOutput": "true",
              "explanation": "0 is a palindrome.",
              "id": "f0d193bb-e677-4e0b-94a7-6da88695f5a3",
              "input": "x = 0"
            }
          ]
        }
      ],
      "id": "0840dd80-aae7-4974-a215-3c35e374b0a3",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "palindrome-number",
      "relatedProblems": [
        "palindrome-linked-list",
        "valid-palindrome",
        "valid-palindrome-ii"
      ],
      "summary": "Determine if an integer reads the same forwards and backwards. The optimal approach reverses half the number and compares, avoiding string conversion and potential overflow."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a map of Roman symbols to values\n2. Start from the rightmost character\n3. Track the previous value seen\n4. If current < previous, subtract; else add\n5. Update previous and continue left",
          "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    var result = 0\n    var prev = 0\n    \n    for char in s.reversed() {\n        let curr = values[char, default: 0]\n        if curr < prev {\n            result -= curr\n        } else {\n            result += curr\n        }\n        prev = curr\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Fixed-size map and a few variables",
            "time": "O(n)",
            "timeExplanation": "Single pass through the string of length n"
          },
          "explanation": "Roman numerals are mostly additive (VI = 5+1 = 6), but use subtraction for cases like IV (4) and IX (9). By scanning right to left, whenever we see a smaller value before a larger one, we know to subtract. This elegantly handles all subtraction cases.",
          "id": "70873fcb-4207-4214-97fd-8a61effb555a",
          "intuition": "Process from right to left, adding values. If current value is less than the previous value we added, subtract instead (handles IV, IX, etc.).",
          "name": "Right to Left Scan",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "III = 1 + 1 + 1 = 3",
              "id": "288ded23-f065-4af0-af7f-07fe355ef3ab",
              "input": "s = \"III\""
            },
            {
              "expectedOutput": "58",
              "explanation": "L = 50, V = 5, III = 3. Total = 58",
              "id": "89138bab-f104-4fb0-8b85-fc4ba1dde1c5",
              "input": "s = \"LVIII\""
            },
            {
              "expectedOutput": "1994",
              "explanation": "M=1000, CM=900, XC=90, IV=4. Total = 1994",
              "id": "22b5dbe2-5629-4e0d-9e26-7334cee2bca7",
              "input": "s = \"MCMXCIV\""
            }
          ]
        },
        {
          "approach": "1. Create value map\n2. Iterate through string with index\n3. If current value < next value, subtract current\n4. Otherwise add current\n5. Return total",
          "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    let chars = Array(s)\n    var result = 0\n    \n    for i in 0..<chars.count {\n        let curr = values[chars[i], default: 0]\n        let next = i + 1 < chars.count ? values[chars[i + 1], default: 0] : 0\n        \n        if curr < next {\n            result -= curr\n        } else {\n            result += curr\n        }\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Converting string to array takes O(n) space",
            "time": "O(n)",
            "timeExplanation": "Single pass through the string"
          },
          "explanation": "This approach is more intuitive as it processes the string in reading order. We peek at the next character to decide whether to add or subtract. When we see 'I' followed by 'V', we know it's 4 (subtract 1), not 6 (add 1).",
          "id": "35093bc0-4fbf-426d-828b-66d998bdcc28",
          "intuition": "Process left to right. Look ahead to the next character - if current is less than next, subtract current; otherwise add it.",
          "name": "Left to Right with Lookahead",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "I(1) < V(5), so subtract 1, then add 5. Result: -1 + 5 = 4",
              "id": "4706b80f-4754-4a1c-948f-859b9892d237",
              "input": "s = \"IV\""
            },
            {
              "expectedOutput": "9",
              "explanation": "I(1) < X(10), so -1 + 10 = 9",
              "id": "e81ef371-d1be-42e9-8830-53dd669974d5",
              "input": "s = \"IX\""
            },
            {
              "expectedOutput": "42",
              "explanation": "X < L, so -10. L > I, so +50. I < I? No, +1. I, +1. Total: -10+50+1+1 = 42",
              "id": "5390fbf7-6ce0-4568-9520-13867563a55e",
              "input": "s = \"XLII\""
            }
          ]
        }
      ],
      "id": "3552812e-ed96-4ee4-8ba7-50d13af418de",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "roman-to-integer",
      "relatedProblems": [
        "integer-to-roman"
      ],
      "summary": "Convert a Roman numeral string to an integer. The key insight is that when a smaller value appears before a larger value, we subtract it; otherwise, we add it."
    },
    {
      "approaches": [
        {
          "approach": "1. Handle empty array edge case\n2. Use first string as reference\n3. For each character position i in first string:\n   a. Check if position i exists in all strings\n   b. Check if all strings have same character at position i\n   c. If mismatch or end, return prefix so far\n4. Return first string if loop completes",
          "code": "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    let first = Array(strs[0])\n    \n    for i in 0..<first.count {\n        let char = first[i]\n        for str in strs {\n            let arr = Array(str)\n            if i >= arr.count || arr[i] != char {\n                return String(first[0..<i])\n            }\n        }\n    }\n    \n    return strs[0]\n}",
          "complexity": {
            "space": "O(m)",
            "spaceExplanation": "Converting first string to array takes O(m) where m is its length",
            "time": "O(S)",
            "timeExplanation": "S is the sum of all characters in all strings. Worst case compares all characters."
          },
          "explanation": "We iterate through character positions (columns) rather than strings (rows). At each position, we verify all strings have the same character. This is efficient when the common prefix is short, as we stop early on mismatch.",
          "id": "4bf80104-769c-45fc-acc5-bec036b84363",
          "intuition": "Compare characters column by column (same position across all strings). Stop when we find a mismatch or reach the end of any string.",
          "name": "Vertical Scanning",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"fl\"",
              "explanation": "All start with 'f', then 'l', then differ at position 2 (o vs i)",
              "id": "ee631f8a-80b4-436a-a9e9-a8b65def5dff",
              "input": "strs = [\"flower\",\"flow\",\"flight\"]"
            },
            {
              "expectedOutput": "\"\"",
              "explanation": "No common prefix - first characters differ (d vs r vs c)",
              "id": "2bab7c2c-383d-4f33-bfd5-5d2e8c252298",
              "input": "strs = [\"dog\",\"racecar\",\"car\"]"
            }
          ]
        },
        {
          "approach": "1. Start with prefix = first string\n2. For each subsequent string:\n   a. While string doesn't start with prefix\n   b. Remove last character from prefix\n   c. If prefix becomes empty, return \"\"\n3. Return prefix",
          "code": "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    var prefix = strs[0]\n    \n    for i in 1..<strs.count {\n        while !strs[i].hasPrefix(prefix) {\n            prefix = String(prefix.dropLast())\n            if prefix.isEmpty { return \"\" }\n        }\n    }\n    \n    return prefix\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using the prefix variable, no extra data structures",
            "time": "O(S)",
            "timeExplanation": "S is sum of all characters. Worst case: all strings identical, we compare all."
          },
          "explanation": "We assume the entire first string is the common prefix, then trim it down as needed when comparing with each string. If a string doesn't start with our current prefix, we shorten the prefix until it does.",
          "id": "e0ca2b94-8cdf-406d-8c18-8af36fd49823",
          "intuition": "Start with the first string as the prefix. Iteratively shrink it by comparing with each subsequent string until it matches as a prefix of all strings.",
          "name": "Horizontal Scanning",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "\"fl\"",
              "explanation": "Start with 'flower'. 'flow' doesn't have prefix 'flower', shrink to 'flowe', 'flow', then matches. 'flight' doesn't have prefix 'flow', shrink to 'flo', 'fl', matches.",
              "id": "9e30c508-a50b-4b6b-81cb-2cbf031ef19c",
              "input": "strs = [\"flower\",\"flow\",\"flight\"]"
            },
            {
              "expectedOutput": "\"a\"",
              "explanation": "Single string - the entire string is the common prefix",
              "id": "eade3dd4-0be4-4281-bb62-822212eb0118",
              "input": "strs = [\"a\"]"
            },
            {
              "expectedOutput": "\"\"",
              "explanation": "Empty string means no common prefix possible",
              "id": "0134b93a-0905-4121-aaaa-2adb99922852",
              "input": "strs = [\"\"]"
            }
          ]
        }
      ],
      "id": "516ec92a-4848-482b-a3ff-81abccb0745a",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "longest-common-prefix",
      "relatedProblems": [
        "longest-common-suffix"
      ],
      "summary": "Find the longest common prefix among an array of strings. Compare characters at each position across all strings until a mismatch is found or a string ends."
    },
    {
      "approaches": [
        {
          "approach": "1. Handle empty array edge case\n2. Initialize write pointer at index 1 (first element is always unique)\n3. Scan from index 1 with read pointer\n4. When current element differs from previous, write it and advance write pointer\n5. Return write pointer value (count of unique elements)",
          "code": "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 1\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[i - 1] {\n            nums[writeIndex] = nums[i]\n            writeIndex += 1\n        }\n    }\n    \n    return writeIndex\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "In-place modification, only using pointer variables",
            "time": "O(n)",
            "timeExplanation": "Single pass through the array of n elements"
          },
          "explanation": "The key insight is that in a sorted array, duplicates are consecutive. We maintain a 'write' position where the next unique element should go. As we scan, whenever we find a new value (different from previous), we write it to the write position. The array before the write pointer contains all unique elements.",
          "id": "20cdf256-68d7-4455-885b-95d4a0b885cd",
          "intuition": "Since the array is sorted, duplicates are adjacent. Use a slow pointer to track where to write the next unique element, and a fast pointer to scan through the array.",
          "name": "Two Pointers (In-Place)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2, nums = [1,2,_]",
              "explanation": "Two unique elements: 1 and 2. Array becomes [1,2,...] with returned length 2.",
              "id": "db20a2f5-5ca6-42f3-bcbd-1c43646c1e7d",
              "input": "nums = [1,1,2]"
            },
            {
              "expectedOutput": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
              "explanation": "Five unique elements: 0,1,2,3,4. Each written once to front of array.",
              "id": "80edfa7d-0102-4dcb-a2a8-59607c8691a7",
              "input": "nums = [0,0,1,1,1,2,2,3,3,4]"
            },
            {
              "expectedOutput": "1, nums = [1]",
              "explanation": "Single element is always unique.",
              "id": "4693e995-554e-4fd0-848b-44b9ff73abbd",
              "input": "nums = [1]"
            }
          ]
        },
        {
          "approach": "1. Handle empty array\n2. Write pointer starts at 0 (first element always kept)\n3. For each element from index 1:\n   a. If different from element at write pointer, increment write pointer and copy\n4. Return write pointer + 1",
          "code": "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 0\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[writeIndex] {\n            writeIndex += 1\n            nums[writeIndex] = nums[i]\n        }\n    }\n    \n    return writeIndex + 1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using index variables, modification is in-place",
            "time": "O(n)",
            "timeExplanation": "Single pass through all n elements"
          },
          "explanation": "This variant compares the current element with the last unique element we've written (at writeIndex). This pattern extends naturally to 'Remove Duplicates II' where we allow at most 2 of each - just compare with writeIndex-1 instead.",
          "id": "0272bf65-0bcc-4895-a40b-6077271a1d22",
          "intuition": "Instead of comparing with the previous element, compare with the last written unique element. This makes the logic cleaner for extensions like allowing k duplicates.",
          "name": "Two Pointers (Compare with Write Position)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2, nums = [1,2,_]",
              "explanation": "writeIndex=0. i=1: nums[1]=1 == nums[0]=1, skip. i=2: nums[2]=2 != nums[0]=1, writeIndex=1, nums[1]=2. Return 2.",
              "id": "91c1e2a4-1874-4392-870e-964c650624f7",
              "input": "nums = [1,1,2]"
            },
            {
              "expectedOutput": "0",
              "explanation": "Empty array returns 0.",
              "id": "edceb704-906a-4dd6-99ef-a1f14c0f262c",
              "input": "nums = []"
            },
            {
              "expectedOutput": "3, nums = [1,2,3]",
              "explanation": "All unique, no changes needed. writeIndex moves to 2, return 3.",
              "id": "7a0c3408-36ef-4450-b754-7eb88078006a",
              "input": "nums = [1,2,3]"
            }
          ]
        }
      ],
      "id": "32578f5a-83f9-4f6f-b4bd-a4f2b7184bba",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "remove-duplicates-from-sorted-array",
      "relatedProblems": [
        "remove-duplicates-from-sorted-array-ii",
        "remove-element",
        "move-zeroes"
      ],
      "summary": "Remove duplicates from a sorted array in-place, returning the count of unique elements. Use two pointers: one for the write position of unique elements, one to scan through the array."
    },
    {
      "approaches": [
        {
          "approach": "1. Use a frequency map for characters in current window\n2. Track the max frequency of any character in current window\n3. Expand window by moving right pointer\n4. If (window size - maxFreq) > k, shrink from left\n5. Update result with current window size\n6. Return maximum window size found",
          "code": "func characterReplacement(_ s: String, _ k: Int) -> Int {\n    let chars = Array(s)\n    var freq: [Character: Int] = [:]\n    var maxFreq = 0\n    var left = 0\n    var result = 0\n    \n    for right in 0..<chars.count {\n        // Add right character to window\n        freq[chars[right], default: 0] += 1\n        maxFreq = max(maxFreq, freq[chars[right]]!)\n        \n        // Window size - maxFreq = chars we need to replace\n        // If > k, shrink window from left\n        while (right - left + 1) - maxFreq > k {\n            freq[chars[left]]! -= 1\n            left += 1\n        }\n        \n        result = max(result, right - left + 1)\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Frequency map has at most 26 entries (uppercase letters)",
            "time": "O(n)",
            "timeExplanation": "Each character is added and removed from window at most once"
          },
          "explanation": "The key insight is that for any window, the minimum replacements needed equals (window length - frequency of most common character). If this exceeds k, the window is invalid. We don't need to decrease maxFreq when shrinking because we only care about finding a larger valid window - if maxFreq was achieved before, we need at least that many of one character to beat our current best.",
          "id": "dac3e197-d96c-4c89-ac7b-f44e049ffb02",
          "intuition": "Maintain a window where (window size - count of most frequent char) <= k. This means we can replace the non-majority characters to make them all the same. Expand right, shrink left when invalid.",
          "name": "Sliding Window with Frequency Count",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Replace both A's with B's (or vice versa) to get \"BBBB\" or \"AAAA\". Length = 4.",
              "id": "d4103717-7b61-4ffe-8e1b-22495a4ae24c",
              "input": "s = \"ABAB\", k = 2"
            },
            {
              "expectedOutput": "4",
              "explanation": "Replace the B at index 3 to get \"AAAAABA\". Longest same-char substring is \"AAAA\" with length 4.",
              "id": "a20faea5-b299-4b45-bd5d-255daa5124c1",
              "input": "s = \"AABABBA\", k = 1"
            }
          ]
        },
        {
          "approach": "1. Same frequency tracking and maxFreq\n2. When window becomes invalid, shift both left and right (window size stays same)\n3. Only update result when window is valid\n4. Return final window size",
          "code": "func characterReplacement(_ s: String, _ k: Int) -> Int {\n    let chars = Array(s)\n    var freq: [Character: Int] = [:]\n    var maxFreq = 0\n    var left = 0\n    \n    for right in 0..<chars.count {\n        freq[chars[right], default: 0] += 1\n        maxFreq = max(maxFreq, freq[chars[right]]!)\n        \n        // If invalid, slide window (don't shrink, just shift)\n        if (right - left + 1) - maxFreq > k {\n            freq[chars[left]]! -= 1\n            left += 1\n        }\n    }\n    \n    // Final window size is our answer\n    return chars.count - left\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Frequency map bounded by alphabet size (26)",
            "time": "O(n)",
            "timeExplanation": "Single pass, no inner loop - each pointer moves at most n times"
          },
          "explanation": "This optimization works because we're looking for the maximum window. Once we achieve a window of size w, there's no point checking smaller windows. When invalid, we slide the entire window right (maintaining size) rather than shrinking. The window only grows when we find a better maxFreq.",
          "id": "6450f4c5-35fc-4dac-b904-cde41c4c828e",
          "intuition": "We can skip the while loop by only ever growing or shifting the window, never shrinking it. Since we want the maximum window, once we find a valid window of size w, we only care about windows of size > w.",
          "name": "Sliding Window (Optimized - No Shrink Loop)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Window grows to size 4 and stays valid throughout.",
              "id": "59707323-3700-44f9-ae26-aab83890b26a",
              "input": "s = \"ABAB\", k = 2"
            },
            {
              "expectedOutput": "4",
              "explanation": "All same characters, no replacement needed. Window = entire string.",
              "id": "713e474b-4439-4af2-9d4e-aaa52629de6d",
              "input": "s = \"AAAA\", k = 0"
            },
            {
              "expectedOutput": "1",
              "explanation": "With k=0, can't replace anything. Best is single character.",
              "id": "a5d4d816-e3a9-42c5-a7f9-85057c9668f7",
              "input": "s = \"ABCD\", k = 0"
            }
          ]
        }
      ],
      "id": "2f7967f8-0288-408c-9e14-67efd5d58556",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "longest-repeating-character-replacement",
      "relatedProblems": [
        "longest-substring-without-repeating-characters",
        "longest-substring-with-at-most-k-distinct-characters",
        "max-consecutive-ones-iii"
      ],
      "summary": "Find the length of the longest substring where you can replace at most k characters to make all characters the same. Use sliding window: expand right, track most frequent character, shrink left when replacements needed exceed k."
    },
    {
      "approaches": [
        {
          "approach": "1. Transpose the matrix: swap matrix[i][j] with matrix[j][i] for all i < j\n2. Reverse each row: swap elements from start and end moving inward\n3. The matrix is now rotated 90° clockwise",
          "code": "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    // Step 1: Transpose\n    for i in 0..<n {\n        for j in i+1..<n {\n            let temp = matrix[i][j]\n            matrix[i][j] = matrix[j][i]\n            matrix[j][i] = temp\n        }\n    }\n    \n    // Step 2: Reverse each row\n    for i in 0..<n {\n        matrix[i].reverse()\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "In-place modification, only using temp variable for swaps",
            "time": "O(n²)",
            "timeExplanation": "We visit each element twice: once for transpose, once for reverse"
          },
          "explanation": "Consider element at position (i, j). After transpose, it moves to (j, i). After reversing the row, it moves to (j, n-1-i). This is exactly where it should be after a 90° clockwise rotation. The transpose swaps across the main diagonal, and reversing rows completes the rotation. Both operations are O(n²) but simple to implement.",
          "id": "933e672d-34b9-447e-a76c-09644d8f7918",
          "intuition": "A 90° clockwise rotation can be decomposed into two simpler operations: first transpose the matrix (swap rows and columns), then reverse each row. This avoids complex index math.",
          "name": "Transpose + Reverse",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[7,4,1],[8,5,2],[9,6,3]]",
              "explanation": "After transpose: [[1,4,7],[2,5,8],[3,6,9]]. After reversing rows: [[7,4,1],[8,5,2],[9,6,3]]",
              "id": "834ddbb1-2512-461c-8d69-89990cdb3ac4",
              "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
              "explanation": "4x4 matrix rotated 90° clockwise",
              "id": "29336c48-3e1e-4719-9b3e-edc488e0bc5e",
              "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]"
            }
          ]
        },
        {
          "approach": "1. Process layers from outside to inside (0 to n/2)\n2. For each layer, rotate elements in groups of 4\n3. For position i in current layer: save top, move left→top, bottom→left, right→bottom, saved→right\n4. Continue until all layers processed",
          "code": "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    for layer in 0..<n/2 {\n        let first = layer\n        let last = n - 1 - layer\n        \n        for i in first..<last {\n            let offset = i - first\n            \n            // Save top\n            let top = matrix[first][i]\n            \n            // Left -> Top\n            matrix[first][i] = matrix[last - offset][first]\n            \n            // Bottom -> Left\n            matrix[last - offset][first] = matrix[last][last - offset]\n            \n            // Right -> Bottom\n            matrix[last][last - offset] = matrix[i][last]\n            \n            // Top -> Right\n            matrix[i][last] = top\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only one temp variable regardless of matrix size",
            "time": "O(n²)",
            "timeExplanation": "Each element is moved exactly once"
          },
          "explanation": "We process the matrix in concentric square layers. For each layer, we rotate 4 elements at a time that form a rotation cycle. Element at top goes to right, right goes to bottom, bottom goes to left, left goes to top. We use one temp variable to facilitate this 4-way swap. This directly implements the rotation without decomposing into simpler operations.",
          "id": "77b504e7-773e-49d5-b46f-a0b83dd6a98e",
          "intuition": "Rotate the matrix layer by layer, from the outermost layer inward. For each position in a layer, rotate four cells simultaneously in a cycle.",
          "name": "Rotate Four Cells at a Time",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[3,1],[4,2]]",
              "explanation": "2x2 has one layer. Rotate: 1→right, 2→bottom, 4→left, 3→top",
              "id": "2a7b75f5-a5b4-47ee-ab9f-9dc915b99de3",
              "input": "matrix = [[1,2],[3,4]]"
            },
            {
              "expectedOutput": "[[1]]",
              "explanation": "1x1 matrix has no layers to rotate (n/2 = 0)",
              "id": "b97b5b40-5421-465f-836a-767045b6c098",
              "input": "matrix = [[1]]"
            }
          ]
        }
      ],
      "id": "49fa1410-d23d-4411-a6a0-e931a35c7a76",
      "lastUpdated": "2026-02-06T08:31:51Z",
      "problemSlug": "rotate-image",
      "relatedProblems": [
        "rotate-array",
        "determine-whether-matrix-can-be-obtained-by-rotation"
      ],
      "summary": "Rotate an n×n matrix 90 degrees clockwise in-place. The key insight is that rotation equals transpose + reverse each row, or you can rotate layer by layer from outside in."
    },
    {
      "approaches": [
        {
          "approach": "1. Create sets to store row and column indices that have zeros\n2. Scan matrix, add row/col indices to sets when we find a zero\n3. Scan matrix again, set cell to 0 if its row or column is in the sets",
          "code": "func setZeroes(_ matrix: inout [[Int]]) {\n    let m = matrix.count\n    let n = matrix[0].count\n    var zeroRows = Set<Int>()\n    var zeroCols = Set<Int>()\n    \n    // Find zeros\n    for i in 0..<m {\n        for j in 0..<n {\n            if matrix[i][j] == 0 {\n                zeroRows.insert(i)\n                zeroCols.insert(j)\n            }\n        }\n    }\n    \n    // Set zeros\n    for i in 0..<m {\n        for j in 0..<n {\n            if zeroRows.contains(i) || zeroCols.contains(j) {\n                matrix[i][j] = 0\n            }\n        }\n    }\n}",
          "complexity": {
            "space": "O(m + n)",
            "spaceExplanation": "Sets can store at most m rows and n columns",
            "time": "O(m × n)",
            "timeExplanation": "Two passes through all m×n elements"
          },
          "explanation": "We separate the 'finding zeros' phase from the 'setting zeros' phase to avoid the cascade problem where newly set zeros would incorrectly trigger more zeros. The sets give us O(1) lookup to check if a row or column should be zeroed.",
          "id": "d5d56952-c02a-469e-babc-30e33f5267d7",
          "intuition": "First pass: record which rows and columns contain zeros. Second pass: set those rows and columns to zero. Simple but uses O(m+n) extra space.",
          "name": "Extra Space with Sets",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1,0,1],[0,0,0],[1,0,1]]",
              "explanation": "Zero at (1,1) → row 1 and column 1 become zeros",
              "id": "18a901d8-7ec7-4cd5-9012-133dfb29dc4b",
              "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
              "explanation": "Zeros at (0,0) and (0,3) → row 0, col 0, col 3 become zeros",
              "id": "df4ce654-93b3-48e5-af64-3d9872b62da6",
              "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]"
            }
          ]
        },
        {
          "approach": "1. Check if first row/column originally have zeros (save this info)\n2. Use first row to mark which columns should be zero\n3. Use first column to mark which rows should be zero\n4. Zero out cells based on markers (skip first row/col)\n5. Finally, zero out first row/column if needed",
          "code": "func setZeroes(_ matrix: inout [[Int]]) {\n    let m = matrix.count\n    let n = matrix[0].count\n    var firstColZero = false\n    \n    // Use first row and column as markers\n    for i in 0..<m {\n        if matrix[i][0] == 0 {\n            firstColZero = true\n        }\n        for j in 1..<n {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    \n    // Zero out cells based on markers (process from bottom-right)\n    for i in (1..<m).reversed() {\n        for j in (1..<n).reversed() {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    \n    // Zero out first row if needed\n    if matrix[0][0] == 0 {\n        for j in 0..<n {\n            matrix[0][j] = 0\n        }\n    }\n    \n    // Zero out first column if needed\n    if firstColZero {\n        for i in 0..<m {\n            matrix[i][0] = 0\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using one boolean variable, markers stored in matrix itself",
            "time": "O(m × n)",
            "timeExplanation": "Two passes through the matrix"
          },
          "explanation": "We repurpose matrix[0][j] to indicate 'column j should be zeroed' and matrix[i][0] to indicate 'row i should be zeroed'. Since these markers share cell (0,0), we use a separate variable for the first column. We process inner cells first, then handle the first row/column last to preserve our markers until they're no longer needed.",
          "id": "6f14e90d-231f-4292-ba06-31badbee9f10",
          "intuition": "Use the first row and first column of the matrix itself as markers. This eliminates extra space, but we need special handling for the first row/column themselves.",
          "name": "O(1) Space - First Row/Col as Markers",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[1,0,1],[0,0,0],[1,0,1]]",
              "explanation": "matrix[1][0]=0 marks row 1, matrix[0][1]=0 marks col 1",
              "id": "e34dbe64-1945-46ab-9e1b-a575842a39c8",
              "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput": "[[0,0],[0,0]]",
              "explanation": "Both rows and columns get zeroed due to diagonal zeros",
              "id": "79abf255-2aea-47e6-a66c-847d3965a42b",
              "input": "matrix = [[1,0],[0,1]]"
            }
          ]
        }
      ],
      "id": "c27abb9e-e150-414f-b57b-89af2ebfaea8",
      "lastUpdated": "2026-02-06T08:31:51Z",
      "problemSlug": "set-matrix-zeroes",
      "relatedProblems": [
        "game-of-life"
      ],
      "summary": "If an element is 0, set its entire row and column to 0. The challenge is doing this in-place without using extra space proportional to matrix size. Use the first row/column as markers."
    },
    {
      "approaches": [
        {
          "approach": "1. Create 9 sets for rows, 9 for columns, 9 for boxes\n2. Iterate through each cell\n3. For non-empty cells, check if number exists in its row/col/box set\n4. If duplicate found, return false\n5. Otherwise, add number to all three sets",
          "code": "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = Array(repeating: Set<Character>(), count: 9)\n    var cols = Array(repeating: Set<Character>(), count: 9)\n    var boxes = Array(repeating: Set<Character>(), count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let boxIndex = (i / 3) * 3 + (j / 3)\n            \n            if rows[i].contains(char) ||\n               cols[j].contains(char) ||\n               boxes[boxIndex].contains(char) {\n                return false\n            }\n            \n            rows[i].insert(char)\n            cols[j].insert(char)\n            boxes[boxIndex].insert(char)\n        }\n    }\n    \n    return true\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "27 sets with at most 9 elements each - constant space",
            "time": "O(1)",
            "timeExplanation": "Always 81 cells to check - constant for 9×9 board"
          },
          "explanation": "Each cell belongs to exactly one row, one column, and one 3×3 box. The box index can be computed as (row/3)*3 + (col/3). We only need to check filled cells since empty cells don't violate constraints. Using sets gives O(1) lookup for duplicates.",
          "id": "58b9d294-df9f-4d96-91b8-645874d585c0",
          "intuition": "Use hash sets to track seen numbers for each row, column, and 3×3 box. If we encounter a duplicate in any unit, the board is invalid.",
          "name": "Three Sets per Unit",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Valid Sudoku board - no duplicates in any row, column, or box",
              "id": "e78eb467-73bd-47ac-ba04-86ee0c6d6ab2",
              "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Two 8's in the first column (rows 0 and 3)",
              "id": "76516396-63ad-47a5-a64e-293a1b37e327",
              "input": "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]"
            }
          ]
        },
        {
          "approach": "1. Use 9 integers for rows, 9 for cols, 9 for boxes (bits represent digits)\n2. For each cell, compute bit mask for the digit\n3. Check if bit is already set in row/col/box\n4. If set, return false; otherwise set the bit",
          "code": "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = [Int](repeating: 0, count: 9)\n    var cols = [Int](repeating: 0, count: 9)\n    var boxes = [Int](repeating: 0, count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let digit = Int(char.asciiValue! - Character(\"0\").asciiValue!)\n            let bit = 1 << digit\n            let boxIndex = (i / 3) * 3 + (j / 3)\n            \n            if (rows[i] & bit) != 0 ||\n               (cols[j] & bit) != 0 ||\n               (boxes[boxIndex] & bit) != 0 {\n                return false\n            }\n            \n            rows[i] |= bit\n            cols[j] |= bit\n            boxes[boxIndex] |= bit\n        }\n    }\n    \n    return true\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "27 integers - more efficient than sets",
            "time": "O(1)",
            "timeExplanation": "Fixed 81 cells, constant operations per cell"
          },
          "explanation": "For digit d, we use bit (1 << d) as a marker. If (row[i] & bit) != 0, the digit was already seen in that row. Using bitwise operations is faster than hash set operations and uses less memory (just integers instead of set objects).",
          "id": "4eae77bf-4c9e-4eed-93a6-c08647b6b6e3",
          "intuition": "Use integers as bit sets instead of hash sets. Each bit represents whether a digit (1-9) has been seen. This is more memory-efficient.",
          "name": "Bit Manipulation",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Bit operations efficiently check for duplicates",
              "id": "1631ed7a-06d3-42b2-ab74-b940bb35c787",
              "input": "board with valid partial fill"
            },
            {
              "expectedOutput": "false",
              "explanation": "boxes[boxIndex] & bit detects the duplicate",
              "id": "bac657ff-962c-422f-ab04-4e7d4f8b4fe2",
              "input": "board with duplicate in box"
            }
          ]
        }
      ],
      "id": "5fbc2392-bb1a-4357-8ddf-87c26873abb0",
      "lastUpdated": "2026-02-06T08:31:51Z",
      "problemSlug": "valid-sudoku",
      "relatedProblems": [
        "sudoku-solver"
      ],
      "summary": "Validate a 9×9 Sudoku board. Check that each row, column, and 3×3 sub-box contains digits 1-9 without repetition. Empty cells (denoted by '.') are allowed."
    },
    {
      "approaches": [
        {
          "approach": "1. Add all intervals that end before newInterval starts (no overlap)\n2. Merge all intervals that overlap with newInterval\n3. Add the merged interval\n4. Add all remaining intervals (start after newInterval ends)",
          "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var newInterval = newInterval\n    var i = 0\n    let n = intervals.count\n    \n    // Phase 1: Add intervals that end before newInterval starts\n    while i < n && intervals[i][1] < newInterval[0] {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    // Phase 2: Merge overlapping intervals\n    while i < n && intervals[i][0] <= newInterval[1] {\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    }\n    result.append(newInterval)\n    \n    // Phase 3: Add remaining intervals\n    while i < n {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Output array can contain up to n+1 intervals",
            "time": "O(n)",
            "timeExplanation": "Single pass through all n intervals"
          },
          "explanation": "Two intervals [a,b] and [c,d] overlap if a <= d AND c <= b. For overlapping intervals, we merge by taking min of starts and max of ends. The key insight is that once we pass intervals that could overlap, all remaining intervals must come after.",
          "id": "df1ec182-5cf8-4451-828c-a8545cbd2617",
          "intuition": "Since intervals are sorted and non-overlapping, we can process them in order: add all intervals that end before the new one starts, merge all that overlap with the new interval, then add remaining intervals.",
          "name": "Linear Scan with Three Phases",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1,5],[6,9]]",
              "explanation": "[1,3] overlaps with [2,5] → merge to [1,5]. [6,9] comes after.",
              "id": "7f6edf21-9fac-4c2c-b63a-bed9d76182f6",
              "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]"
            },
            {
              "expectedOutput": "[[1,2],[3,10],[12,16]]",
              "explanation": "[3,5], [6,7], [8,10] all overlap with [4,8] → merge to [3,10]",
              "id": "63fa4600-8327-4db9-be86-b65d0d65d6d9",
              "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]"
            },
            {
              "expectedOutput": "[[5,7]]",
              "explanation": "Empty list - just add the new interval",
              "id": "9a40ce24-9c31-480f-8cea-2db806d4f00d",
              "input": "intervals = [], newInterval = [5,7]"
            },
            {
              "expectedOutput": "[[1,5]]",
              "explanation": "New interval is completely inside existing one - merge is just [1,5]",
              "id": "8d13d3c1-ad3f-4c88-ba50-ec4d4c186d56",
              "input": "intervals = [[1,5]], newInterval = [2,3]"
            }
          ]
        },
        {
          "approach": "1. Binary search to find first interval that could overlap (start <= newInterval.end)\n2. Binary search to find last interval that could overlap (end >= newInterval.start)\n3. Merge all intervals in that range with newInterval\n4. Construct result with non-overlapping + merged + remaining",
          "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    if intervals.isEmpty {\n        return [newInterval]\n    }\n    \n    var result: [[Int]] = []\n    var merged = newInterval\n    var inserted = false\n    \n    for interval in intervals {\n        if interval[1] < merged[0] {\n            // Current interval ends before merged starts\n            result.append(interval)\n        } else if interval[0] > merged[1] {\n            // Current interval starts after merged ends\n            if !inserted {\n                result.append(merged)\n                inserted = true\n            }\n            result.append(interval)\n        } else {\n            // Overlap - expand merged interval\n            merged[0] = min(merged[0], interval[0])\n            merged[1] = max(merged[1], interval[1])\n        }\n    }\n    \n    if !inserted {\n        result.append(merged)\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Output array stores all resulting intervals",
            "time": "O(n)",
            "timeExplanation": "Process each interval once"
          },
          "explanation": "Binary search finds the boundaries faster, but we still need to merge intervals in the overlapping range. This approach shines when there are few or no overlaps, as binary search is O(log n). However, worst case is still O(n) when many intervals merge.",
          "id": "d89c66e4-0239-48cd-9979-f2cd4aafe7dc",
          "intuition": "Use binary search to find where the new interval should be inserted, then handle merging. This can be faster for finding the insertion point but still O(n) overall due to potential merging.",
          "name": "Binary Search + Merge",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[1,3],[6,9],[10,11]]",
              "explanation": "No overlap - new interval added at end",
              "id": "a3a73289-40f2-4112-bcff-3d260c085332",
              "input": "intervals = [[1,3],[6,9]], newInterval = [10,11]"
            },
            {
              "expectedOutput": "[[1,2],[3,5],[6,9]]",
              "explanation": "No overlap - new interval added at beginning",
              "id": "7e504eb2-9b6d-4e6f-9bbe-31a52f8cc338",
              "input": "intervals = [[3,5],[6,9]], newInterval = [1,2]"
            }
          ]
        }
      ],
      "id": "b443a1cd-9001-45a3-99cd-27885c49e65a",
      "lastUpdated": "2026-02-06T08:31:51Z",
      "problemSlug": "insert-interval",
      "relatedProblems": [
        "merge-intervals",
        "range-module",
        "data-stream-as-disjoint-intervals"
      ],
      "summary": "Insert a new interval into a sorted list of non-overlapping intervals, merging if necessary. Process intervals in three phases: those before, those overlapping, and those after the new interval."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a dp table same size as grid\n2. Initialize dp[0][0] = grid[0][0]\n3. Fill first row (can only come from left)\n4. Fill first column (can only come from above)\n5. For other cells: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n6. Return dp[m-1][n-1]",
          "code": "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n    \n    dp[0][0] = grid[0][0]\n    \n    // Fill first row\n    for j in 1..<n {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    \n    // Fill first column\n    for i in 1..<m {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    \n    // Fill rest\n    for i in 1..<m {\n        for j in 1..<n {\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    \n    return dp[m-1][n-1]\n}",
          "complexity": {
            "space": "O(m × n)",
            "spaceExplanation": "DP table has same dimensions as input grid",
            "time": "O(m × n)",
            "timeExplanation": "Visit each cell exactly once"
          },
          "explanation": "Since we can only move right or down, each cell can only be reached from the cell above or to the left. We compute the minimum cumulative sum for each cell. The first row and column are special cases since they have only one possible path. The answer is the value in the bottom-right cell of our dp table.",
          "id": "60d1784d-8702-4df7-8e41-af8c58bcaa7b",
          "intuition": "For each cell, the minimum path sum to reach it is the cell's value plus the minimum of the path sum from above or from the left. Build the solution bottom-up.",
          "name": "2D Dynamic Programming",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "Path 1→3→1→1→1 = 7. Path goes right, right, down, down.",
              "id": "335352a7-673f-4c04-8b33-bf9e560e2bba",
              "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]"
            },
            {
              "expectedOutput": "12",
              "explanation": "Path 1→2→3→6 = 12",
              "id": "7b6388f3-a1b2-4f61-9d7f-8c27431e7a07",
              "input": "grid = [[1,2,3],[4,5,6]]"
            }
          ]
        },
        {
          "approach": "1. Use a 1D dp array of size n\n2. Initialize with first row's cumulative sums\n3. For each subsequent row, update dp left-to-right\n4. dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n5. Return dp[n-1]",
          "code": "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = [Int](repeating: 0, count: n)\n    \n    // Initialize with first row\n    dp[0] = grid[0][0]\n    for j in 1..<n {\n        dp[j] = dp[j-1] + grid[0][j]\n    }\n    \n    // Process remaining rows\n    for i in 1..<m {\n        dp[0] += grid[i][0]  // First column: only from above\n        for j in 1..<n {\n            dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n        }\n    }\n    \n    return dp[n-1]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Only store one row at a time",
            "time": "O(m × n)",
            "timeExplanation": "Still visit each cell once"
          },
          "explanation": "When computing dp[i][j], we need dp[i-1][j] (above) and dp[i][j-1] (left). In our 1D array, dp[j] still holds the value from the previous row (above), and dp[j-1] was just updated for the current row (left). By processing left-to-right, we always have both values available.",
          "id": "be3872d1-ca2f-4c3e-9e5c-60b24abe0596",
          "intuition": "We only need the previous row to compute the current row. Use a 1D array and update it in-place, reducing space from O(m×n) to O(n).",
          "name": "Space-Optimized DP (1D Array)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "Same result with optimized space",
              "id": "2bbf05b9-36e3-4d84-b551-d400d026f53b",
              "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Single cell grid",
              "id": "90c9fcb8-5e8b-4fe1-a38f-4a9ca33ca1a6",
              "input": "grid = [[1]]"
            }
          ]
        }
      ],
      "id": "fc295f47-1ddf-4721-b421-4b08b57fe7b0",
      "lastUpdated": "2026-02-06T08:33:51Z",
      "problemSlug": "minimum-path-sum",
      "relatedProblems": [
        "unique-paths",
        "unique-paths-ii",
        "dungeon-game",
        "cherry-pickup"
      ],
      "summary": "Find the minimum sum path from top-left to bottom-right in a grid, moving only right or down. Classic 2D dynamic programming - each cell's minimum sum is its value plus min of top or left cell."
    },
    {
      "approaches": [
        {
          "approach": "1. Pair positions with speeds and sort by position descending\n2. Calculate time to reach target for each car\n3. Use a stack to track fleet arrival times\n4. If current car's time > stack top, it forms a new fleet\n5. If current car's time <= stack top, it joins that fleet (don't push)\n6. Return stack size",
          "code": "func carFleet(_ target: Int, _ position: [Int], _ speed: [Int]) -> Int {\n    let n = position.count\n    if n == 0 { return 0 }\n    \n    // Pair (position, speed) and sort by position descending\n    var cars = zip(position, speed).map { ($0, $1) }\n    cars.sort { $0.0 > $1.0 }\n    \n    var fleets = 0\n    var lastTime: Double = 0\n    \n    for (pos, spd) in cars {\n        let time = Double(target - pos) / Double(spd)\n        if time > lastTime {\n            fleets += 1\n            lastTime = time\n        }\n    }\n    \n    return fleets\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Storage for the cars array with position-speed pairs",
            "time": "O(n log n)",
            "timeExplanation": "Dominated by sorting the cars array"
          },
          "explanation": "A car closer to target will block all faster cars behind it. If car B is behind car A and would arrive sooner, B must slow down to A's pace - they become one fleet arriving at A's time. By processing from front to back, we determine if each car forms a new fleet or joins an existing one.",
          "id": "37292528-4b17-4e06-be95-5a8452460e56",
          "intuition": "Process cars from closest to target to furthest. Calculate time to reach target for each car. If a car behind takes less time, it catches up and merges with the fleet ahead.",
          "name": "Sort by Position + Stack",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Car at 10 arrives at time 1. Car at 8 arrives at time 1, catches up → 1 fleet. Car at 0 arrives at time 12. Cars at 5,3 catch up to it → 1 fleet. Total: 3 fleets.",
              "id": "d6a8a0ea-2823-48e6-a7ed-e8144455d56f",
              "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Single car forms one fleet",
              "id": "edb7842f-ad7b-4612-a849-12d5d89e2185",
              "input": "target = 10, position = [3], speed = [3]"
            },
            {
              "expectedOutput": "1",
              "explanation": "All cars eventually catch up to the slowest (front) car",
              "id": "94296bc3-99ed-4fd6-b92e-ac47d88dc6df",
              "input": "target = 100, position = [0,2,4], speed = [4,2,1]"
            }
          ]
        },
        {
          "approach": "1. Sort cars by position descending\n2. Maintain stack of arrival times (monotonically increasing)\n3. For each car, calculate arrival time\n4. While stack not empty and current time >= stack top, pop (merge)\n5. Push current time\n6. Return stack size",
          "code": "func carFleet(_ target: Int, _ position: [Int], _ speed: [Int]) -> Int {\n    let n = position.count\n    if n == 0 { return 0 }\n    \n    var cars = zip(position, speed).map { ($0, $1) }\n    cars.sort { $0.0 > $1.0 }\n    \n    var stack: [Double] = []\n    \n    for (pos, spd) in cars {\n        let time = Double(target - pos) / Double(spd)\n        \n        // If this car is slower (takes longer), it forms new fleet\n        // Otherwise it joins the fleet ahead\n        if stack.isEmpty || time > stack.last! {\n            stack.append(time)\n        }\n    }\n    \n    return stack.count\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack can hold at most n fleet times",
            "time": "O(n log n)",
            "timeExplanation": "Sorting dominates; stack operations are O(n) total"
          },
          "explanation": "The stack maintains fleet arrival times in increasing order. When we find a car that takes longer to arrive than the fleet ahead, it becomes a new fleet. Cars that would arrive faster join existing fleets. This explicitly models the fleet merging process.",
          "id": "51b25e8b-2f98-4829-bf7d-f8fe2252404d",
          "intuition": "Maintain a stack of arrival times. Each time represents a fleet. Pop times that would be caught by a slower car behind.",
          "name": "Monotonic Stack (Explicit)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Stack builds: [1.0] → [1.0] (8 catches 10) → [1.0, 12.0] → [1.0, 12.0] (5 joins) → [1.0, 12.0] (3 joins)",
              "id": "4e3426cc-6d78-4fb6-93ea-517360bc3dc2",
              "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]"
            },
            {
              "expectedOutput": "2",
              "explanation": "Car at 8 takes time 1. Car at 6 takes time 4/3 ≈ 1.33 > 1, so 2 fleets",
              "id": "e9a3a080-97b8-4f87-b952-e7cb36164ce7",
              "input": "target = 10, position = [6,8], speed = [3,2]"
            }
          ]
        }
      ],
      "id": "ac6324e0-9fb4-4fee-afae-1e40a521f8d3",
      "lastUpdated": "2026-02-06T08:33:51Z",
      "problemSlug": "car-fleet",
      "relatedProblems": [
        "car-fleet-ii"
      ],
      "summary": "Determine how many car fleets arrive at the destination. Cars that catch up merge into one fleet. Sort by position descending and count how many cars don't catch up to the car ahead."
    },
    {
      "approaches": [
        {
          "approach": "1. tweets: [userId: [(timestamp, tweetId)]]\n2. follows: [userId: Set<followeeId>]\n3. postTweet: append (timestamp, tweetId) to user's list\n4. getNewsFeed: collect tweets from user + followees, heap-merge top 10\n5. follow/unfollow: add/remove from follows set",
          "code": "class Twitter {\n    private var tweets: [Int: [(Int, Int)]] = [:]  // userId -> [(time, tweetId)]\n    private var follows: [Int: Set<Int>] = [:]      // userId -> Set<followeeId>\n    private var timestamp = 0\n    \n    init() {}\n    \n    func postTweet(_ userId: Int, _ tweetId: Int) {\n        tweets[userId, default: []].append((timestamp, tweetId))\n        timestamp += 1\n    }\n    \n    func getNewsFeed(_ userId: Int) -> [Int] {\n        var allTweets: [(Int, Int)] = []\n        \n        // Get own tweets\n        if let userTweets = tweets[userId] {\n            allTweets.append(contentsOf: userTweets.suffix(10))\n        }\n        \n        // Get followees' tweets\n        for followeeId in follows[userId, default: []] {\n            if let followeeTweets = tweets[followeeId] {\n                allTweets.append(contentsOf: followeeTweets.suffix(10))\n            }\n        }\n        \n        // Sort by timestamp descending and take top 10\n        allTweets.sort { $0.0 > $1.0 }\n        return Array(allTweets.prefix(10).map { $0.1 })\n    }\n    \n    func follow(_ followerId: Int, _ followeeId: Int) {\n        if followerId != followeeId {\n            follows[followerId, default: []].insert(followeeId)\n        }\n    }\n    \n    func unfollow(_ followerId: Int, _ followeeId: Int) {\n        follows[followerId, default: []].remove(followeeId)\n    }\n}",
          "complexity": {
            "space": "O(users × tweets + users × follows)",
            "spaceExplanation": "Store all tweets and follow relationships",
            "time": "O(n log n) for getNewsFeed, O(1) for others",
            "timeExplanation": "getNewsFeed collects up to 10×(followees+1) tweets and sorts them"
          },
          "explanation": "Each user has a list of tweets in chronological order. For getNewsFeed, we need to merge k sorted lists (user's tweets + followees' tweets) and get top 10. A max-heap efficiently handles this merge operation. We only need to consider recent tweets, so we can optimize by only adding a limited number from each user to the heap.",
          "id": "215a2955-d7b3-4a91-802d-0e4521331fa2",
          "intuition": "Store each user's tweets with timestamps. For news feed, collect tweets from user and all followees, use a max-heap to get the 10 most recent. Maintain follow relationships in a set.",
          "name": "Hash Maps + Heap Merge",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[5], [6,5], [5]",
              "explanation": "User 1 posts tweet 5. Feed shows [5]. User 1 follows 2. User 2 posts 6. Feed shows [6,5]. Unfollow, feed shows [5].",
              "id": "c397a34a-5a42-4758-952d-17b16a9afd4f",
              "input": "postTweet(1,5), getNewsFeed(1), follow(1,2), postTweet(2,6), getNewsFeed(1), unfollow(1,2), getNewsFeed(1)"
            }
          ]
        },
        {
          "approach": "1. Use a max-heap with entries (timestamp, tweetId, userId, tweetIndex)\n2. Add most recent tweet from user and each followee to heap\n3. Pop 10 times, each time adding the next tweet from that user\n4. This efficiently merges k sorted lists",
          "code": "class Twitter {\n    private var tweets: [Int: [(Int, Int)]] = [:]\n    private var follows: [Int: Set<Int>] = [:]\n    private var timestamp = 0\n    \n    init() {}\n    \n    func postTweet(_ userId: Int, _ tweetId: Int) {\n        tweets[userId, default: []].append((timestamp, tweetId))\n        timestamp += 1\n    }\n    \n    func getNewsFeed(_ userId: Int) -> [Int] {\n        // Collect users to check (self + followees)\n        var users = follows[userId, default: []]\n        users.insert(userId)\n        \n        // Build heap: (negTime, tweetId, userId, index)\n        // Using negative time for max-heap behavior with min-heap\n        var heap: [(Int, Int, Int, Int)] = []\n        \n        for uid in users {\n            if let userTweets = tweets[uid], !userTweets.isEmpty {\n                let idx = userTweets.count - 1\n                let (time, tid) = userTweets[idx]\n                heap.append((-time, tid, uid, idx))\n            }\n        }\n        \n        // Heapify\n        heap.sort { $0.0 < $1.0 }\n        \n        var result: [Int] = []\n        while !heap.isEmpty && result.count < 10 {\n            let (_, tweetId, uid, idx) = heap.removeFirst()\n            result.append(tweetId)\n            \n            if idx > 0, let userTweets = tweets[uid] {\n                let newIdx = idx - 1\n                let (time, tid) = userTweets[newIdx]\n                heap.append((-time, tid, uid, newIdx))\n                heap.sort { $0.0 < $1.0 }\n            }\n        }\n        \n        return result\n    }\n    \n    func follow(_ followerId: Int, _ followeeId: Int) {\n        if followerId != followeeId {\n            follows[followerId, default: []].insert(followeeId)\n        }\n    }\n    \n    func unfollow(_ followerId: Int, _ followeeId: Int) {\n        follows[followerId, default: []].remove(followeeId)\n    }\n}",
          "complexity": {
            "space": "O(k) for heap",
            "spaceExplanation": "Heap holds at most k entries (one per user)",
            "time": "O(k + 10 log k) for getNewsFeed where k = followees",
            "timeExplanation": "Initialize heap with k users, then 10 heap operations"
          },
          "explanation": "This is the classic k-way merge pattern. We initialize the heap with one tweet from each source (user + followees). After popping the max, we push the next tweet from that same source. This ensures we process tweets in timestamp order without loading all tweets into memory.",
          "id": "a0d42c75-2f8f-4f47-bf6a-984e3c80aa76",
          "intuition": "For large followee lists, use a proper k-way merge with a heap. Start with the most recent tweet from each user, pop min, add next tweet from that user.",
          "name": "Optimized with Min-Heap (k-way merge)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Correctly merged feed by timestamp",
              "explanation": "K-way merge ensures efficient retrieval even with many followees",
              "id": "e9aa502e-7036-407e-9a78-7fc053e62928",
              "input": "Multiple users posting and following"
            }
          ]
        }
      ],
      "id": "3d79efaf-1994-409f-90c2-554ac79378f5",
      "lastUpdated": "2026-02-06T08:33:51Z",
      "problemSlug": "design-twitter",
      "relatedProblems": [
        "design-a-food-rating-system"
      ],
      "summary": "Design a simplified Twitter with postTweet, getNewsFeed (10 most recent from self + followees), follow, and unfollow. Use a heap to merge tweets from multiple users for the feed."
    },
    {
      "approaches": [
        {
          "approach": "1. Build a max-heap from all stones\n2. While heap has more than one stone:\n   a. Pop two largest (y >= x)\n   b. If y > x, push y - x back\n3. Return heap top if exists, else 0",
          "code": "func lastStoneWeight(_ stones: [Int]) -> Int {\n    var heap = stones.sorted()\n    \n    while heap.count > 1 {\n        let y = heap.removeLast()  // Largest\n        let x = heap.removeLast()  // Second largest\n        \n        if y > x {\n            // Insert y - x in sorted position\n            let diff = y - x\n            let insertIndex = heap.firstIndex { $0 >= diff } ?? heap.count\n            heap.insert(diff, at: insertIndex)\n        }\n    }\n    \n    return heap.first ?? 0\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Storing all stones in heap/array",
            "time": "O(n² log n) worst case with array",
            "timeExplanation": "Up to n smashes, each with O(n) insertion. True heap would be O(n log n)"
          },
          "explanation": "A max-heap maintains the invariant that the largest element is always at the root. By using a heap, each smash operation (2 pops + 1 optional push) is O(log n). We continue until at most one stone remains. Swift doesn't have a built-in heap, so we simulate with sorted array or use negative values with a min-heap.",
          "id": "692027f4-b14d-4154-bca0-9b91453aecfd",
          "intuition": "We always need the two largest stones. A max-heap gives us O(log n) access to the maximum element. Pop two, push back the difference if non-zero.",
          "name": "Max-Heap (Priority Queue)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "8,7→1. 4,2→2. 2,1→1. 1,1→0. 1 remains.",
              "id": "59b7c3ce-9587-4219-a922-2f511d48226f",
              "input": "stones = [2,7,4,1,8,1]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Single stone, nothing to smash",
              "id": "4649cb51-be63-4c19-b39a-9eef23da39f2",
              "input": "stones = [1]"
            },
            {
              "expectedOutput": "0",
              "explanation": "Equal stones destroy each other",
              "id": "ec500a07-17d6-46fb-8716-77533f63c411",
              "input": "stones = [2,2]"
            }
          ]
        },
        {
          "approach": "1. Store negative values (so min-heap acts as max-heap)\n2. Pop two smallest (most negative = largest original)\n3. If difference, push negative difference\n4. Return negative of remaining value",
          "code": "func lastStoneWeight(_ stones: [Int]) -> Int {\n    // Using sorted array as simple heap\n    var heap = stones.sorted(by: >)  // Descending order\n    \n    while heap.count > 1 {\n        let first = heap.removeFirst()   // Largest\n        let second = heap.removeFirst()  // Second largest\n        \n        if first != second {\n            let diff = first - second\n            // Binary search insert to maintain sorted order\n            if let idx = heap.firstIndex(where: { $0 < diff }) {\n                heap.insert(diff, at: idx)\n            } else {\n                heap.append(diff)\n            }\n        }\n    }\n    \n    return heap.first ?? 0\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Array stores all remaining stones",
            "time": "O(n² ) with sorted array simulation",
            "timeExplanation": "Each insertion is O(n) for binary search + shift, n iterations"
          },
          "explanation": "This is a common trick when only min-heap is available. By negating all values, the smallest negative corresponds to the largest original value. The algorithm remains the same, just negate on insert and extract.",
          "id": "efca2132-cc38-4f72-8e29-49eb20707b0c",
          "intuition": "Swift's standard library doesn't include a heap, but we can use CFBinaryHeap or simulate with an array. Using negative values with a min-heap simulates a max-heap.",
          "name": "Simulated Max-Heap with Negative Values",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Same process, different implementation",
              "id": "6c0a6b46-8c42-4d2e-ad7f-2eac7cd9d526",
              "input": "stones = [2,7,4,1,8,1]"
            },
            {
              "expectedOutput": "2",
              "explanation": "10,10→0. 4,2→2. Result: 2",
              "id": "6f6364d3-8697-4f14-97f1-0fbeb99f282f",
              "input": "stones = [10,4,2,10]"
            }
          ]
        }
      ],
      "id": "95602fb1-a612-4a07-b587-641ca1d9fa88",
      "lastUpdated": "2026-02-06T08:33:51Z",
      "problemSlug": "last-stone-weight",
      "relatedProblems": [
        "last-stone-weight-ii"
      ],
      "summary": "Smash the two heaviest stones together repeatedly. If equal, both destroyed; if different, the difference remains. Return the last remaining stone's weight or 0. Use a max-heap for efficient retrieval."
    },
    {
      "approaches": [
        {
          "approach": "1. Main stack stores all values\n2. Min stack stores the minimum at each height\n3. Push: push value to main, push min(value, minStack.top) to min stack\n4. Pop: pop from both stacks\n5. GetMin: return min stack top",
          "code": "class MinStack {\n    private var stack: [Int] = []\n    private var minStack: [Int] = []\n    \n    init() {}\n    \n    func push(_ val: Int) {\n        stack.append(val)\n        let newMin = minStack.isEmpty ? val : min(val, minStack.last!)\n        minStack.append(newMin)\n    }\n    \n    func pop() {\n        stack.removeLast()\n        minStack.removeLast()\n    }\n    \n    func top() -> Int {\n        return stack.last!\n    }\n    \n    func getMin() -> Int {\n        return minStack.last!\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Two stacks, each can hold up to n elements",
            "time": "O(1) for all operations",
            "timeExplanation": "All operations are constant time - just array append/remove/access"
          },
          "explanation": "The min stack maintains the invariant that minStack[i] is the minimum of all elements from stack[0] to stack[i]. When we push a new element, the new minimum is either the element itself or the previous minimum (whichever is smaller). When we pop, we remove from both stacks, and the min stack still correctly reflects the minimum of remaining elements.",
          "id": "c4bb01c8-4f03-4165-82ed-7b61dfc8ce33",
          "intuition": "Maintain a regular stack for values and a parallel stack that tracks the minimum at each level. When we push, also push the new minimum to the min stack.",
          "name": "Two Stacks",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "-3, 0, -2",
              "explanation": "After pushes: stack=[-2,0,-3], minStack=[-2,-2,-3]. getMin=-3. Pop. stack=[-2,0], minStack=[-2,-2]. top=0, getMin=-2.",
              "id": "b05fcab8-333c-4f7e-a26e-85e9153149f7",
              "input": "push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()"
            }
          ]
        },
        {
          "approach": "1. Stack stores tuples of (value, minAtThisLevel)\n2. Push: calculate new min, push (value, newMin)\n3. Pop: remove top tuple\n4. Top: return first element of top tuple\n5. GetMin: return second element of top tuple",
          "code": "class MinStack {\n    private var stack: [(val: Int, min: Int)] = []\n    \n    init() {}\n    \n    func push(_ val: Int) {\n        let currentMin = stack.isEmpty ? val : min(val, stack.last!.min)\n        stack.append((val, currentMin))\n    }\n    \n    func pop() {\n        stack.removeLast()\n    }\n    \n    func top() -> Int {\n        return stack.last!.val\n    }\n    \n    func getMin() -> Int {\n        return stack.last!.min\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack stores n pairs",
            "time": "O(1) for all operations",
            "timeExplanation": "All operations are single array operations"
          },
          "explanation": "By storing the minimum alongside each value, we embed the min-tracking directly into the main data structure. This uses the same total memory as two stacks but with better cache locality since related data is adjacent.",
          "id": "4192110c-e0e8-4f2f-94c4-520ac5782146",
          "intuition": "Store (value, currentMin) pairs in a single stack. Each entry knows the minimum at that point in the stack's history.",
          "name": "Single Stack with Pairs",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1, -1, 1",
              "explanation": "Stack builds: [(1,1), (2,1), (-1,-1)]. Mins are 1, -1, then back to 1 after pop.",
              "id": "eeeb1204-451b-4747-bcfc-bc529d3b491e",
              "input": "push(1), push(2), getMin(), push(-1), getMin(), pop(), getMin()"
            }
          ]
        }
      ],
      "id": "8d191a58-986c-4fbe-9803-3d37ec73ebaa",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "min-stack",
      "relatedProblems": [
        "max-stack"
      ],
      "summary": "Design a stack that supports push, pop, top, and retrieving the minimum element in O(1) time. Store the minimum alongside each element or use a separate min-tracking stack."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize result = 0\n2. XOR each number with result\n3. Return result",
          "code": "func singleNumber(_ nums: [Int]) -> Int {\n    var result = 0\n    for num in nums {\n        result ^= num\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only one variable regardless of input size",
            "time": "O(n)",
            "timeExplanation": "Single pass through all n elements"
          },
          "explanation": "XOR is associative and commutative, so the order doesn't matter. For array [a,b,a], we compute a^b^a = (a^a)^b = 0^b = b. Every number that appears twice contributes 0 to the final result, leaving only the unique number.",
          "id": "28a878f9-24ec-4596-9442-f8800f2b359f",
          "intuition": "XOR has two key properties: a^a=0 and a^0=a. If we XOR all numbers, pairs cancel out and only the single number remains.",
          "name": "XOR Bit Manipulation",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "2^2^1 = 0^1 = 1",
              "id": "15868032-4a1e-47f2-b857-a67476ea59c4",
              "input": "nums = [2,2,1]"
            },
            {
              "expectedOutput": "4",
              "explanation": "4^1^2^1^2 = 4^(1^1)^(2^2) = 4^0^0 = 4",
              "id": "24e4778c-eaf5-4d5a-a079-7e1067283207",
              "input": "nums = [4,1,2,1,2]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Single element is the answer",
              "id": "478e854c-936b-4ba3-b7a5-0f1c431207e0",
              "input": "nums = [1]"
            }
          ]
        },
        {
          "approach": "1. Create empty set\n2. For each number: if in set, remove it; else add it\n3. Return the single element in set",
          "code": "func singleNumber(_ nums: [Int]) -> Int {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) {\n            seen.remove(num)\n        } else {\n            seen.insert(num)\n        }\n    }\n    return seen.first!\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Set can hold up to n/2 elements",
            "time": "O(n)",
            "timeExplanation": "Single pass with O(1) set operations"
          },
          "explanation": "This approach explicitly models the 'pairing' logic. Numbers that appear twice get added then removed, leaving only the unique number. While correct, it uses O(n) space unlike the XOR solution.",
          "id": "c13da035-5193-4c36-b588-86f58c901033",
          "intuition": "Track seen numbers in a set. If we see a number again, remove it. The remaining number is the answer.",
          "name": "Hash Set",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Add 2, remove 2, add 1. Set = {1}",
              "id": "0d27a6a6-e787-4ff0-83ab-626d1a1edb19",
              "input": "nums = [2,2,1]"
            }
          ]
        }
      ],
      "id": "723e644e-c251-4527-8f72-f4065ad929c6",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "single-number",
      "relatedProblems": [
        "single-number-ii",
        "single-number-iii"
      ],
      "summary": "Find the element that appears only once when all others appear twice. XOR all elements - pairs cancel out (a^a=0) leaving only the single number."
    },
    {
      "approaches": [
        {
          "approach": "1. writeIndex starts at 0\n2. For each non-zero element, write it at writeIndex and increment\n3. Fill remaining positions with zeros",
          "code": "func moveZeroes(_ nums: inout [Int]) {\n    var writeIndex = 0\n    \n    // Move all non-zeros to front\n    for num in nums {\n        if num != 0 {\n            nums[writeIndex] = num\n            writeIndex += 1\n        }\n    }\n    \n    // Fill rest with zeros\n    while writeIndex < nums.count {\n        nums[writeIndex] = 0\n        writeIndex += 1\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "In-place modification with one pointer variable",
            "time": "O(n)",
            "timeExplanation": "Two passes through the array"
          },
          "explanation": "The first pass compacts all non-zero elements to the front, maintaining their relative order. writeIndex ends up at the count of non-zeros. The second pass fills zeros from writeIndex to the end. This is cache-friendly as we write sequentially.",
          "id": "4c27ce4e-1d2b-475a-916e-425817f46de8",
          "intuition": "Copy all non-zero elements to the front, then fill the rest with zeros. Two passes but very clean logic.",
          "name": "Two Pointers (Overwrite + Fill)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,3,12,0,0]",
              "explanation": "Non-zeros 1,3,12 moved to front, zeros fill the rest",
              "id": "7520c7aa-1eed-4a4d-89c1-c90e954d6812",
              "input": "nums = [0,1,0,3,12]"
            },
            {
              "expectedOutput": "[0]",
              "explanation": "Single zero stays in place",
              "id": "fe7422ae-092a-458f-8774-a980544fb244",
              "input": "nums = [0]"
            }
          ]
        },
        {
          "approach": "1. slow pointer marks end of non-zero zone\n2. fast pointer scans through array\n3. When fast finds non-zero, swap with slow and increment slow\n4. Single pass, minimal writes",
          "code": "func moveZeroes(_ nums: inout [Int]) {\n    var slow = 0\n    \n    for fast in 0..<nums.count {\n        if nums[fast] != 0 {\n            // Swap only if positions differ (avoid self-swap)\n            if slow != fast {\n                nums.swapAt(slow, fast)\n            }\n            slow += 1\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using pointer variables",
            "time": "O(n)",
            "timeExplanation": "Single pass through array"
          },
          "explanation": "The slow pointer always points to the first zero (or end of non-zero section). When fast finds a non-zero, swapping places it at the boundary and moves the boundary forward. This performs fewer writes than the fill approach when there are few zeros.",
          "id": "a16613bd-2811-47a1-ad61-a7819ceb6902",
          "intuition": "Maintain a slow pointer for the 'non-zero zone' boundary. When we find a non-zero, swap it with the boundary position and expand the zone.",
          "name": "Two Pointers (Swap)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,3,12,0,0]",
              "explanation": "Swap 1↔0, then 3↔0, then 12↔0",
              "id": "627eb173-cf19-4d10-b422-0104d97be4e7",
              "input": "nums = [0,1,0,3,12]"
            },
            {
              "expectedOutput": "[1,2,3]",
              "explanation": "No zeros, no swaps needed (slow==fast always)",
              "id": "08a2f445-fc71-4492-ab02-12b90c7e50dd",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "[1,0,0]",
              "explanation": "1 swaps with first 0",
              "id": "e429ad05-3571-4451-800f-058842518499",
              "input": "nums = [0,0,1]"
            }
          ]
        }
      ],
      "id": "1eaeb2ef-7769-43d9-9a82-32a5b0112c9b",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "move-zeroes",
      "relatedProblems": [
        "remove-element"
      ],
      "summary": "Move all zeros to the end while maintaining the relative order of non-zero elements. Use two pointers: one for the write position of non-zeros, one to scan."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate from right to left\n2. Add 1 to current digit\n3. If digit < 10, we're done (no carry)\n4. If digit == 10, set to 0 and continue (carry)\n5. If we exit loop with carry, prepend 1",
          "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    for i in (0..<digits.count).reversed() {\n        digits[i] += 1\n        if digits[i] < 10 {\n            return digits\n        }\n        digits[i] = 0\n    }\n    \n    // All digits were 9, need new leading 1\n    return [1] + digits\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "May need to create new array with n+1 digits",
            "time": "O(n)",
            "timeExplanation": "Worst case traverses all n digits (all 9s)"
          },
          "explanation": "The key insight is that we only continue carrying if digit becomes 10 (i.e., was 9). As soon as we add to a non-9 digit, we can return immediately. If all digits were 9 (like 999), we need a new leading 1 (1000).",
          "id": "3d80c2ac-ab41-4eb4-acd5-e51cea3ebb18",
          "intuition": "Start from the rightmost digit and add one. If it becomes 10, set to 0 and carry to next digit. Continue until no carry or we reach the front.",
          "name": "Right to Left with Carry",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2,4]",
              "explanation": "123 + 1 = 124. Only last digit changes.",
              "id": "b65e1a7c-01f5-443f-aa73-4872ff0e3497",
              "input": "digits = [1,2,3]"
            },
            {
              "expectedOutput": "[4,3,2,2]",
              "explanation": "4321 + 1 = 4322",
              "id": "44c8de99-16c2-4c2a-8eeb-b1ec76a512dc",
              "input": "digits = [4,3,2,1]"
            },
            {
              "expectedOutput": "[1,0,0,0]",
              "explanation": "999 + 1 = 1000. Carry propagates through all digits, need new leading 1.",
              "id": "e9679c66-7051-42a3-adbf-3030b92b21d4",
              "input": "digits = [9,9,9]"
            },
            {
              "expectedOutput": "[2,0,0]",
              "explanation": "199 + 1 = 200. Carry stops at first digit.",
              "id": "ade4dd71-42d5-4633-acc8-926c7b23488e",
              "input": "digits = [1,9,9]"
            }
          ]
        },
        {
          "approach": "1. Find rightmost non-9 digit\n2. If found: increment it, zero out all digits to the right\n3. If not found: all digits are 9, return [1] + array of zeros",
          "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    // Find rightmost non-9\n    var i = digits.count - 1\n    while i >= 0 && digits[i] == 9 {\n        i -= 1\n    }\n    \n    if i < 0 {\n        // All 9s: 999 -> 1000\n        return [1] + Array(repeating: 0, count: digits.count)\n    }\n    \n    // Increment found digit, zero everything to its right\n    digits[i] += 1\n    for j in (i+1)..<digits.count {\n        digits[j] = 0\n    }\n    \n    return digits\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Worst case creates new array of n+1 digits",
            "time": "O(n)",
            "timeExplanation": "Scan for non-9, then potentially zero trailing digits"
          },
          "explanation": "This approach explicitly identifies the 'stopping point' of the carry before modifying anything. It's equivalent to the carry approach but thinks about it differently - we're looking for where the increment actually happens.",
          "id": "33612655-cab5-4792-b5c4-873440c52bdf",
          "intuition": "Find the rightmost digit that isn't 9, increment it, and set all digits to its right to 0. If all are 9, prepend 1 and set all to 0.",
          "name": "Find Rightmost Non-9",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,0]",
              "explanation": "9 + 1 = 10",
              "id": "7325e2cd-97db-4e05-9f1e-d6550b4079b0",
              "input": "digits = [9]"
            },
            {
              "expectedOutput": "[9,0,0]",
              "explanation": "899 + 1 = 900. Rightmost non-9 is 8 at index 0.",
              "id": "a17c9969-801e-490b-b7dd-a4fbb90d6fd5",
              "input": "digits = [8,9,9]"
            }
          ]
        }
      ],
      "id": "c90f653b-4db2-4d85-a272-cc49a7748364",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "plus-one",
      "relatedProblems": [
        "add-binary",
        "add-to-array-form-of-integer",
        "multiply-strings"
      ],
      "summary": "Add one to a number represented as an array of digits. Handle carry propagation from right to left. Only need a new digit if all digits were 9."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize result = n (start with the last index)\n2. XOR result with each index i and nums[i]\n3. Return result",
          "code": "func missingNumber(_ nums: [Int]) -> Int {\n    var result = nums.count  // This is 'n'\n    \n    for i in 0..<nums.count {\n        result ^= i ^ nums[i]\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only one variable for result",
            "time": "O(n)",
            "timeExplanation": "Single pass through array"
          },
          "explanation": "If array has numbers [0,1,3] with n=3, we XOR: (0^1^2^3) ^ (0^1^3) = 2. The index sequence gives us 0 to n-1, and we initialize with n to cover all expected numbers. Each present number appears in both sequences and cancels out.",
          "id": "e6b65cba-825b-40d3-8a32-3dc70f8ae099",
          "intuition": "XOR all numbers 0 to n and all numbers in array. Pairs cancel out (a^a=0), leaving only the missing number.",
          "name": "XOR Bit Manipulation",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "n=3, expected [0,1,2,3]. Missing is 2.",
              "id": "10adef1d-bd59-4aa6-982b-4a1ba9ec7f69",
              "input": "nums = [3,0,1]"
            },
            {
              "expectedOutput": "2",
              "explanation": "n=2, expected [0,1,2]. Missing is 2.",
              "id": "6738d3b9-a776-4ff6-b2ae-9a839a1bfdf5",
              "input": "nums = [0,1]"
            },
            {
              "expectedOutput": "8",
              "explanation": "n=9, missing 8 from sequence 0-9",
              "id": "29f1623d-1245-4b49-a7fd-e7720f5560a7",
              "input": "nums = [9,6,4,2,3,5,7,0,1]"
            }
          ]
        },
        {
          "approach": "1. Calculate expected sum = n * (n + 1) / 2\n2. Calculate actual sum of array\n3. Return expected - actual",
          "code": "func missingNumber(_ nums: [Int]) -> Int {\n    let n = nums.count\n    let expectedSum = n * (n + 1) / 2\n    let actualSum = nums.reduce(0, +)\n    return expectedSum - actualSum\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only storing two integers",
            "time": "O(n)",
            "timeExplanation": "Single pass to compute sum"
          },
          "explanation": "Gauss's formula gives us the sum of first n natural numbers (including 0, it's 0+1+...+n). The difference between expected and actual sum is exactly the missing number. Watch for integer overflow with very large n.",
          "id": "5ec59ea6-82f6-46ae-bff2-545faa02ce82",
          "intuition": "Sum of 0 to n is n*(n+1)/2. Subtract actual array sum to get missing number.",
          "name": "Math (Gauss Sum)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Expected sum = 3*4/2 = 6. Actual = 4. Missing = 2.",
              "id": "ff495192-98ec-4462-a2a1-a8765bde9cd5",
              "input": "nums = [3,0,1]"
            },
            {
              "expectedOutput": "1",
              "explanation": "n=1, expected [0,1]. Sum should be 1, actual is 0. Missing = 1.",
              "id": "e3f517a4-6fba-459d-ac36-82db1cd0a414",
              "input": "nums = [0]"
            }
          ]
        }
      ],
      "id": "134c6c0c-6d76-4fe0-92dd-4c81f2fb988b",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "missing-number",
      "relatedProblems": [
        "find-the-duplicate-number",
        "find-all-numbers-disappeared-in-an-array",
        "first-missing-positive"
      ],
      "summary": "Find the missing number in array containing n distinct numbers from 0 to n. Use XOR (numbers cancel out) or math (expected sum - actual sum)."
    },
    {
      "approaches": [
        {
          "approach": "1. Create set to store seen numbers\n2. While n != 1 and n not in set:\n   a. Add n to set\n   b. Replace n with sum of digit squares\n3. Return n == 1",
          "code": "func isHappy(_ n: Int) -> Bool {\n    var seen = Set<Int>()\n    var num = n\n    \n    while num != 1 && !seen.contains(num) {\n        seen.insert(num)\n        num = sumOfSquares(num)\n    }\n    \n    return num == 1\n}\n\nfunc sumOfSquares(_ n: Int) -> Int {\n    var sum = 0\n    var num = n\n    while num > 0 {\n        let digit = num % 10\n        sum += digit * digit\n        num /= 10\n    }\n    return sum\n}",
          "complexity": {
            "space": "O(k)",
            "spaceExplanation": "Set stores all numbers in the sequence",
            "time": "O(log n) per step, O(k) steps",
            "timeExplanation": "Each sum of squares is O(log n) for digit count. Number of steps k is bounded."
          },
          "explanation": "The sequence must eventually either reach 1 or enter a cycle (since there are finite possible values). If we detect a cycle before reaching 1, the number isn't happy. The set gives O(1) lookup to detect repeats.",
          "id": "d9b6163f-4b28-48ce-9727-5e210baa811e",
          "intuition": "If we see the same number twice, we're in a cycle and will never reach 1. Track all seen numbers in a set.",
          "name": "Hash Set Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "19 → 82 → 68 → 100 → 1. Happy!",
              "id": "8ec52fe1-7f06-46a4-acd4-df0c5b1588e4",
              "input": "n = 19"
            },
            {
              "expectedOutput": "false",
              "explanation": "2 → 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 (cycle)",
              "id": "a1b7d11b-e59b-4a4e-91f0-73ef1980abb1",
              "input": "n = 2"
            }
          ]
        },
        {
          "approach": "1. slow moves one step at a time\n2. fast moves two steps at a time\n3. Continue until fast reaches 1 or slow == fast\n4. Return whether ended at 1",
          "code": "func isHappy(_ n: Int) -> Bool {\n    var slow = n\n    var fast = sumOfSquares(n)\n    \n    while fast != 1 && slow != fast {\n        slow = sumOfSquares(slow)\n        fast = sumOfSquares(sumOfSquares(fast))\n    }\n    \n    return fast == 1\n}\n\nfunc sumOfSquares(_ n: Int) -> Int {\n    var sum = 0\n    var num = n\n    while num > 0 {\n        let digit = num % 10\n        sum += digit * digit\n        num /= 10\n    }\n    return sum\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only two pointer variables, no storage of sequence",
            "time": "O(log n) per step",
            "timeExplanation": "Same time complexity, but space-optimized"
          },
          "explanation": "This is the tortoise and hare algorithm. In a sequence that either ends at 1 or cycles, the fast pointer will eventually either reach 1 or catch up to slow (indicating a cycle). This uses O(1) space since we don't store previous numbers.",
          "id": "4d750e62-c2cc-49c3-b561-f044512d778c",
          "intuition": "Use slow and fast pointers like in linked list cycle detection. If they meet at 1, it's happy. If they meet elsewhere, there's a cycle.",
          "name": "Floyd's Cycle Detection (Two Pointers)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Fast reaches 1 before meeting slow",
              "id": "75d470e5-0bfc-4214-9330-823179392cda",
              "input": "n = 19"
            },
            {
              "expectedOutput": "true",
              "explanation": "7 → 49 → 97 → 130 → 10 → 1",
              "id": "d1148d34-bd55-49fe-8110-329c516440cc",
              "input": "n = 7"
            },
            {
              "expectedOutput": "false",
              "explanation": "Enters cycle, slow and fast meet before reaching 1",
              "id": "bb11dd88-96ec-4c83-a9a1-f3d4a3c84c1b",
              "input": "n = 116"
            }
          ]
        }
      ],
      "id": "e35d9a28-5db8-422d-9823-5ea0e18a2cdf",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "happy-number",
      "relatedProblems": [
        "linked-list-cycle",
        "add-digits",
        "ugly-number"
      ],
      "summary": "Determine if a number is happy: repeatedly replace with sum of squares of digits until it reaches 1 (happy) or loops endlessly (not happy). Detect cycle with Floyd's algorithm or hash set."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize count = 0\n2. While n != 0:\n   a. n = n & (n - 1)\n   b. count += 1\n3. Return count",
          "code": "func hammingWeight(_ n: Int) -> Int {\n    var num = n\n    var count = 0\n    \n    while num != 0 {\n        num &= (num - 1)\n        count += 1\n    }\n    \n    return count\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using counter variable",
            "time": "O(k)",
            "timeExplanation": "k is the number of 1 bits, at most 32 for 32-bit integer"
          },
          "explanation": "When we subtract 1 from n, all bits after the rightmost 1 are flipped (including the 1 itself). ANDing with original n clears that rightmost 1. For example: 12 (1100) & 11 (1011) = 8 (1000). We cleared the rightmost 1 bit. This runs in O(k) where k is the number of 1 bits, not the total bits.",
          "id": "7e52ff8f-6b86-4568-ab67-678e4f25ab81",
          "intuition": "n & (n-1) clears the rightmost set bit. Count how many times we can do this until n becomes 0.",
          "name": "Brian Kernighan's Algorithm",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "1011 → 1010 (count 1) → 1000 (count 2) → 0 (count 3)",
              "id": "7e530791-0f85-4efb-9104-240c4ba9e316",
              "input": "n = 11 (binary: 1011)"
            },
            {
              "expectedOutput": "1",
              "explanation": "Only one 1 bit, single iteration",
              "id": "d6ea447a-f77a-414f-b869-80206cdca6d8",
              "input": "n = 128 (binary: 10000000)"
            },
            {
              "expectedOutput": "30",
              "explanation": "Almost all bits set in this large number",
              "id": "25e3b834-3ef2-4eda-ae68-63a3ed4b12c2",
              "input": "n = 2147483645 (many 1s)"
            }
          ]
        },
        {
          "approach": "1. Initialize count = 0\n2. Repeat 32 times:\n   a. If n & 1 == 1, increment count\n   b. Right shift n by 1\n3. Return count",
          "code": "func hammingWeight(_ n: Int) -> Int {\n    var num = n\n    var count = 0\n    \n    for _ in 0..<32 {\n        count += num & 1\n        num >>= 1\n    }\n    \n    return count\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only counter and input variables",
            "time": "O(1)",
            "timeExplanation": "Always exactly 32 iterations for 32-bit integer"
          },
          "explanation": "We examine each bit position by masking with 1 (which checks if the LSB is set) and then shifting right to bring the next bit into position. This always takes 32 iterations for a 32-bit integer regardless of how many 1s there are.",
          "id": "62ed1384-def6-43d4-9894-5ef76815664d",
          "intuition": "Check the least significant bit with n & 1, then right shift. Repeat for all 32 bits.",
          "name": "Check Each Bit",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Check all 32 bits, count three 1s",
              "id": "acfb3fb2-c207-4274-a082-c27cd8d7905c",
              "input": "n = 11"
            },
            {
              "expectedOutput": "0",
              "explanation": "No bits set",
              "id": "ffcc6c1f-4e8b-4cd5-8ac7-b7da345e6989",
              "input": "n = 0"
            }
          ]
        }
      ],
      "id": "9de8a3ba-238c-41a0-856e-07e952e0576a",
      "lastUpdated": "2026-02-06T08:38:32Z",
      "problemSlug": "number-of-1-bits",
      "relatedProblems": [
        "reverse-bits",
        "counting-bits",
        "hamming-distance"
      ],
      "summary": "Count the number of 1 bits (Hamming weight) in an integer. Use bit manipulation: n & (n-1) clears the lowest set bit, or check each bit with n & 1."
    },
    {
      "approaches": [
        {
          "approach": "1. Create array ans of size n+1\n2. ans[0] = 0\n3. For i from 1 to n: ans[i] = ans[i >> 1] + (i & 1)\n4. Return ans",
          "code": "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i >> 1] + (i & 1)\n    }\n    \n    return ans\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Output array of size n+1",
            "time": "O(n)",
            "timeExplanation": "Single pass from 1 to n"
          },
          "explanation": "Right shifting drops the last bit. So i's bit count is (i >> 1)'s bit count plus the dropped bit (0 or 1). For example, 5 (101) >> 1 = 2 (10). ans[5] = ans[2] + (5 & 1) = 1 + 1 = 2. We build up from smaller numbers, which we've already computed.",
          "id": "a061a99c-3f78-41ac-ab70-2c5cfefe9cd5",
          "intuition": "The number of 1s in i equals the number of 1s in i/2 (i >> 1) plus whether the last bit is 1 (i & 1).",
          "name": "DP with Right Shift",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,1,1]",
              "explanation": "0=0b0 (0), 1=0b1 (1), 2=0b10 (1)",
              "id": "33d46ac6-aeb7-42c1-8a50-e7de4965922b",
              "input": "n = 2"
            },
            {
              "expectedOutput": "[0,1,1,2,1,2]",
              "explanation": "0,1,10,11,100,101 have 0,1,1,2,1,2 ones respectively",
              "id": "9fa413ed-869c-400f-8c98-5ab0729dab99",
              "input": "n = 5"
            }
          ]
        },
        {
          "approach": "1. Create array ans of size n+1, ans[0] = 0\n2. For i from 1 to n: ans[i] = ans[i & (i-1)] + 1\n3. Return ans",
          "code": "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i & (i - 1)] + 1\n    }\n    \n    return ans\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Output array of size n+1",
            "time": "O(n)",
            "timeExplanation": "Single pass, O(1) work per number"
          },
          "explanation": "i & (i-1) removes exactly one 1 bit from i. So ans[i] is one more than ans of the result. For example, 6 (110) & 5 (101) = 4 (100). ans[6] = ans[4] + 1 = 1 + 1 = 2. This directly uses the relationship between adjacent numbers in terms of set bits.",
          "id": "359c7fe7-37ea-468a-af26-f9c326c80395",
          "intuition": "ans[i] = ans[i & (i-1)] + 1, since i & (i-1) clears the lowest set bit. We've already computed ans for that smaller number.",
          "name": "DP with Brian Kernighan",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0,1,1,2,1,2]",
              "explanation": "Same result, different recurrence",
              "id": "417bdca3-a29f-4525-87fd-272adecdf2a2",
              "input": "n = 5"
            },
            {
              "expectedOutput": "[0]",
              "explanation": "Just zero, which has 0 ones",
              "id": "2826e6d6-d705-41c3-85a2-e8cb2c2a9635",
              "input": "n = 0"
            }
          ]
        }
      ],
      "id": "9e0e6f5c-993a-4a8d-98a6-10b60726633a",
      "lastUpdated": "2026-02-06T08:38:32Z",
      "problemSlug": "counting-bits",
      "relatedProblems": [
        "number-of-1-bits",
        "binary-watch"
      ],
      "summary": "Return array where ans[i] is the number of 1 bits in i, for i from 0 to n. Use DP: ans[i] = ans[i >> 1] + (i & 1), or ans[i] = ans[i & (i-1)] + 1."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize result = 0\n2. For 32 iterations:\n   a. Left shift result by 1 (make room)\n   b. Add n's least significant bit (n & 1)\n   c. Right shift n by 1\n3. Return result",
          "code": "func reverseBits(_ n: Int) -> Int {\n    var result = 0\n    var num = n\n    \n    for _ in 0..<32 {\n        result = (result << 1) | (num & 1)\n        num >>= 1\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using two integer variables",
            "time": "O(1)",
            "timeExplanation": "Always exactly 32 iterations"
          },
          "explanation": "We process bits from right to left in n, and place them from left to right in result. After 32 iterations, bit 0 of original n is now bit 31 of result, bit 1 is bit 30, etc. Each iteration shifts result left (making room at LSB) and shifts n right (exposing next bit).",
          "id": "6d5a3516-6d13-47e4-9839-166a5774c3db",
          "intuition": "Extract the least significant bit from input, place it at the most significant position of result, then shift both accordingly.",
          "name": "Bit by Bit",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "964176192 (00111001011110000010100101000000)",
              "explanation": "Bits reversed position by position",
              "id": "6282dc33-c2e8-4621-9832-cc6d9d6f12ac",
              "input": "n = 43261596 (00000010100101000001111010011100)"
            },
            {
              "expectedOutput": "3221225471 (10111111111111111111111111111111)",
              "explanation": "Near-maximum value with trailing zeros becomes leading zeros",
              "id": "c7e8530f-84bb-453d-89bc-a2cba0a3dbb4",
              "input": "n = 4294967293 (11111111111111111111111111111101)"
            }
          ]
        },
        {
          "approach": "1. Swap adjacent bits\n2. Swap adjacent 2-bit groups\n3. Swap adjacent 4-bit groups\n4. Swap adjacent 8-bit groups\n5. Swap adjacent 16-bit groups",
          "code": "func reverseBits(_ n: Int) -> Int {\n    var num = n\n    // Swap adjacent bits\n    num = ((num & 0x55555555) << 1) | ((num >> 1) & 0x55555555)\n    // Swap adjacent 2-bit pairs\n    num = ((num & 0x33333333) << 2) | ((num >> 2) & 0x33333333)\n    // Swap adjacent 4-bit nibbles\n    num = ((num & 0x0F0F0F0F) << 4) | ((num >> 4) & 0x0F0F0F0F)\n    // Swap adjacent bytes\n    num = ((num & 0x00FF00FF) << 8) | ((num >> 8) & 0x00FF00FF)\n    // Swap adjacent 16-bit halves\n    num = ((num & 0x0000FFFF) << 16) | ((num >> 16) & 0x0000FFFF)\n    return num\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using one variable",
            "time": "O(1)",
            "timeExplanation": "Fixed 5 swap operations"
          },
          "explanation": "Each step swaps groups of increasing size. After swapping 1s, 2s, 4s, 8s, and 16s, we've effectively reversed all 32 bits. Uses bit masks to isolate and move groups. Very fast with just 5 operations (plus masks).",
          "id": "7d60de68-5728-4be5-bce4-8e3002633e6e",
          "intuition": "Swap adjacent bits, then adjacent pairs, then adjacent nibbles, etc. Like merge sort in reverse - combine small swaps into larger reversal.",
          "name": "Divide and Conquer (Swap)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "964176192",
              "explanation": "Same result as bit-by-bit, but faster constant factor",
              "id": "7c2f9bc5-face-40fb-8d99-a11140a6b2ad",
              "input": "n = 43261596"
            }
          ]
        }
      ],
      "id": "11b186ca-5869-4db6-a077-e6144d07bc3f",
      "lastUpdated": "2026-02-06T08:38:32Z",
      "problemSlug": "reverse-bits",
      "relatedProblems": [
        "number-of-1-bits",
        "reverse-integer"
      ],
      "summary": "Reverse the bits of a 32-bit unsigned integer. Extract each bit from the input and place it in the mirrored position of the result."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort intervals by end time\n2. Track the end time of last kept interval\n3. For each interval:\n   a. If start >= lastEnd, keep it (update lastEnd)\n   b. Else, skip it (it overlaps)\n4. Return total - kept",
          "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by end time\n    let sorted = intervals.sorted { $0[1] < $1[1] }\n    \n    var kept = 1\n    var lastEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] >= lastEnd {\n            kept += 1\n            lastEnd = sorted[i][1]\n        }\n    }\n    \n    return intervals.count - kept\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Creating sorted copy of intervals",
            "time": "O(n log n)",
            "timeExplanation": "Dominated by sorting"
          },
          "explanation": "Sorting by end time ensures we greedily pick intervals that finish earliest. If a new interval starts after the previous ends, it doesn't overlap. By choosing early-ending intervals, we maximize the number we can fit. The intervals we don't keep are the ones we'd remove.",
          "id": "a6006334-a763-4410-8e1d-222c69ea4608",
          "intuition": "Always keep the interval that ends earliest - this leaves maximum room for subsequent intervals. Count how many we keep, subtract from total.",
          "name": "Greedy (Sort by End Time)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Remove [1,3]. Keep [1,2], [2,3], [3,4] which don't overlap.",
              "id": "5b6d32d6-27d5-469e-aa62-013ed6aeeb5d",
              "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]"
            },
            {
              "expectedOutput": "2",
              "explanation": "All identical, can only keep 1. Remove 2.",
              "id": "500527a5-4b75-4804-884b-633594a23aae",
              "input": "intervals = [[1,2],[1,2],[1,2]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "Already non-overlapping (touching endpoints is OK)",
              "id": "06f907b4-5c21-4a4e-b78c-ea98e32b4a40",
              "input": "intervals = [[1,2],[2,3]]"
            }
          ]
        },
        {
          "approach": "1. Sort intervals by start time\n2. Track end of previous kept interval\n3. For each interval:\n   a. If overlap (start < prevEnd), increment removals, keep shorter one (update prevEnd to min)\n   b. Else, update prevEnd to current end",
          "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by start time\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    \n    var removals = 0\n    var prevEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] < prevEnd {\n            // Overlap - remove one (keep the one ending sooner)\n            removals += 1\n            prevEnd = min(prevEnd, sorted[i][1])\n        } else {\n            prevEnd = sorted[i][1]\n        }\n    }\n    \n    return removals\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Sorted copy of intervals",
            "time": "O(n log n)",
            "timeExplanation": "Sorting dominates"
          },
          "explanation": "When intervals overlap, we want to keep the one ending sooner. By sorting by start time and keeping the smaller end when conflicts occur, we minimize future overlaps. This is equivalent to the end-time approach but processes differently.",
          "id": "9292907f-e7f5-415a-a981-a74969447d6d",
          "intuition": "Sort by start time. When two intervals overlap, remove the one that ends later (it's more likely to cause future conflicts).",
          "name": "Greedy (Sort by Start, Track Overlaps)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Keep [1,11] and [11,22], remove the longer overlapping ones",
              "id": "5b89ec8c-8ada-4764-af2b-3636c8083efe",
              "input": "intervals = [[1,100],[11,22],[1,11],[2,12]]"
            }
          ]
        }
      ],
      "id": "801675de-2c25-440e-9366-c3b5e3014fe9",
      "lastUpdated": "2026-02-06T08:38:32Z",
      "problemSlug": "non-overlapping-intervals",
      "relatedProblems": [
        "merge-intervals",
        "insert-interval",
        "minimum-number-of-arrows-to-burst-balloons"
      ],
      "summary": "Find minimum intervals to remove to make the rest non-overlapping. Greedy: sort by end time, keep intervals that don't overlap with previous kept interval. Remove count = total - kept."
    },
    {
      "approaches": [
        {
          "approach": "1. For each asteroid:\n   a. If positive, push to stack\n   b. If negative, resolve collisions with stack:\n      - While stack top is positive and smaller, pop (it explodes)\n      - If stack top is positive and equal, pop and don't push (both explode)\n      - If stack empty or top is negative, push (survives)\n2. Return stack as array",
          "code": "func asteroidCollision(_ asteroids: [Int]) -> [Int] {\n    var stack: [Int] = []\n    \n    for asteroid in asteroids {\n        if asteroid > 0 {\n            stack.append(asteroid)\n        } else {\n            // asteroid < 0, resolve collisions\n            while !stack.isEmpty && stack.last! > 0 && stack.last! < -asteroid {\n                stack.removeLast()  // Stack asteroid explodes\n            }\n            \n            if stack.isEmpty || stack.last! < 0 {\n                stack.append(asteroid)  // Survives\n            } else if stack.last! == -asteroid {\n                stack.removeLast()  // Both explode\n            }\n            // else: stack.last! > -asteroid, incoming asteroid explodes (don't push)\n        }\n    }\n    \n    return stack\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack can hold all asteroids in worst case",
            "time": "O(n)",
            "timeExplanation": "Each asteroid pushed and popped at most once"
          },
          "explanation": "Only right-moving (positive) and left-moving (negative) can collide. Two left-movers never collide (both going left). The stack holds surviving asteroids. When we see a negative asteroid, it can only collide with positive ones on the stack. We keep destroying stack asteroids until the negative one is destroyed or survives.",
          "id": "67155985-058b-4e25-9765-927480dad570",
          "intuition": "Right-moving asteroids wait on stack for potential collision. Left-moving asteroids collide with stack (right-movers) until destroyed or survives.",
          "name": "Stack Simulation",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[5,10]",
              "explanation": "10 and -5 collide, 10 survives. 5 and 10 don't collide (same direction).",
              "id": "1831cc38-dde5-4ed2-9e43-35c09d414259",
              "input": "asteroids = [5,10,-5]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Equal size, both explode.",
              "id": "0a8f32d9-ac07-482e-ad2f-440a97f52ac6",
              "input": "asteroids = [8,-8]"
            },
            {
              "expectedOutput": "[10]",
              "explanation": "-5 destroys 2, then collides with 10 and explodes.",
              "id": "323c831c-7e40-4a2b-82d2-a1f5993b7617",
              "input": "asteroids = [10,2,-5]"
            },
            {
              "expectedOutput": "[-2,-1,1,2]",
              "explanation": "Left-movers go left, right-movers go right. No collisions.",
              "id": "50acb1d7-41cc-4eeb-912a-951d1d9c70b7",
              "input": "asteroids = [-2,-1,1,2]"
            }
          ]
        },
        {
          "approach": "1. For each asteroid:\n   a. Set alive = true\n   b. While alive and asteroid < 0 and stack top > 0:\n      - If |asteroid| > stack top: pop, continue\n      - If |asteroid| == stack top: pop, alive = false\n      - If |asteroid| < stack top: alive = false\n   c. If alive, push asteroid",
          "code": "func asteroidCollision(_ asteroids: [Int]) -> [Int] {\n    var stack: [Int] = []\n    \n    for asteroid in asteroids {\n        var alive = true\n        \n        while alive && asteroid < 0 && !stack.isEmpty && stack.last! > 0 {\n            let top = stack.last!\n            if top < -asteroid {\n                stack.removeLast()  // Top explodes, continue checking\n            } else if top == -asteroid {\n                stack.removeLast()  // Both explode\n                alive = false\n            } else {\n                alive = false  // Incoming explodes\n            }\n        }\n        \n        if alive {\n            stack.append(asteroid)\n        }\n    }\n    \n    return stack\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Stack size at most n",
            "time": "O(n)",
            "timeExplanation": "Each asteroid processed once, total pops <= n"
          },
          "explanation": "This version explicitly tracks whether the incoming asteroid survives. The while loop continues as long as there's potential for collision (incoming negative, stack top positive) and the incoming asteroid is still 'alive'. This makes the three collision outcomes clearer.",
          "id": "a12e9c2c-de32-4f84-adc3-bb5e34ef8599",
          "intuition": "Same logic but with a boolean to track if the incoming asteroid survives all collisions, making the code flow clearer.",
          "name": "Stack with Explicit State",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[-2]",
              "explanation": "1 and -1 both explode. -2 survives (nothing to collide with).",
              "id": "70ee2306-1434-42a4-a5f1-1be479c8dfc5",
              "input": "asteroids = [1,-1,-2]"
            }
          ]
        }
      ],
      "id": "868ed1fa-3119-4d0f-abd2-c4cb47b6ce64",
      "lastUpdated": "2026-02-06T08:38:32Z",
      "problemSlug": "asteroid-collision",
      "relatedProblems": [
        "can-place-flowers",
        "destroying-asteroids"
      ],
      "summary": "Asteroids move right (+) or left (-). When they collide, smaller one explodes; equal sizes both explode. Use a stack to simulate collisions as asteroids move."
    },
    {
      "approaches": [
        {
          "approach": "1. low = 0 (boundary for 0s), high = n-1 (boundary for 2s), mid = 0\n2. While mid <= high:\n   a. If nums[mid] == 0: swap with low, increment both low and mid\n   b. If nums[mid] == 1: just increment mid\n   c. If nums[mid] == 2: swap with high, decrement high (don't increment mid!)\n3. Array is sorted",
          "code": "func sortColors(_ nums: inout [Int]) {\n    var low = 0\n    var mid = 0\n    var high = nums.count - 1\n    \n    while mid <= high {\n        switch nums[mid] {\n        case 0:\n            nums.swapAt(low, mid)\n            low += 1\n            mid += 1\n        case 1:\n            mid += 1\n        case 2:\n            nums.swapAt(mid, high)\n            high -= 1\n            // Don't increment mid - need to check swapped value\n        default:\n            break\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "In-place sorting with just pointer variables",
            "time": "O(n)",
            "timeExplanation": "Single pass through array"
          },
          "explanation": "The array is partitioned into 4 regions: [0...low-1] are 0s, [low...mid-1] are 1s, [mid...high] are unknown, [high+1...n-1] are 2s. We scan with mid, placing 0s at low and 2s at high. When swapping with high, we don't advance mid because the swapped element is unknown and needs to be checked.",
          "id": "0681a423-fedc-4957-8fe3-fae31d7dca79",
          "intuition": "Maintain three regions: 0s at the front, 2s at the back, 1s in the middle. Use three pointers to expand these regions.",
          "name": "Dutch National Flag (3 Pointers)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,0,1,1,2,2]",
              "explanation": "0s moved to front, 2s to back, 1s in middle",
              "id": "844a778a-0d0d-4c7a-90c6-351278cb66c8",
              "input": "nums = [2,0,2,1,1,0]"
            },
            {
              "expectedOutput": "[0,1,2]",
              "explanation": "Simple case with one of each",
              "id": "b38571d6-a563-448d-b6db-e3984d068290",
              "input": "nums = [2,0,1]"
            },
            {
              "expectedOutput": "[0]",
              "explanation": "Single element already sorted",
              "id": "d0a964d6-024b-4111-ae21-4d5715c6e6ea",
              "input": "nums = [0]"
            }
          ]
        },
        {
          "approach": "1. Count how many 0s, 1s, 2s\n2. Fill array: first count0 zeros, then count1 ones, then count2 twos",
          "code": "func sortColors(_ nums: inout [Int]) {\n    var count = [0, 0, 0]\n    \n    for num in nums {\n        count[num] += 1\n    }\n    \n    var index = 0\n    for color in 0..<3 {\n        for _ in 0..<count[color] {\n            nums[index] = color\n            index += 1\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only 3 counter variables",
            "time": "O(n)",
            "timeExplanation": "Two passes through array"
          },
          "explanation": "Since we only have 3 possible values, counting sort is efficient. First pass counts, second pass writes. This uses O(1) extra space (just 3 counters) but requires two passes through the array.",
          "id": "1a57e429-0f48-469f-8b63-a78fb5721ab5",
          "intuition": "Count occurrences of 0, 1, 2, then overwrite array with that many of each. Two passes but very simple.",
          "name": "Counting Sort",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0,0,1,1,2,2]",
              "explanation": "Count: [2,2,2]. Write 2 zeros, 2 ones, 2 twos.",
              "id": "309baa40-9e30-4a02-9f9a-e6660074201a",
              "input": "nums = [2,0,2,1,1,0]"
            }
          ]
        }
      ],
      "id": "d9aa754e-e590-4782-babf-c84ee1fdd224",
      "lastUpdated": "2026-02-06T08:40:26Z",
      "problemSlug": "sort-colors",
      "relatedProblems": [
        "sort-list",
        "wiggle-sort",
        "wiggle-sort-ii"
      ],
      "summary": "Sort array with values 0, 1, 2 (Dutch National Flag problem). Use three pointers to partition in single pass: low for 0s boundary, high for 2s boundary, mid for scanning."
    },
    {
      "approaches": [
        {
          "approach": "1. Calculate total elements n = rows * cols\n2. Binary search with left = 0, right = n - 1\n3. For mid, convert to matrix[mid / cols][mid % cols]\n4. Standard binary search comparison and bounds update",
          "code": "func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n    let rows = matrix.count\n    let cols = matrix[0].count\n    var left = 0\n    var right = rows * cols - 1\n    \n    while left <= right {\n        let mid = left + (right - left) / 2\n        let value = matrix[mid / cols][mid % cols]\n        \n        if value == target {\n            return true\n        } else if value < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using pointer variables",
            "time": "O(log(m*n))",
            "timeExplanation": "Binary search over m*n elements"
          },
          "explanation": "Since rows are contiguous in sorted order, index i in a flattened array maps to row i/cols, column i%cols. This lets us use standard binary search with O(1) index conversion. The matrix structure is just a visual layout of a sorted array.",
          "id": "f5b3a5ed-97cf-47dc-891d-aba935280e7d",
          "intuition": "The matrix is essentially a sorted 1D array laid out in rows. Map 1D index to 2D coordinates: row = idx / cols, col = idx % cols.",
          "name": "Binary Search (Treat as 1D)",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "3 is at position (0,1)",
              "id": "d0dfb5d1-0790-432d-b945-465a3f381e18",
              "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3"
            },
            {
              "expectedOutput": "false",
              "explanation": "13 not in matrix",
              "id": "0e592c09-488c-4310-8d5d-456ab74966e9",
              "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13"
            }
          ]
        },
        {
          "approach": "1. Binary search on first column to find row where row[0] <= target < nextRow[0]\n2. Binary search within that row for target\n3. Return true if found",
          "code": "func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n    let rows = matrix.count\n    let cols = matrix[0].count\n    \n    // Binary search for row\n    var top = 0\n    var bottom = rows - 1\n    var targetRow = 0\n    \n    while top <= bottom {\n        let mid = top + (bottom - top) / 2\n        if matrix[mid][0] <= target && (mid == rows - 1 || matrix[mid + 1][0] > target) {\n            targetRow = mid\n            break\n        } else if matrix[mid][0] > target {\n            bottom = mid - 1\n        } else {\n            top = mid + 1\n        }\n    }\n    \n    // Binary search within row\n    var left = 0\n    var right = cols - 1\n    \n    while left <= right {\n        let mid = left + (right - left) / 2\n        if matrix[targetRow][mid] == target {\n            return true\n        } else if matrix[targetRow][mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only pointer variables",
            "time": "O(log m + log n)",
            "timeExplanation": "Two separate binary searches"
          },
          "explanation": "We use the property that first elements of each row are sorted. First binary search narrows down to the correct row (the last row whose first element <= target). Second binary search finds target within that row. Two O(log n) searches is still O(log(m*n)).",
          "id": "b5531ab7-8e51-41b4-825c-69262ecbb248",
          "intuition": "First binary search to find the correct row (where target could be), then binary search within that row.",
          "name": "Two Binary Searches",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Row search finds row 0, column search finds index 1",
              "id": "4f610481-8432-4936-87be-9ccba22aa033",
              "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3"
            }
          ]
        }
      ],
      "id": "18fd7cf2-e728-4f5a-957b-b10a87cdadc7",
      "lastUpdated": "2026-02-06T08:40:26Z",
      "problemSlug": "search-a-2d-matrix",
      "relatedProblems": [
        "search-a-2d-matrix-ii"
      ],
      "summary": "Search for a target in a sorted 2D matrix (each row sorted, first element of row > last element of previous row). Treat as 1D array and binary search, or do two binary searches."
    },
    {
      "approaches": [
        {
          "approach": "1. left = 1, right = max(piles)\n2. Binary search:\n   a. Calculate hours needed at mid speed\n   b. If hours <= h, try smaller k (right = mid)\n   c. If hours > h, need faster k (left = mid + 1)\n3. Return left",
          "code": "func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {\n    var left = 1\n    var right = piles.max()!\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        let hours = hoursNeeded(piles, mid)\n        \n        if hours <= h {\n            right = mid  // mid works, try smaller\n        } else {\n            left = mid + 1  // mid too slow\n        }\n    }\n    \n    return left\n}\n\nfunc hoursNeeded(_ piles: [Int], _ k: Int) -> Int {\n    var hours = 0\n    for pile in piles {\n        hours += (pile + k - 1) / k  // Ceiling division\n    }\n    return hours\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using variables",
            "time": "O(n log m)",
            "timeExplanation": "Binary search O(log m) on max pile size, each iteration O(n) to sum hours"
          },
          "explanation": "At speed k, pile of size p takes ceil(p/k) hours. Sum all pile times. If total <= h, k works but maybe a smaller k also works. If total > h, k is too slow. We binary search to find the minimum working k. Using left = mid when feasible ensures we find the minimum.",
          "id": "a31f38a6-9027-4960-8ead-3892edb759cf",
          "intuition": "The answer k is in range [1, max(piles)]. Higher k means fewer hours. Binary search to find minimum k where we can finish in time.",
          "name": "Binary Search on Speed",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "At k=4: 1+2+2+3=8 hours. At k=3: 1+2+3+4=10 hours (too slow).",
              "id": "372f9874-57fb-490b-9f49-5026baaa2104",
              "input": "piles = [3,6,7,11], h = 8"
            },
            {
              "expectedOutput": "30",
              "explanation": "With 5 piles and 5 hours, need to eat each pile in 1 hour. Max pile is 30.",
              "id": "52dfefde-a685-48b9-b335-664f2ee943fc",
              "input": "piles = [30,11,23,4,20], h = 5"
            },
            {
              "expectedOutput": "23",
              "explanation": "Can split largest pile across 2 hours. k=23 gives 2+1+1+1+1=6 hours.",
              "id": "09547910-5a64-48cd-840d-36f65418171c",
              "input": "piles = [30,11,23,4,20], h = 6"
            }
          ]
        },
        {
          "approach": "1. min_k = 1, max_k = max(piles)\n2. Binary search to find leftmost k where canFinish(k, h)\n3. canFinish checks if sum of ceil(pile/k) <= h",
          "code": "func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {\n    func canFinish(_ k: Int) -> Bool {\n        var totalHours = 0\n        for pile in piles {\n            totalHours += (pile + k - 1) / k\n            if totalHours > h { return false }  // Early exit\n        }\n        return true\n    }\n    \n    var left = 1\n    var right = piles.max()!\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        if canFinish(mid) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    \n    return left\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant extra space",
            "time": "O(n log m)",
            "timeExplanation": "Same complexity with potential early exit optimization"
          },
          "explanation": "This version explicitly defines the feasibility function canFinish. We're looking for the minimum k in the 'feasible' region. The transition from infeasible to feasible happens exactly once as k increases, making binary search applicable.",
          "id": "c016e983-e3c5-4178-b8c8-0b3a2a816bbf",
          "intuition": "Same algorithm but with clearer reasoning about bounds. Minimum possible k is 1 (though may not finish in time). Maximum useful k is max pile (anything higher is wasteful).",
          "name": "Binary Search (Explicit Bounds)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "canFinish(4)=true, canFinish(3)=false, so answer is 4",
              "id": "94eaf6fd-ceb2-4ba7-8ffa-4ace1ac22cba",
              "input": "piles = [3,6,7,11], h = 8"
            }
          ]
        }
      ],
      "id": "b5687d2c-91a9-4268-8fc5-5b7f310fdaad",
      "lastUpdated": "2026-02-06T08:40:26Z",
      "problemSlug": "koko-eating-bananas",
      "relatedProblems": [
        "minimize-max-distance-to-gas-station",
        "capacity-to-ship-packages-within-d-days",
        "split-array-largest-sum"
      ],
      "summary": "Find minimum eating speed k to finish all banana piles within h hours. Binary search on k: for each k, calculate total hours needed. Find smallest k where hours <= h."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is null, return false\n2. Subtract root.val from targetSum\n3. If root is leaf (no children), return targetSum == 0\n4. Recursively check left OR right subtree",
          "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    let remaining = targetSum - root.val\n    \n    // Check if leaf\n    if root.left == nil && root.right == nil {\n        return remaining == 0\n    }\n    \n    // Check children\n    return hasPathSum(root.left, remaining) || hasPathSum(root.right, remaining)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Visit each node at most once"
          },
          "explanation": "We accumulate the path sum by subtracting from target as we descend. At a leaf, if we've subtracted exactly targetSum total, we've found a valid path. Using subtraction avoids passing accumulated sum as parameter and handles negative values correctly.",
          "id": "76e1f12b-9f5e-4cad-a2ec-09141802369a",
          "intuition": "Subtract each node's value from target as we go down. At a leaf, check if remaining target equals 0 (or equivalently, if remaining equals leaf value).",
          "name": "DFS Recursive",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Path 5→4→11→2 sums to 22",
              "id": "837e34f3-b495-4dcc-acb4-1fd7ed76b154",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22"
            },
            {
              "expectedOutput": "false",
              "explanation": "Paths are 1→2=3 and 1→3=4. Neither equals 5.",
              "id": "28e4940f-c088-48b8-a931-bb32cae5aac3",
              "input": "root = [1,2,3], targetSum = 5"
            },
            {
              "expectedOutput": "false",
              "explanation": "Empty tree has no paths",
              "id": "2af4823a-4328-4489-9577-0902c4199603",
              "input": "root = [], targetSum = 0"
            }
          ]
        },
        {
          "approach": "1. Stack of (node, remainingSum) pairs\n2. Push root with targetSum\n3. While stack not empty:\n   a. Pop node and remaining\n   b. If leaf and remaining == node.val, return true\n   c. Push children with remaining - node.val\n4. Return false",
          "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    var stack: [(TreeNode, Int)] = [(root, targetSum)]\n    \n    while !stack.isEmpty {\n        let (node, remaining) = stack.removeLast()\n        \n        // Check if leaf with matching sum\n        if node.left == nil && node.right == nil && remaining == node.val {\n            return true\n        }\n        \n        // Push children\n        if let left = node.left {\n            stack.append((left, remaining - node.val))\n        }\n        if let right = node.right {\n            stack.append((right, remaining - node.val))\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most one path worth of nodes",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "This iterative version mimics the recursive approach using an explicit stack. We track the remaining sum needed at each node. When we reach a leaf, we check if the node's value exactly matches the remaining sum (meaning the path sums to target).",
          "id": "56961416-e0ed-45b7-ae59-4e8eca175587",
          "intuition": "Use stack to simulate DFS. Store (node, remaining sum) pairs. At each leaf, check if sum matches.",
          "name": "Iterative with Stack",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same result via iteration",
              "id": "d7596ca3-586f-4cda-88b1-d5bb6ecbc79e",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22"
            }
          ]
        }
      ],
      "id": "9e84e3e8-6da3-45d8-9fd0-3c420790107c",
      "lastUpdated": "2026-02-06T08:40:26Z",
      "problemSlug": "path-sum",
      "relatedProblems": [
        "path-sum-ii",
        "path-sum-iii",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "Check if tree has root-to-leaf path with given sum. DFS subtracting node values from target; at leaf, check if remaining target equals leaf value."
    },
    {
      "id": "5c96629b-5cad-4841-826f-81acff3c5cee",
      "problemSlug": "squares-of-a-sorted-array",
      "summary": "Given sorted array (may have negatives), return array of squares in sorted order. Two pointers from ends, compare absolute values, fill result from back.",
      "approaches": [
        {
          "id": "540673ac-a87e-4c30-ac12-47ac6a5e8f7c",
          "name": "Two Pointers",
          "order": 1,
          "intuition": "Largest squares are at the ends (most negative or most positive). Compare absolute values at both ends, place larger square at end of result, move pointer inward.",
          "approach": "1. Left pointer at start, right at end\n2. Result array filled from back\n3. Compare abs values at left and right\n4. Place larger square at current result position, move that pointer\n5. Decrement result position",
          "explanation": "In a sorted array with negatives, the largest absolute values are at the extremes. By using two pointers and filling the result from the end, we efficiently place squares in sorted order without needing to sort afterward.",
          "code": "func sortedSquares(_ nums: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: nums.count)\n    var left = 0\n    var right = nums.count - 1\n    var pos = nums.count - 1\n    \n    while left <= right {\n        let leftSq = nums[left] * nums[left]\n        let rightSq = nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left += 1\n        } else {\n            result[pos] = rightSq\n            right -= 1\n        }\n        pos -= 1\n    }\n    \n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass with two pointers",
            "spaceExplanation": "Result array of size n"
          },
          "testCases": [
            {
              "id": "70106d22-0d1b-461f-8353-6e8fa03eb7e1",
              "input": "nums = [-4,-1,0,3,10]",
              "expectedOutput": "[0,1,9,16,100]",
              "explanation": "Compare |-4|=4 vs |10|=10. 100 goes last. Then |-4| vs |3|, 16 goes next. Etc."
            },
            {
              "id": "453089a5-45c6-4d42-9a1d-1d9abdbf6b01",
              "input": "nums = [-7,-3,2,3,11]",
              "expectedOutput": "[4,9,9,49,121]",
              "explanation": "Two pointers handle negative numbers efficiently"
            }
          ]
        },
        {
          "id": "75c04428-bf96-4c25-8ec4-d205e19aacee",
          "name": "Square and Sort",
          "order": 2,
          "intuition": "Simple approach: square all elements, then sort. Less efficient but very straightforward.",
          "approach": "1. Square each element\n2. Sort the result",
          "explanation": "This naive approach works but uses O(n log n) time due to sorting. The two-pointer approach is better, but this is simpler to implement and understand.",
          "code": "func sortedSquares(_ nums: [Int]) -> [Int] {\n    return nums.map { $0 * $0 }.sorted()\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "Sorting dominates",
            "spaceExplanation": "New array for result"
          },
          "testCases": [
            {
              "id": "993d38e2-c1b2-4a05-b438-c9ed48cca30b",
              "input": "nums = [-4,-1,0,3,10]",
              "expectedOutput": "[0,1,9,16,100]",
              "explanation": "Square: [16,1,0,9,100]. Sort: [0,1,9,16,100]"
            }
          ]
        }
      ],
      "relatedProblems": [
        "merge-sorted-array",
        "sort-an-array"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "8b7cef2d-6ed2-4b23-96fd-7b7de1042385",
      "problemSlug": "target-sum",
      "summary": "Find number of ways to assign + or - to elements to reach target sum. Use DP: convert to subset sum problem where we find subsets summing to (total + target) / 2.",
      "approaches": [
        {
          "id": "260a898d-1c25-4543-abc3-1288b634343c",
          "name": "2D DP (Subset Sum)",
          "order": 1,
          "intuition": "If we assign + to some numbers and - to others: P - N = target, P + N = total. So P = (total + target) / 2. Count subsets summing to P.",
          "approach": "1. Calculate sum = (total + target) / 2\n2. If (total + target) is odd or target > total, return 0\n3. dp[i][j] = ways to get sum j using first i elements\n4. dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]] (exclude or include)\n5. Return dp[n][sum]",
          "explanation": "We transform the problem: instead of +/- signs, find a subset P where sum(P) = (total + target)/2. The remaining elements form N = total - P. Then P - N = 2P - total = target. This is a classic 0/1 knapsack counting problem.",
          "code": "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    let total = nums.reduce(0, +)\n    if (total + target) % 2 != 0 || abs(target) > total {\n        return 0\n    }\n    \n    let sum = (total + target) / 2\n    var dp = [Int](repeating: 0, count: sum + 1)\n    dp[0] = 1\n    \n    for num in nums {\n        for j in stride(from: sum, through: num, by: -1) {\n            dp[j] += dp[j - num]\n        }\n    }\n    \n    return dp[sum]\n}",
          "complexity": {
            "time": "O(n × sum)",
            "space": "O(sum)",
            "timeExplanation": "Process each number against all possible sums",
            "spaceExplanation": "1D DP array of size sum+1"
          },
          "testCases": [
            {
              "id": "120e9e9c-80ed-4003-9d3f-7ca488346045",
              "input": "nums = [1,1,1,1,1], target = 3",
              "expectedOutput": "5",
              "explanation": "5 ways: -1+1+1+1+1, +1-1+1+1+1, etc."
            },
            {
              "id": "c5c8e617-e174-49dd-bc5b-02ba2265370d",
              "input": "nums = [1], target = 1",
              "expectedOutput": "1",
              "explanation": "Only +1 = 1"
            }
          ]
        },
        {
          "id": "e2ca2b5b-686f-4334-a765-bc855be26b70",
          "name": "Memoized DFS",
          "order": 2,
          "intuition": "Try both + and - for each number. Memoize (index, currentSum) to avoid recomputation.",
          "approach": "1. DFS with parameters (index, currentSum)\n2. Base case: if index == n, return 1 if sum == target, else 0\n3. Try adding and subtracting nums[index]\n4. Memoize results",
          "explanation": "Direct simulation of the problem. At each step, we can add or subtract the current number. Memoization prevents exponential blowup by caching results for (index, sum) pairs we've seen.",
          "code": "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    var memo: [String: Int] = [:]\n    \n    func dfs(_ i: Int, _ sum: Int) -> Int {\n        if i == nums.count {\n            return sum == target ? 1 : 0\n        }\n        \n        let key = \"\\(i),\\(sum)\"\n        if let cached = memo[key] { return cached }\n        \n        let result = dfs(i + 1, sum + nums[i]) + dfs(i + 1, sum - nums[i])\n        memo[key] = result\n        return result\n    }\n    \n    return dfs(0, 0)\n}",
          "complexity": {
            "time": "O(n × totalSum)",
            "space": "O(n × totalSum)",
            "timeExplanation": "Each (index, sum) pair computed once",
            "spaceExplanation": "Memoization table for all states"
          },
          "testCases": [
            {
              "id": "136e7ff9-fd92-4a01-a031-11fc93062b05",
              "input": "nums = [1,1,1,1,1], target = 3",
              "expectedOutput": "5",
              "explanation": "Same result via memoized recursion"
            }
          ]
        }
      ],
      "relatedProblems": [
        "partition-equal-subset-sum",
        "last-stone-weight-ii"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "0462b6a7-f35b-41c6-9230-d2b7d6e85f5b",
      "problemSlug": "partition-equal-subset-sum",
      "summary": "Determine if array can be partitioned into two subsets with equal sum. This is subset sum problem: can we find subset summing to total/2?",
      "approaches": [
        {
          "id": "cc8335b9-2312-44d6-977b-416387e0bc91",
          "name": "DP (Subset Sum)",
          "order": 1,
          "intuition": "If total sum is odd, impossible. Otherwise, find if any subset sums to total/2. Classic 0/1 knapsack.",
          "approach": "1. If sum is odd, return false\n2. target = sum / 2\n3. dp[j] = true if we can make sum j\n4. For each num, update dp from right to left\n5. Return dp[target]",
          "explanation": "We need to find if a subset sums to exactly half the total. dp[j] represents whether sum j is achievable. For each number, we update achievable sums by including it. Process right-to-left to avoid using same number twice.",
          "code": "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total / 2\n    var dp = [Bool](repeating: false, count: target + 1)\n    dp[0] = true\n    \n    for num in nums {\n        for j in stride(from: target, through: num, by: -1) {\n            dp[j] = dp[j] || dp[j - num]\n        }\n    }\n    \n    return dp[target]\n}",
          "complexity": {
            "time": "O(n × sum)",
            "space": "O(sum)",
            "timeExplanation": "Process each number against possible sums",
            "spaceExplanation": "Boolean array of size sum/2"
          },
          "testCases": [
            {
              "id": "bb218084-f362-4c29-9aa1-670fb1c3048c",
              "input": "nums = [1,5,11,5]",
              "expectedOutput": "true",
              "explanation": "Partition: [1,5,5] and [11], both sum to 11"
            },
            {
              "id": "1ed86229-7935-4978-86dc-1f839cf12009",
              "input": "nums = [1,2,3,5]",
              "expectedOutput": "false",
              "explanation": "Total is 11 (odd), can't split equally"
            }
          ]
        },
        {
          "id": "46cf8abf-4483-4079-978c-99ec239a13dc",
          "name": "Bitset Optimization",
          "order": 2,
          "intuition": "Use bitset where bit j is set if sum j is achievable. Shift and OR to update all sums at once.",
          "approach": "1. Use integer/bitset where bit j means sum j achievable\n2. For each num, bits |= bits << num\n3. Check if target bit is set",
          "explanation": "This is a clever optimization. If bits represents achievable sums, then bits << num shifts all achievable sums up by num. ORing with original gives all sums achievable with or without including num. Very fast in practice.",
          "code": "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total / 2\n    var bits = Set<Int>([0])\n    \n    for num in nums {\n        var newBits = Set<Int>()\n        for b in bits {\n            let newSum = b + num\n            if newSum <= target {\n                newBits.insert(newSum)\n            }\n        }\n        bits.formUnion(newBits)\n        if bits.contains(target) { return true }\n    }\n    \n    return bits.contains(target)\n}",
          "complexity": {
            "time": "O(n × sum)",
            "space": "O(sum)",
            "timeExplanation": "Similar to DP but with set operations",
            "spaceExplanation": "Set of achievable sums"
          },
          "testCases": [
            {
              "id": "6dfb3b44-50c2-44d2-a238-b9d0637b865c",
              "input": "nums = [1,5,11,5]",
              "expectedOutput": "true",
              "explanation": "Early exit when target found"
            }
          ]
        }
      ],
      "relatedProblems": [
        "target-sum",
        "last-stone-weight-ii",
        "partition-to-k-equal-sum-subsets"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "fc506863-9dd1-409c-a752-043e9bbcc5ad",
      "problemSlug": "binary-tree-right-side-view",
      "summary": "Return values visible from right side of tree (rightmost node at each level). BFS level-order taking last node per level, or DFS visiting right child first.",
      "approaches": [
        {
          "id": "ef3bba2f-d9ca-46fc-9a37-c34c4699c77a",
          "name": "BFS Level Order",
          "order": 1,
          "intuition": "Process tree level by level. The rightmost node at each level is visible from the right side.",
          "approach": "1. BFS with queue\n2. For each level, record the last node's value\n3. Process all nodes at current level before moving to next",
          "explanation": "Standard level-order traversal. At each level, we process all nodes in the queue (which represents one complete level). The last node we process at each level is the rightmost one, which we add to our result.",
          "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    guard let root = root else { return [] }\n    \n    var result: [Int] = []\n    var queue: [TreeNode] = [root]\n    \n    while !queue.isEmpty {\n        let levelSize = queue.count\n        for i in 0..<levelSize {\n            let node = queue.removeFirst()\n            if i == levelSize - 1 {\n                result.append(node.val)\n            }\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n    }\n    \n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(w)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Queue holds at most one level, max width w"
          },
          "testCases": [
            {
              "id": "d6b6bd11-0cee-4e68-ad8b-80b55c87745d",
              "input": "root = [1,2,3,null,5,null,4]",
              "expectedOutput": "[1,3,4]",
              "explanation": "Level 0: 1, Level 1: 3 (rightmost), Level 2: 4 (rightmost)"
            },
            {
              "id": "d410ae7e-1a0a-42fc-8a1e-e34f6748ed3c",
              "input": "root = [1,null,3]",
              "expectedOutput": "[1,3]",
              "explanation": "Right-skewed tree"
            }
          ]
        },
        {
          "id": "3937746c-65bb-4e74-bec4-9df1318af710",
          "name": "DFS Right-First",
          "order": 2,
          "intuition": "DFS visiting right child before left. First node we see at each depth is the rightmost.",
          "approach": "1. Track current depth and result size\n2. If depth == result.size, this is first (rightmost) node at this depth\n3. Visit right child first, then left",
          "explanation": "By visiting right subtree first, the first node we encounter at each new depth is guaranteed to be the rightmost at that level. We add it to result only when we reach a new depth (result.count == depth).",
          "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    var result: [Int] = []\n    \n    func dfs(_ node: TreeNode?, _ depth: Int) {\n        guard let node = node else { return }\n        \n        if depth == result.count {\n            result.append(node.val)\n        }\n        \n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n    }\n    \n    dfs(root, 0)\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Recursion stack depth is tree height"
          },
          "testCases": [
            {
              "id": "2085e43b-d162-4557-accc-6a3f8e62e51c",
              "input": "root = [1,2,3,null,5,null,4]",
              "expectedOutput": "[1,3,4]",
              "explanation": "DFS right-first finds same nodes"
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "populating-next-right-pointers-in-each-node"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "c1b34626-4b34-4c49-989a-8786f1b8271b",
      "problemSlug": "jump-game-ii",
      "summary": "Find minimum jumps to reach end of array where nums[i] is max jump length from i. Greedy: at each step, jump to position that lets you reach furthest.",
      "approaches": [
        {
          "id": "2e990002-4fa0-4754-a659-614198403aee",
          "name": "Greedy (BFS-like)",
          "order": 1,
          "intuition": "Track the furthest position reachable. When we reach current boundary, we must jump. Count jumps when boundary is reached.",
          "approach": "1. Track currentEnd (boundary of current jump) and furthest reachable\n2. For each position, update furthest\n3. When i reaches currentEnd, increment jumps, update currentEnd to furthest\n4. Stop when currentEnd >= last index",
          "explanation": "Think of it as BFS where each 'level' is positions reachable with the same number of jumps. currentEnd marks the boundary of current level. When we reach it, we've explored all positions at this level and must jump to next level (furthest becomes new boundary).",
          "code": "func jump(_ nums: [Int]) -> Int {\n    if nums.count <= 1 { return 0 }\n    \n    var jumps = 0\n    var currentEnd = 0\n    var furthest = 0\n    \n    for i in 0..<nums.count - 1 {\n        furthest = max(furthest, i + nums[i])\n        \n        if i == currentEnd {\n            jumps += 1\n            currentEnd = furthest\n            if currentEnd >= nums.count - 1 { break }\n        }\n    }\n    \n    return jumps\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass through array",
            "spaceExplanation": "Only tracking three variables"
          },
          "testCases": [
            {
              "id": "d50605a9-c2cc-460f-8632-18d5f5de1d9f",
              "input": "nums = [2,3,1,1,4]",
              "expectedOutput": "2",
              "explanation": "Jump from 0→1 (can reach up to 4), then 1→4. Two jumps."
            },
            {
              "id": "8046a1b0-aba6-44b2-afe2-c0eda02e20dd",
              "input": "nums = [2,3,0,1,4]",
              "expectedOutput": "2",
              "explanation": "Same: 0→1→4"
            }
          ]
        },
        {
          "id": "4046a33a-693c-4542-a4ce-8efaf4285c4a",
          "name": "DP (for comparison)",
          "order": 2,
          "intuition": "dp[i] = minimum jumps to reach position i. For each position, update all reachable positions.",
          "approach": "1. dp[0] = 0, dp[i] = infinity\n2. For each i, for each j reachable from i: dp[j] = min(dp[j], dp[i]+1)\n3. Return dp[n-1]",
          "explanation": "This is the straightforward DP approach. For each position, we update all positions we can jump to. Less efficient than greedy but easier to understand. Shows the greedy solution is optimal.",
          "code": "func jump(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var dp = [Int](repeating: Int.max, count: n)\n    dp[0] = 0\n    \n    for i in 0..<n {\n        for j in i+1...min(i + nums[i], n - 1) {\n            dp[j] = min(dp[j], dp[i] + 1)\n        }\n    }\n    \n    return dp[n - 1]\n}",
          "complexity": {
            "time": "O(n²)",
            "space": "O(n)",
            "timeExplanation": "For each position, potentially update many others",
            "spaceExplanation": "DP array of size n"
          },
          "testCases": [
            {
              "id": "020240d7-acfd-4fee-b5ef-7171273966fe",
              "input": "nums = [2,3,1,1,4]",
              "expectedOutput": "2",
              "explanation": "dp builds: [0,1,1,2,2]. Answer is 2."
            }
          ]
        }
      ],
      "relatedProblems": [
        "jump-game",
        "jump-game-iii"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "7da2ba9b-f8b5-40ee-add3-95cb464ba560",
      "problemSlug": "gas-station",
      "summary": "Find starting gas station index to complete circular trip. If total gas >= total cost, solution exists. Start from station after the one where tank goes negative.",
      "approaches": [
        {
          "id": "1ba963ca-54d1-47b2-ae93-e31fa04a550e",
          "name": "Greedy Single Pass",
          "order": 1,
          "intuition": "If total gas >= total cost, solution exists. If we run out at station i, start after i (stations 0 to i can't be start). Track where tank goes negative.",
          "approach": "1. Track total (gas - cost for all) and tank (running sum)\n2. If tank < 0, reset start to next station, reset tank\n3. Return start if total >= 0, else -1",
          "explanation": "Key insight: if we can't reach station i+1 from some start s, then any station between s and i also can't reach i+1 (because we'd have even less gas). So when tank goes negative, skip all those stations. If total is non-negative, the remaining stations must work.",
          "code": "func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\n    var total = 0\n    var tank = 0\n    var start = 0\n    \n    for i in 0..<gas.count {\n        let diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        \n        if tank < 0 {\n            start = i + 1\n            tank = 0\n        }\n    }\n    \n    return total >= 0 ? start : -1\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass through arrays",
            "spaceExplanation": "Only tracking a few variables"
          },
          "testCases": [
            {
              "id": "ad59c438-fa2b-47ec-a03b-a83316de8c69",
              "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
              "expectedOutput": "3",
              "explanation": "Start at station 3: tank 4-1=3, 3+5-2=6, 6+1-3=4, 4+2-4=2, 2+3-5=0. Success!"
            },
            {
              "id": "b5edb2af-7f12-41f9-8b9d-3f123ded9da1",
              "input": "gas = [2,3,4], cost = [3,4,3]",
              "expectedOutput": "-1",
              "explanation": "Total gas 9 < total cost 10. Impossible."
            }
          ]
        },
        {
          "id": "78e14786-cca2-4b1b-a5b1-f09992ed3099",
          "name": "Brute Force (for understanding)",
          "order": 2,
          "intuition": "Try each station as start. Simulate the trip and check if we complete the circuit.",
          "approach": "1. For each starting station i\n2. Simulate trip: at each station add gas, subtract cost\n3. If tank ever negative, this start fails\n4. If complete circuit, return i",
          "explanation": "Simple simulation to verify the greedy approach. Try each start, simulate the journey. TLE for large inputs but helps understand the problem.",
          "code": "func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\n    let n = gas.count\n    \n    for start in 0..<n {\n        var tank = 0\n        var success = true\n        \n        for i in 0..<n {\n            let station = (start + i) % n\n            tank += gas[station] - cost[station]\n            if tank < 0 {\n                success = false\n                break\n            }\n        }\n        \n        if success { return start }\n    }\n    \n    return -1\n}",
          "complexity": {
            "time": "O(n²)",
            "space": "O(1)",
            "timeExplanation": "Try each of n starts, each simulation is O(n)",
            "spaceExplanation": "Only loop variables"
          },
          "testCases": [
            {
              "id": "1cbb8bbf-bbbd-4fca-aa9c-570b20e9e6db",
              "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
              "expectedOutput": "3",
              "explanation": "Trying stations 0,1,2 fail. Station 3 succeeds."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-cost-to-hire-k-workers"
      ],
      "lastUpdated": "2026-02-06T00:53:56.092Z"
    },
    {
      "id": "d467c1bd-7f83-42a9-8b6d-113bf49b76cf",
      "problemSlug": "contains-duplicate-ii",
      "summary": "Check if array has duplicates within k indices. Use hash map to track last seen index of each value.",
      "approaches": [
        {
          "id": "43c3e701-6317-4e37-b56c-54ef6213375e",
          "name": "Hash Map",
          "order": 1,
          "intuition": "Store last seen index of each number. When we see it again, check if indices differ by <= k.",
          "approach": "1. Map stores value -> last seen index\n2. For each element, if in map and current - last <= k, return true\n3. Update map with current index",
          "explanation": "We only need to track the most recent index for each value because if there's a valid pair, it would involve the closest occurrence.",
          "code": "func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -> Bool {\n    var lastIndex: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        if let last = lastIndex[num], i - last <= k {\n            return true\n        }\n        lastIndex[num] = i\n    }\n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(min(n,k))",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Map stores at most k+1 elements"
          },
          "testCases": [
            {
              "id": "e0012751-0c01-47aa-9829-de5b1a41317a",
              "input": "nums = [1,2,3,1], k = 3",
              "expectedOutput": "true",
              "explanation": "nums[0]=nums[3], 3-0=3<=3"
            }
          ]
        }
      ],
      "relatedProblems": [
        "contains-duplicate",
        "contains-duplicate-iii"
      ],
      "lastUpdated": "2026-02-06T00:56:20.970Z"
    },
    {
      "id": "a6c1f591-a1d5-41cf-a9c1-de9fb94ad8b7",
      "problemSlug": "majority-element",
      "summary": "Find element appearing more than n/2 times. Boyer-Moore voting: maintain candidate and count, guaranteed to find majority.",
      "approaches": [
        {
          "id": "e7a35fb1-6142-4421-9210-db37cbbbdf72",
          "name": "Boyer-Moore Voting",
          "order": 1,
          "intuition": "Pairs of different elements cancel out. Majority element survives because it has more than half.",
          "approach": "1. candidate=first, count=1\n2. For each element: if matches candidate, count++; else count--\n3. If count=0, new candidate\n4. Return candidate",
          "explanation": "When count reaches 0, we've seen equal numbers of candidate and non-candidate elements. The majority still has more remaining than any other.",
          "code": "func majorityElement(_ nums: [Int]) -> Int {\n    var candidate = nums[0]\n    var count = 1\n    for i in 1..<nums.count {\n        if count == 0 {\n            candidate = nums[i]\n            count = 1\n        } else if nums[i] == candidate {\n            count += 1\n        } else {\n            count -= 1\n        }\n    }\n    return candidate\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Two variables"
          },
          "testCases": [
            {
              "id": "ad4712e5-d896-4a24-a993-47a365dfc5dc",
              "input": "nums = [3,2,3]",
              "expectedOutput": "3",
              "explanation": "3 appears 2 times > 3/2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "majority-element-ii"
      ],
      "lastUpdated": "2026-02-06T00:56:20.970Z"
    },
    {
      "id": "5762a62b-66ee-4ddf-8439-fe521956b799",
      "problemSlug": "first-missing-positive",
      "summary": "Find smallest missing positive integer in O(n) time and O(1) space. Use array itself as hash map by placing each number at index num-1.",
      "approaches": [
        {
          "id": "722ce15e-4216-4dda-8d68-b11968c4e0ca",
          "name": "Cyclic Sort / Index Mapping",
          "order": 1,
          "intuition": "Place each positive number i at index i-1. Then scan for first position where nums[i] != i+1.",
          "approach": "1. For each position, swap nums[i] to its correct position nums[i]-1\n2. Keep swapping until number is out of range or already correct\n3. Scan for first i where nums[i] != i+1",
          "explanation": "By placing numbers in their 'home' positions, we can find the missing one in linear time. Numbers > n or <= 0 are ignored since answer is in [1, n+1].",
          "code": "func firstMissingPositive(_ nums: [Int]) -> Int {\n    var nums = nums\n    let n = nums.count\n    for i in 0..<n {\n        while nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] {\n            nums.swapAt(i, nums[i]-1)\n        }\n    }\n    for i in 0..<n {\n        if nums[i] != i + 1 { return i + 1 }\n    }\n    return n + 1\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each element moved at most once",
            "spaceExplanation": "In-place"
          },
          "testCases": [
            {
              "id": "d8d9a770-3fcd-407d-adbd-c7ed2dd86362",
              "input": "nums = [3,4,-1,1]",
              "expectedOutput": "2",
              "explanation": "After sorting: [1,-1,3,4]. Position 1 should have 2."
            }
          ]
        }
      ],
      "relatedProblems": [
        "missing-number",
        "find-all-numbers-disappeared-in-an-array"
      ],
      "lastUpdated": "2026-02-06T00:56:20.970Z"
    },
    {
      "id": "2797689b-71ad-4ab0-987f-e57600535c0f",
      "problemSlug": "partition-labels",
      "summary": "Partition string so each letter appears in at most one part. Track last occurrence, extend partition until position equals last occurrence of all chars in it.",
      "approaches": [
        {
          "id": "3e33e68c-5cfa-428c-bbc5-a7c4f3470948",
          "name": "Greedy with Last Occurrence",
          "order": 1,
          "intuition": "For each char in partition, we must extend to its last occurrence. Track the furthest last occurrence seen.",
          "approach": "1. Map each char to last occurrence\n2. For each char, extend partition end to max(end, last[char])\n3. When i == end, partition complete",
          "explanation": "A partition is valid when we've included all occurrences of all its characters. We track the furthest 'last occurrence' and cut when we reach it.",
          "code": "func partitionLabels(_ s: String) -> [Int] {\n    let chars = Array(s)\n    var last: [Character: Int] = [:]\n    for (i, c) in chars.enumerated() { last[c] = i }\n    var result: [Int] = []\n    var start = 0, end = 0\n    for (i, c) in chars.enumerated() {\n        end = max(end, last[c]!)\n        if i == end {\n            result.append(end - start + 1)\n            start = i + 1\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Two passes",
            "spaceExplanation": "26 letters max"
          },
          "testCases": [
            {
              "id": "b3d7d941-7b07-442c-8c05-d5a20113bcc3",
              "input": "s = \"ababcbacadefegdehijhklij\"",
              "expectedOutput": "[9,7,8]",
              "explanation": "\"ababcbaca\", \"defegde\", \"hijhklij\""
            }
          ]
        }
      ],
      "relatedProblems": [
        "merge-intervals"
      ],
      "lastUpdated": "2026-02-06T00:56:20.970Z"
    },
    {
      "id": "7ca7e958-9e1c-4ed6-95f8-4b1b4b504673",
      "problemSlug": "next-permutation",
      "summary": "Rearrange to next lexicographically greater permutation. Find rightmost ascending pair, swap with smallest larger, reverse suffix.",
      "approaches": [
        {
          "id": "050bf7cd-d5b4-4f59-8af2-ea15de4f8838",
          "name": "Linear Scan",
          "order": 1,
          "intuition": "Find rightmost i where nums[i] < nums[i+1], swap with smallest greater in suffix, reverse.",
          "approach": "1. Find i where nums[i] < nums[i+1] from right\n2. Find j > i where nums[j] > nums[i]\n3. Swap, reverse suffix",
          "explanation": "We need smallest increase. Find the rightmost element we can increase, swap with next larger, make suffix ascending.",
          "code": "func nextPermutation(_ nums: inout [Int]) {\n    let n = nums.count\n    var i = n - 2\n    while i >= 0 && nums[i] >= nums[i+1] { i -= 1 }\n    if i >= 0 {\n        var j = n - 1\n        while nums[j] <= nums[i] { j -= 1 }\n        nums.swapAt(i, j)\n    }\n    nums[(i+1)...].reverse()\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Linear scans",
            "spaceExplanation": "In-place"
          },
          "testCases": [
            {
              "id": "957a3b1c-c9f2-484a-acfd-663c0c7c617b",
              "input": "[1,2,3]",
              "expectedOutput": "[1,3,2]",
              "explanation": "Next after 123 is 132"
            }
          ]
        }
      ],
      "relatedProblems": [
        "permutations",
        "permutations-ii"
      ],
      "lastUpdated": "2026-02-06T01:03:48.938Z"
    },
    {
      "id": "6048f5e3-04d5-40d2-aa60-6c9a87166c80",
      "problemSlug": "minimum-window-substring",
      "summary": "Find minimum window in s containing all chars of t. Expand right to include, shrink left to minimize.",
      "approaches": [
        {
          "id": "9e060409-ff3e-4bbb-912e-df8db7a86696",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "Expand until valid, shrink while valid, track minimum.",
          "approach": "1. Count chars needed from t\n2. Expand right adding chars\n3. When valid, shrink left recording min",
          "explanation": "Two pointers form window. Track how many unique chars satisfied.",
          "code": "func minWindow(_ s: String, _ t: String) -> String {\n    var need: [Character: Int] = [:]\n    for c in t { need[c, default: 0] += 1 }\n    var have: [Character: Int] = [:]\n    var required = need.count, formed = 0\n    var left = 0, minLen = Int.max, minStart = 0\n    let chars = Array(s)\n    for (right, c) in chars.enumerated() {\n        have[c, default: 0] += 1\n        if let n = need[c], have[c] == n { formed += 1 }\n        while formed == required {\n            if right - left + 1 < minLen { minLen = right - left + 1; minStart = left }\n            let lc = chars[left]\n            have[lc]! -= 1\n            if let n = need[lc], have[lc]! < n { formed -= 1 }\n            left += 1\n        }\n    }\n    return minLen == Int.max ? \"\" : String(chars[minStart..<minStart+minLen])\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(k)",
            "timeExplanation": "Each char processed twice",
            "spaceExplanation": "Char counts"
          },
          "testCases": [
            {
              "id": "e75f7685-b4de-48aa-ad3c-4e39545520b0",
              "input": "s=\"ADOBECODEBANC\", t=\"ABC\"",
              "expectedOutput": "\"BANC\"",
              "explanation": "Smallest window containing A,B,C"
            }
          ]
        }
      ],
      "relatedProblems": [
        "substring-with-concatenation-of-all-words"
      ],
      "lastUpdated": "2026-02-06T01:03:48.938Z"
    },
    {
      "id": "b050075d-eb14-4652-aa0c-9f143ac3f530",
      "problemSlug": "sliding-window-maximum",
      "summary": "Return max in each sliding window of size k. Use monotonic deque storing indices of decreasing values.",
      "approaches": [
        {
          "id": "d249a08b-6e7a-43cf-a52d-e623cd924a38",
          "name": "Monotonic Deque",
          "order": 1,
          "intuition": "Deque front is always max. Remove smaller elements, remove out-of-window elements.",
          "approach": "1. Maintain deque of indices with decreasing values\n2. Remove indices outside window\n3. Remove indices with smaller values\n4. Front is current max",
          "explanation": "Deque maintains candidates in decreasing order. Front is always the max in current window.",
          "code": "func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n    var deque: [Int] = []\n    var result: [Int] = []\n    for i in 0..<nums.count {\n        while !deque.isEmpty && deque.first! < i - k + 1 { deque.removeFirst() }\n        while !deque.isEmpty && nums[deque.last!] < nums[i] { deque.removeLast() }\n        deque.append(i)\n        if i >= k - 1 { result.append(nums[deque.first!]) }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(k)",
            "timeExplanation": "Each element added/removed once",
            "spaceExplanation": "Deque size"
          },
          "testCases": [
            {
              "id": "ceee2d57-b172-468d-830e-c6963e6359db",
              "input": "nums=[1,3,-1,-3,5,3,6,7], k=3",
              "expectedOutput": "[3,3,5,5,6,7]",
              "explanation": "Windows: [1,3,-1]→3, [3,-1,-3]→3..."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-window-substring"
      ],
      "lastUpdated": "2026-02-06T01:03:48.938Z"
    },
    {
      "id": "30c73894-5a52-4916-bdf9-ec0e1a170a98",
      "problemSlug": "odd-even-linked-list",
      "summary": "Group odd-indexed nodes followed by even-indexed. Use two pointers to separate lists, then connect.",
      "approaches": [
        {
          "id": "7955f1d9-28d3-48a8-8c3d-d868bf0f45b6",
          "name": "Two Pointers",
          "order": 1,
          "intuition": "Build odd and even lists separately, connect odd tail to even head.",
          "approach": "1. odd = head, even = head.next, evenHead = even\n2. Link odd nodes, link even nodes\n3. Connect odd.next = evenHead",
          "explanation": "Process two nodes at a time, building parallel lists.",
          "code": "func oddEvenList(_ head: ListNode?) -> ListNode? {\n    guard let head = head, let even = head.next else { return head }\n    var odd: ListNode? = head\n    var evenNode: ListNode? = even\n    let evenHead = even\n    while evenNode?.next != nil {\n        odd?.next = evenNode?.next\n        odd = odd?.next\n        evenNode?.next = odd?.next\n        evenNode = evenNode?.next\n    }\n    odd?.next = evenHead\n    return head\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "Relink in place"
          },
          "testCases": [
            {
              "id": "ff8fe070-0f90-4d09-b8dc-fb188234fc9f",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "[1,3,5,2,4]",
              "explanation": "Odd positions: 1,3,5. Even: 2,4."
            }
          ]
        }
      ],
      "relatedProblems": [
        "split-linked-list-in-parts"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "f91c0118-8ed9-44d5-a645-e52202ceebec",
      "problemSlug": "sort-list",
      "summary": "Sort linked list in O(n log n) time, O(1) space. Use bottom-up merge sort.",
      "approaches": [
        {
          "id": "5be78f9e-a88b-40c6-97fe-7085fe46b22e",
          "name": "Merge Sort",
          "order": 1,
          "intuition": "Split list in half, sort each, merge. For O(1) space, use bottom-up.",
          "approach": "1. Find middle using slow/fast pointers\n2. Recursively sort halves\n3. Merge sorted halves",
          "explanation": "Standard merge sort adapted for linked lists. Split at middle, recurse, merge.",
          "code": "func sortList(_ head: ListNode?) -> ListNode? {\n    guard head?.next != nil else { return head }\n    var slow = head, fast = head?.next\n    while fast?.next != nil { slow = slow?.next; fast = fast?.next?.next }\n    let mid = slow?.next; slow?.next = nil\n    let left = sortList(head), right = sortList(mid)\n    return merge(left, right)\n}\nfunc merge(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var curr: ListNode? = dummy\n    var p1 = l1, p2 = l2\n    while p1 != nil && p2 != nil {\n        if p1!.val < p2!.val { curr?.next = p1; p1 = p1?.next }\n        else { curr?.next = p2; p2 = p2?.next }\n        curr = curr?.next\n    }\n    curr?.next = p1 ?? p2\n    return dummy.next\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(log n)",
            "timeExplanation": "Merge sort",
            "spaceExplanation": "Recursion stack"
          },
          "testCases": [
            {
              "id": "b132f4e2-4a99-42b9-b5a0-ddd5d42e242e",
              "input": "[4,2,1,3]",
              "expectedOutput": "[1,2,3,4]",
              "explanation": "Sorted list"
            }
          ]
        }
      ],
      "relatedProblems": [
        "merge-two-sorted-lists",
        "merge-k-sorted-lists"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "e782917c-0c61-4d42-bcce-111fb6e4fbee",
      "problemSlug": "palindrome-linked-list",
      "summary": "Check if linked list is palindrome. Find middle, reverse second half, compare.",
      "approaches": [
        {
          "id": "62d330d3-6c81-46ee-98cf-835a507dff54",
          "name": "Reverse Second Half",
          "order": 1,
          "intuition": "Find middle, reverse from middle, compare with first half.",
          "approach": "1. Find middle with slow/fast\n2. Reverse second half\n3. Compare halves",
          "explanation": "After reversing second half, walk both halves comparing values.",
          "code": "func isPalindrome(_ head: ListNode?) -> Bool {\n    var slow = head, fast = head\n    while fast?.next != nil { slow = slow?.next; fast = fast?.next?.next }\n    var prev: ListNode? = nil\n    while slow != nil { let next = slow?.next; slow?.next = prev; prev = slow; slow = next }\n    var p1 = head, p2 = prev\n    while p2 != nil { if p1?.val != p2?.val { return false }; p1 = p1?.next; p2 = p2?.next }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Two passes",
            "spaceExplanation": "In-place"
          },
          "testCases": [
            {
              "id": "ed8f0111-de65-48e3-8315-c30b990db39d",
              "input": "[1,2,2,1]",
              "expectedOutput": "true",
              "explanation": "Palindrome"
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-palindrome"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "70ea5c54-8586-42e6-a3b6-c960bda1e83f",
      "problemSlug": "largest-rectangle-in-histogram",
      "summary": "Find largest rectangle in histogram. Monotonic stack tracks bars, calculate area when popping.",
      "approaches": [
        {
          "id": "96c38f20-fb88-47af-8d20-b1449a3f541a",
          "name": "Monotonic Stack",
          "order": 1,
          "intuition": "Stack of increasing heights. When smaller found, pop and calculate areas.",
          "approach": "1. For each bar, pop taller bars and calculate their areas\n2. Width extends from previous stack element to current",
          "explanation": "Each bar is pushed once, popped once. Area calculated using stack to determine width.",
          "code": "func largestRectangleArea(_ heights: [Int]) -> Int {\n    var stack: [Int] = []\n    var maxArea = 0\n    let heights = heights + [0]\n    for i in 0..<heights.count {\n        while !stack.isEmpty && heights[i] < heights[stack.last!] {\n            let h = heights[stack.removeLast()]\n            let w = stack.isEmpty ? i : i - stack.last! - 1\n            maxArea = max(maxArea, h * w)\n        }\n        stack.append(i)\n    }\n    return maxArea\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each bar pushed/popped once",
            "spaceExplanation": "Stack"
          },
          "testCases": [
            {
              "id": "4727ed54-0578-4cd6-a348-a050b6863a92",
              "input": "[2,1,5,6,2,3]",
              "expectedOutput": "10",
              "explanation": "Rectangle of height 5, width 2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximal-rectangle"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "ce1f7a4f-a231-4a48-b6bb-a4ea3a5891bb",
      "problemSlug": "decode-string",
      "summary": "Decode k[encoded_string]. Use stack for nested patterns.",
      "approaches": [
        {
          "id": "af80dabe-487c-4b8c-9553-6fc0ca88b220",
          "name": "Stack",
          "order": 1,
          "intuition": "Stack stores previous string and count when entering brackets.",
          "approach": "1. digit → build number\n2. [ → push current string and count, reset\n3. ] → pop, repeat current string count times, append\n4. letter → append to current",
          "explanation": "Stack handles nesting by saving state before entering brackets.",
          "code": "func decodeString(_ s: String) -> String {\n    var stack: [(String, Int)] = []\n    var current = \"\"\n    var num = 0\n    for c in s {\n        if c.isNumber { num = num * 10 + Int(String(c))! }\n        else if c == \"[\" { stack.append((current, num)); current = \"\"; num = 0 }\n        else if c == \"]\" { let (prev, count) = stack.removeLast(); current = prev + String(repeating: current, count: count) }\n        else { current.append(c) }\n    }\n    return current\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Process each char",
            "spaceExplanation": "Stack depth"
          },
          "testCases": [
            {
              "id": "13761e65-eee3-410f-a148-7785123d24c0",
              "input": "\"3[a2[c]]\"",
              "expectedOutput": "\"accaccacc\"",
              "explanation": "2[c]=cc, a+cc=acc, 3[acc]=accaccacc"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-atoms"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "7e0b5512-6155-4235-a11e-9f0b5bd79cd3",
      "problemSlug": "find-first-and-last-position-of-element-in-sorted-array",
      "summary": "Find first and last position of target. Two binary searches: one for first, one for last.",
      "approaches": [
        {
          "id": "97753344-cc51-431f-9548-db5320c9fb0b",
          "name": "Two Binary Searches",
          "order": 1,
          "intuition": "Binary search for leftmost, binary search for rightmost.",
          "approach": "1. Find first: if found, search left\n2. Find last: if found, search right",
          "explanation": "Standard binary search modified to continue searching after finding target.",
          "code": "func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\n    func findFirst() -> Int {\n        var l = 0, r = nums.count - 1, result = -1\n        while l <= r {\n            let m = l + (r - l) / 2\n            if nums[m] == target { result = m; r = m - 1 }\n            else if nums[m] < target { l = m + 1 }\n            else { r = m - 1 }\n        }\n        return result\n    }\n    func findLast() -> Int {\n        var l = 0, r = nums.count - 1, result = -1\n        while l <= r {\n            let m = l + (r - l) / 2\n            if nums[m] == target { result = m; l = m + 1 }\n            else if nums[m] < target { l = m + 1 }\n            else { r = m - 1 }\n        }\n        return result\n    }\n    return [findFirst(), findLast()]\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "Two binary searches",
            "spaceExplanation": "Constant"
          },
          "testCases": [
            {
              "id": "11428b6b-c386-460b-a25d-70ed0dfe90f1",
              "input": "nums=[5,7,7,8,8,10], target=8",
              "expectedOutput": "[3,4]",
              "explanation": "8 at indices 3 and 4"
            }
          ]
        }
      ],
      "relatedProblems": [
        "first-bad-version"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "0f0f4ed4-11fd-48be-bc27-0bb4ee6fcea0",
      "problemSlug": "find-peak-element",
      "summary": "Find any peak (element greater than neighbors). Binary search: if mid < mid+1, peak on right.",
      "approaches": [
        {
          "id": "e9dcd8a6-7e56-434f-a903-122325e984ac",
          "name": "Binary Search",
          "order": 1,
          "intuition": "If mid < mid+1, increasing so peak must be on right. Else peak on left or mid.",
          "approach": "1. If nums[mid] < nums[mid+1], search right\n2. Else search left (including mid)",
          "explanation": "We're guaranteed to find a peak because we move toward the larger neighbor.",
          "code": "func findPeakElement(_ nums: [Int]) -> Int {\n    var l = 0, r = nums.count - 1\n    while l < r {\n        let m = l + (r - l) / 2\n        if nums[m] < nums[m + 1] { l = m + 1 }\n        else { r = m }\n    }\n    return l\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "Binary search",
            "spaceExplanation": "Constant"
          },
          "testCases": [
            {
              "id": "c3aa5432-f616-41d8-8fd6-c071f31c729b",
              "input": "[1,2,3,1]",
              "expectedOutput": "2",
              "explanation": "3 is peak at index 2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "peak-index-in-a-mountain-array"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "dffca197-fc67-4873-a726-00589deac150",
      "problemSlug": "lowest-common-ancestor-of-a-binary-tree",
      "summary": "Find LCA of two nodes. Recursively check if current subtree contains p, q, or both.",
      "approaches": [
        {
          "id": "8be35011-2608-4d66-ad48-7e35e4f53217",
          "name": "Recursive",
          "order": 1,
          "intuition": "If node is p or q, return it. If left and right both return non-null, node is LCA.",
          "approach": "1. If node is p or q, return node\n2. Recurse left and right\n3. If both return non-null, current is LCA\n4. Else return the non-null one",
          "explanation": "LCA is either p/q itself, or the node where p and q are in different subtrees.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    if root === p || root === q { return root }\n    let left = lowestCommonAncestor(root.left, p, q)\n    let right = lowestCommonAncestor(root.right, p, q)\n    if left != nil && right != nil { return root }\n    return left ?? right\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "ab5e453a-ae54-4a7d-8df0-0862484c7915",
              "input": "root=[3,5,1,6,2,0,8], p=5, q=1",
              "expectedOutput": "3",
              "explanation": "3 is LCA of 5 and 1"
            }
          ]
        }
      ],
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "b8ab8619-81ae-4080-ab46-0e2a8b556a64",
      "problemSlug": "flood-fill",
      "summary": "Fill connected cells of same color. DFS/BFS from starting cell.",
      "approaches": [
        {
          "id": "908fed6e-be51-45aa-bd34-bad4b52b792d",
          "name": "DFS",
          "order": 1,
          "intuition": "From start, recursively fill same-color neighbors.",
          "approach": "1. If start color == new color, return\n2. DFS to fill start and all same-color neighbors",
          "explanation": "Standard flood fill using DFS. Check bounds and color before recursing.",
          "code": "func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ color: Int) -> [[Int]] {\n    var image = image\n    let original = image[sr][sc]\n    if original == color { return image }\n    func dfs(_ r: Int, _ c: Int) {\n        if r < 0 || r >= image.count || c < 0 || c >= image[0].count { return }\n        if image[r][c] != original { return }\n        image[r][c] = color\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    }\n    dfs(sr, sc)\n    return image\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Visit each cell once",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "b55894f4-396b-4e32-801e-a49d6a7e9a92",
              "input": "image=[[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, color=2",
              "expectedOutput": "[[2,2,2],[2,2,0],[2,0,1]]",
              "explanation": "Fill connected 1s with 2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "number-of-islands"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "2b6fa75f-5731-4a58-a1af-ff0701dc91f2",
      "problemSlug": "is-graph-bipartite",
      "summary": "Check if graph can be 2-colored. BFS/DFS assigning colors, check no adjacent same colors.",
      "approaches": [
        {
          "id": "47e1cffd-4793-448f-87d2-562eabb175e2",
          "name": "BFS Coloring",
          "order": 1,
          "intuition": "Assign colors. If neighbor has same color, not bipartite.",
          "approach": "1. For each uncolored node, BFS assign colors\n2. If neighbor already has same color, return false",
          "explanation": "Bipartite iff we can 2-color it. BFS level by level alternates colors.",
          "code": "func isBipartite(_ graph: [[Int]]) -> Bool {\n    var colors = [Int](repeating: -1, count: graph.count)\n    for i in 0..<graph.count {\n        if colors[i] != -1 { continue }\n        var queue = [i]; colors[i] = 0\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            for neighbor in graph[node] {\n                if colors[neighbor] == -1 { colors[neighbor] = 1 - colors[node]; queue.append(neighbor) }\n                else if colors[neighbor] == colors[node] { return false }\n            }\n        }\n    }\n    return true\n}",
          "complexity": {
            "time": "O(V+E)",
            "space": "O(V)",
            "timeExplanation": "Visit all nodes and edges",
            "spaceExplanation": "Color array"
          },
          "testCases": [
            {
              "id": "5fb126b2-1636-46aa-a05c-1bba6c7b01f3",
              "input": "[[1,2,3],[0,2],[0,1,3],[0,2]]",
              "expectedOutput": "false",
              "explanation": "Has odd cycle"
            }
          ]
        }
      ],
      "relatedProblems": [
        "possible-bipartition"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "98039a77-0ff1-48af-9170-44de252a2246",
      "problemSlug": "perfect-squares",
      "summary": "Find min perfect squares summing to n. DP: dp[i] = min(dp[i-j²]+1) for all valid j.",
      "approaches": [
        {
          "id": "2a8d3193-d777-4b08-8ca2-4e0c0babbadb",
          "name": "DP",
          "order": 1,
          "intuition": "dp[n] = min squares for n. Try subtracting each square.",
          "approach": "1. dp[0] = 0\n2. For each i, dp[i] = min(dp[i - j*j] + 1) for j where j*j <= i",
          "explanation": "For each number, try using each perfect square and take minimum.",
          "code": "func numSquares(_ n: Int) -> Int {\n    var dp = [Int](repeating: Int.max, count: n + 1)\n    dp[0] = 0\n    for i in 1...n {\n        var j = 1\n        while j * j <= i {\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n        }\n    }\n    return dp[n]\n}",
          "complexity": {
            "time": "O(n√n)",
            "space": "O(n)",
            "timeExplanation": "For each i, check √i squares",
            "spaceExplanation": "DP array"
          },
          "testCases": [
            {
              "id": "fc9e6b6a-4f28-4893-b69a-98bc52145253",
              "input": "n=12",
              "expectedOutput": "3",
              "explanation": "4+4+4=12"
            }
          ]
        }
      ],
      "relatedProblems": [
        "coin-change"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "9a166149-ffbd-4f78-b65e-248f6cb6e773",
      "problemSlug": "coin-change-2",
      "summary": "Count combinations to make amount with coins. DP: process coins then amounts to avoid counting permutations.",
      "approaches": [
        {
          "id": "5911fd0f-1770-422b-a959-0db8de38937d",
          "name": "DP",
          "order": 1,
          "intuition": "For each coin, add ways to make each amount using that coin.",
          "approach": "1. dp[0] = 1 (one way to make 0)\n2. For each coin, for each amount, dp[amount] += dp[amount - coin]",
          "explanation": "Processing coins outer loop ensures we count combinations not permutations.",
          "code": "func change(_ amount: Int, _ coins: [Int]) -> Int {\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1\n    for coin in coins {\n        for a in coin...amount {\n            dp[a] += dp[a - coin]\n        }\n    }\n    return dp[amount]\n}",
          "complexity": {
            "time": "O(n×amount)",
            "space": "O(amount)",
            "timeExplanation": "Each coin × each amount",
            "spaceExplanation": "DP array"
          },
          "testCases": [
            {
              "id": "df58a382-90b4-4d44-a6b6-6b42d0a06620",
              "input": "amount=5, coins=[1,2,5]",
              "expectedOutput": "4",
              "explanation": "5, 2+2+1, 2+1+1+1, 1+1+1+1+1"
            }
          ]
        }
      ],
      "relatedProblems": [
        "coin-change"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "41c366d0-a572-4cbc-9551-ea26370ac705",
      "problemSlug": "combinations",
      "summary": "Generate all combinations of k numbers from 1..n. Backtrack picking or skipping each number.",
      "approaches": [
        {
          "id": "457d0f20-81cd-49e5-916f-b4657cd64740",
          "name": "Backtracking",
          "order": 1,
          "intuition": "At each step, include current number or skip. Stop when k numbers chosen.",
          "approach": "1. If combo size = k, add to result\n2. Try adding each number from start to n\n3. Backtrack",
          "explanation": "Standard combination generation. Use start parameter to avoid duplicates.",
          "code": "func combine(_ n: Int, _ k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var combo: [Int] = []\n    func backtrack(_ start: Int) {\n        if combo.count == k { result.append(combo); return }\n        for i in start...n {\n            combo.append(i)\n            backtrack(i + 1)\n            combo.removeLast()\n        }\n    }\n    backtrack(1)\n    return result\n}",
          "complexity": {
            "time": "O(C(n,k))",
            "space": "O(k)",
            "timeExplanation": "Generate all combinations",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "dbd73f1f-d35a-4b6b-ba45-b5f22e0cf568",
              "input": "n=4, k=2",
              "expectedOutput": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
              "explanation": "All 2-combinations from 1-4"
            }
          ]
        }
      ],
      "relatedProblems": [
        "combination-sum",
        "permutations"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "c57e5800-cdb4-4e89-8c49-569132e8778d",
      "problemSlug": "permutations-ii",
      "summary": "Generate unique permutations with duplicates. Sort, skip duplicates at same level.",
      "approaches": [
        {
          "id": "a29875d5-9308-42f1-b230-7d6297f7691c",
          "name": "Backtracking with Dedup",
          "order": 1,
          "intuition": "Sort input. Skip if same as previous and previous not used (same level).",
          "approach": "1. Sort nums\n2. Skip if nums[i] == nums[i-1] and !used[i-1]\n3. Standard backtracking",
          "explanation": "Sorting groups duplicates. Skip duplicate at same recursion level to avoid repeats.",
          "code": "func permuteUnique(_ nums: [Int]) -> [[Int]] {\n    let sorted = nums.sorted()\n    var result: [[Int]] = []\n    var perm: [Int] = []\n    var used = [Bool](repeating: false, count: nums.count)\n    func backtrack() {\n        if perm.count == sorted.count { result.append(perm); return }\n        for i in 0..<sorted.count {\n            if used[i] { continue }\n            if i > 0 && sorted[i] == sorted[i-1] && !used[i-1] { continue }\n            used[i] = true; perm.append(sorted[i])\n            backtrack()\n            perm.removeLast(); used[i] = false\n        }\n    }\n    backtrack()\n    return result\n}",
          "complexity": {
            "time": "O(n!)",
            "space": "O(n)",
            "timeExplanation": "Up to n! permutations",
            "spaceExplanation": "Recursion and used array"
          },
          "testCases": [
            {
              "id": "49f8da2f-e841-4184-8a6e-8a1d3bb26d91",
              "input": "[1,1,2]",
              "expectedOutput": "[[1,1,2],[1,2,1],[2,1,1]]",
              "explanation": "3 unique permutations"
            }
          ]
        }
      ],
      "relatedProblems": [
        "permutations",
        "next-permutation"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "aa7d86c6-8f75-4c12-9cc6-09de14ef8ea5",
      "problemSlug": "pow-x-n",
      "summary": "Calculate x^n efficiently. Use binary exponentiation: x^n = (x^(n/2))².",
      "approaches": [
        {
          "id": "26c2fd01-f876-41e1-babc-8ad4f3f4eac0",
          "name": "Binary Exponentiation",
          "order": 1,
          "intuition": "x^n = x^(n/2) × x^(n/2). Handle negative n.",
          "approach": "1. If n < 0, return 1/pow(x, -n)\n2. If n = 0, return 1\n3. If n even: half = pow(x, n/2), return half × half\n4. If n odd: return x × pow(x, n-1)",
          "explanation": "Reduce problem size by half each step for O(log n) time.",
          "code": "func myPow(_ x: Double, _ n: Int) -> Double {\n    if n == 0 { return 1 }\n    if n < 0 { return 1 / myPow(x, -n) }\n    let half = myPow(x, n / 2)\n    return n % 2 == 0 ? half * half : half * half * x\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(log n)",
            "timeExplanation": "Halve n each step",
            "spaceExplanation": "Recursion depth"
          },
          "testCases": [
            {
              "id": "7c47823c-599f-4be6-930b-9942349b13ee",
              "input": "x=2.0, n=10",
              "expectedOutput": "1024.0",
              "explanation": "2^10 = 1024"
            }
          ]
        }
      ],
      "relatedProblems": [
        "sqrt-x"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "0d963846-644f-441f-8125-871b063b8bf1",
      "problemSlug": "sqrt-x",
      "summary": "Integer square root. Binary search for largest n where n² <= x.",
      "approaches": [
        {
          "id": "af9dabef-dfbc-42aa-ae5e-16fd4b193530",
          "name": "Binary Search",
          "order": 1,
          "intuition": "Search for n where n² <= x < (n+1)².",
          "approach": "1. Binary search [0, x]\n2. If mid² <= x, search higher, record mid\n3. Else search lower",
          "explanation": "Find largest integer whose square doesn't exceed x.",
          "code": "func mySqrt(_ x: Int) -> Int {\n    if x < 2 { return x }\n    var left = 1, right = x / 2, result = 0\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if mid <= x / mid { result = mid; left = mid + 1 }\n        else { right = mid - 1 }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(log x)",
            "space": "O(1)",
            "timeExplanation": "Binary search",
            "spaceExplanation": "Constant"
          },
          "testCases": [
            {
              "id": "434b4a89-2e0b-4601-b15b-52a83f233e1e",
              "input": "x=8",
              "expectedOutput": "2",
              "explanation": "√8 ≈ 2.83, floor is 2"
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-perfect-square"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    },
    {
      "id": "d9c60ce0-d177-4d0c-906f-08e6232a4127",
      "problemSlug": "find-all-anagrams-in-a-string",
      "summary": "Find start indices of p's anagrams in s. Sliding window with character counts.",
      "approaches": [
        {
          "id": "34c07c66-37a3-4c15-b036-f3d069840486",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "Fixed window of size len(p). Track char counts, compare with p's counts.",
          "approach": "1. Count chars in p\n2. Slide window of size len(p)\n3. If counts match, add index",
          "explanation": "Maintain window counts. Instead of comparing entire arrays, track how many chars are correctly matched.",
          "code": "func findAnagrams(_ s: String, _ p: String) -> [Int] {\n    if s.count < p.count { return [] }\n    let sChars = Array(s), pChars = Array(p)\n    var pCount = [Character: Int]()\n    var sCount = [Character: Int]()\n    for c in pChars { pCount[c, default: 0] += 1 }\n    var result: [Int] = []\n    for i in 0..<sChars.count {\n        sCount[sChars[i], default: 0] += 1\n        if i >= pChars.count {\n            let c = sChars[i - pChars.count]\n            if sCount[c] == 1 { sCount.removeValue(forKey: c) }\n            else { sCount[c]! -= 1 }\n        }\n        if sCount == pCount { result.append(i - pChars.count + 1) }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass",
            "spaceExplanation": "26 chars max"
          },
          "testCases": [
            {
              "id": "dfb95b10-1a38-4391-aa82-42eece0caaf2",
              "input": "s=\"cbaebabacd\", p=\"abc\"",
              "expectedOutput": "[0,6]",
              "explanation": "\"cba\" at 0, \"bac\" at 6"
            }
          ]
        }
      ],
      "relatedProblems": [
        "permutation-in-string"
      ],
      "lastUpdated": "2026-02-06T01:03:48.939Z"
    }
  ],
  "version": "1.0.0",
  "two-sum": {
    "summary": "Given an array of integers and a target, return indices of the two numbers that add up to the target. Use a hash map to achieve O(n) time by storing complements.",
    "approaches": [
      {
        "name": "Brute Force",
        "intuition": "Check every pair of numbers to see if they sum to the target. Simple but inefficient.",
        "approach": "1. Iterate through each element with index i\n2. For each i, iterate through remaining elements with index j\n3. Check if nums[i] + nums[j] equals target\n4. Return [i, j] when found",
        "explanation": "We use two nested loops to check all possible pairs. The outer loop picks the first number, and the inner loop checks all numbers after it. This guarantees we find the answer if it exists, but is slow for large arrays.",
        "code": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    for i in 0..<nums.count {\n        for j in (i + 1)..<nums.count {\n            if nums[i] + nums[j] == target {\n                return [i, j]\n            }\n        }\n    }\n    return []\n}",
        "complexity": {
          "time": "O(n^2)",
          "space": "O(1)",
          "timeExplanation": "Two nested loops, each iterating up to n times",
          "spaceExplanation": "Only using a constant amount of extra space for loop variables"
        },
        "testCases": [
          {
            "input": "nums = [2,7,11,15], target = 9",
            "expectedOutput": "[0,1]",
            "explanation": "nums[0] + nums[1] = 2 + 7 = 9"
          },
          {
            "input": "nums = [3,2,4], target = 6",
            "expectedOutput": "[1,2]",
            "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
          }
        ]
      },
      {
        "name": "Hash Map (One Pass)",
        "intuition": "For each number, we need to find if its complement (target - num) exists. A hash map lets us check this in O(1) time.",
        "approach": "1. Create an empty hash map to store value -> index\n2. Iterate through the array once\n3. For each number, calculate complement = target - num\n4. If complement exists in map, return [map[complement], currentIndex]\n5. Otherwise, store current number and index in map",
        "explanation": "Instead of looking backward for each element, we build a map as we go. When we see a number, we check if we've already seen its complement. This single pass through the array with O(1) lookups gives us O(n) time complexity.",
        "code": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    var map: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        let complement = target - num\n        if let j = map[complement] {\n            return [j, i]\n        }\n        map[num] = i\n    }\n    return []\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass through the array with O(1) hash map operations",
          "spaceExplanation": "Hash map can store up to n elements in the worst case"
        },
        "testCases": [
          {
            "input": "nums = [2,7,11,15], target = 9",
            "expectedOutput": "[0,1]",
            "explanation": "When we reach 7, complement is 2 which is already in the map at index 0"
          },
          {
            "input": "nums = [3,3], target = 6",
            "expectedOutput": "[0,1]",
            "explanation": "When we reach second 3, complement 3 is already in the map at index 0"
          }
        ]
      }
    ],
    "relatedProblems": [
      "three-sum",
      "two-sum-ii-input-array-is-sorted",
      "two-sum-iv-input-is-a-bst"
    ]
  },
  "find-minimum-in-rotated-sorted-array": {
    "summary": "Find the minimum element in a sorted array that has been rotated. The key insight is that the minimum is at the rotation pivot point, and we can use binary search to find it in O(log n) time by checking which half is sorted.",
    "approaches": [
      {
        "name": "Linear Scan",
        "intuition": "Simply iterate through the array and track the minimum value. This works but doesn't leverage the sorted property of the array.",
        "approach": "1. Initialize minimum as the first element\n2. Iterate through each element in the array\n3. Update minimum if current element is smaller\n4. Return the minimum value",
        "explanation": "This brute force approach ignores the sorted and rotated properties of the array. While it always finds the correct answer, it's inefficient for large arrays since we check every element. The sorted nature of the array allows for a much faster binary search solution.",
        "code": "func findMin(_ nums: [Int]) -> Int {\n    var minVal = nums[0]\n    for num in nums {\n        minVal = min(minVal, num)\n    }\n    return minVal\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "We iterate through all n elements once",
          "spaceExplanation": "Only using a single variable to track minimum"
        },
        "testCases": [
          {
            "input": "nums = [3,4,5,1,2]",
            "expectedOutput": "1",
            "explanation": "Original sorted array [1,2,3,4,5] was rotated 3 times. Minimum is 1."
          },
          {
            "input": "nums = [4,5,6,7,0,1,2]",
            "expectedOutput": "0",
            "explanation": "Original sorted array [0,1,2,4,5,6,7] was rotated 4 times. Minimum is 0."
          }
        ]
      },
      {
        "name": "Binary Search",
        "intuition": "In a rotated sorted array, the minimum element is at the pivot point where the rotation happened. We can use binary search: if the middle element is greater than the rightmost element, the minimum must be in the right half (the pivot is there). Otherwise, it's in the left half including middle.",
        "approach": "1. Initialize left = 0 and right = nums.count - 1\n2. While left < right:\n   a. Calculate mid = left + (right - left) / 2\n   b. If nums[mid] > nums[right], minimum is in right half: left = mid + 1\n   c. Else, minimum is in left half (including mid): right = mid\n3. Return nums[left] - this is the minimum",
        "explanation": "The key observation is that in a rotated sorted array, one half is always properly sorted. If nums[mid] > nums[right], the rotation pivot (minimum) must be in the right half because the left half is sorted but wraps around. If nums[mid] <= nums[right], the right half is sorted, so the minimum is in the left half or at mid. We keep narrowing until left equals right, pointing to the minimum.",
        "code": "func findMin(_ nums: [Int]) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        \n        if nums[mid] > nums[right] {\n            // Minimum is in the right half\n            left = mid + 1\n        } else {\n            // Minimum is in the left half (including mid)\n            right = mid\n        }\n    }\n    \n    return nums[left]\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Binary search halves the search space each iteration, giving logarithmic time",
          "spaceExplanation": "Only using a few pointer variables, constant extra space"
        },
        "testCases": [
          {
            "input": "nums = [3,4,5,1,2]",
            "expectedOutput": "1",
            "explanation": "mid=2 (value 5) > right value 2, so search right. mid=3 (value 1) <= right value 2, narrow to left=right=3. Return nums[3]=1."
          },
          {
            "input": "nums = [4,5,6,7,0,1,2]",
            "expectedOutput": "0",
            "explanation": "Binary search finds pivot at index 4 where value drops from 7 to 0."
          },
          {
            "input": "nums = [11,13,15,17]",
            "expectedOutput": "11",
            "explanation": "Array not rotated (or rotated n times). nums[mid] <= nums[right] always, converges to index 0."
          },
          {
            "input": "nums = [2,1]",
            "expectedOutput": "1",
            "explanation": "Small array rotated once. nums[0]=2 > nums[1]=1, so left becomes 1, return nums[1]=1."
          }
        ]
      }
    ],
    "relatedProblems": [
      "find-minimum-in-rotated-sorted-array-ii",
      "search-in-rotated-sorted-array",
      "search-in-rotated-sorted-array-ii"
    ]
  },
  "remove-duplicates-from-sorted-array": {
    "summary": "Remove duplicates from a sorted array in-place, returning the count of unique elements. Use two pointers: one for the write position of unique elements, one to scan through the array.",
    "approaches": [
      {
        "name": "Two Pointers (In-Place)",
        "intuition": "Since the array is sorted, duplicates are adjacent. Use a slow pointer to track where to write the next unique element, and a fast pointer to scan through the array.",
        "approach": "1. Handle empty array edge case\n2. Initialize write pointer at index 1 (first element is always unique)\n3. Scan from index 1 with read pointer\n4. When current element differs from previous, write it and advance write pointer\n5. Return write pointer value (count of unique elements)",
        "explanation": "The key insight is that in a sorted array, duplicates are consecutive. We maintain a 'write' position where the next unique element should go. As we scan, whenever we find a new value (different from previous), we write it to the write position. The array before the write pointer contains all unique elements.",
        "code": "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 1\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[i - 1] {\n            nums[writeIndex] = nums[i]\n            writeIndex += 1\n        }\n    }\n    \n    return writeIndex\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through the array of n elements",
          "spaceExplanation": "In-place modification, only using pointer variables"
        },
        "testCases": [
          {
            "input": "nums = [1,1,2]",
            "expectedOutput": "2, nums = [1,2,_]",
            "explanation": "Two unique elements: 1 and 2. Array becomes [1,2,...] with returned length 2."
          },
          {
            "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
            "expectedOutput": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
            "explanation": "Five unique elements: 0,1,2,3,4. Each written once to front of array."
          },
          {
            "input": "nums = [1]",
            "expectedOutput": "1, nums = [1]",
            "explanation": "Single element is always unique."
          }
        ]
      },
      {
        "name": "Two Pointers (Compare with Write Position)",
        "intuition": "Instead of comparing with the previous element, compare with the last written unique element. This makes the logic cleaner for extensions like allowing k duplicates.",
        "approach": "1. Handle empty array\n2. Write pointer starts at 0 (first element always kept)\n3. For each element from index 1:\n   a. If different from element at write pointer, increment write pointer and copy\n4. Return write pointer + 1",
        "explanation": "This variant compares the current element with the last unique element we've written (at writeIndex). This pattern extends naturally to 'Remove Duplicates II' where we allow at most 2 of each - just compare with writeIndex-1 instead.",
        "code": "func removeDuplicates(_ nums: inout [Int]) -> Int {\n    guard nums.count > 0 else { return 0 }\n    \n    var writeIndex = 0\n    \n    for i in 1..<nums.count {\n        if nums[i] != nums[writeIndex] {\n            writeIndex += 1\n            nums[writeIndex] = nums[i]\n        }\n    }\n    \n    return writeIndex + 1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through all n elements",
          "spaceExplanation": "Only using index variables, modification is in-place"
        },
        "testCases": [
          {
            "input": "nums = [1,1,2]",
            "expectedOutput": "2, nums = [1,2,_]",
            "explanation": "writeIndex=0. i=1: nums[1]=1 == nums[0]=1, skip. i=2: nums[2]=2 != nums[0]=1, writeIndex=1, nums[1]=2. Return 2."
          },
          {
            "input": "nums = []",
            "expectedOutput": "0",
            "explanation": "Empty array returns 0."
          },
          {
            "input": "nums = [1,2,3]",
            "expectedOutput": "3, nums = [1,2,3]",
            "explanation": "All unique, no changes needed. writeIndex moves to 2, return 3."
          }
        ]
      }
    ],
    "relatedProblems": [
      "remove-duplicates-from-sorted-array-ii",
      "remove-element",
      "move-zeroes"
    ]
  },
  "move-zeroes": {
    "summary": "Move all zeros to the end while maintaining the relative order of non-zero elements. Use two pointers: one for the write position of non-zeros, one to scan.",
    "approaches": [
      {
        "name": "Two Pointers (Overwrite + Fill)",
        "intuition": "Copy all non-zero elements to the front, then fill the rest with zeros. Two passes but very clean logic.",
        "approach": "1. writeIndex starts at 0\n2. For each non-zero element, write it at writeIndex and increment\n3. Fill remaining positions with zeros",
        "explanation": "The first pass compacts all non-zero elements to the front, maintaining their relative order. writeIndex ends up at the count of non-zeros. The second pass fills zeros from writeIndex to the end. This is cache-friendly as we write sequentially.",
        "code": "func moveZeroes(_ nums: inout [Int]) {\n    var writeIndex = 0\n    \n    // Move all non-zeros to front\n    for num in nums {\n        if num != 0 {\n            nums[writeIndex] = num\n            writeIndex += 1\n        }\n    }\n    \n    // Fill rest with zeros\n    while writeIndex < nums.count {\n        nums[writeIndex] = 0\n        writeIndex += 1\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two passes through the array",
          "spaceExplanation": "In-place modification with one pointer variable"
        },
        "testCases": [
          {
            "input": "nums = [0,1,0,3,12]",
            "expectedOutput": "[1,3,12,0,0]",
            "explanation": "Non-zeros 1,3,12 moved to front, zeros fill the rest"
          },
          {
            "input": "nums = [0]",
            "expectedOutput": "[0]",
            "explanation": "Single zero stays in place"
          }
        ]
      },
      {
        "name": "Two Pointers (Swap)",
        "intuition": "Maintain a slow pointer for the 'non-zero zone' boundary. When we find a non-zero, swap it with the boundary position and expand the zone.",
        "approach": "1. slow pointer marks end of non-zero zone\n2. fast pointer scans through array\n3. When fast finds non-zero, swap with slow and increment slow\n4. Single pass, minimal writes",
        "explanation": "The slow pointer always points to the first zero (or end of non-zero section). When fast finds a non-zero, swapping places it at the boundary and moves the boundary forward. This performs fewer writes than the fill approach when there are few zeros.",
        "code": "func moveZeroes(_ nums: inout [Int]) {\n    var slow = 0\n    \n    for fast in 0..<nums.count {\n        if nums[fast] != 0 {\n            // Swap only if positions differ (avoid self-swap)\n            if slow != fast {\n                nums.swapAt(slow, fast)\n            }\n            slow += 1\n        }\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Only using pointer variables"
        },
        "testCases": [
          {
            "input": "nums = [0,1,0,3,12]",
            "expectedOutput": "[1,3,12,0,0]",
            "explanation": "Swap 1↔0, then 3↔0, then 12↔0"
          },
          {
            "input": "nums = [1,2,3]",
            "expectedOutput": "[1,2,3]",
            "explanation": "No zeros, no swaps needed (slow==fast always)"
          },
          {
            "input": "nums = [0,0,1]",
            "expectedOutput": "[1,0,0]",
            "explanation": "1 swaps with first 0"
          }
        ]
      }
    ],
    "relatedProblems": [
      "remove-element"
    ]
  },
  "rotate-image": {
    "summary": "Rotate an n×n matrix 90 degrees clockwise in-place. The key insight is that rotation equals transpose + reverse each row, or you can rotate layer by layer from outside in.",
    "approaches": [
      {
        "name": "Transpose + Reverse",
        "intuition": "A 90° clockwise rotation can be decomposed into two simpler operations: first transpose the matrix (swap rows and columns), then reverse each row. This avoids complex index math.",
        "approach": "1. Transpose the matrix: swap matrix[i][j] with matrix[j][i] for all i < j\n2. Reverse each row: swap elements from start and end moving inward\n3. The matrix is now rotated 90° clockwise",
        "explanation": "Consider element at position (i, j). After transpose, it moves to (j, i). After reversing the row, it moves to (j, n-1-i). This is exactly where it should be after a 90° clockwise rotation. The transpose swaps across the main diagonal, and reversing rows completes the rotation. Both operations are O(n²) but simple to implement.",
        "code": "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    // Step 1: Transpose\n    for i in 0..<n {\n        for j in i+1..<n {\n            let temp = matrix[i][j]\n            matrix[i][j] = matrix[j][i]\n            matrix[j][i] = temp\n        }\n    }\n    \n    // Step 2: Reverse each row\n    for i in 0..<n {\n        matrix[i].reverse()\n    }\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(1)",
          "timeExplanation": "We visit each element twice: once for transpose, once for reverse",
          "spaceExplanation": "In-place modification, only using temp variable for swaps"
        },
        "testCases": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "expectedOutput": "[[7,4,1],[8,5,2],[9,6,3]]",
            "explanation": "After transpose: [[1,4,7],[2,5,8],[3,6,9]]. After reversing rows: [[7,4,1],[8,5,2],[9,6,3]]"
          },
          {
            "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
            "expectedOutput": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
            "explanation": "4x4 matrix rotated 90° clockwise"
          }
        ]
      },
      {
        "name": "Rotate Four Cells at a Time",
        "intuition": "Rotate the matrix layer by layer, from the outermost layer inward. For each position in a layer, rotate four cells simultaneously in a cycle.",
        "approach": "1. Process layers from outside to inside (0 to n/2)\n2. For each layer, rotate elements in groups of 4\n3. For position i in current layer: save top, move left→top, bottom→left, right→bottom, saved→right\n4. Continue until all layers processed",
        "explanation": "We process the matrix in concentric square layers. For each layer, we rotate 4 elements at a time that form a rotation cycle. Element at top goes to right, right goes to bottom, bottom goes to left, left goes to top. We use one temp variable to facilitate this 4-way swap. This directly implements the rotation without decomposing into simpler operations.",
        "code": "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    for layer in 0..<n/2 {\n        let first = layer\n        let last = n - 1 - layer\n        \n        for i in first..<last {\n            let offset = i - first\n            \n            // Save top\n            let top = matrix[first][i]\n            \n            // Left -> Top\n            matrix[first][i] = matrix[last - offset][first]\n            \n            // Bottom -> Left\n            matrix[last - offset][first] = matrix[last][last - offset]\n            \n            // Right -> Bottom\n            matrix[last][last - offset] = matrix[i][last]\n            \n            // Top -> Right\n            matrix[i][last] = top\n        }\n    }\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(1)",
          "timeExplanation": "Each element is moved exactly once",
          "spaceExplanation": "Only one temp variable regardless of matrix size"
        },
        "testCases": [
          {
            "input": "matrix = [[1,2],[3,4]]",
            "expectedOutput": "[[3,1],[4,2]]",
            "explanation": "2x2 has one layer. Rotate: 1→right, 2→bottom, 4→left, 3→top"
          },
          {
            "input": "matrix = [[1]]",
            "expectedOutput": "[[1]]",
            "explanation": "1x1 matrix has no layers to rotate (n/2 = 0)"
          }
        ]
      }
    ],
    "relatedProblems": [
      "rotate-array",
      "determine-whether-matrix-can-be-obtained-by-rotation"
    ]
  },
  "set-matrix-zeroes": {
    "summary": "Set row/col to 0 if element is 0. Use first row/col as markers.",
    "approaches": [
      {
        "name": "In-place Markers",
        "intuition": "Use first row and column to mark which rows/cols to zero.",
        "approach": "1. Check if first row/col have zeros\n2. Use first row/col to mark other zeros\n3. Zero based on marks\n4. Handle first row/col separately",
        "explanation": "O(1) extra space by reusing matrix space.",
        "code": "func setZeroes(_ matrix: inout [[Int]]) {\n    let m = matrix.count, n = matrix[0].count\n    var firstRowZero = false, firstColZero = false\n    \n    for j in 0..<n { if matrix[0][j] == 0 { firstRowZero = true } }\n    for i in 0..<m { if matrix[i][0] == 0 { firstColZero = true } }\n    \n    for i in 1..<m {\n        for j in 1..<n {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    \n    for i in 1..<m {\n        for j in 1..<n {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    \n    if firstRowZero { for j in 0..<n { matrix[0][j] = 0 } }\n    if firstColZero { for i in 0..<m { matrix[i][0] = 0 } }\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(1)",
          "timeExplanation": "Visit each cell",
          "spaceExplanation": "In-place modification"
        },
        "testCases": [
          {
            "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
            "expectedOutput": "[[1,0,1],[0,0,0],[1,0,1]]",
            "explanation": "Row and col of 0 zeroed"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "sort-colors": {
    "summary": "Sort array with values 0, 1, 2 (Dutch National Flag problem). Use three pointers to partition in single pass: low for 0s boundary, high for 2s boundary, mid for scanning.",
    "approaches": [
      {
        "name": "Dutch National Flag (3 Pointers)",
        "intuition": "Maintain three regions: 0s at the front, 2s at the back, 1s in the middle. Use three pointers to expand these regions.",
        "approach": "1. low = 0 (boundary for 0s), high = n-1 (boundary for 2s), mid = 0\n2. While mid <= high:\n   a. If nums[mid] == 0: swap with low, increment both low and mid\n   b. If nums[mid] == 1: just increment mid\n   c. If nums[mid] == 2: swap with high, decrement high (don't increment mid!)\n3. Array is sorted",
        "explanation": "The array is partitioned into 4 regions: [0...low-1] are 0s, [low...mid-1] are 1s, [mid...high] are unknown, [high+1...n-1] are 2s. We scan with mid, placing 0s at low and 2s at high. When swapping with high, we don't advance mid because the swapped element is unknown and needs to be checked.",
        "code": "func sortColors(_ nums: inout [Int]) {\n    var low = 0\n    var mid = 0\n    var high = nums.count - 1\n    \n    while mid <= high {\n        switch nums[mid] {\n        case 0:\n            nums.swapAt(low, mid)\n            low += 1\n            mid += 1\n        case 1:\n            mid += 1\n        case 2:\n            nums.swapAt(mid, high)\n            high -= 1\n            // Don't increment mid - need to check swapped value\n        default:\n            break\n        }\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "In-place sorting with just pointer variables"
        },
        "testCases": [
          {
            "input": "nums = [2,0,2,1,1,0]",
            "expectedOutput": "[0,0,1,1,2,2]",
            "explanation": "0s moved to front, 2s to back, 1s in middle"
          },
          {
            "input": "nums = [2,0,1]",
            "expectedOutput": "[0,1,2]",
            "explanation": "Simple case with one of each"
          },
          {
            "input": "nums = [0]",
            "expectedOutput": "[0]",
            "explanation": "Single element already sorted"
          }
        ]
      },
      {
        "name": "Counting Sort",
        "intuition": "Count occurrences of 0, 1, 2, then overwrite array with that many of each. Two passes but very simple.",
        "approach": "1. Count how many 0s, 1s, 2s\n2. Fill array: first count0 zeros, then count1 ones, then count2 twos",
        "explanation": "Since we only have 3 possible values, counting sort is efficient. First pass counts, second pass writes. This uses O(1) extra space (just 3 counters) but requires two passes through the array.",
        "code": "func sortColors(_ nums: inout [Int]) {\n    var count = [0, 0, 0]\n    \n    for num in nums {\n        count[num] += 1\n    }\n    \n    var index = 0\n    for color in 0..<3 {\n        for _ in 0..<count[color] {\n            nums[index] = color\n            index += 1\n        }\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two passes through array",
          "spaceExplanation": "Only 3 counter variables"
        },
        "testCases": [
          {
            "input": "nums = [2,0,2,1,1,0]",
            "expectedOutput": "[0,0,1,1,2,2]",
            "explanation": "Count: [2,2,2]. Write 2 zeros, 2 ones, 2 twos."
          }
        ]
      }
    ],
    "relatedProblems": [
      "sort-list",
      "wiggle-sort",
      "wiggle-sort-ii"
    ]
  },
  "search-a-2d-matrix": {
    "summary": "Search for a target in a sorted 2D matrix (each row sorted, first element of row > last element of previous row). Treat as 1D array and binary search, or do two binary searches.",
    "approaches": [
      {
        "name": "Binary Search (Treat as 1D)",
        "intuition": "The matrix is essentially a sorted 1D array laid out in rows. Map 1D index to 2D coordinates: row = idx / cols, col = idx % cols.",
        "approach": "1. Calculate total elements n = rows * cols\n2. Binary search with left = 0, right = n - 1\n3. For mid, convert to matrix[mid / cols][mid % cols]\n4. Standard binary search comparison and bounds update",
        "explanation": "Since rows are contiguous in sorted order, index i in a flattened array maps to row i/cols, column i%cols. This lets us use standard binary search with O(1) index conversion. The matrix structure is just a visual layout of a sorted array.",
        "code": "func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n    let rows = matrix.count\n    let cols = matrix[0].count\n    var left = 0\n    var right = rows * cols - 1\n    \n    while left <= right {\n        let mid = left + (right - left) / 2\n        let value = matrix[mid / cols][mid % cols]\n        \n        if value == target {\n            return true\n        } else if value < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return false\n}",
        "complexity": {
          "time": "O(log(m*n))",
          "space": "O(1)",
          "timeExplanation": "Binary search over m*n elements",
          "spaceExplanation": "Only using pointer variables"
        },
        "testCases": [
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
            "expectedOutput": "true",
            "explanation": "3 is at position (0,1)"
          },
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
            "expectedOutput": "false",
            "explanation": "13 not in matrix"
          }
        ]
      },
      {
        "name": "Two Binary Searches",
        "intuition": "First binary search to find the correct row (where target could be), then binary search within that row.",
        "approach": "1. Binary search on first column to find row where row[0] <= target < nextRow[0]\n2. Binary search within that row for target\n3. Return true if found",
        "explanation": "We use the property that first elements of each row are sorted. First binary search narrows down to the correct row (the last row whose first element <= target). Second binary search finds target within that row. Two O(log n) searches is still O(log(m*n)).",
        "code": "func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n    let rows = matrix.count\n    let cols = matrix[0].count\n    \n    // Binary search for row\n    var top = 0\n    var bottom = rows - 1\n    var targetRow = 0\n    \n    while top <= bottom {\n        let mid = top + (bottom - top) / 2\n        if matrix[mid][0] <= target && (mid == rows - 1 || matrix[mid + 1][0] > target) {\n            targetRow = mid\n            break\n        } else if matrix[mid][0] > target {\n            bottom = mid - 1\n        } else {\n            top = mid + 1\n        }\n    }\n    \n    // Binary search within row\n    var left = 0\n    var right = cols - 1\n    \n    while left <= right {\n        let mid = left + (right - left) / 2\n        if matrix[targetRow][mid] == target {\n            return true\n        } else if matrix[targetRow][mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return false\n}",
        "complexity": {
          "time": "O(log m + log n)",
          "space": "O(1)",
          "timeExplanation": "Two separate binary searches",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
            "expectedOutput": "true",
            "explanation": "Row search finds row 0, column search finds index 1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "search-a-2d-matrix-ii"
    ]
  },
  "squares-of-a-sorted-array": {
    "summary": "Given sorted array (may have negatives), return array of squares in sorted order. Two pointers from ends, compare absolute values, fill result from back.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "Largest squares are at the ends (most negative or most positive). Compare absolute values at both ends, place larger square at end of result, move pointer inward.",
        "approach": "1. Left pointer at start, right at end\n2. Result array filled from back\n3. Compare abs values at left and right\n4. Place larger square at current result position, move that pointer\n5. Decrement result position",
        "explanation": "In a sorted array with negatives, the largest absolute values are at the extremes. By using two pointers and filling the result from the end, we efficiently place squares in sorted order without needing to sort afterward.",
        "code": "func sortedSquares(_ nums: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: nums.count)\n    var left = 0\n    var right = nums.count - 1\n    var pos = nums.count - 1\n    \n    while left <= right {\n        let leftSq = nums[left] * nums[left]\n        let rightSq = nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left += 1\n        } else {\n            result[pos] = rightSq\n            right -= 1\n        }\n        pos -= 1\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass with two pointers",
          "spaceExplanation": "Result array of size n"
        },
        "testCases": [
          {
            "input": "nums = [-4,-1,0,3,10]",
            "expectedOutput": "[0,1,9,16,100]",
            "explanation": "Compare |-4|=4 vs |10|=10. 100 goes last. Then |-4| vs |3|, 16 goes next. Etc."
          },
          {
            "input": "nums = [-7,-3,2,3,11]",
            "expectedOutput": "[4,9,9,49,121]",
            "explanation": "Two pointers handle negative numbers efficiently"
          }
        ]
      },
      {
        "name": "Square and Sort",
        "intuition": "Simple approach: square all elements, then sort. Less efficient but very straightforward.",
        "approach": "1. Square each element\n2. Sort the result",
        "explanation": "This naive approach works but uses O(n log n) time due to sorting. The two-pointer approach is better, but this is simpler to implement and understand.",
        "code": "func sortedSquares(_ nums: [Int]) -> [Int] {\n    return nums.map { $0 * $0 }.sorted()\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting dominates",
          "spaceExplanation": "New array for result"
        },
        "testCases": [
          {
            "input": "nums = [-4,-1,0,3,10]",
            "expectedOutput": "[0,1,9,16,100]",
            "explanation": "Square: [16,1,0,9,100]. Sort: [0,1,9,16,100]"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-sorted-array",
      "sort-an-array"
    ]
  },
  "palindrome-number": {
    "summary": "Determine if an integer reads the same forwards and backwards. The optimal approach reverses half the number and compares, avoiding string conversion and potential overflow.",
    "approaches": [
      {
        "name": "String Conversion",
        "intuition": "Convert the number to a string and check if it equals its reverse. Simple but uses extra space for the string.",
        "approach": "1. Handle negative numbers (always false - minus sign)\n2. Convert number to string\n3. Compare string with its reverse\n4. Return true if equal",
        "explanation": "This approach leverages string manipulation to easily reverse and compare. While intuitive, it requires O(n) extra space for the string representation and is slower due to string operations.",
        "code": "func isPalindrome(_ x: Int) -> Bool {\n    if x < 0 { return false }\n    let str = String(x)\n    return str == String(str.reversed())\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Where n is the number of digits. String conversion and reversal are O(n)",
          "spaceExplanation": "String representation requires O(n) space for n digits"
        },
        "testCases": [
          {
            "input": "x = 121",
            "expectedOutput": "true",
            "explanation": "121 reads as 121 from left to right and from right to left"
          },
          {
            "input": "x = -121",
            "expectedOutput": "false",
            "explanation": "From left to right it reads -121, from right to left it's 121-. Not a palindrome."
          }
        ]
      },
      {
        "name": "Reverse Half Number",
        "intuition": "Instead of reversing the entire number (which could overflow), reverse only half. If it's a palindrome, the first half equals the reversed second half.",
        "approach": "1. Return false for negative numbers\n2. Return false if number ends in 0 (except 0 itself)\n3. Reverse digits until reversed >= remaining\n4. Compare: for even digits, they should be equal; for odd digits, ignore middle digit",
        "explanation": "We reverse the second half of the number by repeatedly taking the last digit (x % 10) and building the reversed number. We stop when the reversed number is >= the remaining original. For even-length palindromes, they're equal. For odd-length, we divide reversed by 10 to skip the middle digit.",
        "code": "func isPalindrome(_ x: Int) -> Bool {\n    // Negative numbers and numbers ending in 0 (except 0) aren't palindromes\n    if x < 0 || (x % 10 == 0 && x != 0) {\n        return false\n    }\n    \n    var num = x\n    var reversed = 0\n    \n    // Reverse half of the number\n    while num > reversed {\n        reversed = reversed * 10 + num % 10\n        num /= 10\n    }\n    \n    // For even length: num == reversed\n    // For odd length: num == reversed / 10 (skip middle digit)\n    return num == reversed || num == reversed / 10\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "We process half the digits, and number of digits is log10(n)",
          "spaceExplanation": "Only using a few integer variables"
        },
        "testCases": [
          {
            "input": "x = 121",
            "expectedOutput": "true",
            "explanation": "After loop: num=1, reversed=12. num == reversed/10 (1 == 1). True."
          },
          {
            "input": "x = 1221",
            "expectedOutput": "true",
            "explanation": "After loop: num=12, reversed=12. num == reversed. True."
          },
          {
            "input": "x = 10",
            "expectedOutput": "false",
            "explanation": "Ends in 0 but isn't 0, so immediately return false."
          },
          {
            "input": "x = 0",
            "expectedOutput": "true",
            "explanation": "0 is a palindrome."
          }
        ]
      }
    ],
    "relatedProblems": [
      "palindrome-linked-list",
      "valid-palindrome",
      "valid-palindrome-ii"
    ]
  },
  "plus-one": {
    "summary": "Add one to a number represented as an array of digits. Handle carry propagation from right to left. Only need a new digit if all digits were 9.",
    "approaches": [
      {
        "name": "Right to Left with Carry",
        "intuition": "Start from the rightmost digit and add one. If it becomes 10, set to 0 and carry to next digit. Continue until no carry or we reach the front.",
        "approach": "1. Iterate from right to left\n2. Add 1 to current digit\n3. If digit < 10, we're done (no carry)\n4. If digit == 10, set to 0 and continue (carry)\n5. If we exit loop with carry, prepend 1",
        "explanation": "The key insight is that we only continue carrying if digit becomes 10 (i.e., was 9). As soon as we add to a non-9 digit, we can return immediately. If all digits were 9 (like 999), we need a new leading 1 (1000).",
        "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    for i in (0..<digits.count).reversed() {\n        digits[i] += 1\n        if digits[i] < 10 {\n            return digits\n        }\n        digits[i] = 0\n    }\n    \n    // All digits were 9, need new leading 1\n    return [1] + digits\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Worst case traverses all n digits (all 9s)",
          "spaceExplanation": "May need to create new array with n+1 digits"
        },
        "testCases": [
          {
            "input": "digits = [1,2,3]",
            "expectedOutput": "[1,2,4]",
            "explanation": "123 + 1 = 124. Only last digit changes."
          },
          {
            "input": "digits = [4,3,2,1]",
            "expectedOutput": "[4,3,2,2]",
            "explanation": "4321 + 1 = 4322"
          },
          {
            "input": "digits = [9,9,9]",
            "expectedOutput": "[1,0,0,0]",
            "explanation": "999 + 1 = 1000. Carry propagates through all digits, need new leading 1."
          },
          {
            "input": "digits = [1,9,9]",
            "expectedOutput": "[2,0,0]",
            "explanation": "199 + 1 = 200. Carry stops at first digit."
          }
        ]
      },
      {
        "name": "Find Rightmost Non-9",
        "intuition": "Find the rightmost digit that isn't 9, increment it, and set all digits to its right to 0. If all are 9, prepend 1 and set all to 0.",
        "approach": "1. Find rightmost non-9 digit\n2. If found: increment it, zero out all digits to the right\n3. If not found: all digits are 9, return [1] + array of zeros",
        "explanation": "This approach explicitly identifies the 'stopping point' of the carry before modifying anything. It's equivalent to the carry approach but thinks about it differently - we're looking for where the increment actually happens.",
        "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    // Find rightmost non-9\n    var i = digits.count - 1\n    while i >= 0 && digits[i] == 9 {\n        i -= 1\n    }\n    \n    if i < 0 {\n        // All 9s: 999 -> 1000\n        return [1] + Array(repeating: 0, count: digits.count)\n    }\n    \n    // Increment found digit, zero everything to its right\n    digits[i] += 1\n    for j in (i+1)..<digits.count {\n        digits[j] = 0\n    }\n    \n    return digits\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Scan for non-9, then potentially zero trailing digits",
          "spaceExplanation": "Worst case creates new array of n+1 digits"
        },
        "testCases": [
          {
            "input": "digits = [9]",
            "expectedOutput": "[1,0]",
            "explanation": "9 + 1 = 10"
          },
          {
            "input": "digits = [8,9,9]",
            "expectedOutput": "[9,0,0]",
            "explanation": "899 + 1 = 900. Rightmost non-9 is 8 at index 0."
          }
        ]
      }
    ],
    "relatedProblems": [
      "add-binary",
      "add-to-array-form-of-integer",
      "multiply-strings"
    ]
  },
  "happy-number": {
    "summary": "Determine if number reaches 1 by summing squares of digits. Detect cycle with Floyd's or set.",
    "approaches": [
      {
        "name": "Floyd's Cycle Detection",
        "intuition": "Process either reaches 1 or cycles. Detect cycle like linked list.",
        "approach": "1. Slow: one step, fast: two steps\n2. If they meet at 1, happy\n3. If they meet elsewhere, cycle (unhappy)",
        "explanation": "Guaranteed to either reach 1 or enter finite cycle.",
        "code": "func isHappy(_ n: Int) -> Bool {\n    func next(_ num: Int) -> Int {\n        var num = num, sum = 0\n        while num > 0 {\n            let d = num % 10\n            sum += d * d\n            num /= 10\n        }\n        return sum\n    }\n    \n    var slow = n, fast = next(n)\n    while fast != 1 && slow != fast {\n        slow = next(slow)\n        fast = next(next(fast))\n    }\n    return fast == 1\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Number of digits processed",
          "spaceExplanation": "Two pointers"
        },
        "testCases": [
          {
            "input": "n = 19",
            "expectedOutput": "true",
            "explanation": "19→82→68→100→1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "linked-list-cycle"
    ]
  },
  "single-number": {
    "summary": "Find the element that appears only once when all others appear twice. XOR all elements - pairs cancel out (a^a=0) leaving only the single number.",
    "approaches": [
      {
        "name": "XOR Bit Manipulation",
        "intuition": "XOR has two key properties: a^a=0 and a^0=a. If we XOR all numbers, pairs cancel out and only the single number remains.",
        "approach": "1. Initialize result = 0\n2. XOR each number with result\n3. Return result",
        "explanation": "XOR is associative and commutative, so the order doesn't matter. For array [a,b,a], we compute a^b^a = (a^a)^b = 0^b = b. Every number that appears twice contributes 0 to the final result, leaving only the unique number.",
        "code": "func singleNumber(_ nums: [Int]) -> Int {\n    var result = 0\n    for num in nums {\n        result ^= num\n    }\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through all n elements",
          "spaceExplanation": "Only one variable regardless of input size"
        },
        "testCases": [
          {
            "input": "nums = [2,2,1]",
            "expectedOutput": "1",
            "explanation": "2^2^1 = 0^1 = 1"
          },
          {
            "input": "nums = [4,1,2,1,2]",
            "expectedOutput": "4",
            "explanation": "4^1^2^1^2 = 4^(1^1)^(2^2) = 4^0^0 = 4"
          },
          {
            "input": "nums = [1]",
            "expectedOutput": "1",
            "explanation": "Single element is the answer"
          }
        ]
      },
      {
        "name": "Hash Set",
        "intuition": "Track seen numbers in a set. If we see a number again, remove it. The remaining number is the answer.",
        "approach": "1. Create empty set\n2. For each number: if in set, remove it; else add it\n3. Return the single element in set",
        "explanation": "This approach explicitly models the 'pairing' logic. Numbers that appear twice get added then removed, leaving only the unique number. While correct, it uses O(n) space unlike the XOR solution.",
        "code": "func singleNumber(_ nums: [Int]) -> Int {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) {\n            seen.remove(num)\n        } else {\n            seen.insert(num)\n        }\n    }\n    return seen.first!\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass with O(1) set operations",
          "spaceExplanation": "Set can hold up to n/2 elements"
        },
        "testCases": [
          {
            "input": "nums = [2,2,1]",
            "expectedOutput": "1",
            "explanation": "Add 2, remove 2, add 1. Set = {1}"
          }
        ]
      }
    ],
    "relatedProblems": [
      "single-number-ii",
      "single-number-iii"
    ]
  },
  "number-of-1-bits": {
    "summary": "Count the number of 1 bits (Hamming weight) in an integer. Use bit manipulation: n & (n-1) clears the lowest set bit, or check each bit with n & 1.",
    "approaches": [
      {
        "name": "Brian Kernighan's Algorithm",
        "intuition": "n & (n-1) clears the rightmost set bit. Count how many times we can do this until n becomes 0.",
        "approach": "1. Initialize count = 0\n2. While n != 0:\n   a. n = n & (n - 1)\n   b. count += 1\n3. Return count",
        "explanation": "When we subtract 1 from n, all bits after the rightmost 1 are flipped (including the 1 itself). ANDing with original n clears that rightmost 1. For example: 12 (1100) & 11 (1011) = 8 (1000). We cleared the rightmost 1 bit. This runs in O(k) where k is the number of 1 bits, not the total bits.",
        "code": "func hammingWeight(_ n: Int) -> Int {\n    var num = n\n    var count = 0\n    \n    while num != 0 {\n        num &= (num - 1)\n        count += 1\n    }\n    \n    return count\n}",
        "complexity": {
          "time": "O(k)",
          "space": "O(1)",
          "timeExplanation": "k is the number of 1 bits, at most 32 for 32-bit integer",
          "spaceExplanation": "Only using counter variable"
        },
        "testCases": [
          {
            "input": "n = 11 (binary: 1011)",
            "expectedOutput": "3",
            "explanation": "1011 → 1010 (count 1) → 1000 (count 2) → 0 (count 3)"
          },
          {
            "input": "n = 128 (binary: 10000000)",
            "expectedOutput": "1",
            "explanation": "Only one 1 bit, single iteration"
          },
          {
            "input": "n = 2147483645 (many 1s)",
            "expectedOutput": "30",
            "explanation": "Almost all bits set in this large number"
          }
        ]
      },
      {
        "name": "Check Each Bit",
        "intuition": "Check the least significant bit with n & 1, then right shift. Repeat for all 32 bits.",
        "approach": "1. Initialize count = 0\n2. Repeat 32 times:\n   a. If n & 1 == 1, increment count\n   b. Right shift n by 1\n3. Return count",
        "explanation": "We examine each bit position by masking with 1 (which checks if the LSB is set) and then shifting right to bring the next bit into position. This always takes 32 iterations for a 32-bit integer regardless of how many 1s there are.",
        "code": "func hammingWeight(_ n: Int) -> Int {\n    var num = n\n    var count = 0\n    \n    for _ in 0..<32 {\n        count += num & 1\n        num >>= 1\n    }\n    \n    return count\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(1)",
          "timeExplanation": "Always exactly 32 iterations for 32-bit integer",
          "spaceExplanation": "Only counter and input variables"
        },
        "testCases": [
          {
            "input": "n = 11",
            "expectedOutput": "3",
            "explanation": "Check all 32 bits, count three 1s"
          },
          {
            "input": "n = 0",
            "expectedOutput": "0",
            "explanation": "No bits set"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-bits",
      "counting-bits",
      "hamming-distance"
    ]
  },
  "counting-bits": {
    "summary": "Return array where ans[i] is the number of 1 bits in i, for i from 0 to n. Use DP: ans[i] = ans[i >> 1] + (i & 1), or ans[i] = ans[i & (i-1)] + 1.",
    "approaches": [
      {
        "name": "DP with Right Shift",
        "intuition": "The number of 1s in i equals the number of 1s in i/2 (i >> 1) plus whether the last bit is 1 (i & 1).",
        "approach": "1. Create array ans of size n+1\n2. ans[0] = 0\n3. For i from 1 to n: ans[i] = ans[i >> 1] + (i & 1)\n4. Return ans",
        "explanation": "Right shifting drops the last bit. So i's bit count is (i >> 1)'s bit count plus the dropped bit (0 or 1). For example, 5 (101) >> 1 = 2 (10). ans[5] = ans[2] + (5 & 1) = 1 + 1 = 2. We build up from smaller numbers, which we've already computed.",
        "code": "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i >> 1] + (i & 1)\n    }\n    \n    return ans\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass from 1 to n",
          "spaceExplanation": "Output array of size n+1"
        },
        "testCases": [
          {
            "input": "n = 2",
            "expectedOutput": "[0,1,1]",
            "explanation": "0=0b0 (0), 1=0b1 (1), 2=0b10 (1)"
          },
          {
            "input": "n = 5",
            "expectedOutput": "[0,1,1,2,1,2]",
            "explanation": "0,1,10,11,100,101 have 0,1,1,2,1,2 ones respectively"
          }
        ]
      },
      {
        "name": "DP with Brian Kernighan",
        "intuition": "ans[i] = ans[i & (i-1)] + 1, since i & (i-1) clears the lowest set bit. We've already computed ans for that smaller number.",
        "approach": "1. Create array ans of size n+1, ans[0] = 0\n2. For i from 1 to n: ans[i] = ans[i & (i-1)] + 1\n3. Return ans",
        "explanation": "i & (i-1) removes exactly one 1 bit from i. So ans[i] is one more than ans of the result. For example, 6 (110) & 5 (101) = 4 (100). ans[6] = ans[4] + 1 = 1 + 1 = 2. This directly uses the relationship between adjacent numbers in terms of set bits.",
        "code": "func countBits(_ n: Int) -> [Int] {\n    var ans = [Int](repeating: 0, count: n + 1)\n    \n    for i in 1...n {\n        ans[i] = ans[i & (i - 1)] + 1\n    }\n    \n    return ans\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass, O(1) work per number",
          "spaceExplanation": "Output array of size n+1"
        },
        "testCases": [
          {
            "input": "n = 5",
            "expectedOutput": "[0,1,1,2,1,2]",
            "explanation": "Same result, different recurrence"
          },
          {
            "input": "n = 0",
            "expectedOutput": "[0]",
            "explanation": "Just zero, which has 0 ones"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-1-bits",
      "binary-watch"
    ]
  },
  "reverse-bits": {
    "summary": "Reverse the bits of a 32-bit unsigned integer. Extract each bit from the input and place it in the mirrored position of the result.",
    "approaches": [
      {
        "name": "Bit by Bit",
        "intuition": "Extract the least significant bit from input, place it at the most significant position of result, then shift both accordingly.",
        "approach": "1. Initialize result = 0\n2. For 32 iterations:\n   a. Left shift result by 1 (make room)\n   b. Add n's least significant bit (n & 1)\n   c. Right shift n by 1\n3. Return result",
        "explanation": "We process bits from right to left in n, and place them from left to right in result. After 32 iterations, bit 0 of original n is now bit 31 of result, bit 1 is bit 30, etc. Each iteration shifts result left (making room at LSB) and shifts n right (exposing next bit).",
        "code": "func reverseBits(_ n: Int) -> Int {\n    var result = 0\n    var num = n\n    \n    for _ in 0..<32 {\n        result = (result << 1) | (num & 1)\n        num >>= 1\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(1)",
          "timeExplanation": "Always exactly 32 iterations",
          "spaceExplanation": "Only using two integer variables"
        },
        "testCases": [
          {
            "input": "n = 43261596 (00000010100101000001111010011100)",
            "expectedOutput": "964176192 (00111001011110000010100101000000)",
            "explanation": "Bits reversed position by position"
          },
          {
            "input": "n = 4294967293 (11111111111111111111111111111101)",
            "expectedOutput": "3221225471 (10111111111111111111111111111111)",
            "explanation": "Near-maximum value with trailing zeros becomes leading zeros"
          }
        ]
      },
      {
        "name": "Divide and Conquer (Swap)",
        "intuition": "Swap adjacent bits, then adjacent pairs, then adjacent nibbles, etc. Like merge sort in reverse - combine small swaps into larger reversal.",
        "approach": "1. Swap adjacent bits\n2. Swap adjacent 2-bit groups\n3. Swap adjacent 4-bit groups\n4. Swap adjacent 8-bit groups\n5. Swap adjacent 16-bit groups",
        "explanation": "Each step swaps groups of increasing size. After swapping 1s, 2s, 4s, 8s, and 16s, we've effectively reversed all 32 bits. Uses bit masks to isolate and move groups. Very fast with just 5 operations (plus masks).",
        "code": "func reverseBits(_ n: Int) -> Int {\n    var num = n\n    // Swap adjacent bits\n    num = ((num & 0x55555555) << 1) | ((num >> 1) & 0x55555555)\n    // Swap adjacent 2-bit pairs\n    num = ((num & 0x33333333) << 2) | ((num >> 2) & 0x33333333)\n    // Swap adjacent 4-bit nibbles\n    num = ((num & 0x0F0F0F0F) << 4) | ((num >> 4) & 0x0F0F0F0F)\n    // Swap adjacent bytes\n    num = ((num & 0x00FF00FF) << 8) | ((num >> 8) & 0x00FF00FF)\n    // Swap adjacent 16-bit halves\n    num = ((num & 0x0000FFFF) << 16) | ((num >> 16) & 0x0000FFFF)\n    return num\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(1)",
          "timeExplanation": "Fixed 5 swap operations",
          "spaceExplanation": "Only using one variable"
        },
        "testCases": [
          {
            "input": "n = 43261596",
            "expectedOutput": "964176192",
            "explanation": "Same result as bit-by-bit, but faster constant factor"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-1-bits",
      "reverse-integer"
    ]
  },
  "missing-number": {
    "summary": "Find the missing number in array containing n distinct numbers from 0 to n. Use XOR (numbers cancel out) or math (expected sum - actual sum).",
    "approaches": [
      {
        "name": "XOR Bit Manipulation",
        "intuition": "XOR all numbers 0 to n and all numbers in array. Pairs cancel out (a^a=0), leaving only the missing number.",
        "approach": "1. Initialize result = n (start with the last index)\n2. XOR result with each index i and nums[i]\n3. Return result",
        "explanation": "If array has numbers [0,1,3] with n=3, we XOR: (0^1^2^3) ^ (0^1^3) = 2. The index sequence gives us 0 to n-1, and we initialize with n to cover all expected numbers. Each present number appears in both sequences and cancels out.",
        "code": "func missingNumber(_ nums: [Int]) -> Int {\n    var result = nums.count  // This is 'n'\n    \n    for i in 0..<nums.count {\n        result ^= i ^ nums[i]\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Only one variable for result"
        },
        "testCases": [
          {
            "input": "nums = [3,0,1]",
            "expectedOutput": "2",
            "explanation": "n=3, expected [0,1,2,3]. Missing is 2."
          },
          {
            "input": "nums = [0,1]",
            "expectedOutput": "2",
            "explanation": "n=2, expected [0,1,2]. Missing is 2."
          },
          {
            "input": "nums = [9,6,4,2,3,5,7,0,1]",
            "expectedOutput": "8",
            "explanation": "n=9, missing 8 from sequence 0-9"
          }
        ]
      },
      {
        "name": "Math (Gauss Sum)",
        "intuition": "Sum of 0 to n is n*(n+1)/2. Subtract actual array sum to get missing number.",
        "approach": "1. Calculate expected sum = n * (n + 1) / 2\n2. Calculate actual sum of array\n3. Return expected - actual",
        "explanation": "Gauss's formula gives us the sum of first n natural numbers (including 0, it's 0+1+...+n). The difference between expected and actual sum is exactly the missing number. Watch for integer overflow with very large n.",
        "code": "func missingNumber(_ nums: [Int]) -> Int {\n    let n = nums.count\n    let expectedSum = n * (n + 1) / 2\n    let actualSum = nums.reduce(0, +)\n    return expectedSum - actualSum\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass to compute sum",
          "spaceExplanation": "Only storing two integers"
        },
        "testCases": [
          {
            "input": "nums = [3,0,1]",
            "expectedOutput": "2",
            "explanation": "Expected sum = 3*4/2 = 6. Actual = 4. Missing = 2."
          },
          {
            "input": "nums = [0]",
            "expectedOutput": "1",
            "explanation": "n=1, expected [0,1]. Sum should be 1, actual is 0. Missing = 1."
          }
        ]
      }
    ],
    "relatedProblems": [
      "find-the-duplicate-number",
      "find-all-numbers-disappeared-in-an-array",
      "first-missing-positive"
    ]
  },
  "min-stack": {
    "summary": "Design a stack that supports push, pop, top, and retrieving the minimum element in O(1) time. Store the minimum alongside each element or use a separate min-tracking stack.",
    "approaches": [
      {
        "name": "Two Stacks",
        "intuition": "Maintain a regular stack for values and a parallel stack that tracks the minimum at each level. When we push, also push the new minimum to the min stack.",
        "approach": "1. Main stack stores all values\n2. Min stack stores the minimum at each height\n3. Push: push value to main, push min(value, minStack.top) to min stack\n4. Pop: pop from both stacks\n5. GetMin: return min stack top",
        "explanation": "The min stack maintains the invariant that minStack[i] is the minimum of all elements from stack[0] to stack[i]. When we push a new element, the new minimum is either the element itself or the previous minimum (whichever is smaller). When we pop, we remove from both stacks, and the min stack still correctly reflects the minimum of remaining elements.",
        "code": "class MinStack {\n    private var stack: [Int] = []\n    private var minStack: [Int] = []\n    \n    init() {}\n    \n    func push(_ val: Int) {\n        stack.append(val)\n        let newMin = minStack.isEmpty ? val : min(val, minStack.last!)\n        minStack.append(newMin)\n    }\n    \n    func pop() {\n        stack.removeLast()\n        minStack.removeLast()\n    }\n    \n    func top() -> Int {\n        return stack.last!\n    }\n    \n    func getMin() -> Int {\n        return minStack.last!\n    }\n}",
        "complexity": {
          "time": "O(1) for all operations",
          "space": "O(n)",
          "timeExplanation": "All operations are constant time - just array append/remove/access",
          "spaceExplanation": "Two stacks, each can hold up to n elements"
        },
        "testCases": [
          {
            "input": "push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()",
            "expectedOutput": "-3, 0, -2",
            "explanation": "After pushes: stack=[-2,0,-3], minStack=[-2,-2,-3]. getMin=-3. Pop. stack=[-2,0], minStack=[-2,-2]. top=0, getMin=-2."
          }
        ]
      },
      {
        "name": "Single Stack with Pairs",
        "intuition": "Store (value, currentMin) pairs in a single stack. Each entry knows the minimum at that point in the stack's history.",
        "approach": "1. Stack stores tuples of (value, minAtThisLevel)\n2. Push: calculate new min, push (value, newMin)\n3. Pop: remove top tuple\n4. Top: return first element of top tuple\n5. GetMin: return second element of top tuple",
        "explanation": "By storing the minimum alongside each value, we embed the min-tracking directly into the main data structure. This uses the same total memory as two stacks but with better cache locality since related data is adjacent.",
        "code": "class MinStack {\n    private var stack: [(val: Int, min: Int)] = []\n    \n    init() {}\n    \n    func push(_ val: Int) {\n        let currentMin = stack.isEmpty ? val : min(val, stack.last!.min)\n        stack.append((val, currentMin))\n    }\n    \n    func pop() {\n        stack.removeLast()\n    }\n    \n    func top() -> Int {\n        return stack.last!.val\n    }\n    \n    func getMin() -> Int {\n        return stack.last!.min\n    }\n}",
        "complexity": {
          "time": "O(1) for all operations",
          "space": "O(n)",
          "timeExplanation": "All operations are single array operations",
          "spaceExplanation": "Stack stores n pairs"
        },
        "testCases": [
          {
            "input": "push(1), push(2), getMin(), push(-1), getMin(), pop(), getMin()",
            "expectedOutput": "1, -1, 1",
            "explanation": "Stack builds: [(1,1), (2,1), (-1,-1)]. Mins are 1, -1, then back to 1 after pop."
          }
        ]
      }
    ],
    "relatedProblems": [
      "max-stack"
    ]
  },
  "asteroid-collision": {
    "summary": "Asteroids move right (+) or left (-). When they collide, smaller one explodes; equal sizes both explode. Use a stack to simulate collisions as asteroids move.",
    "approaches": [
      {
        "name": "Stack Simulation",
        "intuition": "Right-moving asteroids wait on stack for potential collision. Left-moving asteroids collide with stack (right-movers) until destroyed or survives.",
        "approach": "1. For each asteroid:\n   a. If positive, push to stack\n   b. If negative, resolve collisions with stack:\n      - While stack top is positive and smaller, pop (it explodes)\n      - If stack top is positive and equal, pop and don't push (both explode)\n      - If stack empty or top is negative, push (survives)\n2. Return stack as array",
        "explanation": "Only right-moving (positive) and left-moving (negative) can collide. Two left-movers never collide (both going left). The stack holds surviving asteroids. When we see a negative asteroid, it can only collide with positive ones on the stack. We keep destroying stack asteroids until the negative one is destroyed or survives.",
        "code": "func asteroidCollision(_ asteroids: [Int]) -> [Int] {\n    var stack: [Int] = []\n    \n    for asteroid in asteroids {\n        if asteroid > 0 {\n            stack.append(asteroid)\n        } else {\n            // asteroid < 0, resolve collisions\n            while !stack.isEmpty && stack.last! > 0 && stack.last! < -asteroid {\n                stack.removeLast()  // Stack asteroid explodes\n            }\n            \n            if stack.isEmpty || stack.last! < 0 {\n                stack.append(asteroid)  // Survives\n            } else if stack.last! == -asteroid {\n                stack.removeLast()  // Both explode\n            }\n            // else: stack.last! > -asteroid, incoming asteroid explodes (don't push)\n        }\n    }\n    \n    return stack\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Each asteroid pushed and popped at most once",
          "spaceExplanation": "Stack can hold all asteroids in worst case"
        },
        "testCases": [
          {
            "input": "asteroids = [5,10,-5]",
            "expectedOutput": "[5,10]",
            "explanation": "10 and -5 collide, 10 survives. 5 and 10 don't collide (same direction)."
          },
          {
            "input": "asteroids = [8,-8]",
            "expectedOutput": "[]",
            "explanation": "Equal size, both explode."
          },
          {
            "input": "asteroids = [10,2,-5]",
            "expectedOutput": "[10]",
            "explanation": "-5 destroys 2, then collides with 10 and explodes."
          },
          {
            "input": "asteroids = [-2,-1,1,2]",
            "expectedOutput": "[-2,-1,1,2]",
            "explanation": "Left-movers go left, right-movers go right. No collisions."
          }
        ]
      },
      {
        "name": "Stack with Explicit State",
        "intuition": "Same logic but with a boolean to track if the incoming asteroid survives all collisions, making the code flow clearer.",
        "approach": "1. For each asteroid:\n   a. Set alive = true\n   b. While alive and asteroid < 0 and stack top > 0:\n      - If |asteroid| > stack top: pop, continue\n      - If |asteroid| == stack top: pop, alive = false\n      - If |asteroid| < stack top: alive = false\n   c. If alive, push asteroid",
        "explanation": "This version explicitly tracks whether the incoming asteroid survives. The while loop continues as long as there's potential for collision (incoming negative, stack top positive) and the incoming asteroid is still 'alive'. This makes the three collision outcomes clearer.",
        "code": "func asteroidCollision(_ asteroids: [Int]) -> [Int] {\n    var stack: [Int] = []\n    \n    for asteroid in asteroids {\n        var alive = true\n        \n        while alive && asteroid < 0 && !stack.isEmpty && stack.last! > 0 {\n            let top = stack.last!\n            if top < -asteroid {\n                stack.removeLast()  // Top explodes, continue checking\n            } else if top == -asteroid {\n                stack.removeLast()  // Both explode\n                alive = false\n            } else {\n                alive = false  // Incoming explodes\n            }\n        }\n        \n        if alive {\n            stack.append(asteroid)\n        }\n    }\n    \n    return stack\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Each asteroid processed once, total pops <= n",
          "spaceExplanation": "Stack size at most n"
        },
        "testCases": [
          {
            "input": "asteroids = [1,-1,-2]",
            "expectedOutput": "[-2]",
            "explanation": "1 and -1 both explode. -2 survives (nothing to collide with)."
          }
        ]
      }
    ],
    "relatedProblems": [
      "can-place-flowers",
      "destroying-asteroids"
    ]
  },
  "daily-temperatures": {
    "summary": "For each day, find how many days until a warmer temperature. Use a monotonic decreasing stack to track indices of days waiting for a warmer day.",
    "approaches": [
      {
        "name": "Monotonic Stack",
        "intuition": "Maintain a stack of indices for days we haven't found a warmer day yet. When we see a warmer day, pop all colder days from stack and record their wait times.",
        "approach": "1. Initialize result array with zeros\n2. Use stack to store indices of temperatures\n3. For each day i:\n   a. While stack not empty and T[i] > T[stack.top]:\n      - Pop index j, set result[j] = i - j\n   b. Push i to stack\n4. Return result (days left in stack stay 0)",
        "explanation": "The stack maintains indices in decreasing temperature order. When we find a warmer temperature, it's the answer for all cooler temperatures on the stack. We pop them and calculate the day difference. Days that never find a warmer temperature remain in the stack with result[i] = 0.",
        "code": "func dailyTemperatures(_ temperatures: [Int]) -> [Int] {\n    var result = [Int](repeating: 0, count: temperatures.count)\n    var stack: [Int] = []  // Stack of indices\n    \n    for i in 0..<temperatures.count {\n        while !stack.isEmpty && temperatures[i] > temperatures[stack.last!] {\n            let j = stack.removeLast()\n            result[j] = i - j\n        }\n        stack.append(i)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Each index pushed and popped at most once",
          "spaceExplanation": "Stack can hold all indices in worst case (decreasing temps)"
        },
        "testCases": [
          {
            "input": "temperatures = [73,74,75,71,69,72,76,73]",
            "expectedOutput": "[1,1,4,2,1,1,0,0]",
            "explanation": "Day 0: next warmer is day 1 (1 day). Day 2: next warmer is day 6 (4 days). Days 6,7: no warmer day."
          },
          {
            "input": "temperatures = [30,40,50,60]",
            "expectedOutput": "[1,1,1,0]",
            "explanation": "Increasing temps - each day's answer is 1 except last"
          },
          {
            "input": "temperatures = [30,60,90]",
            "expectedOutput": "[1,1,0]",
            "explanation": "Strictly increasing"
          }
        ]
      },
      {
        "name": "Reverse Iteration",
        "intuition": "Process from right to left. For each day, check if the next day is warmer. If not, use the next day's result to skip ahead.",
        "approach": "1. Initialize result array with zeros\n2. For i from n-2 down to 0:\n   a. j = i + 1\n   b. While T[j] <= T[i] and result[j] > 0: j += result[j]\n   c. If T[j] > T[i]: result[i] = j - i",
        "explanation": "When T[i+1] isn't warmer than T[i], we can use result[i+1] to skip directly to the next warmer day after i+1. This creates a form of path compression. If we hit a day with result = 0 (no warmer day), we know T[i] also has no warmer day.",
        "code": "func dailyTemperatures(_ temperatures: [Int]) -> [Int] {\n    let n = temperatures.count\n    var result = [Int](repeating: 0, count: n)\n    \n    for i in (0..<n-1).reversed() {\n        var j = i + 1\n        while temperatures[j] <= temperatures[i] && result[j] > 0 {\n            j += result[j]\n        }\n        if temperatures[j] > temperatures[i] {\n            result[i] = j - i\n        }\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Amortized O(n) - each element visited limited times via skipping",
          "spaceExplanation": "Output array of size n"
        },
        "testCases": [
          {
            "input": "temperatures = [73,74,75,71,69,72,76,73]",
            "expectedOutput": "[1,1,4,2,1,1,0,0]",
            "explanation": "Same result, processed right to left"
          }
        ]
      }
    ],
    "relatedProblems": [
      "next-greater-element-i",
      "next-greater-element-ii",
      "online-stock-span"
    ]
  },
  "car-fleet": {
    "summary": "Count car fleets arriving at target. Sort by position, stack by arrival time.",
    "approaches": [
      {
        "name": "Sort + Stack",
        "intuition": "Cars that catch up merge into fleets.",
        "approach": "1. Sort by position descending\n2. Calculate arrival times\n3. If current arrives later than stack top, new fleet",
        "explanation": "Car behind can't pass car ahead.",
        "code": "func carFleet(_ target: Int, _ position: [Int], _ speed: [Int]) -> Int {\n    let cars = zip(position, speed).sorted { $0.0 > $1.0 }\n    var stack: [Double] = []\n    for (pos, spd) in cars {\n        let time = Double(target - pos) / Double(spd)\n        if stack.isEmpty || time > stack.last! {\n            stack.append(time)\n        }\n    }\n    return stack.count\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting",
          "spaceExplanation": "Stack"
        },
        "testCases": [
          {
            "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
            "expectedOutput": "3",
            "explanation": "3 separate fleets"
          }
        ]
      }
    ],
    "relatedProblems": [
      "car-fleet-ii"
    ]
  },
  "valid-sudoku": {
    "summary": "Validate a 9×9 Sudoku board. Check that each row, column, and 3×3 sub-box contains digits 1-9 without repetition. Empty cells (denoted by '.') are allowed.",
    "approaches": [
      {
        "name": "Three Sets per Unit",
        "intuition": "Use hash sets to track seen numbers for each row, column, and 3×3 box. If we encounter a duplicate in any unit, the board is invalid.",
        "approach": "1. Create 9 sets for rows, 9 for columns, 9 for boxes\n2. Iterate through each cell\n3. For non-empty cells, check if number exists in its row/col/box set\n4. If duplicate found, return false\n5. Otherwise, add number to all three sets",
        "explanation": "Each cell belongs to exactly one row, one column, and one 3×3 box. The box index can be computed as (row/3)*3 + (col/3). We only need to check filled cells since empty cells don't violate constraints. Using sets gives O(1) lookup for duplicates.",
        "code": "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = Array(repeating: Set<Character>(), count: 9)\n    var cols = Array(repeating: Set<Character>(), count: 9)\n    var boxes = Array(repeating: Set<Character>(), count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let boxIndex = (i / 3) * 3 + (j / 3)\n            \n            if rows[i].contains(char) ||\n               cols[j].contains(char) ||\n               boxes[boxIndex].contains(char) {\n                return false\n            }\n            \n            rows[i].insert(char)\n            cols[j].insert(char)\n            boxes[boxIndex].insert(char)\n        }\n    }\n    \n    return true\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(1)",
          "timeExplanation": "Always 81 cells to check - constant for 9×9 board",
          "spaceExplanation": "27 sets with at most 9 elements each - constant space"
        },
        "testCases": [
          {
            "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "expectedOutput": "true",
            "explanation": "Valid Sudoku board - no duplicates in any row, column, or box"
          },
          {
            "input": "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "expectedOutput": "false",
            "explanation": "Two 8's in the first column (rows 0 and 3)"
          }
        ]
      },
      {
        "name": "Bit Manipulation",
        "intuition": "Use integers as bit sets instead of hash sets. Each bit represents whether a digit (1-9) has been seen. This is more memory-efficient.",
        "approach": "1. Use 9 integers for rows, 9 for cols, 9 for boxes (bits represent digits)\n2. For each cell, compute bit mask for the digit\n3. Check if bit is already set in row/col/box\n4. If set, return false; otherwise set the bit",
        "explanation": "For digit d, we use bit (1 << d) as a marker. If (row[i] & bit) != 0, the digit was already seen in that row. Using bitwise operations is faster than hash set operations and uses less memory (just integers instead of set objects).",
        "code": "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = [Int](repeating: 0, count: 9)\n    var cols = [Int](repeating: 0, count: 9)\n    var boxes = [Int](repeating: 0, count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let digit = Int(char.asciiValue! - Character(\"0\").asciiValue!)\n            let bit = 1 << digit\n            let boxIndex = (i / 3) * 3 + (j / 3)\n            \n            if (rows[i] & bit) != 0 ||\n               (cols[j] & bit) != 0 ||\n               (boxes[boxIndex] & bit) != 0 {\n                return false\n            }\n            \n            rows[i] |= bit\n            cols[j] |= bit\n            boxes[boxIndex] |= bit\n        }\n    }\n    \n    return true\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(1)",
          "timeExplanation": "Fixed 81 cells, constant operations per cell",
          "spaceExplanation": "27 integers - more efficient than sets"
        },
        "testCases": [
          {
            "input": "board with valid partial fill",
            "expectedOutput": "true",
            "explanation": "Bit operations efficiently check for duplicates"
          },
          {
            "input": "board with duplicate in box",
            "expectedOutput": "false",
            "explanation": "boxes[boxIndex] & bit detects the duplicate"
          }
        ]
      }
    ],
    "relatedProblems": [
      "sudoku-solver"
    ]
  },
  "jump-game-ii": {
    "summary": "Find minimum jumps to reach end of array where nums[i] is max jump length from i. Greedy: at each step, jump to position that lets you reach furthest.",
    "approaches": [
      {
        "name": "Greedy (BFS-like)",
        "intuition": "Track the furthest position reachable. When we reach current boundary, we must jump. Count jumps when boundary is reached.",
        "approach": "1. Track currentEnd (boundary of current jump) and furthest reachable\n2. For each position, update furthest\n3. When i reaches currentEnd, increment jumps, update currentEnd to furthest\n4. Stop when currentEnd >= last index",
        "explanation": "Think of it as BFS where each 'level' is positions reachable with the same number of jumps. currentEnd marks the boundary of current level. When we reach it, we've explored all positions at this level and must jump to next level (furthest becomes new boundary).",
        "code": "func jump(_ nums: [Int]) -> Int {\n    if nums.count <= 1 { return 0 }\n    \n    var jumps = 0\n    var currentEnd = 0\n    var furthest = 0\n    \n    for i in 0..<nums.count - 1 {\n        furthest = max(furthest, i + nums[i])\n        \n        if i == currentEnd {\n            jumps += 1\n            currentEnd = furthest\n            if currentEnd >= nums.count - 1 { break }\n        }\n    }\n    \n    return jumps\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Only tracking three variables"
        },
        "testCases": [
          {
            "input": "nums = [2,3,1,1,4]",
            "expectedOutput": "2",
            "explanation": "Jump from 0→1 (can reach up to 4), then 1→4. Two jumps."
          },
          {
            "input": "nums = [2,3,0,1,4]",
            "expectedOutput": "2",
            "explanation": "Same: 0→1→4"
          }
        ]
      },
      {
        "name": "DP (for comparison)",
        "intuition": "dp[i] = minimum jumps to reach position i. For each position, update all reachable positions.",
        "approach": "1. dp[0] = 0, dp[i] = infinity\n2. For each i, for each j reachable from i: dp[j] = min(dp[j], dp[i]+1)\n3. Return dp[n-1]",
        "explanation": "This is the straightforward DP approach. For each position, we update all positions we can jump to. Less efficient than greedy but easier to understand. Shows the greedy solution is optimal.",
        "code": "func jump(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var dp = [Int](repeating: Int.max, count: n)\n    dp[0] = 0\n    \n    for i in 0..<n {\n        for j in i+1...min(i + nums[i], n - 1) {\n            dp[j] = min(dp[j], dp[i] + 1)\n        }\n    }\n    \n    return dp[n - 1]\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(n)",
          "timeExplanation": "For each position, potentially update many others",
          "spaceExplanation": "DP array of size n"
        },
        "testCases": [
          {
            "input": "nums = [2,3,1,1,4]",
            "expectedOutput": "2",
            "explanation": "dp builds: [0,1,1,2,2]. Answer is 2."
          }
        ]
      }
    ],
    "relatedProblems": [
      "jump-game",
      "jump-game-iii"
    ]
  },
  "gas-station": {
    "summary": "Find starting gas station index to complete circular trip. If total gas >= total cost, solution exists. Start from station after the one where tank goes negative.",
    "approaches": [
      {
        "name": "Greedy Single Pass",
        "intuition": "If total gas >= total cost, solution exists. If we run out at station i, start after i (stations 0 to i can't be start). Track where tank goes negative.",
        "approach": "1. Track total (gas - cost for all) and tank (running sum)\n2. If tank < 0, reset start to next station, reset tank\n3. Return start if total >= 0, else -1",
        "explanation": "Key insight: if we can't reach station i+1 from some start s, then any station between s and i also can't reach i+1 (because we'd have even less gas). So when tank goes negative, skip all those stations. If total is non-negative, the remaining stations must work.",
        "code": "func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\n    var total = 0\n    var tank = 0\n    var start = 0\n    \n    for i in 0..<gas.count {\n        let diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        \n        if tank < 0 {\n            start = i + 1\n            tank = 0\n        }\n    }\n    \n    return total >= 0 ? start : -1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through arrays",
          "spaceExplanation": "Only tracking a few variables"
        },
        "testCases": [
          {
            "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
            "expectedOutput": "3",
            "explanation": "Start at station 3: tank 4-1=3, 3+5-2=6, 6+1-3=4, 4+2-4=2, 2+3-5=0. Success!"
          },
          {
            "input": "gas = [2,3,4], cost = [3,4,3]",
            "expectedOutput": "-1",
            "explanation": "Total gas 9 < total cost 10. Impossible."
          }
        ]
      },
      {
        "name": "Brute Force (for understanding)",
        "intuition": "Try each station as start. Simulate the trip and check if we complete the circuit.",
        "approach": "1. For each starting station i\n2. Simulate trip: at each station add gas, subtract cost\n3. If tank ever negative, this start fails\n4. If complete circuit, return i",
        "explanation": "Simple simulation to verify the greedy approach. Try each start, simulate the journey. TLE for large inputs but helps understand the problem.",
        "code": "func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\n    let n = gas.count\n    \n    for start in 0..<n {\n        var tank = 0\n        var success = true\n        \n        for i in 0..<n {\n            let station = (start + i) % n\n            tank += gas[station] - cost[station]\n            if tank < 0 {\n                success = false\n                break\n            }\n        }\n        \n        if success { return start }\n    }\n    \n    return -1\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(1)",
          "timeExplanation": "Try each of n starts, each simulation is O(n)",
          "spaceExplanation": "Only loop variables"
        },
        "testCases": [
          {
            "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
            "expectedOutput": "3",
            "explanation": "Trying stations 0,1,2 fail. Station 3 succeeds."
          }
        ]
      }
    ],
    "relatedProblems": [
      "minimum-cost-to-hire-k-workers"
    ]
  },
  "last-stone-weight": {
    "summary": "Smash the two heaviest stones together repeatedly. If equal, both destroyed; if different, the difference remains. Return the last remaining stone's weight or 0. Use a max-heap for efficient retrieval.",
    "approaches": [
      {
        "name": "Max-Heap (Priority Queue)",
        "intuition": "We always need the two largest stones. A max-heap gives us O(log n) access to the maximum element. Pop two, push back the difference if non-zero.",
        "approach": "1. Build a max-heap from all stones\n2. While heap has more than one stone:\n   a. Pop two largest (y >= x)\n   b. If y > x, push y - x back\n3. Return heap top if exists, else 0",
        "explanation": "A max-heap maintains the invariant that the largest element is always at the root. By using a heap, each smash operation (2 pops + 1 optional push) is O(log n). We continue until at most one stone remains. Swift doesn't have a built-in heap, so we simulate with sorted array or use negative values with a min-heap.",
        "code": "func lastStoneWeight(_ stones: [Int]) -> Int {\n    var heap = stones.sorted()\n    \n    while heap.count > 1 {\n        let y = heap.removeLast()  // Largest\n        let x = heap.removeLast()  // Second largest\n        \n        if y > x {\n            // Insert y - x in sorted position\n            let diff = y - x\n            let insertIndex = heap.firstIndex { $0 >= diff } ?? heap.count\n            heap.insert(diff, at: insertIndex)\n        }\n    }\n    \n    return heap.first ?? 0\n}",
        "complexity": {
          "time": "O(n² log n) worst case with array",
          "space": "O(n)",
          "timeExplanation": "Up to n smashes, each with O(n) insertion. True heap would be O(n log n)",
          "spaceExplanation": "Storing all stones in heap/array"
        },
        "testCases": [
          {
            "input": "stones = [2,7,4,1,8,1]",
            "expectedOutput": "1",
            "explanation": "8,7→1. 4,2→2. 2,1→1. 1,1→0. 1 remains."
          },
          {
            "input": "stones = [1]",
            "expectedOutput": "1",
            "explanation": "Single stone, nothing to smash"
          },
          {
            "input": "stones = [2,2]",
            "expectedOutput": "0",
            "explanation": "Equal stones destroy each other"
          }
        ]
      },
      {
        "name": "Simulated Max-Heap with Negative Values",
        "intuition": "Swift's standard library doesn't include a heap, but we can use CFBinaryHeap or simulate with an array. Using negative values with a min-heap simulates a max-heap.",
        "approach": "1. Store negative values (so min-heap acts as max-heap)\n2. Pop two smallest (most negative = largest original)\n3. If difference, push negative difference\n4. Return negative of remaining value",
        "explanation": "This is a common trick when only min-heap is available. By negating all values, the smallest negative corresponds to the largest original value. The algorithm remains the same, just negate on insert and extract.",
        "code": "func lastStoneWeight(_ stones: [Int]) -> Int {\n    // Using sorted array as simple heap\n    var heap = stones.sorted(by: >)  // Descending order\n    \n    while heap.count > 1 {\n        let first = heap.removeFirst()   // Largest\n        let second = heap.removeFirst()  // Second largest\n        \n        if first != second {\n            let diff = first - second\n            // Binary search insert to maintain sorted order\n            if let idx = heap.firstIndex(where: { $0 < diff }) {\n                heap.insert(diff, at: idx)\n            } else {\n                heap.append(diff)\n            }\n        }\n    }\n    \n    return heap.first ?? 0\n}",
        "complexity": {
          "time": "O(n² ) with sorted array simulation",
          "space": "O(n)",
          "timeExplanation": "Each insertion is O(n) for binary search + shift, n iterations",
          "spaceExplanation": "Array stores all remaining stones"
        },
        "testCases": [
          {
            "input": "stones = [2,7,4,1,8,1]",
            "expectedOutput": "1",
            "explanation": "Same process, different implementation"
          },
          {
            "input": "stones = [10,4,2,10]",
            "expectedOutput": "2",
            "explanation": "10,10→0. 4,2→2. Result: 2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "last-stone-weight-ii"
    ]
  },
  "insert-interval": {
    "summary": "Insert a new interval into a sorted list of non-overlapping intervals, merging if necessary. Process intervals in three phases: those before, those overlapping, and those after the new interval.",
    "approaches": [
      {
        "name": "Linear Scan with Three Phases",
        "intuition": "Since intervals are sorted and non-overlapping, we can process them in order: add all intervals that end before the new one starts, merge all that overlap with the new interval, then add remaining intervals.",
        "approach": "1. Add all intervals that end before newInterval starts (no overlap)\n2. Merge all intervals that overlap with newInterval\n3. Add the merged interval\n4. Add all remaining intervals (start after newInterval ends)",
        "explanation": "Two intervals [a,b] and [c,d] overlap if a <= d AND c <= b. For overlapping intervals, we merge by taking min of starts and max of ends. The key insight is that once we pass intervals that could overlap, all remaining intervals must come after.",
        "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var newInterval = newInterval\n    var i = 0\n    let n = intervals.count\n    \n    // Phase 1: Add intervals that end before newInterval starts\n    while i < n && intervals[i][1] < newInterval[0] {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    // Phase 2: Merge overlapping intervals\n    while i < n && intervals[i][0] <= newInterval[1] {\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    }\n    result.append(newInterval)\n    \n    // Phase 3: Add remaining intervals\n    while i < n {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass through all n intervals",
          "spaceExplanation": "Output array can contain up to n+1 intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
            "expectedOutput": "[[1,5],[6,9]]",
            "explanation": "[1,3] overlaps with [2,5] → merge to [1,5]. [6,9] comes after."
          },
          {
            "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
            "expectedOutput": "[[1,2],[3,10],[12,16]]",
            "explanation": "[3,5], [6,7], [8,10] all overlap with [4,8] → merge to [3,10]"
          },
          {
            "input": "intervals = [], newInterval = [5,7]",
            "expectedOutput": "[[5,7]]",
            "explanation": "Empty list - just add the new interval"
          },
          {
            "input": "intervals = [[1,5]], newInterval = [2,3]",
            "expectedOutput": "[[1,5]]",
            "explanation": "New interval is completely inside existing one - merge is just [1,5]"
          }
        ]
      },
      {
        "name": "Binary Search + Merge",
        "intuition": "Use binary search to find where the new interval should be inserted, then handle merging. This can be faster for finding the insertion point but still O(n) overall due to potential merging.",
        "approach": "1. Binary search to find first interval that could overlap (start <= newInterval.end)\n2. Binary search to find last interval that could overlap (end >= newInterval.start)\n3. Merge all intervals in that range with newInterval\n4. Construct result with non-overlapping + merged + remaining",
        "explanation": "Binary search finds the boundaries faster, but we still need to merge intervals in the overlapping range. This approach shines when there are few or no overlaps, as binary search is O(log n). However, worst case is still O(n) when many intervals merge.",
        "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    if intervals.isEmpty {\n        return [newInterval]\n    }\n    \n    var result: [[Int]] = []\n    var merged = newInterval\n    var inserted = false\n    \n    for interval in intervals {\n        if interval[1] < merged[0] {\n            // Current interval ends before merged starts\n            result.append(interval)\n        } else if interval[0] > merged[1] {\n            // Current interval starts after merged ends\n            if !inserted {\n                result.append(merged)\n                inserted = true\n            }\n            result.append(interval)\n        } else {\n            // Overlap - expand merged interval\n            merged[0] = min(merged[0], interval[0])\n            merged[1] = max(merged[1], interval[1])\n        }\n    }\n    \n    if !inserted {\n        result.append(merged)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Process each interval once",
          "spaceExplanation": "Output array stores all resulting intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [10,11]",
            "expectedOutput": "[[1,3],[6,9],[10,11]]",
            "explanation": "No overlap - new interval added at end"
          },
          {
            "input": "intervals = [[3,5],[6,9]], newInterval = [1,2]",
            "expectedOutput": "[[1,2],[3,5],[6,9]]",
            "explanation": "No overlap - new interval added at beginning"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-intervals",
      "range-module",
      "data-stream-as-disjoint-intervals"
    ]
  },
  "non-overlapping-intervals": {
    "summary": "Find minimum intervals to remove to make the rest non-overlapping. Greedy: sort by end time, keep intervals that don't overlap with previous kept interval. Remove count = total - kept.",
    "approaches": [
      {
        "name": "Greedy (Sort by End Time)",
        "intuition": "Always keep the interval that ends earliest - this leaves maximum room for subsequent intervals. Count how many we keep, subtract from total.",
        "approach": "1. Sort intervals by end time\n2. Track the end time of last kept interval\n3. For each interval:\n   a. If start >= lastEnd, keep it (update lastEnd)\n   b. Else, skip it (it overlaps)\n4. Return total - kept",
        "explanation": "Sorting by end time ensures we greedily pick intervals that finish earliest. If a new interval starts after the previous ends, it doesn't overlap. By choosing early-ending intervals, we maximize the number we can fit. The intervals we don't keep are the ones we'd remove.",
        "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by end time\n    let sorted = intervals.sorted { $0[1] < $1[1] }\n    \n    var kept = 1\n    var lastEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] >= lastEnd {\n            kept += 1\n            lastEnd = sorted[i][1]\n        }\n    }\n    \n    return intervals.count - kept\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Dominated by sorting",
          "spaceExplanation": "Creating sorted copy of intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
            "expectedOutput": "1",
            "explanation": "Remove [1,3]. Keep [1,2], [2,3], [3,4] which don't overlap."
          },
          {
            "input": "intervals = [[1,2],[1,2],[1,2]]",
            "expectedOutput": "2",
            "explanation": "All identical, can only keep 1. Remove 2."
          },
          {
            "input": "intervals = [[1,2],[2,3]]",
            "expectedOutput": "0",
            "explanation": "Already non-overlapping (touching endpoints is OK)"
          }
        ]
      },
      {
        "name": "Greedy (Sort by Start, Track Overlaps)",
        "intuition": "Sort by start time. When two intervals overlap, remove the one that ends later (it's more likely to cause future conflicts).",
        "approach": "1. Sort intervals by start time\n2. Track end of previous kept interval\n3. For each interval:\n   a. If overlap (start < prevEnd), increment removals, keep shorter one (update prevEnd to min)\n   b. Else, update prevEnd to current end",
        "explanation": "When intervals overlap, we want to keep the one ending sooner. By sorting by start time and keeping the smaller end when conflicts occur, we minimize future overlaps. This is equivalent to the end-time approach but processes differently.",
        "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by start time\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    \n    var removals = 0\n    var prevEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] < prevEnd {\n            // Overlap - remove one (keep the one ending sooner)\n            removals += 1\n            prevEnd = min(prevEnd, sorted[i][1])\n        } else {\n            prevEnd = sorted[i][1]\n        }\n    }\n    \n    return removals\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting dominates",
          "spaceExplanation": "Sorted copy of intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,100],[11,22],[1,11],[2,12]]",
            "expectedOutput": "2",
            "explanation": "Keep [1,11] and [11,22], remove the longer overlapping ones"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-intervals",
      "insert-interval",
      "minimum-number-of-arrows-to-burst-balloons"
    ]
  },
  "diameter-of-binary-tree": {
    "summary": "Find the longest path between any two nodes (doesn't need to pass through root). For each node, diameter through it = left depth + right depth. Track max across all nodes.",
    "approaches": [
      {
        "name": "DFS with Global Max",
        "intuition": "At each node, calculate left and right depths. The path through this node has length leftDepth + rightDepth. Track the maximum across all nodes.",
        "approach": "1. Initialize maxDiameter = 0\n2. DFS function returns depth of subtree\n3. At each node:\n   a. Get left depth, right depth\n   b. Update maxDiameter = max(maxDiameter, left + right)\n   c. Return 1 + max(left, right) as depth\n4. Return maxDiameter",
        "explanation": "The diameter is the number of edges on the longest path. At each node, the longest path through it uses the deepest node in left subtree + node + deepest node in right subtree. The depth we return is for the parent to use in its calculation. We compute diameter at every node and keep the maximum.",
        "code": "func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\n    var maxDiameter = 0\n    \n    func depth(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        \n        let leftDepth = depth(node.left)\n        let rightDepth = depth(node.right)\n        \n        // Update diameter at this node\n        maxDiameter = max(maxDiameter, leftDepth + rightDepth)\n        \n        // Return depth for parent's calculation\n        return 1 + max(leftDepth, rightDepth)\n    }\n    \n    depth(root)\n    return maxDiameter\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node exactly once",
          "spaceExplanation": "Recursion stack depth is tree height h, O(n) worst case for skewed tree"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,4,5]",
            "expectedOutput": "3",
            "explanation": "Longest path is 4-2-1-3 or 5-2-1-3, length 3 edges"
          },
          {
            "input": "root = [1,2]",
            "expectedOutput": "1",
            "explanation": "Only one edge: 2-1"
          }
        ]
      },
      {
        "name": "DFS Returning Tuple",
        "intuition": "Return both depth and max diameter from each subtree. No need for global variable.",
        "approach": "1. DFS returns (depth, maxDiameterInSubtree)\n2. At each node:\n   a. Get (leftDepth, leftMax) and (rightDepth, rightMax)\n   b. diameterThroughHere = leftDepth + rightDepth\n   c. Return (1 + max depths, max of leftMax, rightMax, diameterThroughHere)",
        "explanation": "This functional approach avoids mutable state by returning all needed information. The diameter at any point is the max of: diameter entirely in left subtree, diameter entirely in right subtree, or diameter passing through current node.",
        "code": "func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?) -> (depth: Int, diameter: Int) {\n        guard let node = node else { return (0, 0) }\n        \n        let left = dfs(node.left)\n        let right = dfs(node.right)\n        \n        let depth = 1 + max(left.depth, right.depth)\n        let diameter = max(left.depth + right.depth, max(left.diameter, right.diameter))\n        \n        return (depth, diameter)\n    }\n    \n    return dfs(root).diameter\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Single traversal of all nodes",
          "spaceExplanation": "Recursion stack bounded by tree height"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,4,5]",
            "expectedOutput": "3",
            "explanation": "Same result without global state"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-maximum-path-sum",
      "longest-univalue-path"
    ]
  },
  "balanced-binary-tree": {
    "summary": "Check if a binary tree is height-balanced (for every node, left and right subtree heights differ by at most 1). DFS returning height, return -1 if unbalanced.",
    "approaches": [
      {
        "name": "DFS with Height Check",
        "intuition": "Compute height of each subtree. If difference > 1 at any node, tree is unbalanced. Use -1 as sentinel for unbalanced subtree.",
        "approach": "1. DFS returns height if balanced, -1 if not\n2. At each node:\n   a. Get left height (return -1 if left returns -1)\n   b. Get right height (return -1 if right returns -1)\n   c. If |left - right| > 1, return -1\n   d. Return 1 + max(left, right)\n3. Return dfs(root) != -1",
        "explanation": "We compute height bottom-up. If any subtree is unbalanced, we propagate -1 upward and stop checking. If subtrees are balanced but their heights differ by more than 1, we also return -1. Only if we reach the root without returning -1 is the tree balanced.",
        "code": "func isBalanced(_ root: TreeNode?) -> Bool {\n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        \n        let leftHeight = height(node.left)\n        if leftHeight == -1 { return -1 }\n        \n        let rightHeight = height(node.right)\n        if rightHeight == -1 { return -1 }\n        \n        if abs(leftHeight - rightHeight) > 1 {\n            return -1\n        }\n        \n        return 1 + max(leftHeight, rightHeight)\n    }\n    \n    return height(root) != -1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node at most once, early exit on imbalance",
          "spaceExplanation": "Recursion stack depth equals tree height"
        },
        "testCases": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "expectedOutput": "true",
            "explanation": "All nodes have subtrees differing by at most 1 in height"
          },
          {
            "input": "root = [1,2,2,3,3,null,null,4,4]",
            "expectedOutput": "false",
            "explanation": "Left subtree has height 3, right has height 1. Difference > 1."
          },
          {
            "input": "root = []",
            "expectedOutput": "true",
            "explanation": "Empty tree is balanced"
          }
        ]
      },
      {
        "name": "Top-Down (Less Efficient)",
        "intuition": "Check balance at each node by computing full height of both subtrees. Simple but recomputes heights.",
        "approach": "1. isBalanced checks: left balanced, right balanced, height difference <= 1\n2. height function computes full height recursively\n3. Results in redundant height calculations",
        "explanation": "This naive approach checks balance at root, then recursively checks children. But computing heights is O(n), and we do it for each node, giving O(n²) time. Shown for comparison with the optimal O(n) solution.",
        "code": "func isBalanced(_ root: TreeNode?) -> Bool {\n    guard let root = root else { return true }\n    \n    let leftHeight = height(root.left)\n    let rightHeight = height(root.right)\n    \n    return abs(leftHeight - rightHeight) <= 1 &&\n           isBalanced(root.left) &&\n           isBalanced(root.right)\n}\n\nfunc height(_ node: TreeNode?) -> Int {\n    guard let node = node else { return 0 }\n    return 1 + max(height(node.left), height(node.right))\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(h)",
          "timeExplanation": "Height computed at each node, O(n) per call, n calls",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "expectedOutput": "true",
            "explanation": "Correct but slower than optimal"
          }
        ]
      }
    ],
    "relatedProblems": [
      "maximum-depth-of-binary-tree",
      "diameter-of-binary-tree"
    ]
  },
  "path-sum": {
    "summary": "Check if tree has root-to-leaf path with given sum. DFS subtracting node values from target; at leaf, check if remaining target equals leaf value.",
    "approaches": [
      {
        "name": "DFS Recursive",
        "intuition": "Subtract each node's value from target as we go down. At a leaf, check if remaining target equals 0 (or equivalently, if remaining equals leaf value).",
        "approach": "1. If root is null, return false\n2. Subtract root.val from targetSum\n3. If root is leaf (no children), return targetSum == 0\n4. Recursively check left OR right subtree",
        "explanation": "We accumulate the path sum by subtracting from target as we descend. At a leaf, if we've subtracted exactly targetSum total, we've found a valid path. Using subtraction avoids passing accumulated sum as parameter and handles negative values correctly.",
        "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    let remaining = targetSum - root.val\n    \n    // Check if leaf\n    if root.left == nil && root.right == nil {\n        return remaining == 0\n    }\n    \n    // Check children\n    return hasPathSum(root.left, remaining) || hasPathSum(root.right, remaining)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node at most once",
          "spaceExplanation": "Recursion depth equals tree height"
        },
        "testCases": [
          {
            "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
            "expectedOutput": "true",
            "explanation": "Path 5→4→11→2 sums to 22"
          },
          {
            "input": "root = [1,2,3], targetSum = 5",
            "expectedOutput": "false",
            "explanation": "Paths are 1→2=3 and 1→3=4. Neither equals 5."
          },
          {
            "input": "root = [], targetSum = 0",
            "expectedOutput": "false",
            "explanation": "Empty tree has no paths"
          }
        ]
      },
      {
        "name": "Iterative with Stack",
        "intuition": "Use stack to simulate DFS. Store (node, remaining sum) pairs. At each leaf, check if sum matches.",
        "approach": "1. Stack of (node, remainingSum) pairs\n2. Push root with targetSum\n3. While stack not empty:\n   a. Pop node and remaining\n   b. If leaf and remaining == node.val, return true\n   c. Push children with remaining - node.val\n4. Return false",
        "explanation": "This iterative version mimics the recursive approach using an explicit stack. We track the remaining sum needed at each node. When we reach a leaf, we check if the node's value exactly matches the remaining sum (meaning the path sums to target).",
        "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    var stack: [(TreeNode, Int)] = [(root, targetSum)]\n    \n    while !stack.isEmpty {\n        let (node, remaining) = stack.removeLast()\n        \n        // Check if leaf with matching sum\n        if node.left == nil && node.right == nil && remaining == node.val {\n            return true\n        }\n        \n        // Push children\n        if let left = node.left {\n            stack.append((left, remaining - node.val))\n        }\n        if let right = node.right {\n            stack.append((right, remaining - node.val))\n        }\n    }\n    \n    return false\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Stack holds at most one path worth of nodes"
        },
        "testCases": [
          {
            "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
            "expectedOutput": "true",
            "explanation": "Same result via iteration"
          }
        ]
      }
    ],
    "relatedProblems": [
      "path-sum-ii",
      "path-sum-iii",
      "binary-tree-maximum-path-sum"
    ]
  },
  "binary-tree-right-side-view": {
    "summary": "Return values visible from right side of tree (rightmost node at each level). BFS level-order taking last node per level, or DFS visiting right child first.",
    "approaches": [
      {
        "name": "BFS Level Order",
        "intuition": "Process tree level by level. The rightmost node at each level is visible from the right side.",
        "approach": "1. BFS with queue\n2. For each level, record the last node's value\n3. Process all nodes at current level before moving to next",
        "explanation": "Standard level-order traversal. At each level, we process all nodes in the queue (which represents one complete level). The last node we process at each level is the rightmost one, which we add to our result.",
        "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    guard let root = root else { return [] }\n    \n    var result: [Int] = []\n    var queue: [TreeNode] = [root]\n    \n    while !queue.isEmpty {\n        let levelSize = queue.count\n        for i in 0..<levelSize {\n            let node = queue.removeFirst()\n            if i == levelSize - 1 {\n                result.append(node.val)\n            }\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(w)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Queue holds at most one level, max width w"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,null,5,null,4]",
            "expectedOutput": "[1,3,4]",
            "explanation": "Level 0: 1, Level 1: 3 (rightmost), Level 2: 4 (rightmost)"
          },
          {
            "input": "root = [1,null,3]",
            "expectedOutput": "[1,3]",
            "explanation": "Right-skewed tree"
          }
        ]
      },
      {
        "name": "DFS Right-First",
        "intuition": "DFS visiting right child before left. First node we see at each depth is the rightmost.",
        "approach": "1. Track current depth and result size\n2. If depth == result.size, this is first (rightmost) node at this depth\n3. Visit right child first, then left",
        "explanation": "By visiting right subtree first, the first node we encounter at each new depth is guaranteed to be the rightmost at that level. We add it to result only when we reach a new depth (result.count == depth).",
        "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    var result: [Int] = []\n    \n    func dfs(_ node: TreeNode?, _ depth: Int) {\n        guard let node = node else { return }\n        \n        if depth == result.count {\n            result.append(node.val)\n        }\n        \n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n    }\n    \n    dfs(root, 0)\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth is tree height"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,null,5,null,4]",
            "expectedOutput": "[1,3,4]",
            "explanation": "DFS right-first finds same nodes"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "populating-next-right-pointers-in-each-node"
    ]
  },
  "koko-eating-bananas": {
    "summary": "Find minimum eating speed k to finish all banana piles within h hours. Binary search on k: for each k, calculate total hours needed. Find smallest k where hours <= h.",
    "approaches": [
      {
        "name": "Binary Search on Speed",
        "intuition": "The answer k is in range [1, max(piles)]. Higher k means fewer hours. Binary search to find minimum k where we can finish in time.",
        "approach": "1. left = 1, right = max(piles)\n2. Binary search:\n   a. Calculate hours needed at mid speed\n   b. If hours <= h, try smaller k (right = mid)\n   c. If hours > h, need faster k (left = mid + 1)\n3. Return left",
        "explanation": "At speed k, pile of size p takes ceil(p/k) hours. Sum all pile times. If total <= h, k works but maybe a smaller k also works. If total > h, k is too slow. We binary search to find the minimum working k. Using left = mid when feasible ensures we find the minimum.",
        "code": "func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {\n    var left = 1\n    var right = piles.max()!\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        let hours = hoursNeeded(piles, mid)\n        \n        if hours <= h {\n            right = mid  // mid works, try smaller\n        } else {\n            left = mid + 1  // mid too slow\n        }\n    }\n    \n    return left\n}\n\nfunc hoursNeeded(_ piles: [Int], _ k: Int) -> Int {\n    var hours = 0\n    for pile in piles {\n        hours += (pile + k - 1) / k  // Ceiling division\n    }\n    return hours\n}",
        "complexity": {
          "time": "O(n log m)",
          "space": "O(1)",
          "timeExplanation": "Binary search O(log m) on max pile size, each iteration O(n) to sum hours",
          "spaceExplanation": "Only using variables"
        },
        "testCases": [
          {
            "input": "piles = [3,6,7,11], h = 8",
            "expectedOutput": "4",
            "explanation": "At k=4: 1+2+2+3=8 hours. At k=3: 1+2+3+4=10 hours (too slow)."
          },
          {
            "input": "piles = [30,11,23,4,20], h = 5",
            "expectedOutput": "30",
            "explanation": "With 5 piles and 5 hours, need to eat each pile in 1 hour. Max pile is 30."
          },
          {
            "input": "piles = [30,11,23,4,20], h = 6",
            "expectedOutput": "23",
            "explanation": "Can split largest pile across 2 hours. k=23 gives 2+1+1+1+1=6 hours."
          }
        ]
      },
      {
        "name": "Binary Search (Explicit Bounds)",
        "intuition": "Same algorithm but with clearer reasoning about bounds. Minimum possible k is 1 (though may not finish in time). Maximum useful k is max pile (anything higher is wasteful).",
        "approach": "1. min_k = 1, max_k = max(piles)\n2. Binary search to find leftmost k where canFinish(k, h)\n3. canFinish checks if sum of ceil(pile/k) <= h",
        "explanation": "This version explicitly defines the feasibility function canFinish. We're looking for the minimum k in the 'feasible' region. The transition from infeasible to feasible happens exactly once as k increases, making binary search applicable.",
        "code": "func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {\n    func canFinish(_ k: Int) -> Bool {\n        var totalHours = 0\n        for pile in piles {\n            totalHours += (pile + k - 1) / k\n            if totalHours > h { return false }  // Early exit\n        }\n        return true\n    }\n    \n    var left = 1\n    var right = piles.max()!\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        if canFinish(mid) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    \n    return left\n}",
        "complexity": {
          "time": "O(n log m)",
          "space": "O(1)",
          "timeExplanation": "Same complexity with potential early exit optimization",
          "spaceExplanation": "Constant extra space"
        },
        "testCases": [
          {
            "input": "piles = [3,6,7,11], h = 8",
            "expectedOutput": "4",
            "explanation": "canFinish(4)=true, canFinish(3)=false, so answer is 4"
          }
        ]
      }
    ],
    "relatedProblems": [
      "minimize-max-distance-to-gas-station",
      "capacity-to-ship-packages-within-d-days",
      "split-array-largest-sum"
    ]
  },
  "minimum-path-sum": {
    "summary": "Find the minimum sum path from top-left to bottom-right in a grid, moving only right or down. Classic 2D dynamic programming - each cell's minimum sum is its value plus min of top or left cell.",
    "approaches": [
      {
        "name": "2D Dynamic Programming",
        "intuition": "For each cell, the minimum path sum to reach it is the cell's value plus the minimum of the path sum from above or from the left. Build the solution bottom-up.",
        "approach": "1. Create a dp table same size as grid\n2. Initialize dp[0][0] = grid[0][0]\n3. Fill first row (can only come from left)\n4. Fill first column (can only come from above)\n5. For other cells: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n6. Return dp[m-1][n-1]",
        "explanation": "Since we can only move right or down, each cell can only be reached from the cell above or to the left. We compute the minimum cumulative sum for each cell. The first row and column are special cases since they have only one possible path. The answer is the value in the bottom-right cell of our dp table.",
        "code": "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n    \n    dp[0][0] = grid[0][0]\n    \n    // Fill first row\n    for j in 1..<n {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    \n    // Fill first column\n    for i in 1..<m {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    \n    // Fill rest\n    for i in 1..<m {\n        for j in 1..<n {\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    \n    return dp[m-1][n-1]\n}",
        "complexity": {
          "time": "O(m × n)",
          "space": "O(m × n)",
          "timeExplanation": "Visit each cell exactly once",
          "spaceExplanation": "DP table has same dimensions as input grid"
        },
        "testCases": [
          {
            "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
            "expectedOutput": "7",
            "explanation": "Path 1→3→1→1→1 = 7. Path goes right, right, down, down."
          },
          {
            "input": "grid = [[1,2,3],[4,5,6]]",
            "expectedOutput": "12",
            "explanation": "Path 1→2→3→6 = 12"
          }
        ]
      },
      {
        "name": "Space-Optimized DP (1D Array)",
        "intuition": "We only need the previous row to compute the current row. Use a 1D array and update it in-place, reducing space from O(m×n) to O(n).",
        "approach": "1. Use a 1D dp array of size n\n2. Initialize with first row's cumulative sums\n3. For each subsequent row, update dp left-to-right\n4. dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n5. Return dp[n-1]",
        "explanation": "When computing dp[i][j], we need dp[i-1][j] (above) and dp[i][j-1] (left). In our 1D array, dp[j] still holds the value from the previous row (above), and dp[j-1] was just updated for the current row (left). By processing left-to-right, we always have both values available.",
        "code": "func minPathSum(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var dp = [Int](repeating: 0, count: n)\n    \n    // Initialize with first row\n    dp[0] = grid[0][0]\n    for j in 1..<n {\n        dp[j] = dp[j-1] + grid[0][j]\n    }\n    \n    // Process remaining rows\n    for i in 1..<m {\n        dp[0] += grid[i][0]  // First column: only from above\n        for j in 1..<n {\n            dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n        }\n    }\n    \n    return dp[n-1]\n}",
        "complexity": {
          "time": "O(m × n)",
          "space": "O(n)",
          "timeExplanation": "Still visit each cell once",
          "spaceExplanation": "Only store one row at a time"
        },
        "testCases": [
          {
            "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
            "expectedOutput": "7",
            "explanation": "Same result with optimized space"
          },
          {
            "input": "grid = [[1]]",
            "expectedOutput": "1",
            "explanation": "Single cell grid"
          }
        ]
      }
    ],
    "relatedProblems": [
      "unique-paths",
      "unique-paths-ii",
      "dungeon-game",
      "cherry-pickup"
    ]
  },
  "target-sum": {
    "summary": "Find number of ways to assign + or - to elements to reach target sum. Use DP: convert to subset sum problem where we find subsets summing to (total + target) / 2.",
    "approaches": [
      {
        "name": "2D DP (Subset Sum)",
        "intuition": "If we assign + to some numbers and - to others: P - N = target, P + N = total. So P = (total + target) / 2. Count subsets summing to P.",
        "approach": "1. Calculate sum = (total + target) / 2\n2. If (total + target) is odd or target > total, return 0\n3. dp[i][j] = ways to get sum j using first i elements\n4. dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]] (exclude or include)\n5. Return dp[n][sum]",
        "explanation": "We transform the problem: instead of +/- signs, find a subset P where sum(P) = (total + target)/2. The remaining elements form N = total - P. Then P - N = 2P - total = target. This is a classic 0/1 knapsack counting problem.",
        "code": "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    let total = nums.reduce(0, +)\n    if (total + target) % 2 != 0 || abs(target) > total {\n        return 0\n    }\n    \n    let sum = (total + target) / 2\n    var dp = [Int](repeating: 0, count: sum + 1)\n    dp[0] = 1\n    \n    for num in nums {\n        for j in stride(from: sum, through: num, by: -1) {\n            dp[j] += dp[j - num]\n        }\n    }\n    \n    return dp[sum]\n}",
        "complexity": {
          "time": "O(n × sum)",
          "space": "O(sum)",
          "timeExplanation": "Process each number against all possible sums",
          "spaceExplanation": "1D DP array of size sum+1"
        },
        "testCases": [
          {
            "input": "nums = [1,1,1,1,1], target = 3",
            "expectedOutput": "5",
            "explanation": "5 ways: -1+1+1+1+1, +1-1+1+1+1, etc."
          },
          {
            "input": "nums = [1], target = 1",
            "expectedOutput": "1",
            "explanation": "Only +1 = 1"
          }
        ]
      },
      {
        "name": "Memoized DFS",
        "intuition": "Try both + and - for each number. Memoize (index, currentSum) to avoid recomputation.",
        "approach": "1. DFS with parameters (index, currentSum)\n2. Base case: if index == n, return 1 if sum == target, else 0\n3. Try adding and subtracting nums[index]\n4. Memoize results",
        "explanation": "Direct simulation of the problem. At each step, we can add or subtract the current number. Memoization prevents exponential blowup by caching results for (index, sum) pairs we've seen.",
        "code": "func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n    var memo: [String: Int] = [:]\n    \n    func dfs(_ i: Int, _ sum: Int) -> Int {\n        if i == nums.count {\n            return sum == target ? 1 : 0\n        }\n        \n        let key = \"\\(i),\\(sum)\"\n        if let cached = memo[key] { return cached }\n        \n        let result = dfs(i + 1, sum + nums[i]) + dfs(i + 1, sum - nums[i])\n        memo[key] = result\n        return result\n    }\n    \n    return dfs(0, 0)\n}",
        "complexity": {
          "time": "O(n × totalSum)",
          "space": "O(n × totalSum)",
          "timeExplanation": "Each (index, sum) pair computed once",
          "spaceExplanation": "Memoization table for all states"
        },
        "testCases": [
          {
            "input": "nums = [1,1,1,1,1], target = 3",
            "expectedOutput": "5",
            "explanation": "Same result via memoized recursion"
          }
        ]
      }
    ],
    "relatedProblems": [
      "partition-equal-subset-sum",
      "last-stone-weight-ii"
    ]
  },
  "partition-equal-subset-sum": {
    "summary": "Determine if array can be partitioned into two subsets with equal sum. This is subset sum problem: can we find subset summing to total/2?",
    "approaches": [
      {
        "name": "DP (Subset Sum)",
        "intuition": "If total sum is odd, impossible. Otherwise, find if any subset sums to total/2. Classic 0/1 knapsack.",
        "approach": "1. If sum is odd, return false\n2. target = sum / 2\n3. dp[j] = true if we can make sum j\n4. For each num, update dp from right to left\n5. Return dp[target]",
        "explanation": "We need to find if a subset sums to exactly half the total. dp[j] represents whether sum j is achievable. For each number, we update achievable sums by including it. Process right-to-left to avoid using same number twice.",
        "code": "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total / 2\n    var dp = [Bool](repeating: false, count: target + 1)\n    dp[0] = true\n    \n    for num in nums {\n        for j in stride(from: target, through: num, by: -1) {\n            dp[j] = dp[j] || dp[j - num]\n        }\n    }\n    \n    return dp[target]\n}",
        "complexity": {
          "time": "O(n × sum)",
          "space": "O(sum)",
          "timeExplanation": "Process each number against possible sums",
          "spaceExplanation": "Boolean array of size sum/2"
        },
        "testCases": [
          {
            "input": "nums = [1,5,11,5]",
            "expectedOutput": "true",
            "explanation": "Partition: [1,5,5] and [11], both sum to 11"
          },
          {
            "input": "nums = [1,2,3,5]",
            "expectedOutput": "false",
            "explanation": "Total is 11 (odd), can't split equally"
          }
        ]
      },
      {
        "name": "Bitset Optimization",
        "intuition": "Use bitset where bit j is set if sum j is achievable. Shift and OR to update all sums at once.",
        "approach": "1. Use integer/bitset where bit j means sum j achievable\n2. For each num, bits |= bits << num\n3. Check if target bit is set",
        "explanation": "This is a clever optimization. If bits represents achievable sums, then bits << num shifts all achievable sums up by num. ORing with original gives all sums achievable with or without including num. Very fast in practice.",
        "code": "func canPartition(_ nums: [Int]) -> Bool {\n    let total = nums.reduce(0, +)\n    if total % 2 != 0 { return false }\n    \n    let target = total / 2\n    var bits = Set<Int>([0])\n    \n    for num in nums {\n        var newBits = Set<Int>()\n        for b in bits {\n            let newSum = b + num\n            if newSum <= target {\n                newBits.insert(newSum)\n            }\n        }\n        bits.formUnion(newBits)\n        if bits.contains(target) { return true }\n    }\n    \n    return bits.contains(target)\n}",
        "complexity": {
          "time": "O(n × sum)",
          "space": "O(sum)",
          "timeExplanation": "Similar to DP but with set operations",
          "spaceExplanation": "Set of achievable sums"
        },
        "testCases": [
          {
            "input": "nums = [1,5,11,5]",
            "expectedOutput": "true",
            "explanation": "Early exit when target found"
          }
        ]
      }
    ],
    "relatedProblems": [
      "target-sum",
      "last-stone-weight-ii",
      "partition-to-k-equal-sum-subsets"
    ]
  },
  "longest-common-prefix": {
    "summary": "Find the longest common prefix among an array of strings. Compare characters at each position across all strings until a mismatch is found or a string ends.",
    "approaches": [
      {
        "name": "Vertical Scanning",
        "intuition": "Compare characters column by column (same position across all strings). Stop when we find a mismatch or reach the end of any string.",
        "approach": "1. Handle empty array edge case\n2. Use first string as reference\n3. For each character position i in first string:\n   a. Check if position i exists in all strings\n   b. Check if all strings have same character at position i\n   c. If mismatch or end, return prefix so far\n4. Return first string if loop completes",
        "explanation": "We iterate through character positions (columns) rather than strings (rows). At each position, we verify all strings have the same character. This is efficient when the common prefix is short, as we stop early on mismatch.",
        "code": "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    let first = Array(strs[0])\n    \n    for i in 0..<first.count {\n        let char = first[i]\n        for str in strs {\n            let arr = Array(str)\n            if i >= arr.count || arr[i] != char {\n                return String(first[0..<i])\n            }\n        }\n    }\n    \n    return strs[0]\n}",
        "complexity": {
          "time": "O(S)",
          "space": "O(m)",
          "timeExplanation": "S is the sum of all characters in all strings. Worst case compares all characters.",
          "spaceExplanation": "Converting first string to array takes O(m) where m is its length"
        },
        "testCases": [
          {
            "input": "strs = [\"flower\",\"flow\",\"flight\"]",
            "expectedOutput": "\"fl\"",
            "explanation": "All start with 'f', then 'l', then differ at position 2 (o vs i)"
          },
          {
            "input": "strs = [\"dog\",\"racecar\",\"car\"]",
            "expectedOutput": "\"\"",
            "explanation": "No common prefix - first characters differ (d vs r vs c)"
          }
        ]
      },
      {
        "name": "Horizontal Scanning",
        "intuition": "Start with the first string as the prefix. Iteratively shrink it by comparing with each subsequent string until it matches as a prefix of all strings.",
        "approach": "1. Start with prefix = first string\n2. For each subsequent string:\n   a. While string doesn't start with prefix\n   b. Remove last character from prefix\n   c. If prefix becomes empty, return \"\"\n3. Return prefix",
        "explanation": "We assume the entire first string is the common prefix, then trim it down as needed when comparing with each string. If a string doesn't start with our current prefix, we shorten the prefix until it does.",
        "code": "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    var prefix = strs[0]\n    \n    for i in 1..<strs.count {\n        while !strs[i].hasPrefix(prefix) {\n            prefix = String(prefix.dropLast())\n            if prefix.isEmpty { return \"\" }\n        }\n    }\n    \n    return prefix\n}",
        "complexity": {
          "time": "O(S)",
          "space": "O(1)",
          "timeExplanation": "S is sum of all characters. Worst case: all strings identical, we compare all.",
          "spaceExplanation": "Only using the prefix variable, no extra data structures"
        },
        "testCases": [
          {
            "input": "strs = [\"flower\",\"flow\",\"flight\"]",
            "expectedOutput": "\"fl\"",
            "explanation": "Start with 'flower'. 'flow' doesn't have prefix 'flower', shrink to 'flowe', 'flow', then matches. 'flight' doesn't have prefix 'flow', shrink to 'flo', 'fl', matches."
          },
          {
            "input": "strs = [\"a\"]",
            "expectedOutput": "\"a\"",
            "explanation": "Single string - the entire string is the common prefix"
          },
          {
            "input": "strs = [\"\"]",
            "expectedOutput": "\"\"",
            "explanation": "Empty string means no common prefix possible"
          }
        ]
      }
    ],
    "relatedProblems": [
      "longest-common-suffix"
    ]
  },
  "roman-to-integer": {
    "summary": "Convert a Roman numeral string to an integer. The key insight is that when a smaller value appears before a larger value, we subtract it; otherwise, we add it.",
    "approaches": [
      {
        "name": "Right to Left Scan",
        "intuition": "Process from right to left, adding values. If current value is less than the previous value we added, subtract instead (handles IV, IX, etc.).",
        "approach": "1. Create a map of Roman symbols to values\n2. Start from the rightmost character\n3. Track the previous value seen\n4. If current < previous, subtract; else add\n5. Update previous and continue left",
        "explanation": "Roman numerals are mostly additive (VI = 5+1 = 6), but use subtraction for cases like IV (4) and IX (9). By scanning right to left, whenever we see a smaller value before a larger one, we know to subtract. This elegantly handles all subtraction cases.",
        "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    var result = 0\n    var prev = 0\n    \n    for char in s.reversed() {\n        let curr = values[char, default: 0]\n        if curr < prev {\n            result -= curr\n        } else {\n            result += curr\n        }\n        prev = curr\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through the string of length n",
          "spaceExplanation": "Fixed-size map and a few variables"
        },
        "testCases": [
          {
            "input": "s = \"III\"",
            "expectedOutput": "3",
            "explanation": "III = 1 + 1 + 1 = 3"
          },
          {
            "input": "s = \"LVIII\"",
            "expectedOutput": "58",
            "explanation": "L = 50, V = 5, III = 3. Total = 58"
          },
          {
            "input": "s = \"MCMXCIV\"",
            "expectedOutput": "1994",
            "explanation": "M=1000, CM=900, XC=90, IV=4. Total = 1994"
          }
        ]
      },
      {
        "name": "Left to Right with Lookahead",
        "intuition": "Process left to right. Look ahead to the next character - if current is less than next, subtract current; otherwise add it.",
        "approach": "1. Create value map\n2. Iterate through string with index\n3. If current value < next value, subtract current\n4. Otherwise add current\n5. Return total",
        "explanation": "This approach is more intuitive as it processes the string in reading order. We peek at the next character to decide whether to add or subtract. When we see 'I' followed by 'V', we know it's 4 (subtract 1), not 6 (add 1).",
        "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    let chars = Array(s)\n    var result = 0\n    \n    for i in 0..<chars.count {\n        let curr = values[chars[i], default: 0]\n        let next = i + 1 < chars.count ? values[chars[i + 1], default: 0] : 0\n        \n        if curr < next {\n            result -= curr\n        } else {\n            result += curr\n        }\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass through the string",
          "spaceExplanation": "Converting string to array takes O(n) space"
        },
        "testCases": [
          {
            "input": "s = \"IV\"",
            "expectedOutput": "4",
            "explanation": "I(1) < V(5), so subtract 1, then add 5. Result: -1 + 5 = 4"
          },
          {
            "input": "s = \"IX\"",
            "expectedOutput": "9",
            "explanation": "I(1) < X(10), so -1 + 10 = 9"
          },
          {
            "input": "s = \"XLII\"",
            "expectedOutput": "42",
            "explanation": "X < L, so -10. L > I, so +50. I < I? No, +1. I, +1. Total: -10+50+1+1 = 42"
          }
        ]
      }
    ],
    "relatedProblems": [
      "integer-to-roman"
    ]
  },
  "longest-repeating-character-replacement": {
    "summary": "Find the length of the longest substring where you can replace at most k characters to make all characters the same. Use sliding window: expand right, track most frequent character, shrink left when replacements needed exceed k.",
    "approaches": [
      {
        "name": "Sliding Window with Frequency Count",
        "intuition": "Maintain a window where (window size - count of most frequent char) <= k. This means we can replace the non-majority characters to make them all the same. Expand right, shrink left when invalid.",
        "approach": "1. Use a frequency map for characters in current window\n2. Track the max frequency of any character in current window\n3. Expand window by moving right pointer\n4. If (window size - maxFreq) > k, shrink from left\n5. Update result with current window size\n6. Return maximum window size found",
        "explanation": "The key insight is that for any window, the minimum replacements needed equals (window length - frequency of most common character). If this exceeds k, the window is invalid. We don't need to decrease maxFreq when shrinking because we only care about finding a larger valid window - if maxFreq was achieved before, we need at least that many of one character to beat our current best.",
        "code": "func characterReplacement(_ s: String, _ k: Int) -> Int {\n    let chars = Array(s)\n    var freq: [Character: Int] = [:]\n    var maxFreq = 0\n    var left = 0\n    var result = 0\n    \n    for right in 0..<chars.count {\n        // Add right character to window\n        freq[chars[right], default: 0] += 1\n        maxFreq = max(maxFreq, freq[chars[right]]!)\n        \n        // Window size - maxFreq = chars we need to replace\n        // If > k, shrink window from left\n        while (right - left + 1) - maxFreq > k {\n            freq[chars[left]]! -= 1\n            left += 1\n        }\n        \n        result = max(result, right - left + 1)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Each character is added and removed from window at most once",
          "spaceExplanation": "Frequency map has at most 26 entries (uppercase letters)"
        },
        "testCases": [
          {
            "input": "s = \"ABAB\", k = 2",
            "expectedOutput": "4",
            "explanation": "Replace both A's with B's (or vice versa) to get \"BBBB\" or \"AAAA\". Length = 4."
          },
          {
            "input": "s = \"AABABBA\", k = 1",
            "expectedOutput": "4",
            "explanation": "Replace the B at index 3 to get \"AAAAABA\". Longest same-char substring is \"AAAA\" with length 4."
          }
        ]
      },
      {
        "name": "Sliding Window (Optimized - No Shrink Loop)",
        "intuition": "We can skip the while loop by only ever growing or shifting the window, never shrinking it. Since we want the maximum window, once we find a valid window of size w, we only care about windows of size > w.",
        "approach": "1. Same frequency tracking and maxFreq\n2. When window becomes invalid, shift both left and right (window size stays same)\n3. Only update result when window is valid\n4. Return final window size",
        "explanation": "This optimization works because we're looking for the maximum window. Once we achieve a window of size w, there's no point checking smaller windows. When invalid, we slide the entire window right (maintaining size) rather than shrinking. The window only grows when we find a better maxFreq.",
        "code": "func characterReplacement(_ s: String, _ k: Int) -> Int {\n    let chars = Array(s)\n    var freq: [Character: Int] = [:]\n    var maxFreq = 0\n    var left = 0\n    \n    for right in 0..<chars.count {\n        freq[chars[right], default: 0] += 1\n        maxFreq = max(maxFreq, freq[chars[right]]!)\n        \n        // If invalid, slide window (don't shrink, just shift)\n        if (right - left + 1) - maxFreq > k {\n            freq[chars[left]]! -= 1\n            left += 1\n        }\n    }\n    \n    // Final window size is our answer\n    return chars.count - left\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass, no inner loop - each pointer moves at most n times",
          "spaceExplanation": "Frequency map bounded by alphabet size (26)"
        },
        "testCases": [
          {
            "input": "s = \"ABAB\", k = 2",
            "expectedOutput": "4",
            "explanation": "Window grows to size 4 and stays valid throughout."
          },
          {
            "input": "s = \"AAAA\", k = 0",
            "expectedOutput": "4",
            "explanation": "All same characters, no replacement needed. Window = entire string."
          },
          {
            "input": "s = \"ABCD\", k = 0",
            "expectedOutput": "1",
            "explanation": "With k=0, can't replace anything. Best is single character."
          }
        ]
      }
    ],
    "relatedProblems": [
      "longest-substring-without-repeating-characters",
      "longest-substring-with-at-most-k-distinct-characters",
      "max-consecutive-ones-iii"
    ]
  },
  "design-twitter": {
    "summary": "Design Twitter with follow, unfollow, post, newsfeed. Use heap for k-way merge of feeds.",
    "approaches": [
      {
        "name": "OOP Design",
        "intuition": "User has followers and tweets. Merge recent tweets from followed users.",
        "approach": "1. Map user to tweets and followees\n2. Post: add tweet with timestamp\n3. News feed: merge top 10 from self + followees using heap",
        "explanation": "Min-heap of size 10 for efficient top-k selection.",
        "code": "class Twitter {\n    var tweets: [Int: [(Int, Int)]] = [:]  // userId: [(time, tweetId)]\n    var follows: [Int: Set<Int>] = []\n    var time = 0\n    \n    func postTweet(_ userId: Int, _ tweetId: Int) {\n        tweets[userId, default: []].append((time, tweetId))\n        time += 1\n    }\n    \n    func getNewsFeed(_ userId: Int) -> [Int] {\n        var heap: [(Int, Int)] = []\n        let users = follows[userId, default: []] + [userId]\n        for u in Set(users) {\n            for tweet in tweets[u] ?? [] {\n                heap.append(tweet)\n            }\n        }\n        heap.sort { $0.0 > $1.0 }\n        return Array(heap.prefix(10).map { $0.1 })\n    }\n    \n    func follow(_ followerId: Int, _ followeeId: Int) {\n        follows[followerId, default: []].insert(followeeId)\n    }\n    \n    func unfollow(_ followerId: Int, _ followeeId: Int) {\n        follows[followerId]?.remove(followeeId)\n    }\n}",
        "complexity": {
          "time": "O(n log n) for feed",
          "space": "O(U + T)",
          "timeExplanation": "Sorting for feed",
          "spaceExplanation": "Users and tweets"
        },
        "testCases": [
          {
            "input": "post(1,5), getNewsFeed(1), follow(1,2), post(2,6), getNewsFeed(1)",
            "expectedOutput": "[5], [6,5]",
            "explanation": "Feed updates with follows"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "contains-duplicate": {
    "summary": "Check if array contains any duplicates. Use a HashSet - if insertion fails, we've seen this element before.",
    "approaches": [
      {
        "name": "HashSet",
        "intuition": "A set only stores unique elements. If we try to insert a duplicate, it won't be added.",
        "approach": "1. Create empty set\n2. For each number, check if it's in set\n3. If yes, return true (duplicate found)\n4. If no, add to set\n5. Return false if loop completes",
        "explanation": "We iterate once, checking membership and inserting in O(1) average time. The moment we find a number already in the set, we've found a duplicate.",
        "code": "func containsDuplicate(_ nums: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) {\n            return true\n        }\n        seen.insert(num)\n    }\n    return false\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Set can hold up to n elements"
        },
        "testCases": [
          {
            "input": "nums = [1,2,3,1]",
            "expectedOutput": "true",
            "explanation": "1 appears twice"
          },
          {
            "input": "nums = [1,2,3,4]",
            "expectedOutput": "false",
            "explanation": "All distinct"
          }
        ]
      }
    ],
    "relatedProblems": [
      "contains-duplicate-ii",
      "contains-duplicate-iii"
    ]
  },
  "product-of-array-except-self": {
    "summary": "Return array where each element is product of all other elements. Use prefix and suffix products without division.",
    "approaches": [
      {
        "name": "Prefix and Suffix Products",
        "intuition": "For position i, the answer is (product of all elements before i) × (product of all elements after i).",
        "approach": "1. Build prefix products left to right\n2. Build suffix products right to left\n3. Multiply prefix[i] × suffix[i] for each position",
        "explanation": "We compute running products from both directions. For each index, we don't need to include the element at that index - prefix gives us everything before, suffix gives us everything after.",
        "code": "func productExceptSelf(_ nums: [Int]) -> [Int] {\n    let n = nums.count\n    var result = [Int](repeating: 1, count: n)\n    \n    // Prefix products\n    var prefix = 1\n    for i in 0..<n {\n        result[i] = prefix\n        prefix *= nums[i]\n    }\n    \n    // Suffix products\n    var suffix = 1\n    for i in stride(from: n-1, through: 0, by: -1) {\n        result[i] *= suffix\n        suffix *= nums[i]\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two passes through array",
          "spaceExplanation": "Output array doesn't count, only using two variables"
        },
        "testCases": [
          {
            "input": "nums = [1,2,3,4]",
            "expectedOutput": "[24,12,8,6]",
            "explanation": "24=2×3×4, 12=1×3×4, etc."
          },
          {
            "input": "nums = [-1,1,0,-3,3]",
            "expectedOutput": "[0,0,9,0,0]",
            "explanation": "Zero makes most products 0"
          }
        ]
      }
    ],
    "relatedProblems": [
      "trapping-rain-water",
      "maximum-product-subarray"
    ]
  },
  "maximum-subarray": {
    "summary": "Find contiguous subarray with largest sum. Kadane's algorithm: track current sum, reset when negative.",
    "approaches": [
      {
        "name": "Kadane's Algorithm",
        "intuition": "At each position, decide: start new subarray here, or extend the previous one? Extend only if previous sum is positive.",
        "approach": "1. Initialize maxSum and currentSum to first element\n2. For each element from index 1:\n   a. currentSum = max(num, currentSum + num)\n   b. maxSum = max(maxSum, currentSum)\n3. Return maxSum",
        "explanation": "If currentSum becomes negative, starting fresh is better. We track the best sum seen so far separately from the current running sum.",
        "code": "func maxSubArray(_ nums: [Int]) -> Int {\n    var maxSum = nums[0]\n    var currentSum = nums[0]\n    \n    for i in 1..<nums.count {\n        currentSum = max(nums[i], currentSum + nums[i])\n        maxSum = max(maxSum, currentSum)\n    }\n    \n    return maxSum\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Only two variables"
        },
        "testCases": [
          {
            "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
            "expectedOutput": "6",
            "explanation": "Subarray [4,-1,2,1] has sum 6"
          },
          {
            "input": "nums = [5,4,-1,7,8]",
            "expectedOutput": "23",
            "explanation": "Entire array sums to 23"
          }
        ]
      }
    ],
    "relatedProblems": [
      "maximum-product-subarray",
      "maximum-sum-circular-subarray"
    ]
  },
  "maximum-product-subarray": {
    "summary": "Find contiguous subarray with largest product. Track both max and min at each position (negatives can flip).",
    "approaches": [
      {
        "name": "Track Min and Max",
        "intuition": "A negative number can turn the smallest product into the largest. Track both extremes at each position.",
        "approach": "1. Track currentMax, currentMin, and result\n2. For each number:\n   a. If negative, swap max and min\n   b. currentMax = max(num, currentMax * num)\n   c. currentMin = min(num, currentMin * num)\n   d. Update result\n3. Return result",
        "explanation": "Unlike sum, products with negatives require tracking minimums. A very negative product times a negative number becomes very positive. We handle this by tracking both extremes.",
        "code": "func maxProduct(_ nums: [Int]) -> Int {\n    var result = nums[0]\n    var currentMax = nums[0]\n    var currentMin = nums[0]\n    \n    for i in 1..<nums.count {\n        let num = nums[i]\n        if num < 0 {\n            swap(&currentMax, &currentMin)\n        }\n        \n        currentMax = max(num, currentMax * num)\n        currentMin = min(num, currentMin * num)\n        result = max(result, currentMax)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through array",
          "spaceExplanation": "Only tracking three variables"
        },
        "testCases": [
          {
            "input": "nums = [2,3,-2,4]",
            "expectedOutput": "6",
            "explanation": "[2,3] gives product 6"
          },
          {
            "input": "nums = [-2,0,-1]",
            "expectedOutput": "0",
            "explanation": "Zero breaks the chain"
          }
        ]
      }
    ],
    "relatedProblems": [
      "maximum-subarray",
      "maximum-sum-circular-subarray"
    ]
  },
  "find-minimum-in-rotated-sorted-array-ii": {
    "summary": "Find minimum in rotated sorted array with duplicates. Binary search with special handling when nums[mid] == nums[right].",
    "approaches": [
      {
        "name": "Modified Binary Search",
        "intuition": "When mid equals right, we can't determine which half has minimum, so shrink right by 1.",
        "approach": "1. Binary search with left and right pointers\n2. If nums[mid] > nums[right]: minimum in right half\n3. If nums[mid] < nums[right]: minimum in left half (including mid)\n4. If nums[mid] == nums[right]: shrink right by 1\n5. Return nums[left]",
        "explanation": "Duplicates create ambiguity. When nums[mid] == nums[right], we safely shrink by 1 since even if right is the minimum, mid has the same value.",
        "code": "func findMin(_ nums: [Int]) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    \n    while left < right {\n        let mid = left + (right - left) / 2\n        \n        if nums[mid] > nums[right] {\n            left = mid + 1\n        } else if nums[mid] < nums[right] {\n            right = mid\n        } else {\n            right -= 1\n        }\n    }\n    \n    return nums[left]\n}",
        "complexity": {
          "time": "O(n) worst, O(log n) average",
          "space": "O(1)",
          "timeExplanation": "Worst case all duplicates requires linear scan",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "nums = [2,2,2,0,1]",
            "expectedOutput": "0",
            "explanation": "Minimum is 0"
          },
          {
            "input": "nums = [1,3,3]",
            "expectedOutput": "1",
            "explanation": "Minimum at start"
          }
        ]
      }
    ],
    "relatedProblems": [
      "find-minimum-in-rotated-sorted-array",
      "search-in-rotated-sorted-array-ii"
    ]
  },
  "3sum": {
    "summary": "Find all unique triplets that sum to zero. Sort array, fix one element, use two pointers for remaining two.",
    "approaches": [
      {
        "name": "Sort + Two Pointers",
        "intuition": "Sorting enables efficient two-pointer search. For each number, find two others that sum to its negative.",
        "approach": "1. Sort the array\n2. For each number nums[i] (skip duplicates):\n   a. Use two pointers j=i+1 and k=n-1\n   b. If sum < 0, move j right\n   c. If sum > 0, move k left\n   d. If sum == 0, record triplet, skip duplicates\n3. Return all triplets",
        "explanation": "After sorting, we iterate through each element as the first of the triplet. The two-pointer technique efficiently finds pairs that sum to the target. We skip duplicates to avoid repeated triplets.",
        "code": "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let sorted = nums.sorted()\n    var result: [[Int]] = []\n    let n = sorted.count\n    \n    for i in 0..<n-2 {\n        if i > 0 && sorted[i] == sorted[i-1] { continue }\n        \n        var j = i + 1\n        var k = n - 1\n        \n        while j < k {\n            let sum = sorted[i] + sorted[j] + sorted[k]\n            if sum < 0 {\n                j += 1\n            } else if sum > 0 {\n                k -= 1\n            } else {\n                result.append([sorted[i], sorted[j], sorted[k]])\n                while j < k && sorted[j] == sorted[j+1] { j += 1 }\n                while j < k && sorted[k] == sorted[k-1] { k -= 1 }\n                j += 1\n                k -= 1\n            }\n        }\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(1)",
          "timeExplanation": "Sorting O(n log n) + nested loops O(n²)",
          "spaceExplanation": "Output not counted, only pointers used"
        },
        "testCases": [
          {
            "input": "nums = [-1,0,1,2,-1,-4]",
            "expectedOutput": "[[-1,-1,2],[-1,0,1]]",
            "explanation": "Two unique triplets sum to 0"
          },
          {
            "input": "nums = [0,0,0]",
            "expectedOutput": "[[0,0,0]]",
            "explanation": "Single triplet of zeros"
          }
        ]
      }
    ],
    "relatedProblems": [
      "two-sum",
      "3sum-closest",
      "4sum"
    ]
  },
  "container-with-most-water": {
    "summary": "Find two lines that form container with most water. Two pointers from ends, move the shorter line inward.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "Water is limited by shorter line. Moving the taller line can only decrease area, so always move the shorter one.",
        "approach": "1. Start with left=0, right=n-1\n2. Calculate area = min(height[left], height[right]) × (right - left)\n3. Track max area\n4. Move pointer with smaller height inward\n5. Repeat until pointers meet",
        "explanation": "Width decreases as we move inward, so we need taller lines to compensate. Moving the shorter line gives a chance to find a taller one; moving the taller line cannot improve area since it's bounded by the shorter line.",
        "code": "func maxArea(_ height: [Int]) -> Int {\n    var left = 0\n    var right = height.count - 1\n    var maxArea = 0\n    \n    while left < right {\n        let width = right - left\n        let h = min(height[left], height[right])\n        maxArea = max(maxArea, width * h)\n        \n        if height[left] < height[right] {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    \n    return maxArea\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass with two pointers",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "height = [1,8,6,2,5,4,8,3,7]",
            "expectedOutput": "49",
            "explanation": "Lines at indices 1 and 8 (heights 8 and 7) with width 7"
          },
          {
            "input": "height = [1,1]",
            "expectedOutput": "1",
            "explanation": "Only two lines, area = 1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "trapping-rain-water"
    ]
  },
  "trapping-rain-water": {
    "summary": "Calculate water trapped between bars. For each position, water = min(maxLeft, maxRight) - height. Use two pointers.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "Water at position i is determined by the shorter of the tallest bars on either side. Process from the side with smaller max.",
        "approach": "1. Two pointers left and right, track leftMax and rightMax\n2. If leftMax < rightMax: water at left is bounded by leftMax\n3. Else: water at right is bounded by rightMax\n4. Add water and move pointer",
        "explanation": "We don't need to know the exact max on the other side, just that it's at least as tall as our current max. If leftMax < rightMax, we know the left position's water level is bounded by leftMax.",
        "code": "func trap(_ height: [Int]) -> Int {\n    var left = 0\n    var right = height.count - 1\n    var leftMax = 0\n    var rightMax = 0\n    var water = 0\n    \n    while left < right {\n        if height[left] < height[right] {\n            if height[left] >= leftMax {\n                leftMax = height[left]\n            } else {\n                water += leftMax - height[left]\n            }\n            left += 1\n        } else {\n            if height[right] >= rightMax {\n                rightMax = height[right]\n            } else {\n                water += rightMax - height[right]\n            }\n            right -= 1\n        }\n    }\n    \n    return water\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass with two pointers",
          "spaceExplanation": "Only tracking max values and pointers"
        },
        "testCases": [
          {
            "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
            "expectedOutput": "6",
            "explanation": "Water fills valleys between bars"
          },
          {
            "input": "height = [4,2,0,3,2,5]",
            "expectedOutput": "9",
            "explanation": "Complex terrain"
          }
        ]
      }
    ],
    "relatedProblems": [
      "container-with-most-water",
      "product-of-array-except-self"
    ]
  },
  "merge-intervals": {
    "summary": "Merge overlapping intervals. Sort by start time, then merge if current start <= previous end.",
    "approaches": [
      {
        "name": "Sort and Merge",
        "intuition": "After sorting by start time, overlapping intervals are adjacent. Merge by extending the end time.",
        "approach": "1. Sort intervals by start time\n2. Initialize result with first interval\n3. For each subsequent interval:\n   a. If overlaps with last in result, extend end\n   b. Else, add as new interval\n4. Return result",
        "explanation": "Sorting ensures we process intervals in order. Two intervals overlap if the second starts before the first ends. When merging, we take the max of both end times.",
        "code": "func merge(_ intervals: [[Int]]) -> [[Int]] {\n    guard !intervals.isEmpty else { return [] }\n    \n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var result: [[Int]] = [sorted[0]]\n    \n    for i in 1..<sorted.count {\n        let current = sorted[i]\n        if current[0] <= result[result.count - 1][1] {\n            result[result.count - 1][1] = max(result[result.count - 1][1], current[1])\n        } else {\n            result.append(current)\n        }\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Dominated by sorting",
          "spaceExplanation": "Result array can hold all intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
            "expectedOutput": "[[1,6],[8,10],[15,18]]",
            "explanation": "[1,3] and [2,6] merge to [1,6]"
          },
          {
            "input": "intervals = [[1,4],[4,5]]",
            "expectedOutput": "[[1,5]]",
            "explanation": "Touching intervals merge"
          }
        ]
      }
    ],
    "relatedProblems": [
      "insert-interval",
      "non-overlapping-intervals",
      "meeting-rooms"
    ]
  },
  "meeting-rooms": {
    "summary": "Check if person can attend all meetings (no overlaps). Sort by start time, check if any meeting starts before previous ends.",
    "approaches": [
      {
        "name": "Sort and Check",
        "intuition": "If meetings are sorted by start time, overlaps happen when a meeting starts before the previous one ends.",
        "approach": "1. Sort meetings by start time\n2. For each consecutive pair:\n   a. If current start < previous end, return false\n3. Return true",
        "explanation": "After sorting, we only need to check adjacent meetings. If meeting[i] starts before meeting[i-1] ends, there's a conflict.",
        "code": "func canAttendMeetings(_ intervals: [[Int]]) -> Bool {\n    guard intervals.count > 1 else { return true }\n    \n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] < sorted[i-1][1] {\n            return false\n        }\n    }\n    \n    return true\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting dominates",
          "spaceExplanation": "Sorted copy of intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "expectedOutput": "false",
            "explanation": "[0,30] overlaps with both others"
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "expectedOutput": "true",
            "explanation": "No overlaps after sorting"
          }
        ]
      }
    ],
    "relatedProblems": [
      "meeting-rooms-ii",
      "merge-intervals"
    ]
  },
  "meeting-rooms-ii": {
    "summary": "Find minimum meeting rooms needed. Use min-heap to track end times, or count overlapping intervals at any point.",
    "approaches": [
      {
        "name": "Min Heap for End Times",
        "intuition": "Track ongoing meetings with a min-heap of end times. When a new meeting starts, free rooms from meetings that ended.",
        "approach": "1. Sort meetings by start time\n2. Use min-heap for end times\n3. For each meeting:\n   a. While heap's min <= current start, pop (room freed)\n   b. Push current end time\n4. Heap size is rooms needed",
        "explanation": "The heap maintains end times of ongoing meetings. When starting a new meeting, we free any rooms from meetings that have already ended (end time <= start time).",
        "code": "func minMeetingRooms(_ intervals: [[Int]]) -> Int {\n    guard !intervals.isEmpty else { return 0 }\n    \n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var endTimes: [Int] = []  // Simulating min-heap\n    \n    for interval in sorted {\n        // Remove ended meetings\n        if let minEnd = endTimes.min(), minEnd <= interval[0] {\n            if let idx = endTimes.firstIndex(of: minEnd) {\n                endTimes.remove(at: idx)\n            }\n        }\n        endTimes.append(interval[1])\n    }\n    \n    return endTimes.count\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting + heap operations",
          "spaceExplanation": "Heap can hold all meetings"
        },
        "testCases": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "expectedOutput": "2",
            "explanation": "[5,10] and [0,30] overlap, need 2 rooms"
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "expectedOutput": "1",
            "explanation": "No overlap, 1 room enough"
          }
        ]
      }
    ],
    "relatedProblems": [
      "meeting-rooms",
      "merge-intervals"
    ]
  },
  "reverse-linked-list": {
    "summary": "Reverse a singly linked list. Iteratively: track prev, current, next; update pointers. Recursively: reverse rest, then point next.next to current.",
    "approaches": [
      {
        "name": "Iterative",
        "intuition": "At each node, reverse the pointer direction. Need to save next node before changing the link.",
        "approach": "1. Initialize prev = nil, current = head\n2. While current != nil:\n   a. Save next = current.next\n   b. Reverse: current.next = prev\n   c. Move: prev = current, current = next\n3. Return prev (new head)",
        "explanation": "We traverse the list once, reversing each pointer. prev trails behind current, and we save next before breaking the link.",
        "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var current = head\n    \n    while current != nil {\n        let next = current?.next\n        current?.next = prev\n        prev = current\n        current = next\n    }\n    \n    return prev\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5]",
            "expectedOutput": "[5,4,3,2,1]",
            "explanation": "List reversed"
          },
          {
            "input": "head = []",
            "expectedOutput": "[]",
            "explanation": "Empty list stays empty"
          }
        ]
      },
      {
        "name": "Recursive",
        "intuition": "Reverse the rest of the list first, then make the next node point back to current.",
        "approach": "1. Base case: empty or single node returns itself\n2. Recursively reverse rest of list\n3. current.next.next = current (point next back to us)\n4. current.next = nil (break forward link)\n5. Return new head from recursion",
        "explanation": "Trust the recursion reverses everything after current. Then current's next should point to current, and current should point to nil (it's now the tail).",
        "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    if head == nil || head?.next == nil {\n        return head\n    }\n    \n    let newHead = reverseList(head?.next)\n    head?.next?.next = head\n    head?.next = nil\n    \n    return newHead\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth equals list length"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5]",
            "expectedOutput": "[5,4,3,2,1]",
            "explanation": "Same result recursively"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-linked-list-ii",
      "palindrome-linked-list"
    ]
  },
  "merge-two-sorted-lists": {
    "summary": "Merge two sorted lists into one sorted list. Compare heads, attach smaller one, recurse or iterate.",
    "approaches": [
      {
        "name": "Iterative with Dummy",
        "intuition": "Use dummy node to simplify edge cases. At each step, attach the smaller node to result.",
        "approach": "1. Create dummy node\n2. While both lists have nodes:\n   a. Compare heads, attach smaller to result\n   b. Advance that list's pointer\n3. Attach remaining list\n4. Return dummy.next",
        "explanation": "The dummy node eliminates special-casing the first node. We build the result list by always choosing the smaller head.",
        "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var current = dummy\n    var l1 = list1\n    var l2 = list2\n    \n    while l1 != nil && l2 != nil {\n        if l1!.val <= l2!.val {\n            current.next = l1\n            l1 = l1?.next\n        } else {\n            current.next = l2\n            l2 = l2?.next\n        }\n        current = current.next!\n    }\n    \n    current.next = l1 ?? l2\n    return dummy.next\n}",
        "complexity": {
          "time": "O(n + m)",
          "space": "O(1)",
          "timeExplanation": "Visit each node once from both lists",
          "spaceExplanation": "Only pointer variables, reusing input nodes"
        },
        "testCases": [
          {
            "input": "list1 = [1,2,4], list2 = [1,3,4]",
            "expectedOutput": "[1,1,2,3,4,4]",
            "explanation": "Merged in sorted order"
          },
          {
            "input": "list1 = [], list2 = [0]",
            "expectedOutput": "[0]",
            "explanation": "Empty list case"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-k-sorted-lists",
      "sort-list"
    ]
  },
  "linked-list-cycle": {
    "summary": "Detect if linked list has a cycle. Floyd's algorithm: slow moves 1 step, fast moves 2 steps; they meet if cycle exists.",
    "approaches": [
      {
        "name": "Floyd's Cycle Detection",
        "intuition": "If there's a cycle, fast pointer will eventually lap slow pointer. If no cycle, fast hits null.",
        "approach": "1. Initialize slow = fast = head\n2. While fast and fast.next exist:\n   a. slow moves 1 step\n   b. fast moves 2 steps\n   c. If slow == fast, cycle exists\n3. Return false (no cycle)",
        "explanation": "Fast gains one step per iteration. In a cycle of length L, fast will catch slow within L iterations. The meeting point is guaranteed if a cycle exists.",
        "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var slow = head\n    var fast = head\n    \n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        \n        if slow === fast {\n            return true\n        }\n    }\n    \n    return false\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "At most 2n steps",
          "spaceExplanation": "Only two pointers"
        },
        "testCases": [
          {
            "input": "head = [3,2,0,-4], pos = 1",
            "expectedOutput": "true",
            "explanation": "Tail connects to node at index 1"
          },
          {
            "input": "head = [1], pos = -1",
            "expectedOutput": "false",
            "explanation": "No cycle"
          }
        ]
      }
    ],
    "relatedProblems": [
      "linked-list-cycle-ii",
      "happy-number"
    ]
  },
  "linked-list-cycle-ii": {
    "summary": "Find cycle start node. Floyd's algorithm to detect, then move one pointer to head and both move 1 step until they meet.",
    "approaches": [
      {
        "name": "Floyd's Algorithm Extended",
        "intuition": "After detecting cycle, distance from head to cycle start equals distance from meeting point to cycle start.",
        "approach": "1. Use Floyd's to find meeting point\n2. If no cycle, return nil\n3. Move one pointer to head\n4. Move both pointers 1 step until they meet\n5. Return meeting point (cycle start)",
        "explanation": "Mathematical proof: if head to cycle start is a, and meeting point to cycle start is b, then slow traveled a+b and fast traveled a+b+c (full cycle). Since fast is 2x slow: 2(a+b) = a+b+c, so a = c-b. Moving from head and meeting point at same speed, they meet at cycle start.",
        "code": "func detectCycle(_ head: ListNode?) -> ListNode? {\n    var slow = head\n    var fast = head\n    \n    // Find meeting point\n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        \n        if slow === fast {\n            // Found cycle, now find start\n            var ptr = head\n            while ptr !== slow {\n                ptr = ptr?.next\n                slow = slow?.next\n            }\n            return ptr\n        }\n    }\n    \n    return nil\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two traversals at most",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "head = [3,2,0,-4], pos = 1",
            "expectedOutput": "Node at index 1",
            "explanation": "Cycle starts at node with value 2"
          },
          {
            "input": "head = [1,2], pos = -1",
            "expectedOutput": "null",
            "explanation": "No cycle"
          }
        ]
      }
    ],
    "relatedProblems": [
      "linked-list-cycle",
      "find-the-duplicate-number"
    ]
  },
  "remove-nth-node-from-end-of-list": {
    "summary": "Remove nth node from end in one pass. Two pointers: advance fast n steps, then move both until fast hits end.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "If fast is n steps ahead of slow, when fast reaches end, slow is at the node before the target.",
        "approach": "1. Use dummy node before head\n2. Advance fast n+1 steps (so slow stops before target)\n3. Move both until fast is null\n4. slow.next = slow.next.next (skip target)\n5. Return dummy.next",
        "explanation": "The dummy node handles the case of removing the head. By keeping n+1 gap, slow stops at the node whose next pointer we need to update.",
        "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    let dummy = ListNode(0)\n    dummy.next = head\n    var slow: ListNode? = dummy\n    var fast: ListNode? = dummy\n    \n    // Move fast n+1 steps ahead\n    for _ in 0...n {\n        fast = fast?.next\n    }\n    \n    // Move both until fast reaches end\n    while fast != nil {\n        slow = slow?.next\n        fast = fast?.next\n    }\n    \n    // Remove the nth node\n    slow?.next = slow?.next?.next\n    \n    return dummy.next\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass through list",
          "spaceExplanation": "Only pointer variables"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5], n = 2",
            "expectedOutput": "[1,2,3,5]",
            "explanation": "Remove 4 (2nd from end)"
          },
          {
            "input": "head = [1], n = 1",
            "expectedOutput": "[]",
            "explanation": "Remove only node"
          }
        ]
      }
    ],
    "relatedProblems": [
      "delete-node-in-a-linked-list",
      "middle-of-the-linked-list"
    ]
  },
  "reorder-list": {
    "summary": "Reorder L0→L1→...→Ln to L0→Ln→L1→Ln-1→... Find middle, reverse second half, merge alternating.",
    "approaches": [
      {
        "name": "Split, Reverse, Merge",
        "intuition": "Split list at middle, reverse second half, then interleave the two halves.",
        "approach": "1. Find middle using slow/fast pointers\n2. Split list into two halves\n3. Reverse second half\n4. Merge by alternating nodes from each half",
        "explanation": "The result alternates between start and end of original list. By reversing the second half, we can simply interleave two lists in one pass.",
        "code": "func reorderList(_ head: ListNode?) {\n    guard head != nil && head?.next != nil else { return }\n    \n    // Find middle\n    var slow = head\n    var fast = head\n    while fast?.next != nil && fast?.next?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n    }\n    \n    // Reverse second half\n    var prev: ListNode? = nil\n    var current = slow?.next\n    slow?.next = nil\n    \n    while current != nil {\n        let next = current?.next\n        current?.next = prev\n        prev = current\n        current = next\n    }\n    \n    // Merge two halves\n    var first = head\n    var second = prev\n    \n    while second != nil {\n        let temp1 = first?.next\n        let temp2 = second?.next\n        first?.next = second\n        second?.next = temp1\n        first = temp1\n        second = temp2\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Three passes: find middle, reverse, merge",
          "spaceExplanation": "In-place modification"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4]",
            "expectedOutput": "[1,4,2,3]",
            "explanation": "Reordered list"
          },
          {
            "input": "head = [1,2,3,4,5]",
            "expectedOutput": "[1,5,2,4,3]",
            "explanation": "Odd length list"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-linked-list",
      "palindrome-linked-list"
    ]
  },
  "middle-of-the-linked-list": {
    "summary": "Find middle node. Slow/fast pointers: when fast reaches end, slow is at middle.",
    "approaches": [
      {
        "name": "Slow and Fast Pointers",
        "intuition": "Fast moves twice as fast as slow. When fast reaches end, slow is at midpoint.",
        "approach": "1. Initialize slow = fast = head\n2. While fast and fast.next exist:\n   a. slow moves 1 step\n   b. fast moves 2 steps\n3. Return slow",
        "explanation": "For even length, this returns the second of the two middle nodes. Fast travels 2x the distance, so when it's done, slow is at 50%.",
        "code": "func middleNode(_ head: ListNode?) -> ListNode? {\n    var slow = head\n    var fast = head\n    \n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n    }\n    \n    return slow\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass (fast goes through all nodes)",
          "spaceExplanation": "Only two pointers"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5]",
            "expectedOutput": "[3,4,5]",
            "explanation": "Middle is node 3"
          },
          {
            "input": "head = [1,2,3,4,5,6]",
            "expectedOutput": "[4,5,6]",
            "explanation": "For even length, second middle"
          }
        ]
      }
    ],
    "relatedProblems": [
      "delete-the-middle-node-of-a-linked-list",
      "reorder-list"
    ]
  },
  "palindrome-linked-list": {
    "summary": "Check if linked list is palindrome. Find middle, reverse second half, compare with first half.",
    "approaches": [
      {
        "name": "Reverse Second Half",
        "intuition": "A palindrome reads same forwards and backwards. Compare first half with reversed second half.",
        "approach": "1. Find middle using slow/fast\n2. Reverse second half\n3. Compare first half with reversed second half\n4. Return true if all match",
        "explanation": "We reuse the reverse list and find middle techniques. After reversing the second half, we compare node by node from start and from middle.",
        "code": "func isPalindrome(_ head: ListNode?) -> Bool {\n    // Find middle\n    var slow = head\n    var fast = head\n    while fast?.next != nil && fast?.next?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n    }\n    \n    // Reverse second half\n    var prev: ListNode? = nil\n    var current = slow?.next\n    while current != nil {\n        let next = current?.next\n        current?.next = prev\n        prev = current\n        current = next\n    }\n    \n    // Compare\n    var p1 = head\n    var p2 = prev\n    while p2 != nil {\n        if p1?.val != p2?.val {\n            return false\n        }\n        p1 = p1?.next\n        p2 = p2?.next\n    }\n    \n    return true\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Three passes through list",
          "spaceExplanation": "In-place reversal, no extra space"
        },
        "testCases": [
          {
            "input": "head = [1,2,2,1]",
            "expectedOutput": "true",
            "explanation": "Palindrome"
          },
          {
            "input": "head = [1,2]",
            "expectedOutput": "false",
            "explanation": "Not palindrome"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-linked-list",
      "valid-palindrome"
    ]
  },
  "add-two-numbers": {
    "summary": "Add two numbers represented as reversed linked lists. Traverse both, sum digits with carry, create result list.",
    "approaches": [
      {
        "name": "Iterative with Carry",
        "intuition": "Process digit by digit like elementary addition. Sum digits, track carry for next position.",
        "approach": "1. Create dummy head for result\n2. While either list has nodes or carry exists:\n   a. Sum current digits + carry\n   b. Create node with sum % 10\n   c. carry = sum / 10\n3. Return dummy.next",
        "explanation": "Numbers are conveniently stored reversed (least significant first). We add corresponding digits plus carry. If one list is shorter, treat missing digits as 0.",
        "code": "func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var current = dummy\n    var p1 = l1\n    var p2 = l2\n    var carry = 0\n    \n    while p1 != nil || p2 != nil || carry > 0 {\n        let sum = (p1?.val ?? 0) + (p2?.val ?? 0) + carry\n        carry = sum / 10\n        current.next = ListNode(sum % 10)\n        current = current.next!\n        p1 = p1?.next\n        p2 = p2?.next\n    }\n    \n    return dummy.next\n}",
        "complexity": {
          "time": "O(max(m, n))",
          "space": "O(max(m, n))",
          "timeExplanation": "Traverse the longer list once",
          "spaceExplanation": "Result list has at most max(m,n)+1 nodes"
        },
        "testCases": [
          {
            "input": "l1 = [2,4,3], l2 = [5,6,4]",
            "expectedOutput": "[7,0,8]",
            "explanation": "342 + 465 = 807"
          },
          {
            "input": "l1 = [9,9,9], l2 = [1]",
            "expectedOutput": "[0,0,0,1]",
            "explanation": "999 + 1 = 1000"
          }
        ]
      }
    ],
    "relatedProblems": [
      "add-two-numbers-ii",
      "multiply-strings"
    ]
  },
  "copy-list-with-random-pointer": {
    "summary": "Deep copy linked list with random pointers. Use HashMap to map original→copy, or interleave nodes.",
    "approaches": [
      {
        "name": "Hash Map",
        "intuition": "First pass: create all nodes and map old→new. Second pass: connect next and random pointers.",
        "approach": "1. Create map of original node → copy node\n2. First pass: create all copy nodes\n3. Second pass: set copy.next and copy.random using map\n4. Return map[head]",
        "explanation": "The HashMap lets us find the copy of any node in O(1). We create all copies first, then link them using the map to find corresponding nodes.",
        "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard let head = head else { return nil }\n    \n    var map: [Node: Node] = [:]\n    \n    // First pass: create copies\n    var current: Node? = head\n    while current != nil {\n        map[current!] = Node(current!.val)\n        current = current?.next\n    }\n    \n    // Second pass: connect pointers\n    current = head\n    while current != nil {\n        map[current!]?.next = map[current!.next!]\n        map[current!]?.random = map[current!.random!]\n        current = current?.next\n    }\n    \n    return map[head]\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Two passes through list",
          "spaceExplanation": "HashMap stores n node mappings"
        },
        "testCases": [
          {
            "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
            "expectedOutput": "Deep copy",
            "explanation": "Each node copied with correct random pointers"
          }
        ]
      }
    ],
    "relatedProblems": [
      "clone-graph"
    ]
  },
  "binary-tree-inorder-traversal": {
    "summary": "Inorder traversal: left, root, right. Recursive is simple; iterative uses stack.",
    "approaches": [
      {
        "name": "Recursive",
        "intuition": "Visit left subtree, then current node, then right subtree.",
        "approach": "1. If node is null, return\n2. Recursively traverse left\n3. Add current value\n4. Recursively traverse right",
        "explanation": "Inorder for BST gives sorted order. The recursion naturally handles the stack for us.",
        "code": "func inorderTraversal(_ root: TreeNode?) -> [Int] {\n    var result: [Int] = []\n    \n    func inorder(_ node: TreeNode?) {\n        guard let node = node else { return }\n        inorder(node.left)\n        result.append(node.val)\n        inorder(node.right)\n    }\n    \n    inorder(root)\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth equals tree height"
        },
        "testCases": [
          {
            "input": "root = [1,null,2,3]",
            "expectedOutput": "[1,3,2]",
            "explanation": "Inorder: 1, then 3, then 2"
          }
        ]
      },
      {
        "name": "Iterative with Stack",
        "intuition": "Push all left nodes to stack. Pop and process, then go to right subtree.",
        "approach": "1. Push all left children onto stack\n2. Pop node, add to result\n3. Move to right child and repeat step 1",
        "explanation": "We manually simulate the call stack. Going left as far as possible, then processing, then going right mirrors the recursive pattern.",
        "code": "func inorderTraversal(_ root: TreeNode?) -> [Int] {\n    var result: [Int] = []\n    var stack: [TreeNode] = []\n    var current = root\n    \n    while current != nil || !stack.isEmpty {\n        while current != nil {\n            stack.append(current!)\n            current = current?.left\n        }\n        current = stack.removeLast()\n        result.append(current!.val)\n        current = current?.right\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Stack holds at most h nodes"
        },
        "testCases": [
          {
            "input": "root = [1,null,2,3]",
            "expectedOutput": "[1,3,2]",
            "explanation": "Same result iteratively"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-preorder-traversal",
      "binary-tree-postorder-traversal"
    ]
  },
  "binary-tree-level-order-traversal": {
    "summary": "Return values level by level. BFS with queue, process all nodes at each level before moving to next.",
    "approaches": [
      {
        "name": "BFS with Queue",
        "intuition": "Process tree level by level using a queue. Track level size to know when one level ends.",
        "approach": "1. Add root to queue\n2. While queue not empty:\n   a. Get current level size\n   b. Process all nodes at this level\n   c. Add their children for next level\n   d. Add level values to result",
        "explanation": "The key insight is capturing the queue size at the start of each level. This tells us exactly how many nodes belong to the current level.",
        "code": "func levelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    \n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    \n    while !queue.isEmpty {\n        let levelSize = queue.count\n        var level: [Int] = []\n        \n        for _ in 0..<levelSize {\n            let node = queue.removeFirst()\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        \n        result.append(level)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(w)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Queue holds at most one level, max width w"
        },
        "testCases": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "expectedOutput": "[[3],[9,20],[15,7]]",
            "explanation": "Three levels"
          },
          {
            "input": "root = [1]",
            "expectedOutput": "[[1]]",
            "explanation": "Single node"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-zigzag-level-order-traversal",
      "binary-tree-right-side-view"
    ]
  },
  "maximum-depth-of-binary-tree": {
    "summary": "Find max depth (root to leaf). Recursively: 1 + max(left depth, right depth).",
    "approaches": [
      {
        "name": "Recursive DFS",
        "intuition": "Depth of tree is 1 (for root) plus the deeper of its two subtrees.",
        "approach": "1. Base case: null node has depth 0\n2. Return 1 + max(depth(left), depth(right))",
        "explanation": "We compute depth bottom-up. Each null returns 0, each node adds 1 to the max depth of its children.",
        "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "expectedOutput": "3",
            "explanation": "Path 3→20→7 or 3→20→15"
          },
          {
            "input": "root = [1,null,2]",
            "expectedOutput": "2",
            "explanation": "Path 1→2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "minimum-depth-of-binary-tree",
      "balanced-binary-tree"
    ]
  },
  "same-tree": {
    "summary": "Check if two trees are identical. Recursively compare: same value and both subtrees match.",
    "approaches": [
      {
        "name": "Recursive Comparison",
        "intuition": "Trees are same if roots equal and left/right subtrees are same.",
        "approach": "1. If both null, return true\n2. If one null or values differ, return false\n3. Recursively check left and right subtrees",
        "explanation": "We check structural equality by comparing each corresponding node. Both must be null, or both must exist with same value and matching subtrees.",
        "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    if p == nil || q == nil { return false }\n    if p!.val != q!.val { return false }\n    \n    return isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion depth equals tree height"
        },
        "testCases": [
          {
            "input": "p = [1,2,3], q = [1,2,3]",
            "expectedOutput": "true",
            "explanation": "Identical trees"
          },
          {
            "input": "p = [1,2], q = [1,null,2]",
            "expectedOutput": "false",
            "explanation": "Different structure"
          }
        ]
      }
    ],
    "relatedProblems": [
      "symmetric-tree",
      "subtree-of-another-tree"
    ]
  },
  "symmetric-tree": {
    "summary": "Check if tree is mirror of itself. Compare left subtree with mirrored right subtree.",
    "approaches": [
      {
        "name": "Recursive Mirror Check",
        "intuition": "Tree is symmetric if left subtree mirrors right subtree.",
        "approach": "1. Define isMirror(t1, t2)\n2. Both null → true\n3. One null or values differ → false\n4. Check t1.left mirrors t2.right AND t1.right mirrors t2.left",
        "explanation": "We check if left and right subtrees are mirrors. In a mirror, t1's left should match t2's right (crossed comparison).",
        "code": "func isSymmetric(_ root: TreeNode?) -> Bool {\n    func isMirror(_ t1: TreeNode?, _ t2: TreeNode?) -> Bool {\n        if t1 == nil && t2 == nil { return true }\n        if t1 == nil || t2 == nil { return false }\n        if t1!.val != t2!.val { return false }\n        \n        return isMirror(t1?.left, t2?.right) && isMirror(t1?.right, t2?.left)\n    }\n    \n    return isMirror(root, root)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "root = [1,2,2,3,4,4,3]",
            "expectedOutput": "true",
            "explanation": "Symmetric around center"
          },
          {
            "input": "root = [1,2,2,null,3,null,3]",
            "expectedOutput": "false",
            "explanation": "Not symmetric"
          }
        ]
      }
    ],
    "relatedProblems": [
      "same-tree"
    ]
  },
  "invert-binary-tree": {
    "summary": "Mirror/flip a binary tree. Swap left and right children at each node recursively.",
    "approaches": [
      {
        "name": "Recursive Swap",
        "intuition": "At each node, swap its children and recursively invert both subtrees.",
        "approach": "1. Base case: null returns null\n2. Swap left and right children\n3. Recursively invert left and right\n4. Return node",
        "explanation": "Post-order or pre-order both work. We swap children at each node, which mirrors the tree structure.",
        "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    \n    let temp = root.left\n    root.left = root.right\n    root.right = temp\n    \n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [4,2,7,1,3,6,9]",
            "expectedOutput": "[4,7,2,9,6,3,1]",
            "explanation": "All nodes swapped"
          },
          {
            "input": "root = [2,1,3]",
            "expectedOutput": "[2,3,1]",
            "explanation": "Children swapped"
          }
        ]
      }
    ],
    "relatedProblems": [
      "symmetric-tree"
    ]
  },
  "subtree-of-another-tree": {
    "summary": "Check if t is subtree of s. At each node in s, check if subtree matches t using sameTree.",
    "approaches": [
      {
        "name": "Recursive with Same Tree Check",
        "intuition": "For each node in s, check if the subtree rooted there is identical to t.",
        "approach": "1. If s is null, return false (t not found)\n2. If sameTree(s, t), return true\n3. Recursively check if t is subtree of s.left or s.right",
        "explanation": "We try every node in s as a potential match point for t. At each node, we use the sameTree function to check for exact structural match.",
        "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    guard let root = root else { return false }\n    \n    func isSame(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n        if p == nil && q == nil { return true }\n        if p == nil || q == nil { return false }\n        if p!.val != q!.val { return false }\n        return isSame(p?.left, q?.left) && isSame(p?.right, q?.right)\n    }\n    \n    if isSame(root, subRoot) { return true }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}",
        "complexity": {
          "time": "O(m × n)",
          "space": "O(h)",
          "timeExplanation": "For each of n nodes in s, potentially compare m nodes of t",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
            "expectedOutput": "true",
            "explanation": "Left subtree matches"
          },
          {
            "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
            "expectedOutput": "false",
            "explanation": "Extra node breaks match"
          }
        ]
      }
    ],
    "relatedProblems": [
      "same-tree"
    ]
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "summary": "Find LCA of two nodes. Recursively search both subtrees; if both contain targets, current node is LCA.",
    "approaches": [
      {
        "name": "Recursive Search",
        "intuition": "If p and q are in different subtrees, current node is LCA. If both in same subtree, recurse into that subtree.",
        "approach": "1. Base: if node is null/p/q, return node\n2. Search left subtree for p and q\n3. Search right subtree for p and q\n4. If both sides return non-null, current is LCA\n5. Return non-null side (or null if both null)",
        "explanation": "The recursion returns the node if it's p, q, or null. When both subtrees return non-null, we've found p in one and q in the other, making current node the LCA.",
        "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    if root == nil || root === p || root === q {\n        return root\n    }\n    \n    let left = lowestCommonAncestor(root?.left, p, q)\n    let right = lowestCommonAncestor(root?.right, p, q)\n    \n    if left != nil && right != nil {\n        return root\n    }\n    \n    return left ?? right\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node at most once",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
            "expectedOutput": "3",
            "explanation": "3 is ancestor of both 5 and 1"
          },
          {
            "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
            "expectedOutput": "5",
            "explanation": "5 is ancestor of 4 and itself"
          }
        ]
      }
    ],
    "relatedProblems": [
      "lowest-common-ancestor-of-a-binary-search-tree"
    ]
  },
  "lowest-common-ancestor-of-a-binary-search-tree": {
    "summary": "Find LCA in BST. Use BST property: if both values < node, go left; if both > node, go right; else current is LCA.",
    "approaches": [
      {
        "name": "BST Property Navigation",
        "intuition": "In a BST, values guide our search. LCA is where p and q paths diverge.",
        "approach": "1. If both p and q < current, search left\n2. If both p and q > current, search right\n3. Otherwise, current is LCA (split point)",
        "explanation": "BST property means all left descendants < node < all right descendants. When p and q are on different sides (or one equals current), we've found the LCA.",
        "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    var current = root\n    \n    while current != nil {\n        if p!.val < current!.val && q!.val < current!.val {\n            current = current?.left\n        } else if p!.val > current!.val && q!.val > current!.val {\n            current = current?.right\n        } else {\n            return current\n        }\n    }\n    \n    return nil\n}",
        "complexity": {
          "time": "O(h)",
          "space": "O(1)",
          "timeExplanation": "Follow one path from root",
          "spaceExplanation": "Iterative, no extra space"
        },
        "testCases": [
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
            "expectedOutput": "6",
            "explanation": "2 < 6 < 8, so 6 is LCA"
          },
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
            "expectedOutput": "2",
            "explanation": "4 is descendant of 2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "lowest-common-ancestor-of-a-binary-tree"
    ]
  },
  "validate-binary-search-tree": {
    "summary": "Check if tree is valid BST. Track valid range [min, max] for each node; value must be within range.",
    "approaches": [
      {
        "name": "Range Validation",
        "intuition": "Each node must be within a valid range determined by its ancestors.",
        "approach": "1. Root can be any value (min: -∞, max: +∞)\n2. Left child must be < parent, so max becomes parent value\n3. Right child must be > parent, so min becomes parent value\n4. Recursively validate with updated ranges",
        "explanation": "We propagate constraints down the tree. A node in left subtree has upper bound from parent; a node in right subtree has lower bound from parent.",
        "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    func validate(_ node: TreeNode?, _ min: Int?, _ max: Int?) -> Bool {\n        guard let node = node else { return true }\n        \n        if let min = min, node.val <= min { return false }\n        if let max = max, node.val >= max { return false }\n        \n        return validate(node.left, min, node.val) &&\n               validate(node.right, node.val, max)\n    }\n    \n    return validate(root, nil, nil)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [2,1,3]",
            "expectedOutput": "true",
            "explanation": "Valid BST"
          },
          {
            "input": "root = [5,1,4,null,null,3,6]",
            "expectedOutput": "false",
            "explanation": "4 is in right but < 5"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-inorder-traversal"
    ]
  },
  "kth-smallest-element-in-a-bst": {
    "summary": "Find kth smallest in BST. Inorder traversal gives sorted order; return kth element.",
    "approaches": [
      {
        "name": "Inorder Traversal",
        "intuition": "Inorder traversal of BST visits nodes in ascending order. Stop at kth node.",
        "approach": "1. Inorder traversal with counter\n2. Decrement k at each node\n3. When k reaches 0, return current value",
        "explanation": "BST property ensures left < root < right. Inorder visits in sorted order, so kth visited is kth smallest.",
        "code": "func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n    var count = k\n    var result = 0\n    \n    func inorder(_ node: TreeNode?) {\n        guard let node = node, count > 0 else { return }\n        \n        inorder(node.left)\n        \n        count -= 1\n        if count == 0 {\n            result = node.val\n            return\n        }\n        \n        inorder(node.right)\n    }\n    \n    inorder(root)\n    return result\n}",
        "complexity": {
          "time": "O(h + k)",
          "space": "O(h)",
          "timeExplanation": "Visit k nodes plus height to reach smallest",
          "spaceExplanation": "Recursion stack"
        },
        "testCases": [
          {
            "input": "root = [3,1,4,null,2], k = 1",
            "expectedOutput": "1",
            "explanation": "Smallest is 1"
          },
          {
            "input": "root = [5,3,6,2,4,null,null,1], k = 3",
            "expectedOutput": "3",
            "explanation": "1,2,3,... third is 3"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-inorder-traversal"
    ]
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "summary": "Build tree from preorder and inorder arrays. Preorder's first is root; find it in inorder to split left/right.",
    "approaches": [
      {
        "name": "Recursive with Index Map",
        "intuition": "Preorder tells us root, inorder tells us left/right split. Use hashmap for O(1) index lookup.",
        "approach": "1. First element of preorder is root\n2. Find root in inorder (splits left/right subtrees)\n3. Recursively build left subtree (next preorder elements, left inorder section)\n4. Recursively build right subtree (remaining preorder, right inorder section)",
        "explanation": "Preorder visits root first, so preorder[0] is root. In inorder, everything left of root belongs to left subtree. The count of left nodes tells us how many preorder elements belong to left subtree.",
        "code": "func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n    var indexMap: [Int: Int] = [:]\n    for (i, val) in inorder.enumerated() {\n        indexMap[val] = i\n    }\n    \n    var preIdx = 0\n    \n    func build(_ left: Int, _ right: Int) -> TreeNode? {\n        if left > right { return nil }\n        \n        let rootVal = preorder[preIdx]\n        preIdx += 1\n        \n        let root = TreeNode(rootVal)\n        let mid = indexMap[rootVal]!\n        \n        root.left = build(left, mid - 1)\n        root.right = build(mid + 1, right)\n        \n        return root\n    }\n    \n    return build(0, inorder.count - 1)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Build each node once, O(1) lookup",
          "spaceExplanation": "HashMap + recursion stack"
        },
        "testCases": [
          {
            "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
            "expectedOutput": "[3,9,20,null,null,15,7]",
            "explanation": "Reconstructed tree"
          },
          {
            "input": "preorder = [-1], inorder = [-1]",
            "expectedOutput": "[-1]",
            "explanation": "Single node"
          }
        ]
      }
    ],
    "relatedProblems": [
      "construct-binary-tree-from-inorder-and-postorder-traversal"
    ]
  },
  "binary-tree-maximum-path-sum": {
    "summary": "Find max sum path (any node to any node). At each node, compute max single path and update global max with path through node.",
    "approaches": [
      {
        "name": "DFS with Global Max",
        "intuition": "At each node, either extend a path (for parent to use) or form a complete path through this node.",
        "approach": "1. DFS returns max sum of path starting at node (single direction)\n2. At each node, max path through it = node + max(leftPath, 0) + max(rightPath, 0)\n3. Update global max with path through current node\n4. Return node + max(left, right, 0) for parent to extend",
        "explanation": "We track two things: the best path ending at current node (to extend upward) and the best path going through current node (using both subtrees). Negative paths are ignored (use 0 instead).",
        "code": "func maxPathSum(_ root: TreeNode?) -> Int {\n    var maxSum = Int.min\n    \n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        \n        let leftMax = max(dfs(node.left), 0)\n        let rightMax = max(dfs(node.right), 0)\n        \n        // Path through this node\n        maxSum = max(maxSum, node.val + leftMax + rightMax)\n        \n        // Max path starting at this node (for parent)\n        return node.val + max(leftMax, rightMax)\n    }\n    \n    dfs(root)\n    return maxSum\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Recursion stack depth"
        },
        "testCases": [
          {
            "input": "root = [1,2,3]",
            "expectedOutput": "6",
            "explanation": "Path 2→1→3 = 6"
          },
          {
            "input": "root = [-10,9,20,null,null,15,7]",
            "expectedOutput": "42",
            "explanation": "Path 15→20→7 = 42"
          }
        ]
      }
    ],
    "relatedProblems": [
      "diameter-of-binary-tree",
      "path-sum-iii"
    ]
  },
  "serialize-and-deserialize-binary-tree": {
    "summary": "Encode tree to string and decode back. Use preorder with null markers, or BFS level-order.",
    "approaches": [
      {
        "name": "Preorder with Null Markers",
        "intuition": "Preorder traversal with explicit null markers allows perfect reconstruction.",
        "approach": "Serialize:\n1. Preorder traversal\n2. Append value or 'null' for each node\n3. Join with delimiter\n\nDeserialize:\n1. Split string, use queue\n2. Recursively build: take next value, create node, build left/right",
        "explanation": "By marking nulls explicitly, we know exactly where subtrees end. Preorder naturally gives root first, allowing top-down reconstruction.",
        "code": "class Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var result: [String] = []\n        \n        func preorder(_ node: TreeNode?) {\n            guard let node = node else {\n                result.append(\"null\")\n                return\n            }\n            result.append(String(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        }\n        \n        preorder(root)\n        return result.joined(separator: \",\")\n    }\n    \n    func deserialize(_ data: String) -> TreeNode? {\n        var values = data.split(separator: \",\").map(String.init)\n        var index = 0\n        \n        func build() -> TreeNode? {\n            if index >= values.count || values[index] == \"null\" {\n                index += 1\n                return nil\n            }\n            \n            let node = TreeNode(Int(values[index])!)\n            index += 1\n            node.left = build()\n            node.right = build()\n            return node\n        }\n        \n        return build()\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Visit each node once for both operations",
          "spaceExplanation": "String/array stores all nodes including nulls"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,null,null,4,5]",
            "expectedOutput": "Same tree after deserialize",
            "explanation": "Roundtrip preserves structure"
          }
        ]
      }
    ],
    "relatedProblems": [
      "construct-binary-tree-from-preorder-and-inorder-traversal"
    ]
  },
  "valid-palindrome": {
    "summary": "Check if string is palindrome considering only alphanumeric, case-insensitive. Two pointers from ends.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "Compare characters from both ends, skipping non-alphanumeric characters.",
        "approach": "1. Initialize left=0, right=n-1\n2. Skip non-alphanumeric characters\n3. Compare lowercase versions\n4. If mismatch, return false",
        "explanation": "We filter characters on-the-fly rather than creating a new string.",
        "code": "func isPalindrome(_ s: String) -> Bool {\n    let chars = Array(s.lowercased())\n    var left = 0\n    var right = chars.count - 1\n    \n    while left < right {\n        while left < right && !chars[left].isLetter && !chars[left].isNumber {\n            left += 1\n        }\n        while left < right && !chars[right].isLetter && !chars[right].isNumber {\n            right -= 1\n        }\n        if chars[left] != chars[right] { return false }\n        left += 1\n        right -= 1\n    }\n    return true\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Array copy"
        },
        "testCases": [
          {
            "input": "s = \"A man, a plan, a canal: Panama\"",
            "expectedOutput": "true",
            "explanation": "Is palindrome"
          }
        ]
      }
    ],
    "relatedProblems": [
      "valid-palindrome-ii"
    ]
  },
  "valid-anagram": {
    "summary": "Check if two strings are anagrams. Compare character frequency counts.",
    "approaches": [
      {
        "name": "Character Count",
        "intuition": "Anagrams have exactly the same characters in same quantities.",
        "approach": "1. Count characters in first string\n2. Decrement counts for second string\n3. All counts should be zero",
        "explanation": "Use dictionary to count character frequencies.",
        "code": "func isAnagram(_ s: String, _ t: String) -> Bool {\n    if s.count != t.count { return false }\n    var count = [Character: Int]()\n    for char in s { count[char, default: 0] += 1 }\n    for char in t {\n        count[char, default: 0] -= 1\n        if count[char]! < 0 { return false }\n    }\n    return true\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two passes",
          "spaceExplanation": "26 letters max"
        },
        "testCases": [
          {
            "input": "s = \"anagram\", t = \"nagaram\"",
            "expectedOutput": "true",
            "explanation": "Same characters"
          }
        ]
      }
    ],
    "relatedProblems": [
      "group-anagrams"
    ]
  },
  "group-anagrams": {
    "summary": "Group strings that are anagrams. Use sorted string as key in hash map.",
    "approaches": [
      {
        "name": "Sorted String Key",
        "intuition": "Anagrams become identical when sorted.",
        "approach": "1. For each string, sort it\n2. Use sorted string as dictionary key\n3. Group original strings by key",
        "explanation": "Sorting normalizes anagrams to the same key.",
        "code": "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups: [String: [String]] = [:]\n    for str in strs {\n        let key = String(str.sorted())\n        groups[key, default: []].append(str)\n    }\n    return Array(groups.values)\n}",
        "complexity": {
          "time": "O(n × k log k)",
          "space": "O(n × k)",
          "timeExplanation": "n strings, each sorted",
          "spaceExplanation": "Store all strings"
        },
        "testCases": [
          {
            "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
            "expectedOutput": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
            "explanation": "Grouped by anagram"
          }
        ]
      }
    ],
    "relatedProblems": [
      "valid-anagram"
    ]
  },
  "longest-substring-without-repeating-characters": {
    "summary": "Find length of longest substring without repeating characters. Sliding window with set.",
    "approaches": [
      {
        "name": "Sliding Window",
        "intuition": "Expand window while no duplicates; shrink when duplicate found.",
        "approach": "1. Use set for current window\n2. Expand right, add to set\n3. If duplicate, shrink from left\n4. Track max size",
        "explanation": "Window always contains unique characters.",
        "code": "func lengthOfLongestSubstring(_ s: String) -> Int {\n    let chars = Array(s)\n    var charSet = Set<Character>()\n    var left = 0, maxLength = 0\n    \n    for right in 0..<chars.count {\n        while charSet.contains(chars[right]) {\n            charSet.remove(chars[left])\n            left += 1\n        }\n        charSet.insert(chars[right])\n        maxLength = max(maxLength, right - left + 1)\n    }\n    return maxLength\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(min(n,m))",
          "timeExplanation": "Each char visited twice max",
          "spaceExplanation": "Set bounded by alphabet"
        },
        "testCases": [
          {
            "input": "s = \"abcabcbb\"",
            "expectedOutput": "3",
            "explanation": "\"abc\" is longest"
          }
        ]
      }
    ],
    "relatedProblems": [
      "minimum-window-substring"
    ]
  },
  "minimum-window-substring": {
    "summary": "Find smallest window in s containing all characters of t. Sliding window: expand then shrink.",
    "approaches": [
      {
        "name": "Sliding Window",
        "intuition": "Expand to include all required chars, then shrink to minimize.",
        "approach": "1. Count required characters from t\n2. Expand right until all satisfied\n3. Shrink from left while still valid\n4. Track minimum window",
        "explanation": "Track how many unique chars have required count met.",
        "code": "func minWindow(_ s: String, _ t: String) -> String {\n    if t.isEmpty { return \"\" }\n    var need: [Character: Int] = [:]\n    for char in t { need[char, default: 0] += 1 }\n    \n    var have: [Character: Int] = [:]\n    var formed = 0, required = need.count\n    let chars = Array(s)\n    var left = 0, minLen = Int.max, result = (0, 0)\n    \n    for right in 0..<chars.count {\n        let char = chars[right]\n        have[char, default: 0] += 1\n        if let n = need[char], have[char] == n { formed += 1 }\n        \n        while formed == required {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n                result = (left, right)\n            }\n            let lc = chars[left]\n            have[lc]! -= 1\n            if let n = need[lc], have[lc]! < n { formed -= 1 }\n            left += 1\n        }\n    }\n    return minLen == Int.max ? \"\" : String(chars[result.0...result.1])\n}",
        "complexity": {
          "time": "O(n + m)",
          "space": "O(m)",
          "timeExplanation": "Each char visited twice",
          "spaceExplanation": "Frequency maps"
        },
        "testCases": [
          {
            "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
            "expectedOutput": "\"BANC\"",
            "explanation": "Smallest window with A,B,C"
          }
        ]
      }
    ],
    "relatedProblems": [
      "longest-substring-without-repeating-characters"
    ]
  },
  "longest-palindromic-substring": {
    "summary": "Find longest palindromic substring. Expand around center for each position.",
    "approaches": [
      {
        "name": "Expand Around Center",
        "intuition": "A palindrome mirrors around its center. Try each position.",
        "approach": "1. For each index, try as center\n2. Expand while chars match\n3. Try both odd and even length\n4. Track longest",
        "explanation": "There are 2n-1 possible centers.",
        "code": "func longestPalindrome(_ s: String) -> String {\n    let chars = Array(s)\n    if chars.isEmpty { return \"\" }\n    var start = 0, maxLen = 1\n    \n    func expand(_ l: Int, _ r: Int) -> Int {\n        var l = l, r = r\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            l -= 1; r += 1\n        }\n        return r - l - 1\n    }\n    \n    for i in 0..<chars.count {\n        let len = max(expand(i, i), expand(i, i + 1))\n        if len > maxLen {\n            maxLen = len\n            start = i - (len - 1) / 2\n        }\n    }\n    return String(chars[start..<start + maxLen])\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(n)",
          "timeExplanation": "n centers, O(n) expansion each",
          "spaceExplanation": "Array copy"
        },
        "testCases": [
          {
            "input": "s = \"babad\"",
            "expectedOutput": "\"bab\"",
            "explanation": "\"aba\" also valid"
          }
        ]
      }
    ],
    "relatedProblems": [
      "palindromic-substrings"
    ]
  },
  "palindromic-substrings": {
    "summary": "Count all palindromic substrings. Expand around each center, count palindromes.",
    "approaches": [
      {
        "name": "Expand Around Center",
        "intuition": "Count every palindrome during expansion.",
        "approach": "1. For each center, expand\n2. Count each successful expansion\n3. Sum all counts",
        "explanation": "Every expansion step is a new palindrome.",
        "code": "func countSubstrings(_ s: String) -> Int {\n    let chars = Array(s)\n    var count = 0\n    \n    func expand(_ l: Int, _ r: Int) -> Int {\n        var l = l, r = r, cnt = 0\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            cnt += 1; l -= 1; r += 1\n        }\n        return cnt\n    }\n    \n    for i in 0..<chars.count {\n        count += expand(i, i) + expand(i, i + 1)\n    }\n    return count\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(n)",
          "timeExplanation": "n centers",
          "spaceExplanation": "Array copy"
        },
        "testCases": [
          {
            "input": "s = \"aaa\"",
            "expectedOutput": "6",
            "explanation": "a×3, aa×2, aaa×1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "longest-palindromic-substring"
    ]
  },
  "word-break": {
    "summary": "Check if string can be segmented into dictionary words. DP approach.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "dp[i] = true if s[0..i) can be segmented.",
        "approach": "1. dp[0] = true\n2. For each i, check all j < i\n3. If dp[j] && s[j..i) is word, dp[i] = true",
        "explanation": "Build up from empty string.",
        "code": "func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n    let words = Set(wordDict)\n    let chars = Array(s)\n    var dp = [Bool](repeating: false, count: chars.count + 1)\n    dp[0] = true\n    \n    for i in 1...chars.count {\n        for j in 0..<i {\n            if dp[j] && words.contains(String(chars[j..<i])) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[chars.count]\n}",
        "complexity": {
          "time": "O(n²×m)",
          "space": "O(n)",
          "timeExplanation": "n² checks, string compare",
          "spaceExplanation": "DP array"
        },
        "testCases": [
          {
            "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
            "expectedOutput": "true",
            "explanation": "leet + code"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-break-ii"
    ]
  },
  "word-search": {
    "summary": "Find if word exists in grid. DFS/backtracking from each cell.",
    "approaches": [
      {
        "name": "DFS Backtracking",
        "intuition": "Try starting from each cell, explore adjacent cells.",
        "approach": "1. For each cell, start DFS\n2. Mark visited, try 4 directions\n3. Backtrack after exploring",
        "explanation": "Backtracking allows exploring alternative paths.",
        "code": "func exist(_ board: [[Character]], _ word: String) -> Bool {\n    var board = board\n    let m = board.count, n = board[0].count\n    let chars = Array(word)\n    \n    func dfs(_ i: Int, _ j: Int, _ k: Int) -> Bool {\n        if k == chars.count { return true }\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != chars[k] { return false }\n        let temp = board[i][j]\n        board[i][j] = \"#\"\n        let found = dfs(i+1,j,k+1) || dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i,j-1,k+1)\n        board[i][j] = temp\n        return found\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if dfs(i, j, 0) { return true }\n        }\n    }\n    return false\n}",
        "complexity": {
          "time": "O(m×n×4^L)",
          "space": "O(L)",
          "timeExplanation": "Each cell starts DFS",
          "spaceExplanation": "Recursion stack"
        },
        "testCases": [
          {
            "input": "board = [[\"A\",\"B\"],[\"C\",\"D\"]], word = \"ABCD\"",
            "expectedOutput": "false",
            "explanation": "No valid path"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-search-ii"
    ]
  },
  "number-of-islands": {
    "summary": "Count islands in grid. DFS/BFS from each '1', mark visited, count connected components.",
    "approaches": [
      {
        "name": "DFS Flood Fill",
        "intuition": "Each unvisited '1' starts a new island. DFS marks all connected land.",
        "approach": "1. Iterate through grid\n2. When '1' found, increment count and DFS\n3. DFS marks all connected '1's as visited",
        "explanation": "We sink each island we find by marking it as '0'.",
        "code": "func numIslands(_ grid: [[Character]]) -> Int {\n    var grid = grid\n    let m = grid.count, n = grid[0].count\n    var count = 0\n    \n    func dfs(_ i: Int, _ j: Int) {\n        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != \"1\" { return }\n        grid[i][j] = \"0\"\n        dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == \"1\" {\n                count += 1\n                dfs(i, j)\n            }\n        }\n    }\n    return count\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell once",
          "spaceExplanation": "Recursion stack worst case"
        },
        "testCases": [
          {
            "input": "grid = [[\"1\",\"1\",\"0\"],[\"1\",\"0\",\"0\"],[\"0\",\"0\",\"1\"]]",
            "expectedOutput": "2",
            "explanation": "Two islands"
          }
        ]
      }
    ],
    "relatedProblems": [
      "max-area-of-island",
      "surrounded-regions"
    ]
  },
  "max-area-of-island": {
    "summary": "Find maximum island area. DFS from each '1', count cells, track max.",
    "approaches": [
      {
        "name": "DFS with Count",
        "intuition": "Same as number of islands, but count cells in each island.",
        "approach": "1. DFS returns size of island\n2. Track maximum size seen",
        "explanation": "Each DFS call returns 1 + sum of recursive calls.",
        "code": "func maxAreaOfIsland(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let m = grid.count, n = grid[0].count\n    var maxArea = 0\n    \n    func dfs(_ i: Int, _ j: Int) -> Int {\n        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1 { return 0 }\n        grid[i][j] = 0\n        return 1 + dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1)\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                maxArea = max(maxArea, dfs(i, j))\n            }\n        }\n    }\n    return maxArea\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell once",
          "spaceExplanation": "Recursion stack"
        },
        "testCases": [
          {
            "input": "grid = [[0,1,1],[1,1,0],[0,0,1]]",
            "expectedOutput": "4",
            "explanation": "Largest island has 4 cells"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-islands"
    ]
  },
  "clone-graph": {
    "summary": "Deep copy undirected graph. BFS/DFS with hash map tracking original→clone.",
    "approaches": [
      {
        "name": "BFS with HashMap",
        "intuition": "Use map to track cloned nodes, BFS to visit all.",
        "approach": "1. Create map original→clone\n2. BFS from start node\n3. For each neighbor, clone if new, add to clone's neighbors",
        "explanation": "Map ensures each node cloned exactly once.",
        "code": "func cloneGraph(_ node: Node?) -> Node? {\n    guard let node = node else { return nil }\n    var map: [Node: Node] = [:]\n    var queue: [Node] = [node]\n    map[node] = Node(node.val)\n    \n    while !queue.isEmpty {\n        let curr = queue.removeFirst()\n        for neighbor in curr.neighbors {\n            if let neighbor = neighbor {\n                if map[neighbor] == nil {\n                    map[neighbor] = Node(neighbor.val)\n                    queue.append(neighbor)\n                }\n                map[curr]!.neighbors.append(map[neighbor])\n            }\n        }\n    }\n    return map[node]\n}",
        "complexity": {
          "time": "O(V+E)",
          "space": "O(V)",
          "timeExplanation": "Visit each node and edge",
          "spaceExplanation": "Map stores all nodes"
        },
        "testCases": [
          {
            "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
            "expectedOutput": "Deep copy",
            "explanation": "4 nodes connected"
          }
        ]
      }
    ],
    "relatedProblems": [
      "copy-list-with-random-pointer"
    ]
  },
  "pacific-atlantic-water-flow": {
    "summary": "Find cells that can reach both oceans. Reverse thinking: BFS/DFS from oceans inward.",
    "approaches": [
      {
        "name": "DFS from Oceans",
        "intuition": "Instead of checking each cell, start from ocean edges and go uphill.",
        "approach": "1. DFS from Pacific edge (top, left)\n2. DFS from Atlantic edge (bottom, right)\n3. Return cells reachable from both",
        "explanation": "Water flows downhill, so we reverse: can reach ocean = can go uphill from ocean.",
        "code": "func pacificAtlantic(_ heights: [[Int]]) -> [[Int]] {\n    let m = heights.count, n = heights[0].count\n    var pacific = Set<String>()\n    var atlantic = Set<String>()\n    \n    func dfs(_ i: Int, _ j: Int, _ visited: inout Set<String>, _ prevHeight: Int) {\n        let key = \"\\(i),\\(j)\"\n        if i < 0 || i >= m || j < 0 || j >= n { return }\n        if visited.contains(key) || heights[i][j] < prevHeight { return }\n        visited.insert(key)\n        dfs(i+1, j, &visited, heights[i][j])\n        dfs(i-1, j, &visited, heights[i][j])\n        dfs(i, j+1, &visited, heights[i][j])\n        dfs(i, j-1, &visited, heights[i][j])\n    }\n    \n    for i in 0..<m {\n        dfs(i, 0, &pacific, 0)\n        dfs(i, n-1, &atlantic, 0)\n    }\n    for j in 0..<n {\n        dfs(0, j, &pacific, 0)\n        dfs(m-1, j, &atlantic, 0)\n    }\n    \n    var result: [[Int]] = []\n    for i in 0..<m {\n        for j in 0..<n {\n            let key = \"\\(i),\\(j)\"\n            if pacific.contains(key) && atlantic.contains(key) {\n                result.append([i, j])\n            }\n        }\n    }\n    return result\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell at most twice",
          "spaceExplanation": "Two visited sets"
        },
        "testCases": [
          {
            "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
            "expectedOutput": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
            "explanation": "These cells reach both oceans"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-islands"
    ]
  },
  "course-schedule": {
    "summary": "Check if can finish all courses (no cycle in prerequisite graph). Topological sort or cycle detection.",
    "approaches": [
      {
        "name": "DFS Cycle Detection",
        "intuition": "Build graph, check for cycles using DFS with visiting state.",
        "approach": "1. Build adjacency list\n2. DFS with 3 states: unvisited, visiting, visited\n3. If we visit a 'visiting' node, cycle found",
        "explanation": "Visiting state means currently in DFS stack - back edge indicates cycle.",
        "code": "func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    for p in prerequisites {\n        graph[p[1]].append(p[0])\n    }\n    \n    var state = [Int](repeating: 0, count: numCourses) // 0=unvisited, 1=visiting, 2=visited\n    \n    func hasCycle(_ node: Int) -> Bool {\n        if state[node] == 1 { return true }  // Cycle\n        if state[node] == 2 { return false } // Already processed\n        state[node] = 1\n        for next in graph[node] {\n            if hasCycle(next) { return true }\n        }\n        state[node] = 2\n        return false\n    }\n    \n    for i in 0..<numCourses {\n        if hasCycle(i) { return false }\n    }\n    return true\n}",
        "complexity": {
          "time": "O(V+E)",
          "space": "O(V+E)",
          "timeExplanation": "Visit each node and edge",
          "spaceExplanation": "Graph + state array"
        },
        "testCases": [
          {
            "input": "numCourses = 2, prerequisites = [[1,0]]",
            "expectedOutput": "true",
            "explanation": "Take 0 then 1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "course-schedule-ii"
    ]
  },
  "course-schedule-ii": {
    "summary": "Return course order if possible. Topological sort using DFS or Kahn's algorithm.",
    "approaches": [
      {
        "name": "DFS Topological Sort",
        "intuition": "Post-order DFS gives reverse topological order.",
        "approach": "1. DFS with cycle detection\n2. Add node to result after processing all dependencies\n3. Reverse result for correct order",
        "explanation": "Post-order ensures prerequisites are processed before dependents.",
        "code": "func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n    var graph = [[Int]](repeating: [], count: numCourses)\n    for p in prerequisites {\n        graph[p[1]].append(p[0])\n    }\n    \n    var state = [Int](repeating: 0, count: numCourses)\n    var result: [Int] = []\n    \n    func dfs(_ node: Int) -> Bool {\n        if state[node] == 1 { return false }\n        if state[node] == 2 { return true }\n        state[node] = 1\n        for next in graph[node] {\n            if !dfs(next) { return false }\n        }\n        state[node] = 2\n        result.append(node)\n        return true\n    }\n    \n    for i in 0..<numCourses {\n        if !dfs(i) { return [] }\n    }\n    return result.reversed()\n}",
        "complexity": {
          "time": "O(V+E)",
          "space": "O(V+E)",
          "timeExplanation": "Visit each node and edge",
          "spaceExplanation": "Graph + result"
        },
        "testCases": [
          {
            "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
            "expectedOutput": "[0,1,2,3] or [0,2,1,3]",
            "explanation": "Valid orderings"
          }
        ]
      }
    ],
    "relatedProblems": [
      "course-schedule"
    ]
  },
  "graph-valid-tree": {
    "summary": "Check if graph is valid tree. Must be connected and have no cycles (n-1 edges).",
    "approaches": [
      {
        "name": "Union Find",
        "intuition": "Tree has n-1 edges and is connected. Check for cycles with Union Find.",
        "approach": "1. If edges != n-1, not a tree\n2. Union Find: if two nodes already connected, adding edge creates cycle\n3. Check all nodes connected",
        "explanation": "A tree with n nodes has exactly n-1 edges.",
        "code": "func validTree(_ n: Int, _ edges: [[Int]]) -> Bool {\n    if edges.count != n - 1 { return false }\n    \n    var parent = Array(0..<n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    func union(_ x: Int, _ y: Int) -> Bool {\n        let px = find(x), py = find(y)\n        if px == py { return false }\n        parent[px] = py\n        return true\n    }\n    \n    for edge in edges {\n        if !union(edge[0], edge[1]) { return false }\n    }\n    return true\n}",
        "complexity": {
          "time": "O(n × α(n))",
          "space": "O(n)",
          "timeExplanation": "Near-linear with path compression",
          "spaceExplanation": "Parent array"
        },
        "testCases": [
          {
            "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
            "expectedOutput": "true",
            "explanation": "Valid tree"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-connected-components-in-an-undirected-graph"
    ]
  },
  "number-of-connected-components-in-an-undirected-graph": {
    "summary": "Count connected components. Union Find or DFS from each unvisited node.",
    "approaches": [
      {
        "name": "Union Find",
        "intuition": "Union all edges, count unique roots.",
        "approach": "1. Initialize each node as its own parent\n2. Union nodes connected by edges\n3. Count unique roots",
        "explanation": "Each unique root represents a component.",
        "code": "func countComponents(_ n: Int, _ edges: [[Int]]) -> Int {\n    var parent = Array(0..<n)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let px = find(edge[0]), py = find(edge[1])\n        if px != py {\n            parent[px] = py\n        }\n    }\n    \n    var count = 0\n    for i in 0..<n {\n        if find(i) == i { count += 1 }\n    }\n    return count\n}",
        "complexity": {
          "time": "O(n + e × α(n))",
          "space": "O(n)",
          "timeExplanation": "Process all edges",
          "spaceExplanation": "Parent array"
        },
        "testCases": [
          {
            "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
            "expectedOutput": "2",
            "explanation": "Two components: {0,1,2} and {3,4}"
          }
        ]
      }
    ],
    "relatedProblems": [
      "graph-valid-tree"
    ]
  },
  "redundant-connection": {
    "summary": "Find edge that creates cycle in tree. Union Find: first edge connecting already-connected nodes.",
    "approaches": [
      {
        "name": "Union Find",
        "intuition": "Process edges, return first one that connects nodes already in same component.",
        "approach": "1. Union Find on edges in order\n2. If union fails (same component), return that edge",
        "explanation": "The redundant edge is the one that would create a cycle.",
        "code": "func findRedundantConnection(_ edges: [[Int]]) -> [Int] {\n    var parent = Array(0...edges.count)\n    \n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n    \n    for edge in edges {\n        let px = find(edge[0]), py = find(edge[1])\n        if px == py {\n            return edge\n        }\n        parent[px] = py\n    }\n    return []\n}",
        "complexity": {
          "time": "O(n × α(n))",
          "space": "O(n)",
          "timeExplanation": "Process each edge",
          "spaceExplanation": "Parent array"
        },
        "testCases": [
          {
            "input": "edges = [[1,2],[1,3],[2,3]]",
            "expectedOutput": "[2,3]",
            "explanation": "[2,3] creates cycle"
          }
        ]
      }
    ],
    "relatedProblems": [
      "graph-valid-tree"
    ]
  },
  "word-ladder": {
    "summary": "Find shortest transformation sequence. BFS treating words as graph nodes.",
    "approaches": [
      {
        "name": "BFS",
        "intuition": "BFS finds shortest path. Each word connects to words differing by one letter.",
        "approach": "1. Build graph or check neighbors on-the-fly\n2. BFS from beginWord\n3. Count steps to reach endWord",
        "explanation": "BFS guarantees shortest path in unweighted graph.",
        "code": "func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n    var wordSet = Set(wordList)\n    if !wordSet.contains(endWord) { return 0 }\n    \n    var queue: [(String, Int)] = [(beginWord, 1)]\n    wordSet.remove(beginWord)\n    \n    while !queue.isEmpty {\n        let (word, steps) = queue.removeFirst()\n        if word == endWord { return steps }\n        \n        var chars = Array(word)\n        for i in 0..<chars.count {\n            let original = chars[i]\n            for c in \"abcdefghijklmnopqrstuvwxyz\" {\n                chars[i] = c\n                let newWord = String(chars)\n                if wordSet.contains(newWord) {\n                    queue.append((newWord, steps + 1))\n                    wordSet.remove(newWord)\n                }\n            }\n            chars[i] = original\n        }\n    }\n    return 0\n}",
        "complexity": {
          "time": "O(n × m × 26)",
          "space": "O(n × m)",
          "timeExplanation": "n words, m length, 26 letters",
          "spaceExplanation": "Word set and queue"
        },
        "testCases": [
          {
            "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
            "expectedOutput": "5",
            "explanation": "hit→hot→dot→dog→cog"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-ladder-ii"
    ]
  },
  "climbing-stairs": {
    "summary": "Count ways to climb n stairs (1 or 2 steps). dp[i] = dp[i-1] + dp[i-2]. Fibonacci pattern.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "To reach step i, come from step i-1 (1 step) or i-2 (2 steps).",
        "approach": "1. Base: dp[1]=1, dp[2]=2\n2. dp[i] = dp[i-1] + dp[i-2]",
        "explanation": "This is the Fibonacci sequence.",
        "code": "func climbStairs(_ n: Int) -> Int {\n    if n <= 2 { return n }\n    var prev2 = 1, prev1 = 2\n    for _ in 3...n {\n        let curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    }\n    return prev1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single loop",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "n = 3",
            "expectedOutput": "3",
            "explanation": "1+1+1, 1+2, 2+1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "min-cost-climbing-stairs"
    ]
  },
  "min-cost-climbing-stairs": {
    "summary": "Minimum cost to climb stairs. dp[i] = cost[i] + min(dp[i-1], dp[i-2]).",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "At each step, choose cheaper path from previous two steps.",
        "approach": "1. Can start at index 0 or 1\n2. dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n3. Answer is min(dp[n-1], dp[n-2])",
        "explanation": "We can reach the top from either of the last two steps.",
        "code": "func minCostClimbingStairs(_ cost: [Int]) -> Int {\n    var prev2 = cost[0], prev1 = cost[1]\n    for i in 2..<cost.count {\n        let curr = cost[i] + min(prev1, prev2)\n        prev2 = prev1\n        prev1 = curr\n    }\n    return min(prev1, prev2)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single loop",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "cost = [10,15,20]",
            "expectedOutput": "15",
            "explanation": "Start at 1, jump to top"
          }
        ]
      }
    ],
    "relatedProblems": [
      "climbing-stairs"
    ]
  },
  "house-robber": {
    "summary": "Max money robbing non-adjacent houses. dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "At each house, choose: skip it or rob it (can't rob previous).",
        "approach": "1. dp[i] = max(skip, rob)\n2. skip = dp[i-1]\n3. rob = dp[i-2] + nums[i]",
        "explanation": "Either take current house + best from 2 ago, or skip and keep previous best.",
        "code": "func rob(_ nums: [Int]) -> Int {\n    if nums.count == 1 { return nums[0] }\n    var prev2 = nums[0]\n    var prev1 = max(nums[0], nums[1])\n    for i in 2..<nums.count {\n        let curr = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = curr\n    }\n    return prev1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single loop",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "nums = [2,7,9,3,1]",
            "expectedOutput": "12",
            "explanation": "Rob 2 + 9 + 1 = 12"
          }
        ]
      }
    ],
    "relatedProblems": [
      "house-robber-ii"
    ]
  },
  "house-robber-ii": {
    "summary": "Houses in circle. Run house robber twice: exclude first or exclude last.",
    "approaches": [
      {
        "name": "Two Passes",
        "intuition": "Circle means first and last can't both be robbed. Try both scenarios.",
        "approach": "1. Rob houses [0..n-2] (exclude last)\n2. Rob houses [1..n-1] (exclude first)\n3. Return max of both",
        "explanation": "By excluding one end, we break the circle.",
        "code": "func rob(_ nums: [Int]) -> Int {\n    if nums.count == 1 { return nums[0] }\n    if nums.count == 2 { return max(nums[0], nums[1]) }\n    \n    func robRange(_ start: Int, _ end: Int) -> Int {\n        var prev2 = nums[start]\n        var prev1 = max(nums[start], nums[start + 1])\n        for i in (start + 2)...end {\n            let curr = max(prev1, prev2 + nums[i])\n            prev2 = prev1\n            prev1 = curr\n        }\n        return prev1\n    }\n    \n    return max(robRange(0, nums.count - 2), robRange(1, nums.count - 1))\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Two passes",
          "spaceExplanation": "Constant space"
        },
        "testCases": [
          {
            "input": "nums = [2,3,2]",
            "expectedOutput": "3",
            "explanation": "Can't rob both 2s, rob middle 3"
          }
        ]
      }
    ],
    "relatedProblems": [
      "house-robber"
    ]
  },
  "longest-increasing-subsequence": {
    "summary": "Find length of LIS. DP: dp[i] = max length ending at i. Or binary search for O(n log n).",
    "approaches": [
      {
        "name": "Binary Search",
        "intuition": "Maintain smallest tail for each LIS length. Binary search to find position.",
        "approach": "1. tails[i] = smallest tail of LIS of length i+1\n2. For each num, binary search for position\n3. Update tails",
        "explanation": "If num > all tails, extend LIS. Otherwise, replace smallest tail >= num.",
        "code": "func lengthOfLIS(_ nums: [Int]) -> Int {\n    var tails: [Int] = []\n    \n    for num in nums {\n        var left = 0, right = tails.count\n        while left < right {\n            let mid = (left + right) / 2\n            if tails[mid] < num {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n        if left == tails.count {\n            tails.append(num)\n        } else {\n            tails[left] = num\n        }\n    }\n    return tails.count\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "n elements, binary search each",
          "spaceExplanation": "Tails array"
        },
        "testCases": [
          {
            "input": "nums = [10,9,2,5,3,7,101,18]",
            "expectedOutput": "4",
            "explanation": "[2,3,7,101] or [2,5,7,18]"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-longest-increasing-subsequence"
    ]
  },
  "coin-change": {
    "summary": "Minimum coins to make amount. dp[i] = min(dp[i-coin] + 1) for all coins.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "Build up from smaller amounts. For each amount, try all coins.",
        "approach": "1. dp[0] = 0\n2. For each amount 1 to target:\n   dp[i] = min(dp[i], dp[i-coin] + 1) for all coins",
        "explanation": "We compute minimum coins for each amount, using previously computed values.",
        "code": "func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n    var dp = [Int](repeating: amount + 1, count: amount + 1)\n    dp[0] = 0\n    \n    for i in 1...amount {\n        for coin in coins {\n            if coin <= i {\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n            }\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount]\n}",
        "complexity": {
          "time": "O(amount × coins)",
          "space": "O(amount)",
          "timeExplanation": "Nested loops",
          "spaceExplanation": "DP array"
        },
        "testCases": [
          {
            "input": "coins = [1,2,5], amount = 11",
            "expectedOutput": "3",
            "explanation": "5+5+1=11"
          }
        ]
      }
    ],
    "relatedProblems": [
      "coin-change-ii"
    ]
  },
  "coin-change-ii": {
    "summary": "Count ways to make amount. dp[i] += dp[i-coin] for each coin.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "Count combinations (order doesn't matter). Process coins then amounts.",
        "approach": "1. dp[0] = 1 (one way to make 0)\n2. For each coin, update dp[coin..amount]\n3. dp[i] += dp[i-coin]",
        "explanation": "Processing coins outer loop avoids counting permutations.",
        "code": "func change(_ amount: Int, _ coins: [Int]) -> Int {\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1\n    \n    for coin in coins {\n        for i in coin...amount {\n            dp[i] += dp[i - coin]\n        }\n    }\n    return dp[amount]\n}",
        "complexity": {
          "time": "O(amount × coins)",
          "space": "O(amount)",
          "timeExplanation": "Nested loops",
          "spaceExplanation": "DP array"
        },
        "testCases": [
          {
            "input": "amount = 5, coins = [1,2,5]",
            "expectedOutput": "4",
            "explanation": "5, 2+2+1, 2+1+1+1, 1+1+1+1+1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "coin-change"
    ]
  },
  "longest-common-subsequence": {
    "summary": "Length of LCS of two strings. 2D DP: if match, dp[i][j] = dp[i-1][j-1] + 1.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "dp[i][j] = LCS of first i chars of text1 and first j chars of text2.",
        "approach": "1. If chars match: dp[i][j] = dp[i-1][j-1] + 1\n2. Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "explanation": "Match extends LCS; mismatch takes best of excluding either char.",
        "code": "func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n    let s1 = Array(text1), s2 = Array(text2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1] + 1\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[m][n]\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Fill m×n table",
          "spaceExplanation": "2D DP table"
        },
        "testCases": [
          {
            "input": "text1 = \"abcde\", text2 = \"ace\"",
            "expectedOutput": "3",
            "explanation": "LCS is \"ace\""
          }
        ]
      }
    ],
    "relatedProblems": [
      "edit-distance"
    ]
  },
  "edit-distance": {
    "summary": "Minimum operations to convert word1 to word2. 2D DP with insert/delete/replace.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "dp[i][j] = min operations to convert first i chars to first j chars.",
        "approach": "1. If chars match: dp[i][j] = dp[i-1][j-1]\n2. Else: dp[i][j] = 1 + min(insert, delete, replace)",
        "explanation": "insert=dp[i][j-1], delete=dp[i-1][j], replace=dp[i-1][j-1]",
        "code": "func minDistance(_ word1: String, _ word2: String) -> Int {\n    let s1 = Array(word1), s2 = Array(word2)\n    let m = s1.count, n = s2.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n    \n    for i in 0...m { dp[i][0] = i }\n    for j in 0...n { dp[0][j] = j }\n    \n    for i in 1...m {\n        for j in 1...n {\n            if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\n            }\n        }\n    }\n    return dp[m][n]\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Fill m×n table",
          "spaceExplanation": "2D DP table"
        },
        "testCases": [
          {
            "input": "word1 = \"horse\", word2 = \"ros\"",
            "expectedOutput": "3",
            "explanation": "horse→rorse→rose→ros"
          }
        ]
      }
    ],
    "relatedProblems": [
      "longest-common-subsequence"
    ]
  },
  "unique-paths": {
    "summary": "Count paths from top-left to bottom-right. dp[i][j] = dp[i-1][j] + dp[i][j-1].",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "Can only come from top or left. Sum both possibilities.",
        "approach": "1. First row and column are all 1s\n2. dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "explanation": "Each cell is sum of ways to reach cell above and cell to left.",
        "code": "func uniquePaths(_ m: Int, _ n: Int) -> Int {\n    var dp = [[Int]](repeating: [Int](repeating: 1, count: n), count: m)\n    for i in 1..<m {\n        for j in 1..<n {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        }\n    }\n    return dp[m-1][n-1]\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Fill grid",
          "spaceExplanation": "2D DP table"
        },
        "testCases": [
          {
            "input": "m = 3, n = 7",
            "expectedOutput": "28",
            "explanation": "28 unique paths"
          }
        ]
      }
    ],
    "relatedProblems": [
      "unique-paths-ii",
      "minimum-path-sum"
    ]
  },
  "decode-ways": {
    "summary": "Count ways to decode number string. dp[i] based on single and double digit validity.",
    "approaches": [
      {
        "name": "Dynamic Programming",
        "intuition": "Each position can be decoded as 1 digit or 2 digits (if valid).",
        "approach": "1. If s[i] != '0', dp[i] += dp[i-1]\n2. If s[i-1..i] is 10-26, dp[i] += dp[i-2]",
        "explanation": "Check validity of single and double digit decodings.",
        "code": "func numDecodings(_ s: String) -> Int {\n    let chars = Array(s)\n    if chars[0] == \"0\" { return 0 }\n    let n = chars.count\n    var prev2 = 1, prev1 = 1\n    \n    for i in 1..<n {\n        var curr = 0\n        if chars[i] != \"0\" {\n            curr += prev1\n        }\n        let twoDigit = Int(String(chars[i-1...i]))!\n        if twoDigit >= 10 && twoDigit <= 26 {\n            curr += prev2\n        }\n        prev2 = prev1\n        prev1 = curr\n    }\n    return prev1\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "s = \"226\"",
            "expectedOutput": "3",
            "explanation": "2,2,6 or 22,6 or 2,26"
          }
        ]
      }
    ],
    "relatedProblems": [
      "decode-ways-ii"
    ]
  },
  "jump-game": {
    "summary": "Can reach last index? Greedy: track farthest reachable position.",
    "approaches": [
      {
        "name": "Greedy",
        "intuition": "Track maximum reachable index. If current index > max reachable, stuck.",
        "approach": "1. maxReach = 0\n2. For each index <= maxReach:\n   maxReach = max(maxReach, i + nums[i])\n3. Return maxReach >= last index",
        "explanation": "If we can reach position i, we can reach any position up to i + nums[i].",
        "code": "func canJump(_ nums: [Int]) -> Bool {\n    var maxReach = 0\n    for i in 0..<nums.count {\n        if i > maxReach { return false }\n        maxReach = max(maxReach, i + nums[i])\n    }\n    return true\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "One variable"
        },
        "testCases": [
          {
            "input": "nums = [2,3,1,1,4]",
            "expectedOutput": "true",
            "explanation": "Jump 1→2→4 or 1→3→4"
          }
        ]
      }
    ],
    "relatedProblems": [
      "jump-game-ii"
    ]
  },
  "binary-search": {
    "summary": "Find target in sorted array. Classic binary search: compare mid, narrow half.",
    "approaches": [
      {
        "name": "Binary Search",
        "intuition": "Sorted array allows eliminating half the search space each step.",
        "approach": "1. left=0, right=n-1\n2. mid = (left+right)/2\n3. If nums[mid]==target, return mid\n4. If target<mid, search left; else search right",
        "explanation": "Each comparison eliminates half the remaining elements.",
        "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0, right = nums.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if nums[mid] == target { return mid }\n        if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Halve search space each step",
          "spaceExplanation": "Two pointers"
        },
        "testCases": [
          {
            "input": "nums = [-1,0,3,5,9,12], target = 9",
            "expectedOutput": "4",
            "explanation": "9 is at index 4"
          }
        ]
      }
    ],
    "relatedProblems": [
      "search-in-rotated-sorted-array"
    ]
  },
  "search-in-rotated-sorted-array": {
    "summary": "Binary search in rotated sorted array. Identify sorted half, check if target in that half.",
    "approaches": [
      {
        "name": "Modified Binary Search",
        "intuition": "One half is always sorted. Check if target is in sorted half.",
        "approach": "1. Find mid\n2. Determine which half is sorted\n3. Check if target is in sorted half\n4. Narrow search accordingly",
        "explanation": "At least one half is sorted after rotation.",
        "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0, right = nums.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if nums[mid] == target { return mid }\n        \n        if nums[left] <= nums[mid] {  // Left half sorted\n            if target >= nums[left] && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {  // Right half sorted\n            if target > nums[mid] && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Binary search",
          "spaceExplanation": "Two pointers"
        },
        "testCases": [
          {
            "input": "nums = [4,5,6,7,0,1,2], target = 0",
            "expectedOutput": "4",
            "explanation": "0 is at index 4"
          }
        ]
      }
    ],
    "relatedProblems": [
      "find-minimum-in-rotated-sorted-array"
    ]
  },
  "search-a-2d-matrix-ii": {
    "summary": "Search in row-sorted and column-sorted matrix. Start from top-right, eliminate row or column.",
    "approaches": [
      {
        "name": "Staircase Search",
        "intuition": "From top-right: if target < current, go left; if target > current, go down.",
        "approach": "1. Start at top-right (or bottom-left)\n2. If current == target, found\n3. If target < current, move left\n4. If target > current, move down",
        "explanation": "Each step eliminates a row or column.",
        "code": "func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n    let m = matrix.count, n = matrix[0].count\n    var row = 0, col = n - 1\n    \n    while row < m && col >= 0 {\n        if matrix[row][col] == target { return true }\n        if matrix[row][col] > target {\n            col -= 1\n        } else {\n            row += 1\n        }\n    }\n    return false\n}",
        "complexity": {
          "time": "O(m+n)",
          "space": "O(1)",
          "timeExplanation": "At most m+n steps",
          "spaceExplanation": "Two pointers"
        },
        "testCases": [
          {
            "input": "matrix = [[1,4,7],[2,5,8],[3,6,9]], target = 5",
            "expectedOutput": "true",
            "explanation": "5 found in matrix"
          }
        ]
      }
    ],
    "relatedProblems": [
      "search-a-2d-matrix"
    ]
  },
  "first-bad-version": {
    "summary": "Find first bad version using binary search. Minimize calls to isBadVersion API.",
    "approaches": [
      {
        "name": "Binary Search",
        "intuition": "Binary search for leftmost bad version.",
        "approach": "1. If mid is bad, answer is mid or before\n2. If mid is good, answer is after mid",
        "explanation": "Find boundary where versions change from good to bad.",
        "code": "func firstBadVersion(_ n: Int) -> Int {\n    var left = 1, right = n\n    while left < right {\n        let mid = left + (right - left) / 2\n        if isBadVersion(mid) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Binary search",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "n = 5, bad = 4",
            "expectedOutput": "4",
            "explanation": "First bad is version 4"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-search"
    ]
  },
  "find-peak-element": {
    "summary": "Find any peak (greater than neighbors). Binary search: move toward larger neighbor.",
    "approaches": [
      {
        "name": "Binary Search",
        "intuition": "If nums[mid] < nums[mid+1], peak exists on right. Else on left (including mid).",
        "approach": "1. Compare mid with mid+1\n2. If mid < mid+1, peak is on right\n3. Else peak is on left (mid could be peak)",
        "explanation": "Always move toward the higher element; guaranteed to find a peak.",
        "code": "func findPeakElement(_ nums: [Int]) -> Int {\n    var left = 0, right = nums.count - 1\n    while left < right {\n        let mid = left + (right - left) / 2\n        if nums[mid] < nums[mid + 1] {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    return left\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Binary search",
          "spaceExplanation": "Two pointers"
        },
        "testCases": [
          {
            "input": "nums = [1,2,1,3,5,6,4]",
            "expectedOutput": "5",
            "explanation": "Peak at index 5 (value 6)"
          }
        ]
      }
    ],
    "relatedProblems": [
      "find-minimum-in-rotated-sorted-array"
    ]
  },
  "subsets": {
    "summary": "Generate all subsets. Backtracking: include/exclude each element, or iterative doubling.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "For each element, choose to include or exclude it.",
        "approach": "1. Start with empty subset\n2. For each element, branch: include or exclude\n3. When all elements processed, add subset to result",
        "explanation": "Decision tree with 2^n leaves.",
        "code": "func subsets(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    \n    func backtrack(_ index: Int) {\n        if index == nums.count {\n            result.append(current)\n            return\n        }\n        // Exclude nums[index]\n        backtrack(index + 1)\n        // Include nums[index]\n        current.append(nums[index])\n        backtrack(index + 1)\n        current.removeLast()\n    }\n    \n    backtrack(0)\n    return result\n}",
        "complexity": {
          "time": "O(n × 2^n)",
          "space": "O(n)",
          "timeExplanation": "2^n subsets, O(n) to copy each",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "nums = [1,2,3]",
            "expectedOutput": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
            "explanation": "All 8 subsets"
          }
        ]
      }
    ],
    "relatedProblems": [
      "subsets-ii",
      "combinations"
    ]
  },
  "subsets-ii": {
    "summary": "Subsets with duplicates. Sort first, skip consecutive duplicates at same level.",
    "approaches": [
      {
        "name": "Backtracking with Skip",
        "intuition": "Sort array, skip duplicates to avoid duplicate subsets.",
        "approach": "1. Sort array\n2. In backtracking, skip if nums[i] == nums[i-1] at same level\n3. Continue as normal subsets",
        "explanation": "Sorting groups duplicates; skipping avoids redundant branches.",
        "code": "func subsetsWithDup(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = nums.sorted()\n    \n    func backtrack(_ start: Int) {\n        result.append(current)\n        for i in start..<sorted.count {\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
        "complexity": {
          "time": "O(n × 2^n)",
          "space": "O(n)",
          "timeExplanation": "Still 2^n subsets max",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "nums = [1,2,2]",
            "expectedOutput": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
            "explanation": "No duplicate subsets"
          }
        ]
      }
    ],
    "relatedProblems": [
      "subsets"
    ]
  },
  "permutations": {
    "summary": "Generate all permutations. Backtracking: swap each element to each position.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "Build permutation by choosing unused elements for each position.",
        "approach": "1. Track used elements\n2. Add unused element, recurse\n3. Backtrack (remove element, mark unused)",
        "explanation": "Each position has decreasing choices: n, n-1, ..., 1.",
        "code": "func permute(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    var used = [Bool](repeating: false, count: nums.count)\n    \n    func backtrack() {\n        if current.count == nums.count {\n            result.append(current)\n            return\n        }\n        for i in 0..<nums.count {\n            if used[i] { continue }\n            used[i] = true\n            current.append(nums[i])\n            backtrack()\n            current.removeLast()\n            used[i] = false\n        }\n    }\n    \n    backtrack()\n    return result\n}",
        "complexity": {
          "time": "O(n × n!)",
          "space": "O(n)",
          "timeExplanation": "n! permutations, O(n) to copy",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "nums = [1,2,3]",
            "expectedOutput": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
            "explanation": "All 6 permutations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "permutations-ii",
      "next-permutation"
    ]
  },
  "permutations-ii": {
    "summary": "Permutations with duplicates. Sort, skip duplicates if previous same element not used.",
    "approaches": [
      {
        "name": "Backtracking with Skip",
        "intuition": "Sort to group duplicates, skip if same as previous and previous not used.",
        "approach": "1. Sort array\n2. Skip if nums[i] == nums[i-1] and !used[i-1]",
        "explanation": "Only use duplicate if all previous duplicates are already used.",
        "code": "func permuteUnique(_ nums: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = nums.sorted()\n    var used = [Bool](repeating: false, count: nums.count)\n    \n    func backtrack() {\n        if current.count == sorted.count {\n            result.append(current)\n            return\n        }\n        for i in 0..<sorted.count {\n            if used[i] { continue }\n            if i > 0 && sorted[i] == sorted[i-1] && !used[i-1] { continue }\n            used[i] = true\n            current.append(sorted[i])\n            backtrack()\n            current.removeLast()\n            used[i] = false\n        }\n    }\n    \n    backtrack()\n    return result\n}",
        "complexity": {
          "time": "O(n × n!)",
          "space": "O(n)",
          "timeExplanation": "At most n! permutations",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "nums = [1,1,2]",
            "expectedOutput": "[[1,1,2],[1,2,1],[2,1,1]]",
            "explanation": "3 unique permutations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "permutations"
    ]
  },
  "combination-sum": {
    "summary": "Find combinations summing to target, can reuse elements. Backtracking with remaining target.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "Try each candidate, subtract from target, allow reuse (start from same index).",
        "approach": "1. If target == 0, found valid combination\n2. For each candidate >= current, try including it\n3. Recurse with reduced target",
        "explanation": "Starting from same index allows reuse; sorting helps early termination.",
        "code": "func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = candidates.sorted()\n    \n    func backtrack(_ start: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        for i in start..<sorted.count {\n            if sorted[i] > remaining { break }\n            current.append(sorted[i])\n            backtrack(i, remaining - sorted[i])\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
        "complexity": {
          "time": "O(n^(t/m))",
          "space": "O(t/m)",
          "timeExplanation": "t=target, m=min candidate",
          "spaceExplanation": "Max recursion depth"
        },
        "testCases": [
          {
            "input": "candidates = [2,3,6,7], target = 7",
            "expectedOutput": "[[2,2,3],[7]]",
            "explanation": "Two valid combinations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "combination-sum-ii",
      "combination-sum-iii"
    ]
  },
  "combination-sum-ii": {
    "summary": "Combination sum, each number used once. Sort, skip duplicates at same level.",
    "approaches": [
      {
        "name": "Backtracking with Skip",
        "intuition": "Sort array, move to next index after use, skip consecutive duplicates.",
        "approach": "1. Sort candidates\n2. Move to i+1 after using candidate[i]\n3. Skip if candidates[i] == candidates[i-1] at same level",
        "explanation": "Each candidate used at most once by moving index forward.",
        "code": "func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var current: [Int] = []\n    let sorted = candidates.sorted()\n    \n    func backtrack(_ start: Int, _ remaining: Int) {\n        if remaining == 0 {\n            result.append(current)\n            return\n        }\n        for i in start..<sorted.count {\n            if sorted[i] > remaining { break }\n            if i > start && sorted[i] == sorted[i-1] { continue }\n            current.append(sorted[i])\n            backtrack(i + 1, remaining - sorted[i])\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, target)\n    return result\n}",
        "complexity": {
          "time": "O(2^n)",
          "space": "O(n)",
          "timeExplanation": "At most 2^n combinations",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "candidates = [10,1,2,7,6,1,5], target = 8",
            "expectedOutput": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
            "explanation": "Four valid combinations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "combination-sum"
    ]
  },
  "letter-combinations-of-a-phone-number": {
    "summary": "Generate all letter combinations from phone digits. Backtracking with digit-to-letters map.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "For each digit, try each corresponding letter.",
        "approach": "1. Map digits to letters\n2. For each digit, iterate through its letters\n3. Recurse to next digit",
        "explanation": "Build combinations character by character.",
        "code": "func letterCombinations(_ digits: String) -> [String] {\n    if digits.isEmpty { return [] }\n    let map: [Character: String] = [\n        \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n        \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"\n    ]\n    let digits = Array(digits)\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ index: Int) {\n        if index == digits.count {\n            result.append(current)\n            return\n        }\n        for char in map[digits[index]]! {\n            current.append(char)\n            backtrack(index + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
        "complexity": {
          "time": "O(4^n)",
          "space": "O(n)",
          "timeExplanation": "At most 4 letters per digit",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "digits = \"23\"",
            "expectedOutput": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
            "explanation": "All combinations of 2(abc) and 3(def)"
          }
        ]
      }
    ],
    "relatedProblems": [
      "generate-parentheses"
    ]
  },
  "generate-parentheses": {
    "summary": "Generate all valid n pairs of parentheses. Backtracking: add ( if open < n, add ) if close < open.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "Can add '(' if haven't used all n, can add ')' if more '(' than ')'.",
        "approach": "1. Track open and close counts\n2. Add '(' if open < n\n3. Add ')' if close < open\n4. When length == 2n, valid combination",
        "explanation": "Ensures we never have more ')' than '(' at any point.",
        "code": "func generateParenthesis(_ n: Int) -> [String] {\n    var result: [String] = []\n    var current = \"\"\n    \n    func backtrack(_ open: Int, _ close: Int) {\n        if current.count == 2 * n {\n            result.append(current)\n            return\n        }\n        if open < n {\n            current.append(\"(\")\n            backtrack(open + 1, close)\n            current.removeLast()\n        }\n        if close < open {\n            current.append(\")\")\n            backtrack(open, close + 1)\n            current.removeLast()\n        }\n    }\n    \n    backtrack(0, 0)\n    return result\n}",
        "complexity": {
          "time": "O(4^n / √n)",
          "space": "O(n)",
          "timeExplanation": "Catalan number",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "n = 3",
            "expectedOutput": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
            "explanation": "5 valid combinations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "valid-parentheses"
    ]
  },
  "n-queens": {
    "summary": "Place n queens on n×n board. Backtracking: place row by row, check column and diagonal conflicts.",
    "approaches": [
      {
        "name": "Backtracking",
        "intuition": "Place one queen per row, track attacked columns and diagonals.",
        "approach": "1. Try placing queen in each column of current row\n2. Check if column, main diagonal, anti-diagonal are free\n3. Mark and recurse, then backtrack",
        "explanation": "Diagonals identified by row-col (main) and row+col (anti).",
        "code": "func solveNQueens(_ n: Int) -> [[String]] {\n    var result: [[String]] = []\n    var board = [[Character]](repeating: [Character](repeating: \".\", count: n), count: n)\n    var cols = Set<Int>(), diag1 = Set<Int>(), diag2 = Set<Int>()\n    \n    func backtrack(_ row: Int) {\n        if row == n {\n            result.append(board.map { String($0) })\n            return\n        }\n        for col in 0..<n {\n            if cols.contains(col) || diag1.contains(row-col) || diag2.contains(row+col) { continue }\n            board[row][col] = \"Q\"\n            cols.insert(col); diag1.insert(row-col); diag2.insert(row+col)\n            backtrack(row + 1)\n            board[row][col] = \".\"\n            cols.remove(col); diag1.remove(row-col); diag2.remove(row+col)\n        }\n    }\n    \n    backtrack(0)\n    return result\n}",
        "complexity": {
          "time": "O(n!)",
          "space": "O(n²)",
          "timeExplanation": "Roughly n! placements tried",
          "spaceExplanation": "Board storage"
        },
        "testCases": [
          {
            "input": "n = 4",
            "expectedOutput": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
            "explanation": "Two solutions for 4-queens"
          }
        ]
      }
    ],
    "relatedProblems": [
      "n-queens-ii"
    ]
  },
  "top-k-frequent-elements": {
    "summary": "Find k most frequent elements. Count frequencies, use heap or bucket sort.",
    "approaches": [
      {
        "name": "Bucket Sort",
        "intuition": "Frequency can be at most n. Use frequency as index into buckets.",
        "approach": "1. Count frequencies\n2. Create buckets by frequency\n3. Collect k elements from highest buckets",
        "explanation": "O(n) time using bucket sort instead of heap.",
        "code": "func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var count: [Int: Int] = [:]\n    for num in nums { count[num, default: 0] += 1 }\n    \n    var buckets = [[Int]](repeating: [], count: nums.count + 1)\n    for (num, freq) in count {\n        buckets[freq].append(num)\n    }\n    \n    var result: [Int] = []\n    for i in stride(from: nums.count, through: 1, by: -1) {\n        for num in buckets[i] {\n            result.append(num)\n            if result.count == k { return result }\n        }\n    }\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Linear with bucket sort",
          "spaceExplanation": "Buckets and count map"
        },
        "testCases": [
          {
            "input": "nums = [1,1,1,2,2,3], k = 2",
            "expectedOutput": "[1,2]",
            "explanation": "1 appears 3 times, 2 appears 2 times"
          }
        ]
      }
    ],
    "relatedProblems": [
      "kth-largest-element-in-an-array"
    ]
  },
  "kth-largest-element-in-an-array": {
    "summary": "Find kth largest element. Use min-heap of size k, or quickselect.",
    "approaches": [
      {
        "name": "Quickselect",
        "intuition": "Partition like quicksort, but only recurse into relevant half.",
        "approach": "1. Partition array around pivot\n2. If pivot at k-1, found\n3. Else recurse into correct half",
        "explanation": "Average O(n) as we only search one partition.",
        "code": "func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n    var nums = nums\n    let target = nums.count - k\n    \n    func partition(_ left: Int, _ right: Int) -> Int {\n        let pivot = nums[right]\n        var i = left\n        for j in left..<right {\n            if nums[j] < pivot {\n                nums.swapAt(i, j)\n                i += 1\n            }\n        }\n        nums.swapAt(i, right)\n        return i\n    }\n    \n    var left = 0, right = nums.count - 1\n    while left <= right {\n        let p = partition(left, right)\n        if p == target { return nums[p] }\n        if p < target { left = p + 1 }\n        else { right = p - 1 }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(n) average",
          "space": "O(1)",
          "timeExplanation": "Quickselect average case",
          "spaceExplanation": "In-place"
        },
        "testCases": [
          {
            "input": "nums = [3,2,1,5,6,4], k = 2",
            "expectedOutput": "5",
            "explanation": "Second largest is 5"
          }
        ]
      }
    ],
    "relatedProblems": [
      "top-k-frequent-elements"
    ]
  },
  "find-median-from-data-stream": {
    "summary": "Track median of streaming data. Two heaps: max-heap for lower half, min-heap for upper half.",
    "approaches": [
      {
        "name": "Two Heaps",
        "intuition": "Keep lower half in max-heap, upper half in min-heap. Median is at tops.",
        "approach": "1. Add to max-heap (lower)\n2. Balance: move max to min-heap if needed\n3. Keep sizes equal or max-heap one larger",
        "explanation": "Median is either max-heap top (odd count) or average of both tops.",
        "code": "class MedianFinder {\n    var lower: [Int] = []  // max-heap (negate values)\n    var upper: [Int] = []  // min-heap\n    \n    func addNum(_ num: Int) {\n        lower.append(-num)\n        lower.sort()\n        upper.append(-lower.removeFirst())\n        upper.sort()\n        if upper.count > lower.count {\n            lower.append(-upper.removeFirst())\n            lower.sort()\n        }\n    }\n    \n    func findMedian() -> Double {\n        if lower.count > upper.count {\n            return Double(-lower.first!)\n        }\n        return Double(-lower.first! + upper.first!) / 2.0\n    }\n}",
        "complexity": {
          "time": "O(log n) add, O(1) find",
          "space": "O(n)",
          "timeExplanation": "Heap operations",
          "spaceExplanation": "Store all numbers"
        },
        "testCases": [
          {
            "input": "addNum(1), addNum(2), findMedian(), addNum(3), findMedian()",
            "expectedOutput": "1.5, 2.0",
            "explanation": "Median updates as numbers added"
          }
        ]
      }
    ],
    "relatedProblems": [
      "sliding-window-median"
    ]
  },
  "merge-k-sorted-lists": {
    "summary": "Merge k sorted linked lists. Use min-heap to always get smallest node.",
    "approaches": [
      {
        "name": "Min Heap",
        "intuition": "Always pick smallest among all list heads. Use heap for efficient min.",
        "approach": "1. Add all list heads to min-heap\n2. Pop smallest, add to result\n3. Push next node from that list\n4. Repeat until heap empty",
        "explanation": "Heap maintains k elements, one from each list.",
        "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    var heap: [(Int, ListNode)] = []\n    for list in lists {\n        if let node = list {\n            heap.append((node.val, node))\n        }\n    }\n    heap.sort { $0.0 < $1.0 }\n    \n    let dummy = ListNode(0)\n    var current = dummy\n    \n    while !heap.isEmpty {\n        let (_, node) = heap.removeFirst()\n        current.next = node\n        current = node\n        if let next = node.next {\n            heap.append((next.val, next))\n            heap.sort { $0.0 < $1.0 }\n        }\n    }\n    return dummy.next\n}",
        "complexity": {
          "time": "O(n log k)",
          "space": "O(k)",
          "timeExplanation": "n total nodes, log k heap ops",
          "spaceExplanation": "Heap holds k nodes"
        },
        "testCases": [
          {
            "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
            "expectedOutput": "[1,1,2,3,4,4,5,6]",
            "explanation": "Merged sorted list"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-two-sorted-lists"
    ]
  },
  "task-scheduler": {
    "summary": "Minimum time to execute tasks with cooldown. Greedy: schedule most frequent tasks first.",
    "approaches": [
      {
        "name": "Math Formula",
        "intuition": "Most frequent task determines minimum time. Fill gaps with other tasks.",
        "approach": "1. Count frequencies, find max\n2. Count tasks with max frequency\n3. Result = max((maxFreq-1)*(n+1) + maxCount, total tasks)",
        "explanation": "Create frames of size n+1, fill with max freq task, then others.",
        "code": "func leastInterval(_ tasks: [Character], _ n: Int) -> Int {\n    var freq = [Int](repeating: 0, count: 26)\n    for task in tasks {\n        freq[Int(task.asciiValue!) - Int(Character(\"A\").asciiValue!)] += 1\n    }\n    let maxFreq = freq.max()!\n    let maxCount = freq.filter { $0 == maxFreq }.count\n    return max((maxFreq - 1) * (n + 1) + maxCount, tasks.count)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Count frequencies",
          "spaceExplanation": "26 letter array"
        },
        "testCases": [
          {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
            "expectedOutput": "8",
            "explanation": "A_B_A_B_A_B or ABXABXAB"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "implement-trie-prefix-tree": {
    "summary": "Implement Trie with insert, search, startsWith. Use nested dictionaries or node objects.",
    "approaches": [
      {
        "name": "Trie with Node Class",
        "intuition": "Each node has children map and end-of-word flag.",
        "approach": "1. Insert: traverse/create nodes for each char, mark end\n2. Search: traverse nodes, check end flag\n3. StartsWith: traverse nodes, just check existence",
        "explanation": "Children map allows variable branching factor.",
        "code": "class TrieNode {\n    var children: [Character: TrieNode] = [:]\n    var isEnd = false\n}\n\nclass Trie {\n    let root = TrieNode()\n    \n    func insert(_ word: String) {\n        var node = root\n        for char in word {\n            if node.children[char] == nil {\n                node.children[char] = TrieNode()\n            }\n            node = node.children[char]!\n        }\n        node.isEnd = true\n    }\n    \n    func search(_ word: String) -> Bool {\n        var node = root\n        for char in word {\n            guard let next = node.children[char] else { return false }\n            node = next\n        }\n        return node.isEnd\n    }\n    \n    func startsWith(_ prefix: String) -> Bool {\n        var node = root\n        for char in prefix {\n            guard let next = node.children[char] else { return false }\n            node = next\n        }\n        return true\n    }\n}",
        "complexity": {
          "time": "O(m) per operation",
          "space": "O(n×m)",
          "timeExplanation": "m = word length",
          "spaceExplanation": "n words, m chars each"
        },
        "testCases": [
          {
            "input": "insert(\"apple\"), search(\"apple\"), search(\"app\"), startsWith(\"app\")",
            "expectedOutput": "true, false, true",
            "explanation": "Trie operations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "design-add-and-search-words-data-structure",
      "word-search-ii"
    ]
  },
  "design-add-and-search-words-data-structure": {
    "summary": "Trie with wildcard search (. matches any). DFS when encountering dot.",
    "approaches": [
      {
        "name": "Trie with DFS",
        "intuition": "Regular trie insert. For search, DFS on '.' to try all children.",
        "approach": "1. Insert: normal trie insert\n2. Search: if '.', try all children recursively\n3. If regular char, proceed as normal",
        "explanation": "Wildcard requires exploring multiple paths.",
        "code": "class WordDictionary {\n    class TrieNode {\n        var children: [Character: TrieNode] = [:]\n        var isEnd = false\n    }\n    let root = TrieNode()\n    \n    func addWord(_ word: String) {\n        var node = root\n        for char in word {\n            if node.children[char] == nil { node.children[char] = TrieNode() }\n            node = node.children[char]!\n        }\n        node.isEnd = true\n    }\n    \n    func search(_ word: String) -> Bool {\n        func dfs(_ node: TrieNode, _ chars: [Character], _ i: Int) -> Bool {\n            if i == chars.count { return node.isEnd }\n            let char = chars[i]\n            if char == \".\" {\n                for child in node.children.values {\n                    if dfs(child, chars, i + 1) { return true }\n                }\n                return false\n            } else {\n                guard let next = node.children[char] else { return false }\n                return dfs(next, chars, i + 1)\n            }\n        }\n        return dfs(root, Array(word), 0)\n    }\n}",
        "complexity": {
          "time": "O(m) add, O(26^m) worst search",
          "space": "O(n×m)",
          "timeExplanation": "Wildcard can explore all paths",
          "spaceExplanation": "Trie storage"
        },
        "testCases": [
          {
            "input": "addWord(\"bad\"), search(\"b.d\")",
            "expectedOutput": "true",
            "explanation": "Dot matches 'a'"
          }
        ]
      }
    ],
    "relatedProblems": [
      "implement-trie-prefix-tree"
    ]
  },
  "word-search-ii": {
    "summary": "Find all words from dictionary in grid. Build trie from words, DFS on grid with trie pruning.",
    "approaches": [
      {
        "name": "Trie + DFS",
        "intuition": "Trie prunes search: if prefix not in trie, stop exploring.",
        "approach": "1. Build trie from all words\n2. DFS from each cell, following trie paths\n3. When word found, add to result\n4. Prune: remove word from trie to avoid duplicates",
        "explanation": "Trie allows efficient prefix checking during grid traversal.",
        "code": "func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\n    var result = Set<String>()\n    var board = board\n    let m = board.count, n = board[0].count\n    \n    // Build trie\n    var trie: [String: Any] = [:]\n    for word in words {\n        var node = trie\n        for char in word {\n            let key = String(char)\n            if node[key] == nil { node[key] = [String: Any]() }\n            // ... simplified for brevity\n        }\n    }\n    \n    func dfs(_ i: Int, _ j: Int, _ node: [String: Any], _ path: String) {\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] == \"#\" { return }\n        let char = String(board[i][j])\n        guard let next = node[char] as? [String: Any] else { return }\n        let newPath = path + char\n        if next[\"#\"] != nil { result.insert(newPath) }\n        let temp = board[i][j]\n        board[i][j] = \"#\"\n        dfs(i+1, j, next, newPath)\n        dfs(i-1, j, next, newPath)\n        dfs(i, j+1, next, newPath)\n        dfs(i, j-1, next, newPath)\n        board[i][j] = temp\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            dfs(i, j, trie, \"\")\n        }\n    }\n    return Array(result)\n}",
        "complexity": {
          "time": "O(m×n×4^L)",
          "space": "O(W×L)",
          "timeExplanation": "Grid cells × word length paths",
          "spaceExplanation": "Trie for W words of length L"
        },
        "testCases": [
          {
            "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"]], words = [\"oath\",\"eat\"]",
            "expectedOutput": "[\"oath\",\"eat\"]",
            "explanation": "Both words found in grid"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-search",
      "implement-trie-prefix-tree"
    ]
  },
  "rotate-array": {
    "summary": "Rotate array by k positions. Reverse whole, then reverse first k and last n-k.",
    "approaches": [
      {
        "name": "Three Reverses",
        "intuition": "Reversing brings elements to correct relative positions, then fix order.",
        "approach": "1. Reverse entire array\n2. Reverse first k elements\n3. Reverse remaining elements",
        "explanation": "Example: [1,2,3,4,5] k=2 → [5,4,3,2,1] → [4,5,3,2,1] → [4,5,1,2,3]",
        "code": "func rotate(_ nums: inout [Int], _ k: Int) {\n    let k = k % nums.count\n    if k == 0 { return }\n    \n    func reverse(_ start: Int, _ end: Int) {\n        var l = start, r = end\n        while l < r {\n            nums.swapAt(l, r)\n            l += 1; r -= 1\n        }\n    }\n    \n    reverse(0, nums.count - 1)\n    reverse(0, k - 1)\n    reverse(k, nums.count - 1)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Three passes",
          "spaceExplanation": "In-place"
        },
        "testCases": [
          {
            "input": "nums = [1,2,3,4,5,6,7], k = 3",
            "expectedOutput": "[5,6,7,1,2,3,4]",
            "explanation": "Rotated right by 3"
          }
        ]
      }
    ],
    "relatedProblems": [
      "rotate-image"
    ]
  },
  "spiral-matrix": {
    "summary": "Return elements in spiral order. Track boundaries: top, bottom, left, right.",
    "approaches": [
      {
        "name": "Layer by Layer",
        "intuition": "Traverse outer layer, then shrink boundaries and repeat.",
        "approach": "1. Go right along top row, shrink top\n2. Go down along right column, shrink right\n3. Go left along bottom row, shrink bottom\n4. Go up along left column, shrink left",
        "explanation": "Boundaries prevent revisiting elements.",
        "code": "func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n    var result: [Int] = []\n    var top = 0, bottom = matrix.count - 1\n    var left = 0, right = matrix[0].count - 1\n    \n    while top <= bottom && left <= right {\n        for col in left...right { result.append(matrix[top][col]) }\n        top += 1\n        for row in top...bottom { result.append(matrix[row][right]) }\n        right -= 1\n        if top <= bottom {\n            for col in stride(from: right, through: left, by: -1) { result.append(matrix[bottom][col]) }\n            bottom -= 1\n        }\n        if left <= right {\n            for row in stride(from: bottom, through: top, by: -1) { result.append(matrix[row][left]) }\n            left += 1\n        }\n    }\n    return result\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(1)",
          "timeExplanation": "Visit each element once",
          "spaceExplanation": "Output not counted"
        },
        "testCases": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "expectedOutput": "[1,2,3,6,9,8,7,4,5]",
            "explanation": "Spiral order"
          }
        ]
      }
    ],
    "relatedProblems": [
      "spiral-matrix-ii"
    ]
  },
  "valid-parentheses": {
    "summary": "Check if brackets are valid. Stack: push opens, pop and match for closes.",
    "approaches": [
      {
        "name": "Stack",
        "intuition": "Each closing bracket must match most recent unmatched opening bracket.",
        "approach": "1. For '(', '[', '{': push to stack\n2. For ')', ']', '}': pop and check match\n3. Stack should be empty at end",
        "explanation": "Stack maintains order of unmatched opening brackets.",
        "code": "func isValid(_ s: String) -> Bool {\n    var stack: [Character] = []\n    let pairs: [Character: Character] = [\")\": \"(\", \"]\": \"[\", \"}\": \"{\"]\n    \n    for char in s {\n        if let open = pairs[char] {\n            if stack.isEmpty || stack.removeLast() != open {\n                return false\n            }\n        } else {\n            stack.append(char)\n        }\n    }\n    return stack.isEmpty\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Stack size"
        },
        "testCases": [
          {
            "input": "s = \"()[]{}\"",
            "expectedOutput": "true",
            "explanation": "All brackets matched"
          }
        ]
      }
    ],
    "relatedProblems": [
      "generate-parentheses"
    ]
  },
  "largest-rectangle-in-histogram": {
    "summary": "Find largest rectangle area in histogram. Stack of indices: when height decreases, calculate areas.",
    "approaches": [
      {
        "name": "Monotonic Stack",
        "intuition": "For each bar, find how far it can extend left and right.",
        "approach": "1. Maintain increasing stack of heights\n2. When height decreases, pop and calculate area\n3. Width = current index - stack top - 1",
        "explanation": "Popped bar can extend from stack top to current index.",
        "code": "func largestRectangleArea(_ heights: [Int]) -> Int {\n    var stack: [Int] = []\n    var maxArea = 0\n    var heights = heights + [0]  // Sentinel\n    \n    for i in 0..<heights.count {\n        while !stack.isEmpty && heights[i] < heights[stack.last!] {\n            let h = heights[stack.removeLast()]\n            let w = stack.isEmpty ? i : i - stack.last! - 1\n            maxArea = max(maxArea, h * w)\n        }\n        stack.append(i)\n    }\n    return maxArea\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Each bar pushed/popped once",
          "spaceExplanation": "Stack size"
        },
        "testCases": [
          {
            "input": "heights = [2,1,5,6,2,3]",
            "expectedOutput": "10",
            "explanation": "Rectangle of height 5, width 2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "maximal-rectangle"
    ]
  },
  "maximal-rectangle": {
    "summary": "Find largest rectangle of 1s in matrix. Treat each row as histogram base, use largest rectangle in histogram.",
    "approaches": [
      {
        "name": "Build Histograms",
        "intuition": "For each row, build histogram of heights, then find largest rectangle.",
        "approach": "1. For each row, compute heights (consecutive 1s above)\n2. Apply largest rectangle in histogram\n3. Track maximum area",
        "explanation": "Heights array represents histogram for each row as base.",
        "code": "func maximalRectangle(_ matrix: [[Character]]) -> Int {\n    if matrix.isEmpty { return 0 }\n    let m = matrix.count, n = matrix[0].count\n    var heights = [Int](repeating: 0, count: n)\n    var maxArea = 0\n    \n    func largestRect(_ h: [Int]) -> Int {\n        var stack: [Int] = []\n        var h = h + [0]\n        var area = 0\n        for i in 0..<h.count {\n            while !stack.isEmpty && h[i] < h[stack.last!] {\n                let height = h[stack.removeLast()]\n                let width = stack.isEmpty ? i : i - stack.last! - 1\n                area = max(area, height * width)\n            }\n            stack.append(i)\n        }\n        return area\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            heights[j] = matrix[i][j] == \"1\" ? heights[j] + 1 : 0\n        }\n        maxArea = max(maxArea, largestRect(heights))\n    }\n    return maxArea\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(n)",
          "timeExplanation": "Process each row",
          "spaceExplanation": "Heights array"
        },
        "testCases": [
          {
            "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"]]",
            "expectedOutput": "6",
            "explanation": "3×2 rectangle"
          }
        ]
      }
    ],
    "relatedProblems": [
      "largest-rectangle-in-histogram"
    ]
  },
  "best-time-to-buy-and-sell-stock": {
    "summary": "Max profit from one buy and sell. Track minimum price seen, update max profit.",
    "approaches": [
      {
        "name": "One Pass",
        "intuition": "Buy at lowest point so far, calculate profit at each day.",
        "approach": "1. Track minPrice and maxProfit\n2. For each price: update minPrice, then maxProfit",
        "explanation": "We want to buy before we sell, so only consider selling at prices after the minimum.",
        "code": "func maxProfit(_ prices: [Int]) -> Int {\n    var minPrice = Int.max\n    var maxProfit = 0\n    for price in prices {\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    }\n    return maxProfit\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Two variables"
        },
        "testCases": [
          {
            "input": "prices = [7,1,5,3,6,4]",
            "expectedOutput": "5",
            "explanation": "Buy at 1, sell at 6"
          }
        ]
      }
    ],
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-ii"
    ]
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "summary": "Max profit with unlimited transactions. Add all positive price differences.",
    "approaches": [
      {
        "name": "Greedy",
        "intuition": "Capture every upward price movement.",
        "approach": "1. For each consecutive day pair\n2. If price increased, add difference to profit",
        "explanation": "Equivalent to buying at every local minimum and selling at every local maximum.",
        "code": "func maxProfit(_ prices: [Int]) -> Int {\n    var profit = 0\n    for i in 1..<prices.count {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "One variable"
        },
        "testCases": [
          {
            "input": "prices = [7,1,5,3,6,4]",
            "expectedOutput": "7",
            "explanation": "(5-1)+(6-3)=7"
          }
        ]
      }
    ],
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock"
    ]
  },
  "best-time-to-buy-and-sell-stock-with-cooldown": {
    "summary": "Max profit with cooldown after sell. DP with states: hold, sold, rest.",
    "approaches": [
      {
        "name": "State Machine DP",
        "intuition": "Track max profit in each state: holding stock, just sold, resting.",
        "approach": "1. hold[i] = max(hold[i-1], rest[i-1] - price)\n2. sold[i] = hold[i-1] + price\n3. rest[i] = max(rest[i-1], sold[i-1])",
        "explanation": "Can only buy from rest state, must rest after selling.",
        "code": "func maxProfit(_ prices: [Int]) -> Int {\n    if prices.isEmpty { return 0 }\n    var hold = -prices[0], sold = 0, rest = 0\n    for i in 1..<prices.count {\n        let prevHold = hold, prevSold = sold\n        hold = max(hold, rest - prices[i])\n        sold = prevHold + prices[i]\n        rest = max(rest, prevSold)\n    }\n    return max(sold, rest)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Three variables"
        },
        "testCases": [
          {
            "input": "prices = [1,2,3,0,2]",
            "expectedOutput": "3",
            "explanation": "buy,sell,cooldown,buy,sell"
          }
        ]
      }
    ],
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-ii"
    ]
  },
  "lru-cache": {
    "summary": "Implement LRU cache. HashMap for O(1) lookup + doubly linked list for O(1) removal/insertion.",
    "approaches": [
      {
        "name": "HashMap + Doubly Linked List",
        "intuition": "Map gives O(1) access, list tracks recency for O(1) eviction.",
        "approach": "1. Map: key → node\n2. List: most recent at tail, least recent at head\n3. On access: move to tail\n4. On eviction: remove head",
        "explanation": "Combined data structures give O(1) for all operations.",
        "code": "class LRUCache {\n    class Node {\n        let key: Int\n        var val: Int\n        var prev: Node?\n        var next: Node?\n        init(_ key: Int, _ val: Int) { self.key = key; self.val = val }\n    }\n    \n    var capacity: Int\n    var map: [Int: Node] = [:]\n    var head = Node(0, 0)\n    var tail = Node(0, 0)\n    \n    init(_ capacity: Int) {\n        self.capacity = capacity\n        head.next = tail\n        tail.prev = head\n    }\n    \n    func get(_ key: Int) -> Int {\n        guard let node = map[key] else { return -1 }\n        remove(node)\n        insert(node)\n        return node.val\n    }\n    \n    func put(_ key: Int, _ value: Int) {\n        if let node = map[key] {\n            node.val = value\n            remove(node)\n            insert(node)\n        } else {\n            let node = Node(key, value)\n            map[key] = node\n            insert(node)\n            if map.count > capacity {\n                let lru = head.next!\n                remove(lru)\n                map[lru.key] = nil\n            }\n        }\n    }\n    \n    func remove(_ node: Node) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n    }\n    \n    func insert(_ node: Node) {\n        node.prev = tail.prev\n        node.next = tail\n        tail.prev?.next = node\n        tail.prev = node\n    }\n}",
        "complexity": {
          "time": "O(1)",
          "space": "O(capacity)",
          "timeExplanation": "All operations O(1)",
          "spaceExplanation": "Store capacity items"
        },
        "testCases": [
          {
            "input": "LRUCache(2), put(1,1), put(2,2), get(1), put(3,3), get(2)",
            "expectedOutput": "1, -1",
            "explanation": "Key 2 evicted when 3 added"
          }
        ]
      }
    ],
    "relatedProblems": [
      "lfu-cache"
    ]
  },
  "surrounded-regions": {
    "summary": "Capture surrounded O's by flipping to X. Mark border-connected O's, flip rest.",
    "approaches": [
      {
        "name": "DFS from Border",
        "intuition": "O's connected to border can't be captured. Mark them, flip the rest.",
        "approach": "1. DFS from all border O's, mark as safe\n2. Flip unmarked O's to X\n3. Restore marked cells to O",
        "explanation": "Only interior O's (not connected to border) get captured.",
        "code": "func solve(_ board: inout [[Character]]) {\n    let m = board.count, n = board[0].count\n    \n    func dfs(_ i: Int, _ j: Int) {\n        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != \"O\" { return }\n        board[i][j] = \"S\"  // Safe\n        dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)\n    }\n    \n    for i in 0..<m {\n        dfs(i, 0); dfs(i, n-1)\n    }\n    for j in 0..<n {\n        dfs(0, j); dfs(m-1, j)\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if board[i][j] == \"O\" { board[i][j] = \"X\" }\n            else if board[i][j] == \"S\" { board[i][j] = \"O\" }\n        }\n    }\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell",
          "spaceExplanation": "Recursion stack"
        },
        "testCases": [
          {
            "input": "board = [[\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\"]]",
            "expectedOutput": "[[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]",
            "explanation": "Center O captured"
          }
        ]
      }
    ],
    "relatedProblems": [
      "number-of-islands"
    ]
  },
  "rotting-oranges": {
    "summary": "Time for all oranges to rot. Multi-source BFS from all rotten oranges.",
    "approaches": [
      {
        "name": "Multi-source BFS",
        "intuition": "All rotten oranges spread simultaneously. BFS level = time.",
        "approach": "1. Add all rotten oranges to queue, count fresh\n2. BFS: each level is one minute\n3. Return time when no fresh left, or -1 if impossible",
        "explanation": "BFS naturally handles simultaneous spreading.",
        "code": "func orangesRotting(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let m = grid.count, n = grid[0].count\n    var queue: [(Int, Int)] = []\n    var fresh = 0\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 2 { queue.append((i, j)) }\n            else if grid[i][j] == 1 { fresh += 1 }\n        }\n    }\n    \n    if fresh == 0 { return 0 }\n    var time = -1\n    let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    \n    while !queue.isEmpty {\n        time += 1\n        let size = queue.count\n        for _ in 0..<size {\n            let (i, j) = queue.removeFirst()\n            for (di, dj) in dirs {\n                let ni = i + di, nj = j + dj\n                if ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1 {\n                    grid[ni][nj] = 2\n                    fresh -= 1\n                    queue.append((ni, nj))\n                }\n            }\n        }\n    }\n    return fresh == 0 ? time : -1\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell",
          "spaceExplanation": "Queue size"
        },
        "testCases": [
          {
            "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
            "expectedOutput": "4",
            "explanation": "4 minutes to rot all"
          }
        ]
      }
    ],
    "relatedProblems": [
      "walls-and-gates"
    ]
  },
  "walls-and-gates": {
    "summary": "Fill empty rooms with distance to nearest gate. Multi-source BFS from all gates.",
    "approaches": [
      {
        "name": "Multi-source BFS",
        "intuition": "BFS from all gates simultaneously gives shortest distances.",
        "approach": "1. Add all gates to queue\n2. BFS: update empty rooms with distance\n3. Each BFS level increases distance by 1",
        "explanation": "First time we reach a room, it's the shortest path.",
        "code": "func wallsAndGates(_ rooms: inout [[Int]]) {\n    let m = rooms.count, n = rooms[0].count\n    let INF = 2147483647\n    var queue: [(Int, Int)] = []\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            if rooms[i][j] == 0 { queue.append((i, j)) }\n        }\n    }\n    \n    let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    while !queue.isEmpty {\n        let (i, j) = queue.removeFirst()\n        for (di, dj) in dirs {\n            let ni = i + di, nj = j + dj\n            if ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF {\n                rooms[ni][nj] = rooms[i][j] + 1\n                queue.append((ni, nj))\n            }\n        }\n    }\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m×n)",
          "timeExplanation": "Visit each cell",
          "spaceExplanation": "Queue size"
        },
        "testCases": [
          {
            "input": "rooms = [[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]]",
            "expectedOutput": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]",
            "explanation": "Distances filled"
          }
        ]
      }
    ],
    "relatedProblems": [
      "rotting-oranges"
    ]
  },
  "alien-dictionary": {
    "summary": "Derive alien alphabet order from sorted words. Build graph from word pairs, topological sort.",
    "approaches": [
      {
        "name": "Topological Sort",
        "intuition": "Compare adjacent words to find char ordering, then topo sort.",
        "approach": "1. Compare each pair of adjacent words\n2. First differing char gives edge in graph\n3. Topological sort the graph",
        "explanation": "Invalid if cycle found or word is prefix of previous.",
        "code": "func alienOrder(_ words: [String]) -> String {\n    var graph: [Character: Set<Character>] = [:]\n    var indegree: [Character: Int] = [:]\n    \n    for word in words {\n        for char in word {\n            indegree[char] = 0\n        }\n    }\n    \n    for i in 0..<words.count - 1 {\n        let w1 = Array(words[i]), w2 = Array(words[i+1])\n        if w1.count > w2.count && w1.starts(with: w2) { return \"\" }\n        for j in 0..<min(w1.count, w2.count) {\n            if w1[j] != w2[j] {\n                if graph[w1[j]]?.contains(w2[j]) != true {\n                    graph[w1[j], default: []].insert(w2[j])\n                    indegree[w2[j], default: 0] += 1\n                }\n                break\n            }\n        }\n    }\n    \n    var queue = indegree.filter { $0.value == 0 }.map { $0.key }\n    var result = \"\"\n    while !queue.isEmpty {\n        let char = queue.removeFirst()\n        result.append(char)\n        for next in graph[char] ?? [] {\n            indegree[next]! -= 1\n            if indegree[next] == 0 { queue.append(next) }\n        }\n    }\n    return result.count == indegree.count ? result : \"\"\n}",
        "complexity": {
          "time": "O(C)",
          "space": "O(1)",
          "timeExplanation": "C = total chars in all words",
          "spaceExplanation": "26 letters max"
        },
        "testCases": [
          {
            "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
            "expectedOutput": "\"wertf\"",
            "explanation": "Derived alphabet order"
          }
        ]
      }
    ],
    "relatedProblems": [
      "course-schedule-ii"
    ]
  },
  "cheapest-flights-within-k-stops": {
    "summary": "Cheapest flight with at most k stops. BFS/Bellman-Ford limited to k+1 edges.",
    "approaches": [
      {
        "name": "BFS with Pruning",
        "intuition": "BFS level by level, each level is one stop. Track best cost to reach each city.",
        "approach": "1. BFS from source\n2. Track minimum cost to each city\n3. Stop after k+1 levels (k stops = k+1 flights)",
        "explanation": "Only add to queue if we found a cheaper path.",
        "code": "func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\n    var graph = [[Int]: Int]()\n    for f in flights { graph[[f[0], f[1]]] = f[2] }\n    \n    var dist = [Int](repeating: Int.max, count: n)\n    dist[src] = 0\n    var queue: [(Int, Int)] = [(src, 0)]  // (city, cost)\n    var stops = 0\n    \n    while !queue.isEmpty && stops <= k {\n        let size = queue.count\n        var newDist = dist\n        for _ in 0..<size {\n            let (city, cost) = queue.removeFirst()\n            for (edge, price) in graph where edge[0] == city {\n                let next = edge[1]\n                let newCost = cost + price\n                if newCost < newDist[next] {\n                    newDist[next] = newCost\n                    queue.append((next, newCost))\n                }\n            }\n        }\n        dist = newDist\n        stops += 1\n    }\n    return dist[dst] == Int.max ? -1 : dist[dst]\n}",
        "complexity": {
          "time": "O(k × E)",
          "space": "O(n)",
          "timeExplanation": "k levels, E edges per level",
          "spaceExplanation": "Distance array"
        },
        "testCases": [
          {
            "input": "n=4, flights=[[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src=0, dst=3, k=1",
            "expectedOutput": "700",
            "explanation": "0→1→3 = 700"
          }
        ]
      }
    ],
    "relatedProblems": [
      "network-delay-time"
    ]
  },
  "network-delay-time": {
    "summary": "Time for signal to reach all nodes. Dijkstra's shortest path from source.",
    "approaches": [
      {
        "name": "Dijkstra's Algorithm",
        "intuition": "Find shortest path to all nodes, return maximum.",
        "approach": "1. Priority queue with (time, node)\n2. Process in order of arrival time\n3. Return max time to reach all nodes",
        "explanation": "Dijkstra gives shortest paths from source to all nodes.",
        "code": "func networkDelayTime(_ times: [[Int]], _ n: Int, _ k: Int) -> Int {\n    var graph = [Int: [(Int, Int)]]()\n    for t in times {\n        graph[t[0], default: []].append((t[1], t[2]))\n    }\n    \n    var dist = [Int](repeating: Int.max, count: n + 1)\n    dist[k] = 0\n    var heap = [(0, k)]  // (time, node)\n    \n    while !heap.isEmpty {\n        heap.sort { $0.0 < $1.0 }\n        let (time, node) = heap.removeFirst()\n        if time > dist[node] { continue }\n        for (next, weight) in graph[node] ?? [] {\n            let newTime = time + weight\n            if newTime < dist[next] {\n                dist[next] = newTime\n                heap.append((newTime, next))\n            }\n        }\n    }\n    \n    let maxTime = dist[1...n].max()!\n    return maxTime == Int.max ? -1 : maxTime\n}",
        "complexity": {
          "time": "O(E log V)",
          "space": "O(V + E)",
          "timeExplanation": "Dijkstra with heap",
          "spaceExplanation": "Graph + distances"
        },
        "testCases": [
          {
            "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
            "expectedOutput": "2",
            "explanation": "Signal reaches node 4 at time 2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "cheapest-flights-within-k-stops"
    ]
  },
  "swim-in-rising-water": {
    "summary": "Minimum time to swim from (0,0) to (n-1,n-1). Binary search on time or Dijkstra on max elevation.",
    "approaches": [
      {
        "name": "Dijkstra/Min-Heap",
        "intuition": "Find path minimizing maximum elevation encountered.",
        "approach": "1. Min-heap with (max_elevation, row, col)\n2. Always expand cell with minimum max elevation\n3. Track minimum max elevation to reach each cell",
        "explanation": "Modified Dijkstra where cost is max(path_max, cell_value).",
        "code": "func swimInWater(_ grid: [[Int]]) -> Int {\n    let n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n    var heap = [(grid[0][0], 0, 0)]  // (max_elevation, row, col)\n    visited[0][0] = true\n    let dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n    \n    while !heap.isEmpty {\n        heap.sort { $0.0 < $1.0 }\n        let (maxE, r, c) = heap.removeFirst()\n        if r == n-1 && c == n-1 { return maxE }\n        for (dr, dc) in dirs {\n            let nr = r + dr, nc = c + dc\n            if nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc] {\n                visited[nr][nc] = true\n                heap.append((max(maxE, grid[nr][nc]), nr, nc))\n            }\n        }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(n² log n)",
          "space": "O(n²)",
          "timeExplanation": "Heap operations on n² cells",
          "spaceExplanation": "Visited array"
        },
        "testCases": [
          {
            "input": "grid = [[0,2],[1,3]]",
            "expectedOutput": "3",
            "explanation": "Wait until t=3 to reach (1,1)"
          }
        ]
      }
    ],
    "relatedProblems": [
      "path-with-minimum-effort"
    ]
  },
  "min-cost-to-connect-all-points": {
    "summary": "Minimum spanning tree connecting all points. Prim's or Kruskal's algorithm.",
    "approaches": [
      {
        "name": "Prim's Algorithm",
        "intuition": "Greedily add closest unvisited point to MST.",
        "approach": "1. Start from any point\n2. Add to MST the closest unvisited point\n3. Update distances to remaining points\n4. Repeat until all connected",
        "explanation": "Min-heap gives O(E log V) complexity.",
        "code": "func minCostConnectPoints(_ points: [[Int]]) -> Int {\n    let n = points.count\n    var visited = [Bool](repeating: false, count: n)\n    var heap = [(0, 0)]  // (cost, point)\n    var cost = 0, edges = 0\n    \n    while edges < n {\n        heap.sort { $0.0 < $1.0 }\n        let (c, p) = heap.removeFirst()\n        if visited[p] { continue }\n        visited[p] = true\n        cost += c\n        edges += 1\n        for i in 0..<n {\n            if !visited[i] {\n                let dist = abs(points[p][0] - points[i][0]) + abs(points[p][1] - points[i][1])\n                heap.append((dist, i))\n            }\n        }\n    }\n    return cost\n}",
        "complexity": {
          "time": "O(n² log n)",
          "space": "O(n²)",
          "timeExplanation": "Dense graph",
          "spaceExplanation": "Heap size"
        },
        "testCases": [
          {
            "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
            "expectedOutput": "20",
            "explanation": "Minimum spanning tree cost"
          }
        ]
      }
    ],
    "relatedProblems": [
      "minimum-spanning-tree"
    ]
  },
  "reconstruct-itinerary": {
    "summary": "Find itinerary using all tickets exactly once. Hierholzer's algorithm for Eulerian path.",
    "approaches": [
      {
        "name": "DFS with Post-order",
        "intuition": "DFS visiting smallest lexical neighbor first, add to result in post-order.",
        "approach": "1. Build graph with sorted adjacency lists\n2. DFS from JFK, remove edges as used\n3. Add to result after exploring all edges",
        "explanation": "Post-order ensures stuck paths are added last (reversed at end).",
        "code": "func findItinerary(_ tickets: [[String]]) -> [String] {\n    var graph: [String: [String]] = [:]\n    for t in tickets {\n        graph[t[0], default: []].append(t[1])\n    }\n    for key in graph.keys {\n        graph[key]!.sort(by: >)  // Reverse for pop efficiency\n    }\n    \n    var result: [String] = []\n    func dfs(_ airport: String) {\n        while !(graph[airport]?.isEmpty ?? true) {\n            dfs(graph[airport]!.removeLast())\n        }\n        result.append(airport)\n    }\n    \n    dfs(\"JFK\")\n    return result.reversed()\n}",
        "complexity": {
          "time": "O(E log E)",
          "space": "O(E)",
          "timeExplanation": "Sorting edges",
          "spaceExplanation": "Graph storage"
        },
        "testCases": [
          {
            "input": "tickets = [[\"MU\",\"LHR\"],[\"JFK\",\"MU\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
            "expectedOutput": "[\"JFK\",\"MU\",\"LHR\",\"SFO\",\"SJC\"]",
            "explanation": "Valid itinerary"
          }
        ]
      }
    ],
    "relatedProblems": [
      "valid-arrangement-of-pairs"
    ]
  },
  "kth-largest-element-in-a-stream": {
    "summary": "Track kth largest in stream. Use min-heap of size k.",
    "approaches": [
      {
        "name": "Min Heap of Size K",
        "intuition": "Keep k largest elements. Min of these k is the kth largest.",
        "approach": "1. Maintain min-heap of size k\n2. For each add: push to heap, pop if size > k\n3. Top of heap is kth largest",
        "explanation": "Min-heap ensures smallest of k largest is at top.",
        "code": "class KthLargest {\n    var heap: [Int] = []\n    let k: Int\n    \n    init(_ k: Int, _ nums: [Int]) {\n        self.k = k\n        for num in nums { add(num) }\n    }\n    \n    func add(_ val: Int) -> Int {\n        heap.append(val)\n        heap.sort()\n        if heap.count > k { heap.removeFirst() }\n        return heap.first!\n    }\n}",
        "complexity": {
          "time": "O(log k) per add",
          "space": "O(k)",
          "timeExplanation": "Heap operations",
          "spaceExplanation": "K elements in heap"
        },
        "testCases": [
          {
            "input": "KthLargest(3, [4,5,8,2]), add(3), add(5), add(10)",
            "expectedOutput": "4, 5, 5",
            "explanation": "3rd largest updates"
          }
        ]
      }
    ],
    "relatedProblems": [
      "kth-largest-element-in-an-array"
    ]
  },
  "reorganize-string": {
    "summary": "Rearrange so no adjacent chars same. Greedy: always place most frequent, then second most.",
    "approaches": [
      {
        "name": "Max Heap Greedy",
        "intuition": "Always place most frequent available char.",
        "approach": "1. Count frequencies, add to max heap\n2. Alternate between top two frequent chars\n3. Return empty if impossible (one char > (n+1)/2)",
        "explanation": "Placing most frequent first minimizes adjacency conflicts.",
        "code": "func reorganizeString(_ s: String) -> String {\n    var count: [Character: Int] = [:]\n    for char in s { count[char, default: 0] += 1 }\n    \n    var heap = count.map { ($0.value, $0.key) }.sorted { $0.0 > $1.0 }\n    if heap[0].0 > (s.count + 1) / 2 { return \"\" }\n    \n    var result = \"\"\n    while heap.count >= 2 {\n        let first = heap.removeFirst()\n        let second = heap.removeFirst()\n        result += String(first.1) + String(second.1)\n        if first.0 > 1 { heap.append((first.0 - 1, first.1)) }\n        if second.0 > 1 { heap.append((second.0 - 1, second.1)) }\n        heap.sort { $0.0 > $1.0 }\n    }\n    if !heap.isEmpty { result += String(heap[0].1) }\n    return result\n}",
        "complexity": {
          "time": "O(n log k)",
          "space": "O(k)",
          "timeExplanation": "n chars, k unique chars",
          "spaceExplanation": "Frequency map"
        },
        "testCases": [
          {
            "input": "s = \"aab\"",
            "expectedOutput": "\"aba\"",
            "explanation": "No adjacent a's"
          }
        ]
      }
    ],
    "relatedProblems": [
      "task-scheduler"
    ]
  },
  "k-closest-points-to-origin": {
    "summary": "Find k closest points to origin. Max-heap of size k or quickselect.",
    "approaches": [
      {
        "name": "Max Heap",
        "intuition": "Keep k smallest distances using max-heap.",
        "approach": "1. Use max-heap of size k\n2. For each point, add to heap\n3. If size > k, remove max (farthest)",
        "explanation": "Max-heap maintains k smallest, largest at top for removal.",
        "code": "func kClosest(_ points: [[Int]], _ k: Int) -> [[Int]] {\n    var heap: [(Int, [Int])] = []  // (dist², point)\n    for p in points {\n        let dist = p[0]*p[0] + p[1]*p[1]\n        heap.append((dist, p))\n        heap.sort { $0.0 > $1.0 }  // Max heap\n        if heap.count > k { heap.removeLast() }\n    }\n    return heap.map { $0.1 }\n}",
        "complexity": {
          "time": "O(n log k)",
          "space": "O(k)",
          "timeExplanation": "n points, log k heap ops",
          "spaceExplanation": "K points in heap"
        },
        "testCases": [
          {
            "input": "points = [[1,3],[-2,2]], k = 1",
            "expectedOutput": "[[-2,2]]",
            "explanation": "Closest to origin"
          }
        ]
      }
    ],
    "relatedProblems": [
      "top-k-frequent-elements"
    ]
  },
  "range-sum-query-immutable": {
    "summary": "Query sum of range [i,j]. Precompute prefix sums.",
    "approaches": [
      {
        "name": "Prefix Sum",
        "intuition": "prefixSum[j+1] - prefixSum[i] gives sum[i..j].",
        "approach": "1. Compute prefix sums in constructor\n2. Query: return prefix[j+1] - prefix[i]",
        "explanation": "O(n) precompute, O(1) query.",
        "code": "class NumArray {\n    var prefix: [Int]\n    \n    init(_ nums: [Int]) {\n        prefix = [0]\n        for num in nums {\n            prefix.append(prefix.last! + num)\n        }\n    }\n    \n    func sumRange(_ left: Int, _ right: Int) -> Int {\n        return prefix[right + 1] - prefix[left]\n    }\n}",
        "complexity": {
          "time": "O(1) query",
          "space": "O(n)",
          "timeExplanation": "Constant time query",
          "spaceExplanation": "Prefix array"
        },
        "testCases": [
          {
            "input": "NumArray([-2,0,3,-5,2,-1]), sumRange(0,2)",
            "expectedOutput": "1",
            "explanation": "-2+0+3=1"
          }
        ]
      }
    ],
    "relatedProblems": [
      "range-sum-query-2d-immutable"
    ]
  },
  "range-sum-query-2d-immutable": {
    "summary": "Query sum of 2D region. Precompute 2D prefix sums.",
    "approaches": [
      {
        "name": "2D Prefix Sum",
        "intuition": "prefix[i][j] = sum of rectangle (0,0) to (i-1,j-1).",
        "approach": "1. Build 2D prefix sum matrix\n2. Query using inclusion-exclusion principle",
        "explanation": "Region sum = prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1]",
        "code": "class NumMatrix {\n    var prefix: [[Int]]\n    \n    init(_ matrix: [[Int]]) {\n        let m = matrix.count, n = matrix[0].count\n        prefix = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)\n        for i in 0..<m {\n            for j in 0..<n {\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]\n            }\n        }\n    }\n    \n    func sumRegion(_ row1: Int, _ col1: Int, _ row2: Int, _ col2: Int) -> Int {\n        return prefix[row2+1][col2+1] - prefix[row1][col2+1] - prefix[row2+1][col1] + prefix[row1][col1]\n    }\n}",
        "complexity": {
          "time": "O(1) query",
          "space": "O(m×n)",
          "timeExplanation": "Constant time query",
          "spaceExplanation": "2D prefix array"
        },
        "testCases": [
          {
            "input": "NumMatrix([[3,0,1],[5,6,3]]), sumRegion(0,1,1,2)",
            "expectedOutput": "10",
            "explanation": "0+1+6+3=10"
          }
        ]
      }
    ],
    "relatedProblems": [
      "range-sum-query-immutable"
    ]
  },
  "longest-consecutive-sequence": {
    "summary": "Find longest consecutive sequence. Use set, for each sequence start count length.",
    "approaches": [
      {
        "name": "HashSet",
        "intuition": "Only start counting from sequence starts (n-1 not in set).",
        "approach": "1. Add all nums to set\n2. For each num where num-1 not in set (sequence start)\n3. Count consecutive nums, track max",
        "explanation": "O(n) because each number visited once as sequence member.",
        "code": "func longestConsecutive(_ nums: [Int]) -> Int {\n    let numSet = Set(nums)\n    var maxLen = 0\n    \n    for num in numSet {\n        if !numSet.contains(num - 1) {  // Start of sequence\n            var length = 1\n            var current = num\n            while numSet.contains(current + 1) {\n                current += 1\n                length += 1\n            }\n            maxLen = max(maxLen, length)\n        }\n    }\n    return maxLen\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Each number visited once",
          "spaceExplanation": "Set storage"
        },
        "testCases": [
          {
            "input": "nums = [100,4,200,1,3,2]",
            "expectedOutput": "4",
            "explanation": "1,2,3,4 is longest"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "find-the-duplicate-number": {
    "summary": "Find duplicate in [1,n] array without modifying. Floyd's cycle detection.",
    "approaches": [
      {
        "name": "Floyd's Cycle Detection",
        "intuition": "Treat array as linked list (value is next index). Duplicate creates cycle.",
        "approach": "1. Use slow/fast pointers to find meeting point\n2. Reset one to start, move both at same speed\n3. They meet at cycle start (duplicate)",
        "explanation": "Same as linked list cycle II - mathematical proof applies.",
        "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    var slow = nums[0]\n    var fast = nums[0]\n    \n    repeat {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    } while slow != fast\n    \n    slow = nums[0]\n    while slow != fast {\n        slow = nums[slow]\n        fast = nums[fast]\n    }\n    return slow\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Linear traversal",
          "spaceExplanation": "Two pointers only"
        },
        "testCases": [
          {
            "input": "nums = [1,3,4,2,2]",
            "expectedOutput": "2",
            "explanation": "2 is duplicated"
          }
        ]
      }
    ],
    "relatedProblems": [
      "linked-list-cycle-ii"
    ]
  },
  "game-of-life": {
    "summary": "Simulate one step of Game of Life. Encode states in-place using extra bits.",
    "approaches": [
      {
        "name": "In-place with State Encoding",
        "intuition": "Use additional bits to store both current and next state.",
        "approach": "1. Count live neighbors for each cell\n2. Encode: 0→dead, 1→live, 2→dead→live, 3→live→dead\n3. Final pass: convert to final state",
        "explanation": "Two LSBs: current state, next state encoded in higher bit.",
        "code": "func gameOfLife(_ board: inout [[Int]]) {\n    let m = board.count, n = board[0].count\n    let dirs = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            var live = 0\n            for (di, dj) in dirs {\n                let ni = i + di, nj = j + dj\n                if ni >= 0 && ni < m && nj >= 0 && nj < n {\n                    live += board[ni][nj] & 1\n                }\n            }\n            if board[i][j] == 1 && (live == 2 || live == 3) {\n                board[i][j] = 3  // 01 -> 11 (live->live)\n            } else if board[i][j] == 0 && live == 3 {\n                board[i][j] = 2  // 00 -> 10 (dead->live)\n            }\n        }\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            board[i][j] >>= 1\n        }\n    }\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(1)",
          "timeExplanation": "Visit each cell twice",
          "spaceExplanation": "In-place encoding"
        },
        "testCases": [
          {
            "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
            "expectedOutput": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
            "explanation": "One generation step"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "reverse-integer": {
    "summary": "Reverse digits of integer. Handle overflow by checking before multiplication.",
    "approaches": [
      {
        "name": "Pop and Push",
        "intuition": "Pop digits from end, push to result.",
        "approach": "1. Pop: digit = x % 10, x /= 10\n2. Check overflow before push\n3. Push: result = result * 10 + digit",
        "explanation": "Check INT_MAX/10 before multiplying.",
        "code": "func reverse(_ x: Int) -> Int {\n    var x = x, result = 0\n    while x != 0 {\n        let digit = x % 10\n        x /= 10\n        if result > Int32.max / 10 || result < Int32.min / 10 { return 0 }\n        result = result * 10 + digit\n    }\n    return result\n}",
        "complexity": {
          "time": "O(log x)",
          "space": "O(1)",
          "timeExplanation": "Number of digits",
          "spaceExplanation": "Constant"
        },
        "testCases": [
          {
            "input": "x = 123",
            "expectedOutput": "321",
            "explanation": "Reversed"
          }
        ]
      }
    ],
    "relatedProblems": [
      "string-to-integer-atoi"
    ]
  },
  "string-to-integer-atoi": {
    "summary": "Convert string to integer. Handle whitespace, sign, overflow.",
    "approaches": [
      {
        "name": "State Machine",
        "intuition": "Process: whitespace → sign → digits → stop.",
        "approach": "1. Skip leading whitespace\n2. Handle sign\n3. Process digits, check overflow",
        "explanation": "Stop at first non-digit after numbers start.",
        "code": "func myAtoi(_ s: String) -> Int {\n    let chars = Array(s)\n    var i = 0, sign = 1, result = 0\n    while i < chars.count && chars[i] == \" \" { i += 1 }\n    if i < chars.count && (chars[i] == \"+\" || chars[i] == \"-\") {\n        sign = chars[i] == \"-\" ? -1 : 1\n        i += 1\n    }\n    while i < chars.count && chars[i].isNumber {\n        let digit = Int(String(chars[i]))!\n        if result > (Int(Int32.max) - digit) / 10 {\n            return sign == 1 ? Int(Int32.max) : Int(Int32.min)\n        }\n        result = result * 10 + digit\n        i += 1\n    }\n    return sign * result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Array copy"
        },
        "testCases": [
          {
            "input": "s = \"   -42\"",
            "expectedOutput": "-42",
            "explanation": "Parsed with sign"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-integer"
    ]
  },
  "pow-x-n": {
    "summary": "Calculate x^n efficiently. Binary exponentiation: x^n = (x^(n/2))^2.",
    "approaches": [
      {
        "name": "Binary Exponentiation",
        "intuition": "x^n = x^(n/2) × x^(n/2) or × x if n odd.",
        "approach": "1. Handle negative n by using 1/x and -n\n2. If n odd: result *= x\n3. x *= x, n /= 2",
        "explanation": "O(log n) multiplications.",
        "code": "func myPow(_ x: Double, _ n: Int) -> Double {\n    var x = x, n = n\n    if n < 0 { x = 1/x; n = -n }\n    var result = 1.0\n    while n > 0 {\n        if n % 2 == 1 { result *= x }\n        x *= x\n        n /= 2\n    }\n    return result\n}",
        "complexity": {
          "time": "O(log n)",
          "space": "O(1)",
          "timeExplanation": "Binary exponentiation",
          "spaceExplanation": "Constant"
        },
        "testCases": [
          {
            "input": "x = 2.0, n = 10",
            "expectedOutput": "1024.0",
            "explanation": "2^10 = 1024"
          }
        ]
      }
    ],
    "relatedProblems": [
      "sqrt-x"
    ]
  },
  "sqrt-x": {
    "summary": "Integer square root. Binary search for largest n where n*n <= x.",
    "approaches": [
      {
        "name": "Binary Search",
        "intuition": "Find largest n where n² ≤ x.",
        "approach": "1. Binary search in [0, x]\n2. If mid² <= x, try higher\n3. Else try lower",
        "explanation": "Use long to avoid overflow in mid*mid.",
        "code": "func mySqrt(_ x: Int) -> Int {\n    if x < 2 { return x }\n    var left = 1, right = x / 2\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if mid <= x / mid {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return right\n}",
        "complexity": {
          "time": "O(log x)",
          "space": "O(1)",
          "timeExplanation": "Binary search",
          "spaceExplanation": "Constant"
        },
        "testCases": [
          {
            "input": "x = 8",
            "expectedOutput": "2",
            "explanation": "√8 ≈ 2.83, floor is 2"
          }
        ]
      }
    ],
    "relatedProblems": [
      "pow-x-n"
    ]
  },
  "multiply-strings": {
    "summary": "Multiply two numbers as strings. Grade school multiplication.",
    "approaches": [
      {
        "name": "Grade School Method",
        "intuition": "Multiply digit by digit, accumulate at position i+j.",
        "approach": "1. result[i+j] += num1[i] * num2[j]\n2. Handle carries\n3. Convert to string",
        "explanation": "Position i+j+1 gets the ones digit, carry to i+j.",
        "code": "func multiply(_ num1: String, _ num2: String) -> String {\n    let n1 = Array(num1), n2 = Array(num2)\n    var result = [Int](repeating: 0, count: n1.count + n2.count)\n    for i in (0..<n1.count).reversed() {\n        for j in (0..<n2.count).reversed() {\n            let mul = Int(String(n1[i]))! * Int(String(n2[j]))!\n            let p1 = i + j, p2 = i + j + 1\n            let sum = mul + result[p2]\n            result[p2] = sum % 10\n            result[p1] += sum / 10\n        }\n    }\n    var str = result.map { String($0) }.joined()\n    while str.count > 1 && str.first == \"0\" { str.removeFirst() }\n    return str\n}",
        "complexity": {
          "time": "O(m×n)",
          "space": "O(m+n)",
          "timeExplanation": "Nested loops",
          "spaceExplanation": "Result array"
        },
        "testCases": [
          {
            "input": "num1 = \"123\", num2 = \"456\"",
            "expectedOutput": "\"56088\"",
            "explanation": "123 × 456 = 56088"
          }
        ]
      }
    ],
    "relatedProblems": [
      "add-strings"
    ]
  },
  "add-strings": {
    "summary": "Add two numbers as strings. Digit by digit with carry.",
    "approaches": [
      {
        "name": "Elementary Addition",
        "intuition": "Add from right to left with carry.",
        "approach": "1. Iterate from end of both strings\n2. Add digits + carry\n3. Prepend result digit",
        "explanation": "Handle different lengths by treating missing digits as 0.",
        "code": "func addStrings(_ num1: String, _ num2: String) -> String {\n    var i = num1.count - 1, j = num2.count - 1\n    var carry = 0, result = \"\"\n    let n1 = Array(num1), n2 = Array(num2)\n    while i >= 0 || j >= 0 || carry > 0 {\n        let d1 = i >= 0 ? Int(String(n1[i]))! : 0\n        let d2 = j >= 0 ? Int(String(n2[j]))! : 0\n        let sum = d1 + d2 + carry\n        result = String(sum % 10) + result\n        carry = sum / 10\n        i -= 1; j -= 1\n    }\n    return result\n}",
        "complexity": {
          "time": "O(max(m,n))",
          "space": "O(max(m,n))",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Result string"
        },
        "testCases": [
          {
            "input": "num1 = \"11\", num2 = \"123\"",
            "expectedOutput": "\"134\"",
            "explanation": "11 + 123 = 134"
          }
        ]
      }
    ],
    "relatedProblems": [
      "add-two-numbers"
    ]
  },
  "detect-squares": {
    "summary": "Design structure to count axis-aligned squares. Store points, query diagonals.",
    "approaches": [
      {
        "name": "HashMap",
        "intuition": "For query point, find diagonal points and check for square corners.",
        "approach": "1. Store point counts in map\n2. For count query, find points at same x or y\n3. Check if other two corners exist",
        "explanation": "Square defined by diagonal - check perpendicular corners.",
        "code": "class DetectSquares {\n    var points: [[Int]: Int] = [:]\n    \n    func add(_ point: [Int]) {\n        points[point, default: 0] += 1\n    }\n    \n    func count(_ point: [Int]) -> Int {\n        let px = point[0], py = point[1]\n        var total = 0\n        for (p, cnt) in points {\n            let x = p[0], y = p[1]\n            if abs(px - x) != abs(py - y) || x == px { continue }\n            total += cnt * (points[[x, py]] ?? 0) * (points[[px, y]] ?? 0)\n        }\n        return total\n    }\n}",
        "complexity": {
          "time": "O(n) count",
          "space": "O(n)",
          "timeExplanation": "Check all points",
          "spaceExplanation": "Store points"
        },
        "testCases": [
          {
            "input": "add([3,10]), add([11,2]), add([3,2]), count([11,10])",
            "expectedOutput": "1",
            "explanation": "One valid square"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "evaluate-reverse-polish-notation": {
    "summary": "Evaluate RPN expression. Stack: push numbers, operators pop two and push result.",
    "approaches": [
      {
        "name": "Stack",
        "intuition": "Operators act on top two stack elements.",
        "approach": "1. If number, push to stack\n2. If operator, pop two, compute, push result\n3. Return stack top",
        "explanation": "RPN eliminates need for parentheses.",
        "code": "func evalRPN(_ tokens: [String]) -> Int {\n    var stack: [Int] = []\n    let ops: [String: (Int, Int) -> Int] = [\"+\": (+), \"-\": (-), \"*\": (*), \"/\": (/)]\n    for token in tokens {\n        if let op = ops[token] {\n            let b = stack.removeLast()\n            let a = stack.removeLast()\n            stack.append(op(a, b))\n        } else {\n            stack.append(Int(token)!)\n        }\n    }\n    return stack[0]\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Stack size"
        },
        "testCases": [
          {
            "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
            "expectedOutput": "9",
            "explanation": "(2+1)*3 = 9"
          }
        ]
      }
    ],
    "relatedProblems": [
      "basic-calculator"
    ]
  },
  "basic-calculator": {
    "summary": "Evaluate expression with +, -, parentheses. Stack for nested parentheses.",
    "approaches": [
      {
        "name": "Stack for Parentheses",
        "intuition": "Push current result and sign when entering parens.",
        "approach": "1. Track current number, result, sign\n2. On '(': push result and sign, reset\n3. On ')': pop and combine with current result",
        "explanation": "Stack stores context before each nested expression.",
        "code": "func calculate(_ s: String) -> Int {\n    var stack: [Int] = []\n    var result = 0, num = 0, sign = 1\n    for char in s {\n        if char.isNumber {\n            num = num * 10 + Int(String(char))!\n        } else if char == \"+\" {\n            result += sign * num; num = 0; sign = 1\n        } else if char == \"-\" {\n            result += sign * num; num = 0; sign = -1\n        } else if char == \"(\" {\n            stack.append(result); stack.append(sign)\n            result = 0; sign = 1\n        } else if char == \")\" {\n            result += sign * num; num = 0\n            result *= stack.removeLast()\n            result += stack.removeLast()\n        }\n    }\n    return result + sign * num\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Stack for nesting"
        },
        "testCases": [
          {
            "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
            "expectedOutput": "23",
            "explanation": "Evaluate with parentheses"
          }
        ]
      }
    ],
    "relatedProblems": [
      "basic-calculator-ii"
    ]
  },
  "basic-calculator-ii": {
    "summary": "Evaluate expression with +, -, *, /. Stack handles precedence.",
    "approaches": [
      {
        "name": "Stack with Precedence",
        "intuition": "* and / operate immediately, + and - wait on stack.",
        "approach": "1. Track previous operator\n2. On +/-: push number to stack\n3. On *//: pop, compute, push result\n4. Sum stack at end",
        "explanation": "Higher precedence ops execute immediately.",
        "code": "func calculate(_ s: String) -> Int {\n    var stack: [Int] = []\n    var num = 0, op: Character = \"+\"\n    let s = s + \"+\"\n    for char in s {\n        if char.isNumber {\n            num = num * 10 + Int(String(char))!\n        } else if char != \" \" {\n            switch op {\n            case \"+\": stack.append(num)\n            case \"-\": stack.append(-num)\n            case \"*\": stack.append(stack.removeLast() * num)\n            case \"/\": stack.append(stack.removeLast() / num)\n            default: break\n            }\n            op = char; num = 0\n        }\n    }\n    return stack.reduce(0, +)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Stack size"
        },
        "testCases": [
          {
            "input": "s = \"3+2*2\"",
            "expectedOutput": "7",
            "explanation": "3+(2*2)=7"
          }
        ]
      }
    ],
    "relatedProblems": [
      "basic-calculator"
    ]
  },
  "sliding-window-maximum": {
    "summary": "Maximum in each sliding window. Monotonic deque stores indices.",
    "approaches": [
      {
        "name": "Monotonic Deque",
        "intuition": "Deque front is always max. Remove smaller elements from back.",
        "approach": "1. Remove indices outside window from front\n2. Remove smaller elements from back\n3. Add current index to back\n4. Front is current window max",
        "explanation": "Deque maintains decreasing order.",
        "code": "func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\n    var deque: [Int] = []  // Indices\n    var result: [Int] = []\n    for i in 0..<nums.count {\n        while !deque.isEmpty && deque.first! <= i - k { deque.removeFirst() }\n        while !deque.isEmpty && nums[deque.last!] < nums[i] { deque.removeLast() }\n        deque.append(i)\n        if i >= k - 1 { result.append(nums[deque.first!]) }\n    }\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(k)",
          "timeExplanation": "Each element added/removed once",
          "spaceExplanation": "Deque size"
        },
        "testCases": [
          {
            "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
            "expectedOutput": "[3,3,5,5,6,7]",
            "explanation": "Max of each window"
          }
        ]
      }
    ],
    "relatedProblems": [
      "min-stack"
    ]
  },
  "next-greater-element-i": {
    "summary": "For each element, find next greater in second array. Monotonic stack + map.",
    "approaches": [
      {
        "name": "Monotonic Stack",
        "intuition": "Build map of next greater elements using stack.",
        "approach": "1. Traverse nums2 with decreasing stack\n2. Pop smaller elements, map them to current\n3. Look up each nums1 element in map",
        "explanation": "Stack maintains elements waiting for next greater.",
        "code": "func nextGreaterElement(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n    var stack: [Int] = []\n    var nextGreater: [Int: Int] = [:]\n    for num in nums2 {\n        while !stack.isEmpty && stack.last! < num {\n            nextGreater[stack.removeLast()] = num\n        }\n        stack.append(num)\n    }\n    return nums1.map { nextGreater[$0] ?? -1 }\n}",
        "complexity": {
          "time": "O(n + m)",
          "space": "O(n)",
          "timeExplanation": "Process both arrays",
          "spaceExplanation": "Map storage"
        },
        "testCases": [
          {
            "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
            "expectedOutput": "[-1,3,-1]",
            "explanation": "Next greater for each"
          }
        ]
      }
    ],
    "relatedProblems": [
      "next-greater-element-ii",
      "daily-temperatures"
    ]
  },
  "sort-list": {
    "summary": "Sort linked list in O(n log n). Merge sort: split at middle, merge sorted halves.",
    "approaches": [
      {
        "name": "Merge Sort",
        "intuition": "Divide and conquer on linked list.",
        "approach": "1. Find middle using slow/fast\n2. Recursively sort both halves\n3. Merge sorted halves",
        "explanation": "Merge sort is natural for linked lists.",
        "code": "func sortList(_ head: ListNode?) -> ListNode? {\n    guard head != nil && head?.next != nil else { return head }\n    var slow = head, fast = head?.next\n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n    }\n    let mid = slow?.next\n    slow?.next = nil\n    return merge(sortList(head), sortList(mid))\n}\n\nfunc merge(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var curr = dummy, l1 = l1, l2 = l2\n    while l1 != nil && l2 != nil {\n        if l1!.val < l2!.val {\n            curr.next = l1; l1 = l1?.next\n        } else {\n            curr.next = l2; l2 = l2?.next\n        }\n        curr = curr.next!\n    }\n    curr.next = l1 ?? l2\n    return dummy.next\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(log n)",
          "timeExplanation": "Merge sort",
          "spaceExplanation": "Recursion stack"
        },
        "testCases": [
          {
            "input": "head = [4,2,1,3]",
            "expectedOutput": "[1,2,3,4]",
            "explanation": "Sorted list"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-two-sorted-lists"
    ]
  },
  "insertion-sort-list": {
    "summary": "Sort linked list using insertion sort. Build sorted portion, insert each node.",
    "approaches": [
      {
        "name": "Insertion Sort",
        "intuition": "Build sorted list by inserting each node in correct position.",
        "approach": "1. Maintain sorted list with dummy head\n2. For each node, find insert position\n3. Insert into sorted portion",
        "explanation": "O(n²) but simple and stable.",
        "code": "func insertionSortList(_ head: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var curr = head\n    while curr != nil {\n        let next = curr?.next\n        var prev = dummy\n        while prev.next != nil && prev.next!.val < curr!.val {\n            prev = prev.next!\n        }\n        curr?.next = prev.next\n        prev.next = curr\n        curr = next\n    }\n    return dummy.next\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(1)",
          "timeExplanation": "Insertion sort",
          "spaceExplanation": "Reuse nodes"
        },
        "testCases": [
          {
            "input": "head = [4,2,1,3]",
            "expectedOutput": "[1,2,3,4]",
            "explanation": "Sorted"
          }
        ]
      }
    ],
    "relatedProblems": [
      "sort-list"
    ]
  },
  "swap-nodes-in-pairs": {
    "summary": "Swap every two adjacent nodes. Recursively or iteratively swap pairs.",
    "approaches": [
      {
        "name": "Iterative",
        "intuition": "Use dummy node, swap each pair.",
        "approach": "1. prev → first → second → next\n2. Change to prev → second → first → next\n3. Move prev two steps",
        "explanation": "Track prev to reconnect after swap.",
        "code": "func swapPairs(_ head: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    dummy.next = head\n    var prev: ListNode? = dummy\n    while prev?.next != nil && prev?.next?.next != nil {\n        let first = prev?.next\n        let second = first?.next\n        first?.next = second?.next\n        second?.next = first\n        prev?.next = second\n        prev = first\n    }\n    return dummy.next\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Constant"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4]",
            "expectedOutput": "[2,1,4,3]",
            "explanation": "Pairs swapped"
          }
        ]
      }
    ],
    "relatedProblems": [
      "reverse-nodes-in-k-group"
    ]
  },
  "reverse-nodes-in-k-group": {
    "summary": "Reverse every k nodes. Count k, reverse group, recursively handle rest.",
    "approaches": [
      {
        "name": "Iterative",
        "intuition": "Reverse k nodes at a time, connect groups.",
        "approach": "1. Count k nodes exist\n2. Reverse those k nodes\n3. Connect to next group (recursive or iterative)",
        "explanation": "Keep partial group at end unchanged.",
        "code": "func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\n    var count = 0\n    var curr = head\n    while curr != nil && count < k {\n        curr = curr?.next\n        count += 1\n    }\n    if count < k { return head }\n    \n    var prev: ListNode? = nil\n    curr = head\n    for _ in 0..<k {\n        let next = curr?.next\n        curr?.next = prev\n        prev = curr\n        curr = next\n    }\n    head?.next = reverseKGroup(curr, k)\n    return prev\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n/k)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "Recursion"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5], k = 2",
            "expectedOutput": "[2,1,4,3,5]",
            "explanation": "Pairs reversed, 5 unchanged"
          }
        ]
      }
    ],
    "relatedProblems": [
      "swap-nodes-in-pairs"
    ]
  },
  "odd-even-linked-list": {
    "summary": "Group odd indices then even indices. Maintain two lists, connect at end.",
    "approaches": [
      {
        "name": "Two Pointers",
        "intuition": "Build odd and even lists, then connect.",
        "approach": "1. odd points to odd indices, even to even\n2. odd.next = even.next (skip even)\n3. Connect odd tail to even head",
        "explanation": "Indices are 1-based.",
        "code": "func oddEvenList(_ head: ListNode?) -> ListNode? {\n    guard head != nil else { return nil }\n    var odd = head, even = head?.next\n    let evenHead = even\n    while even != nil && even?.next != nil {\n        odd?.next = even?.next\n        odd = odd?.next\n        even?.next = odd?.next\n        even = even?.next\n    }\n    odd?.next = evenHead\n    return head\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Single pass",
          "spaceExplanation": "Reuse nodes"
        },
        "testCases": [
          {
            "input": "head = [1,2,3,4,5]",
            "expectedOutput": "[1,3,5,2,4]",
            "explanation": "Odd indices then even"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "flatten-binary-tree-to-linked-list": {
    "summary": "Flatten tree to right-skewed list (preorder). Morris traversal or recursion.",
    "approaches": [
      {
        "name": "Iterative",
        "intuition": "For each node, connect left subtree's rightmost to right subtree.",
        "approach": "1. Move left subtree to right\n2. Find rightmost of moved subtree\n3. Connect original right subtree there",
        "explanation": "Process top-down, restructuring as we go.",
        "code": "func flatten(_ root: TreeNode?) {\n    var curr = root\n    while curr != nil {\n        if curr?.left != nil {\n            var rightmost = curr?.left\n            while rightmost?.right != nil {\n                rightmost = rightmost?.right\n            }\n            rightmost?.right = curr?.right\n            curr?.right = curr?.left\n            curr?.left = nil\n        }\n        curr = curr?.right\n    }\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "In-place"
        },
        "testCases": [
          {
            "input": "root = [1,2,5,3,4,null,6]",
            "expectedOutput": "[1,null,2,null,3,null,4,null,5,null,6]",
            "explanation": "Flattened preorder"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "binary-tree-zigzag-level-order-traversal": {
    "summary": "Level order with alternating direction. BFS with flag to reverse alternate levels.",
    "approaches": [
      {
        "name": "BFS with Direction",
        "intuition": "Standard level order, reverse every other level.",
        "approach": "1. BFS level by level\n2. Toggle direction flag\n3. If right-to-left, reverse level before adding",
        "explanation": "Or use deque and alternate add direction.",
        "code": "func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var leftToRight = true\n    \n    while !queue.isEmpty {\n        var level: [Int] = []\n        let size = queue.count\n        for _ in 0..<size {\n            let node = queue.removeFirst()\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(leftToRight ? level : level.reversed())\n        leftToRight.toggle()\n    }\n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(w)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "Max width"
        },
        "testCases": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "expectedOutput": "[[3],[20,9],[15,7]]",
            "explanation": "Zigzag order"
          }
        ]
      }
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal"
    ]
  },
  "count-good-nodes-in-binary-tree": {
    "summary": "Count nodes with no greater value on path from root. DFS tracking max so far.",
    "approaches": [
      {
        "name": "DFS",
        "intuition": "Node is good if >= all ancestors.",
        "approach": "Track max value seen on path, count nodes >= max.",
        "explanation": "Update max at each node, pass down.",
        "code": "func goodNodes(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?, _ maxVal: Int) -> Int {\n        guard let node = node else { return 0 }\n        let good = node.val >= maxVal ? 1 : 0\n        let newMax = max(maxVal, node.val)\n        return good + dfs(node.left, newMax) + dfs(node.right, newMax)\n    }\n    return dfs(root, Int.min)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(h)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "Recursion depth"
        },
        "testCases": [
          {
            "input": "root = [3,1,4,3,null,1,5]",
            "expectedOutput": "4",
            "explanation": "3,3,4,5 are good"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "time-needed-to-inform-all-employees": {
    "summary": "Max time to inform all employees. DFS/BFS from head, sum inform times on path.",
    "approaches": [
      {
        "name": "DFS",
        "intuition": "Total time = max path sum of inform times.",
        "approach": "DFS accumulating inform times, return max.",
        "explanation": "Each employee waits for manager + manager's path.",
        "code": "func numOfMinutes(_ n: Int, _ headID: Int, _ manager: [Int], _ informTime: [Int]) -> Int {\n    var subordinates = [[Int]](repeating: [], count: n)\n    for i in 0..<n {\n        if manager[i] != -1 { subordinates[manager[i]].append(i) }\n    }\n    func dfs(_ node: Int) -> Int {\n        var maxTime = 0\n        for sub in subordinates[node] {\n            maxTime = max(maxTime, dfs(sub))\n        }\n        return informTime[node] + maxTime\n    }\n    return dfs(headID)\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Visit each employee",
          "spaceExplanation": "Tree storage"
        },
        "testCases": [
          {
            "input": "n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]",
            "expectedOutput": "1",
            "explanation": "1 minute to inform all"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "populating-next-right-pointers-in-each-node": {
    "summary": "Connect each node to its right neighbor. BFS level order or use existing next pointers.",
    "approaches": [
      {
        "name": "Level Order",
        "intuition": "Connect nodes at same level left to right.",
        "approach": "Use next pointer of parent level to traverse and connect children.",
        "explanation": "O(1) space by using established next pointers.",
        "code": "func connect(_ root: Node?) -> Node? {\n    var leftmost = root\n    while leftmost?.left != nil {\n        var head = leftmost\n        while head != nil {\n            head?.left?.next = head?.right\n            if head?.next != nil {\n                head?.right?.next = head?.next?.left\n            }\n            head = head?.next\n        }\n        leftmost = leftmost?.left\n    }\n    return root\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(1)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "Use existing pointers"
        },
        "testCases": [
          {
            "input": "root = [1,2,3,4,5,6,7]",
            "expectedOutput": "Connected tree",
            "explanation": "Each level connected"
          }
        ]
      }
    ],
    "relatedProblems": [
      "populating-next-right-pointers-in-each-node-ii"
    ]
  },
  "word-ladder-ii": {
    "summary": "Find all shortest transformation sequences. BFS to find distance, then DFS to reconstruct paths.",
    "approaches": [
      {
        "name": "BFS + DFS",
        "intuition": "BFS finds distances, DFS backtracks to find all shortest paths.",
        "approach": "1. BFS from endWord to compute distances\n2. DFS from beginWord following decreasing distances",
        "explanation": "BFS ensures we only explore shortest paths.",
        "code": "func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\n    var wordSet = Set(wordList)\n    if !wordSet.contains(endWord) { return [] }\n    // Build graph and BFS for distances (simplified)\n    // Then DFS to collect all paths\n    return []\n}",
        "complexity": {
          "time": "O(n × m × 26)",
          "space": "O(n × m)",
          "timeExplanation": "BFS + DFS",
          "spaceExplanation": "Word set + paths"
        },
        "testCases": [
          {
            "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [...]",
            "expectedOutput": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"]]",
            "explanation": "All shortest paths"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-ladder"
    ]
  },
  "snakes-and-ladders": {
    "summary": "Minimum moves in snakes and ladders. BFS from square 1 to n².",
    "approaches": [
      {
        "name": "BFS",
        "intuition": "BFS finds shortest path in unweighted graph.",
        "approach": "1. Convert board position to coordinates\n2. BFS from 1, try moves 1-6\n3. Handle snakes/ladders",
        "explanation": "Each state is a square, edges are dice rolls.",
        "code": "func snakesAndLadders(_ board: [[Int]]) -> Int {\n    let n = board.count\n    func getCoord(_ s: Int) -> (Int, Int) {\n        let r = (s - 1) / n\n        let c = (s - 1) % n\n        let row = n - 1 - r\n        let col = r % 2 == 0 ? c : n - 1 - c\n        return (row, col)\n    }\n    var visited = Set<Int>([1])\n    var queue = [(1, 0)]\n    while !queue.isEmpty {\n        let (curr, moves) = queue.removeFirst()\n        for i in 1...6 {\n            var next = curr + i\n            if next > n * n { continue }\n            let (r, c) = getCoord(next)\n            if board[r][c] != -1 { next = board[r][c] }\n            if next == n * n { return moves + 1 }\n            if !visited.contains(next) {\n                visited.insert(next)\n                queue.append((next, moves + 1))\n            }\n        }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(n²)",
          "space": "O(n²)",
          "timeExplanation": "Visit each square",
          "spaceExplanation": "Visited set"
        },
        "testCases": [
          {
            "input": "board with snakes/ladders",
            "expectedOutput": "4",
            "explanation": "Minimum dice rolls"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "minimum-genetic-mutation": {
    "summary": "Minimum mutations to reach target gene. BFS treating genes as nodes.",
    "approaches": [
      {
        "name": "BFS",
        "intuition": "Same as word ladder but with 4 choices (A,C,G,T).",
        "approach": "1. BFS from start gene\n2. Try all single-character mutations\n3. Count steps to reach end",
        "explanation": "Only valid mutations (in bank) explored.",
        "code": "func minMutation(_ start: String, _ end: String, _ bank: [String]) -> Int {\n    var bankSet = Set(bank)\n    if !bankSet.contains(end) { return -1 }\n    var queue = [(start, 0)]\n    var visited = Set([start])\n    let genes: [Character] = [\"A\", \"C\", \"G\", \"T\"]\n    \n    while !queue.isEmpty {\n        let (gene, steps) = queue.removeFirst()\n        if gene == end { return steps }\n        var chars = Array(gene)\n        for i in 0..<chars.count {\n            let original = chars[i]\n            for g in genes {\n                chars[i] = g\n                let mutation = String(chars)\n                if bankSet.contains(mutation) && !visited.contains(mutation) {\n                    visited.insert(mutation)\n                    queue.append((mutation, steps + 1))\n                }\n            }\n            chars[i] = original\n        }\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(n × 8 × 4)",
          "space": "O(n)",
          "timeExplanation": "BFS through bank",
          "spaceExplanation": "Visited set"
        },
        "testCases": [
          {
            "input": "start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
            "expectedOutput": "2",
            "explanation": "Two mutations"
          }
        ]
      }
    ],
    "relatedProblems": [
      "word-ladder"
    ]
  },
  "evaluate-division": {
    "summary": "Evaluate a/b given equations. Build graph of ratios, DFS to find path product.",
    "approaches": [
      {
        "name": "Graph DFS",
        "intuition": "a/b = a/c × c/b. Find path and multiply weights.",
        "approach": "1. Build graph: a→b with weight values[i], b→a with 1/values[i]\n2. For query, DFS find path and multiply",
        "explanation": "Graph enables transitive division.",
        "code": "func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\n    var graph: [String: [(String, Double)]] = [:]\n    for i in 0..<equations.count {\n        let a = equations[i][0], b = equations[i][1]\n        graph[a, default: []].append((b, values[i]))\n        graph[b, default: []].append((a, 1.0 / values[i]))\n    }\n    \n    func dfs(_ curr: String, _ target: String, _ visited: inout Set<String>) -> Double {\n        if graph[curr] == nil { return -1.0 }\n        if curr == target { return 1.0 }\n        visited.insert(curr)\n        for (next, val) in graph[curr]! {\n            if !visited.contains(next) {\n                let res = dfs(next, target, &visited)\n                if res != -1.0 { return val * res }\n            }\n        }\n        return -1.0\n    }\n    \n    return queries.map { q in\n        var visited = Set<String>()\n        return dfs(q[0], q[1], &visited)\n    }\n}",
        "complexity": {
          "time": "O(Q × N)",
          "space": "O(N)",
          "timeExplanation": "Q queries, N nodes each",
          "spaceExplanation": "Graph storage"
        },
        "testCases": [
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"]]",
            "expectedOutput": "[6.0]",
            "explanation": "a/c = a/b × b/c = 2×3 = 6"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "accounts-merge": {
    "summary": "Merge accounts with same emails. Union Find on emails.",
    "approaches": [
      {
        "name": "Union Find",
        "intuition": "Union emails in same account, group by root.",
        "approach": "1. Map email to account index\n2. Union emails within each account\n3. Group emails by root, attach to name",
        "explanation": "Same email = same person.",
        "code": "func accountsMerge(_ accounts: [[String]]) -> [[String]] {\n    var parent: [String: String] = [:]\n    var emailToName: [String: String] = [:]\n    \n    func find(_ x: String) -> String {\n        if parent[x] == nil { parent[x] = x }\n        if parent[x] != x { parent[x] = find(parent[x]!) }\n        return parent[x]!\n    }\n    \n    func union(_ x: String, _ y: String) {\n        parent[find(x)] = find(y)\n    }\n    \n    for account in accounts {\n        let name = account[0]\n        for i in 1..<account.count {\n            emailToName[account[i]] = name\n            if i > 1 { union(account[1], account[i]) }\n        }\n    }\n    \n    var groups: [String: [String]] = [:]\n    for email in emailToName.keys {\n        groups[find(email), default: []].append(email)\n    }\n    \n    return groups.values.map { emails in\n        [emailToName[emails[0]]!] + emails.sorted()\n    }\n}",
        "complexity": {
          "time": "O(n × α(n))",
          "space": "O(n)",
          "timeExplanation": "Union-Find operations",
          "spaceExplanation": "Parent map"
        },
        "testCases": [
          {
            "input": "accounts with overlapping emails",
            "expectedOutput": "Merged accounts",
            "explanation": "Same person's accounts merged"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "is-graph-bipartite": {
    "summary": "Check if graph can be 2-colored. BFS/DFS coloring adjacent nodes alternately.",
    "approaches": [
      {
        "name": "BFS Coloring",
        "intuition": "Bipartite = no odd cycles = 2-colorable.",
        "approach": "1. Color nodes with 0 or 1\n2. Adjacent nodes must have different colors\n3. If conflict, not bipartite",
        "explanation": "BFS ensures we catch conflicts.",
        "code": "func isBipartite(_ graph: [[Int]]) -> Bool {\n    var colors = [Int](repeating: -1, count: graph.count)\n    for start in 0..<graph.count {\n        if colors[start] != -1 { continue }\n        var queue = [start]\n        colors[start] = 0\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            for neighbor in graph[node] {\n                if colors[neighbor] == -1 {\n                    colors[neighbor] = 1 - colors[node]\n                    queue.append(neighbor)\n                } else if colors[neighbor] == colors[node] {\n                    return false\n                }\n            }\n        }\n    }\n    return true\n}",
        "complexity": {
          "time": "O(V+E)",
          "space": "O(V)",
          "timeExplanation": "Visit all nodes and edges",
          "spaceExplanation": "Color array"
        },
        "testCases": [
          {
            "input": "graph = [[1,3],[0,2],[1,3],[0,2]]",
            "expectedOutput": "true",
            "explanation": "Can be 2-colored"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "minimum-height-trees": {
    "summary": "Find roots that minimize tree height. Trim leaves until 1-2 nodes remain.",
    "approaches": [
      {
        "name": "Topological Trimming",
        "intuition": "MHT roots are the center(s) of the longest path.",
        "approach": "1. Find all leaves (degree 1)\n2. Remove leaves, update degrees\n3. Repeat until 1-2 nodes remain",
        "explanation": "Tree has 1 or 2 centers.",
        "code": "func findMinHeightTrees(_ n: Int, _ edges: [[Int]]) -> [Int] {\n    if n == 1 { return [0] }\n    var adj = [[Int]](repeating: [], count: n)\n    var degree = [Int](repeating: 0, count: n)\n    for e in edges {\n        adj[e[0]].append(e[1])\n        adj[e[1]].append(e[0])\n        degree[e[0]] += 1\n        degree[e[1]] += 1\n    }\n    var leaves = (0..<n).filter { degree[$0] == 1 }\n    var remaining = n\n    while remaining > 2 {\n        var newLeaves: [Int] = []\n        for leaf in leaves {\n            remaining -= 1\n            for neighbor in adj[leaf] {\n                degree[neighbor] -= 1\n                if degree[neighbor] == 1 { newLeaves.append(neighbor) }\n            }\n        }\n        leaves = newLeaves\n    }\n    return leaves\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Adjacency list"
        },
        "testCases": [
          {
            "input": "n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]",
            "expectedOutput": "[3,4]",
            "explanation": "Two MHT roots"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "loud-and-rich": {
    "summary": "For each person, find quietest among richer people. DFS with memoization.",
    "approaches": [
      {
        "name": "DFS",
        "intuition": "Recursively find quietest in richer subgraph.",
        "approach": "1. Build graph: edge from richer to poorer\n2. DFS from each person into richer neighbors\n3. Memoize results",
        "explanation": "answer[x] = quietest person in x's richer-or-equal set.",
        "code": "func loudAndRich(_ richer: [[Int]], _ quiet: [Int]) -> [Int] {\n    let n = quiet.count\n    var graph = [[Int]](repeating: [], count: n)\n    for r in richer {\n        graph[r[1]].append(r[0])\n    }\n    var answer = [Int](repeating: -1, count: n)\n    \n    func dfs(_ node: Int) -> Int {\n        if answer[node] != -1 { return answer[node] }\n        answer[node] = node\n        for richer in graph[node] {\n            let candidate = dfs(richer)\n            if quiet[candidate] < quiet[answer[node]] {\n                answer[node] = candidate\n            }\n        }\n        return answer[node]\n    }\n    \n    for i in 0..<n { dfs(i) }\n    return answer\n}",
        "complexity": {
          "time": "O(n + r)",
          "space": "O(n + r)",
          "timeExplanation": "Visit each node once",
          "spaceExplanation": "Graph + memo"
        },
        "testCases": [
          {
            "input": "richer = [[1,0],[2,1],[3,1],[3,7],...], quiet = [3,2,5,4,6,1,7,0]",
            "expectedOutput": "[5,5,2,5,4,5,6,7]",
            "explanation": "Quietest richer person for each"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "find-eventual-safe-states": {
    "summary": "Find nodes that don't lead to cycles. Reverse graph, topo sort from terminal nodes.",
    "approaches": [
      {
        "name": "Reverse Topological Sort",
        "intuition": "Safe nodes eventually reach terminal nodes only.",
        "approach": "1. Reverse edges\n2. Start from terminal nodes (no outgoing edges in original)\n3. Propagate safety backwards",
        "explanation": "Or detect cycles with DFS coloring.",
        "code": "func eventualSafeNodes(_ graph: [[Int]]) -> [Int] {\n    let n = graph.count\n    var state = [Int](repeating: 0, count: n)  // 0=unvisited, 1=visiting, 2=safe\n    \n    func dfs(_ node: Int) -> Bool {\n        if state[node] != 0 { return state[node] == 2 }\n        state[node] = 1\n        for next in graph[node] {\n            if !dfs(next) { return false }\n        }\n        state[node] = 2\n        return true\n    }\n    \n    var result: [Int] = []\n    for i in 0..<n {\n        if dfs(i) { result.append(i) }\n    }\n    return result\n}",
        "complexity": {
          "time": "O(V+E)",
          "space": "O(V)",
          "timeExplanation": "Visit each node",
          "spaceExplanation": "State array"
        },
        "testCases": [
          {
            "input": "graph = [[1,2],[2,3],[5],[0],[5],[],[]]",
            "expectedOutput": "[2,4,5,6]",
            "explanation": "Safe nodes"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "bus-routes": {
    "summary": "Minimum buses to reach target. BFS on routes (not stops).",
    "approaches": [
      {
        "name": "BFS on Routes",
        "intuition": "Each bus route is a node, connected if they share a stop.",
        "approach": "1. Map stop to routes\n2. BFS from routes containing source\n3. Count route changes",
        "explanation": "Edges are shared stops between routes.",
        "code": "func numBusesToDestination(_ routes: [[Int]], _ source: Int, _ target: Int) -> Int {\n    if source == target { return 0 }\n    var stopToRoutes: [Int: [Int]] = [:]\n    for (i, route) in routes.enumerated() {\n        for stop in route {\n            stopToRoutes[stop, default: []].append(i)\n        }\n    }\n    var visitedRoutes = Set<Int>()\n    var visitedStops = Set<Int>([source])\n    var queue = [source]\n    var buses = 0\n    \n    while !queue.isEmpty {\n        buses += 1\n        var newStops: [Int] = []\n        for stop in queue {\n            for route in stopToRoutes[stop] ?? [] {\n                if visitedRoutes.contains(route) { continue }\n                visitedRoutes.insert(route)\n                for nextStop in routes[route] {\n                    if nextStop == target { return buses }\n                    if !visitedStops.contains(nextStop) {\n                        visitedStops.insert(nextStop)\n                        newStops.append(nextStop)\n                    }\n                }\n            }\n        }\n        queue = newStops\n    }\n    return -1\n}",
        "complexity": {
          "time": "O(n × m)",
          "space": "O(n × m)",
          "timeExplanation": "n routes, m stops",
          "spaceExplanation": "Stop to route mapping"
        },
        "testCases": [
          {
            "input": "routes = [[1,2,7],[3,6,7]], source = 1, target = 6",
            "expectedOutput": "2",
            "explanation": "Route 0 then route 1"
          }
        ]
      }
    ],
    "relatedProblems": []
  },
  "path-with-maximum-probability": {
    "summary": "Max probability path in graph. Modified Dijkstra with max instead of min.",
    "approaches": [
      {
        "name": "Dijkstra Max",
        "intuition": "Dijkstra but maximize probability product.",
        "approach": "1. Max heap on probability\n2. Relax edges by multiplying probabilities\n3. Return prob[end]",
        "explanation": "Use negative log to convert to shortest path.",
        "code": "func maxProbability(_ n: Int, _ edges: [[Int]], _ succProb: [Double], _ start: Int, _ end: Int) -> Double {\n    var graph = [Int: [(Int, Double)]]()\n    for (i, e) in edges.enumerated() {\n        graph[e[0], default: []].append((e[1], succProb[i]))\n        graph[e[1], default: []].append((e[0], succProb[i]))\n    }\n    var prob = [Double](repeating: 0, count: n)\n    prob[start] = 1\n    var heap = [(1.0, start)]  // (prob, node)\n    \n    while !heap.isEmpty {\n        heap.sort { $0.0 > $1.0 }  // Max heap\n        let (p, node) = heap.removeFirst()\n        if node == end { return p }\n        if p < prob[node] { continue }\n        for (next, edgeProb) in graph[node] ?? [] {\n            let newProb = p * edgeProb\n            if newProb > prob[next] {\n                prob[next] = newProb\n                heap.append((newProb, next))\n            }\n        }\n    }\n    return 0\n}",
        "complexity": {
          "time": "O(E log V)",
          "space": "O(V+E)",
          "timeExplanation": "Dijkstra",
          "spaceExplanation": "Graph + heap"
        },
        "testCases": [
          {
            "input": "n=3, edges=[[0,1],[1,2],[0,2]], succProb=[0.5,0.5,0.2], start=0, end=2",
            "expectedOutput": "0.25",
            "explanation": "0→1→2 has prob 0.25"
          }
        ]
      }
    ],
    "relatedProblems": [
      "network-delay-time"
    ]
  }
}
