{
  "failed" : 1594,
  "failures" : [
    {
      "actual" : "false",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "bits = [1, 0, 1]",
      "slug" : "1-bit-and-2-bit-characters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "false",
      "input" : "bits = [1, 1, 1, 0]",
      "slug" : "1-bit-and-2-bit-characters",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "bits = [1, 0, 1]",
      "slug" : "1-bit-and-2-bit-characters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "10",
      "input" : "A = [0,1,2], B = [0,1,2], C = [0,1,2], D = [0,1,2]",
      "slug" : "4sum-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Hash Table",
      "approachOrder" : 2,
      "expected" : "10",
      "input" : "A = [0,1,2], B = [0,1,2], C = [0,1,2], D = [0,1,2]",
      "slug" : "4sum-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "3",
      "input" : "nums = [9,0,4,6,7,1]",
      "slug" : "array-nesting",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "4",
      "input" : "nums = [9,0,4,6,7,1]",
      "slug" : "array-nesting",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:1: error: expected 'func' keyword in instance method declaration\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    | `- error: expected 'func' keyword in instance method declaration\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:7: error: unnamed parameters must be written with the empty name '_'\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: unnamed parameters must be written with the empty name '_'\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:5:14: error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |              `- error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:5:31: error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |                               `- error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:7: error: cannot find type 'result' in scope\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: cannot find type 'result' in scope\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n",
      "expected" : "2",
      "input" : "board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] ",
      "slug" : "battleships-in-a-board",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:1: error: expected 'func' keyword in instance method declaration\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    | `- error: expected 'func' keyword in instance method declaration\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:7: error: unnamed parameters must be written with the empty name '_'\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: unnamed parameters must be written with the empty name '_'\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:5:14: error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |              `- error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:5:31: error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |                               `- error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_1\/solution.swift:6:7: error: cannot find type 'result' in scope\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: cannot find type 'result' in scope\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n",
      "expected" : "0",
      "input" : "board = [[\".\",\".\",\".\",\".\"]]",
      "slug" : "battleships-in-a-board",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:1: error: expected 'func' keyword in instance method declaration\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    | `- error: expected 'func' keyword in instance method declaration\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:7: error: unnamed parameters must be written with the empty name '_'\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: unnamed parameters must be written with the empty name '_'\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:5:14: error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |              `- error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:5:31: error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |                               `- error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:7: error: cannot find type 'result' in scope\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: cannot find type 'result' in scope\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n",
      "expected" : "2",
      "input" : "board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] ",
      "slug" : "battleships-in-a-board",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:1: error: expected 'func' keyword in instance method declaration\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    | `- error: expected 'func' keyword in instance method declaration\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:7: error: unnamed parameters must be written with the empty name '_'\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: unnamed parameters must be written with the empty name '_'\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:5:14: error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |              `- error: cannot use instance member 'countBattleships' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:5:31: error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  3 | class Solution {\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n    |                               `- error: cannot use instance member 'board' within property initializer; property initializers run before 'self' is available\n  6 | print(result)\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/battleships-in-a-board_2\/solution.swift:6:7: error: cannot find type 'result' in scope\n  4 | let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n  5 | let result = countBattleships(board)\n  6 | print(result)\n    |       `- error: cannot find type 'result' in scope\n  7 | func countBattleships(_ board: [[Character]]) -> Int {\n  8 |     var count = 0\n",
      "expected" : "0",
      "input" : "board = [[\".\",\".\",\".\",\".\"]]",
      "slug" : "battleships-in-a-board",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_1\/solution.swift:4:173: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; for row in wall { var curEdge: Int = 0; for brick in row { if brick == row[row.count - 1] { break; } curEdge += brick; edges[curEdge, default: 0] += 1; } } let maxCount = edges.values.max() ?? 0; return wall.count - maxCount; }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_1\/solution.swift:4:228: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; for row in wall { var curEdge: Int = 0; for brick in row { if brick == row[row.count - 1] { break; } curEdge += brick; edges[curEdge, default: 0] += 1; } } let maxCount = edges.values.max() ?? 0; return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]",
      "slug" : "brick-wall",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_1\/solution.swift:4:173: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; for row in wall { var curEdge: Int = 0; for brick in row { if brick == row[row.count - 1] { break; } curEdge += brick; edges[curEdge, default: 0] += 1; } } let maxCount = edges.values.max() ?? 0; return wall.count - maxCount; }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_1\/solution.swift:4:228: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; for row in wall { var curEdge: Int = 0; for brick in row { if brick == row[row.count - 1] { break; } curEdge += brick; edges[curEdge, default: 0] += 1; } } let maxCount = edges.values.max() ?? 0; return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "wall = [[1],[1],[1]]",
      "slug" : "brick-wall",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:135: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:275: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:359: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]",
      "slug" : "brick-wall",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:135: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:275: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/brick-wall_2\/solution.swift:4:359: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }\n    |                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "wall = [[1],[1],[1]]",
      "slug" : "brick-wall",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:8:14: error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index') to expected argument type 'Int'\n  6 |   var res = false\n  7 |   for i in s.indices {\n  8 |     for j in i+1..<s.count {\n    |              `- error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index') to expected argument type 'Int'\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:10:22: error: no exact matches in call to subscript \n  8 |     for j in i+1..<s.count {\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n    |                      `- error: no exact matches in call to subscript \n 11 |       sNew[i] = sNew[j]\n 12 |       sNew[j] = temp\n\nSwift.Collection.subscript:2:19: note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get set }}\n  |                   `- note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:11:11: error: subscript 'subscript(_:)' requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression'\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n 11 |       sNew[i] = sNew[j]\n    |           `- error: subscript 'subscript(_:)' requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression'\n 12 |       sNew[j] = temp\n 13 |       if String(sNew) == goal {\n\nSwift.MutableCollection.subscript:2:19: note: where 'R' = 'DefaultIndices<String>.Element' (aka 'String.Index')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get set }}\n  |                   `- note: where 'R' = 'DefaultIndices<String>.Element' (aka 'String.Index')\n3 | \n",
      "expected" : "true",
      "input" : "s = \"ab\", goal = \"ba\"",
      "slug" : "buddy-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:8:14: error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index') to expected argument type 'Int'\n  6 |   var res = false\n  7 |   for i in s.indices {\n  8 |     for j in i+1..<s.count {\n    |              `- error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index') to expected argument type 'Int'\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:10:22: error: no exact matches in call to subscript \n  8 |     for j in i+1..<s.count {\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n    |                      `- error: no exact matches in call to subscript \n 11 |       sNew[i] = sNew[j]\n 12 |       sNew[j] = temp\n\nSwift.Collection.subscript:2:19: note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get set }}\n  |                   `- note: candidate requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/buddy-strings_1\/solution.swift:11:11: error: subscript 'subscript(_:)' requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression'\n  9 |       var sNew = Array(s)\n 10 |       let temp = sNew[i]\n 11 |       sNew[i] = sNew[j]\n    |           `- error: subscript 'subscript(_:)' requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression'\n 12 |       sNew[j] = temp\n 13 |       if String(sNew) == goal {\n\nSwift.MutableCollection.subscript:2:19: note: where 'R' = 'DefaultIndices<String>.Element' (aka 'String.Index')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get set }}\n  |                   `- note: where 'R' = 'DefaultIndices<String>.Element' (aka 'String.Index')\n3 | \n",
      "expected" : "false",
      "input" : "s = \"ab\", goal = \"ab\"",
      "slug" : "buddy-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Optimized Solution",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "s = \"ab\", goal = \"ba\"",
      "slug" : "buddy-strings",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:12:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 | \n 11 |     for (i, char) in secret.enumerated() {\n 12 |         if char == guess[i] {\n    |                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |             bulls += 1\n 14 |         } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:16:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |         } else {\n 15 |             secretCount[char] = (secretCount[char] ?? 0) + 1\n 16 |             guessCount[guess[i]] = (guessCount[guess[i]] ?? 0) + 1\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         }\n 18 |     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:16:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |         } else {\n 15 |             secretCount[char] = (secretCount[char] ?? 0) + 1\n 16 |             guessCount[guess[i]] = (guessCount[guess[i]] ?? 0) + 1\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         }\n 18 |     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1A3B",
      "input" : "secret = \"1807\", guess = \"7810\"",
      "slug" : "bulls-and-cows",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:12:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 | \n 11 |     for (i, char) in secret.enumerated() {\n 12 |         if char == guess[i] {\n    |                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |             bulls += 1\n 14 |         } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:16:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |         } else {\n 15 |             secretCount[char] = (secretCount[char] ?? 0) + 1\n 16 |             guessCount[guess[i]] = (guessCount[guess[i]] ?? 0) + 1\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         }\n 18 |     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulls-and-cows_1\/solution.swift:16:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |         } else {\n 15 |             secretCount[char] = (secretCount[char] ?? 0) + 1\n 16 |             guessCount[guess[i]] = (guessCount[guess[i]] ?? 0) + 1\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         }\n 18 |     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1A1B",
      "input" : "secret = \"1123\", guess = \"0111\"",
      "slug" : "bulls-and-cows",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"(bulls)A(cows)B\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1A3B",
      "input" : "secret = \"1807\", guess = \"7810\"",
      "slug" : "bulls-and-cows",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"(bulls)A(cows)B\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1A1B",
      "input" : "secret = \"1123\", guess = \"0111\"",
      "slug" : "bulls-and-cows",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "fronts = [1,2,4,4,7], backs = [1,3,4,1,3]",
      "slug" : "card-flipping-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "fronts = [0,0,0,1], backs = [1,1,0,1]",
      "slug" : "card-flipping-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"kqeepp\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"kqeepq\"",
      "input" : "S = \"kqep\", T = \"pekepq\"",
      "slug" : "custom-sort-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"kqeepp\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"kqeepq\"",
      "input" : "S = \"kqep\", T = \"pekepq\"",
      "slug" : "custom-sort-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:342: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                      `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:389: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                     `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:403: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [1,2,2,3,1]",
      "slug" : "degree-of-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:342: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                      `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:389: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                     `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/degree-of-an-array_2\/solution.swift:4:403: error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: cannot convert value of type '(key: Int, value: Int)' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "nums = [1,2,2,3,1,4,2]",
      "slug" : "degree-of-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_1\/solution.swift:16:20: warning: variable 'sortedColumn' was never mutated; consider changing to 'let' constant\n 14 |            }\n 15 |            for column in columns {\n 16 |                var sortedColumn = column.sorted()\n    |                    `- warning: variable 'sortedColumn' was never mutated; consider changing to 'let' constant\n 17 |                if column != sortedColumn {\n 18 |                    result += 1\n",
      "expected" : "1",
      "input" : "strs = [\"cba\",\"daf\",\"ghi\"]",
      "slug" : "delete-columns-to-make-sorted",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_1\/solution.swift:16:20: warning: variable 'sortedColumn' was never mutated; consider changing to 'let' constant\n 14 |            }\n 15 |            for column in columns {\n 16 |                var sortedColumn = column.sorted()\n    |                    `- warning: variable 'sortedColumn' was never mutated; consider changing to 'let' constant\n 17 |                if column != sortedColumn {\n 18 |                    result += 1\n",
      "expected" : "0",
      "input" : "strs = [\"a\",\"b\"]",
      "slug" : "delete-columns-to-make-sorted",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_2\/solution.swift:8:16: warning: variable 'strs' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n  8 |            var strs = strs.map { Array($0) }\n    |                `- warning: variable 'strs' was never mutated; consider changing to 'let' constant\n  9 |            var result = 0\n 10 |            for col in 0..<strs[0].count {\n",
      "expected" : "1",
      "input" : "strs = [\"rr\",\"ss\",\"aa\",\"vv\"]",
      "slug" : "delete-columns-to-make-sorted",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted_2\/solution.swift:8:16: warning: variable 'strs' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |        func minDeletionSize(_ strs: [String]) -> Int {\n  8 |            var strs = strs.map { Array($0) }\n    |                `- warning: variable 'strs' was never mutated; consider changing to 'let' constant\n  9 |            var result = 0\n 10 |            for col in 0..<strs[0].count {\n",
      "expected" : "1",
      "input" : "strs = [\"zyx\"]",
      "slug" : "delete-columns-to-make-sorted",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "HashMap",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/detect-squares_1\/solution.swift:245:23: error: value of type 'Solution' has no member 'add'\n243 | \n244 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n245 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n246 | let output: Any = NSNull()\n247 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "add([3,10]), add([11,2]), add([3,2]), count([11,10])",
      "slug" : "detect-squares",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[1,2,4,3,5,7,6,8,9]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1,2,4,7,5,3,6,8,9]",
      "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]]",
      "slug" : "diagonal-traverse",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1,2,4,7,5,3,9,6,8]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[1,2,4,7,5,3,6,8,9]",
      "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]]",
      "slug" : "diagonal-traverse",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class Codec {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:8:27: error: no exact matches in call to initializer \n  6 | \n  7 | class Codec {\n  8 |     let chars: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    |                           `- error: no exact matches in call to initializer \n  9 |     var map: [String: String] = [:]\n 10 |     var map2: [String: String] = [:]\n\nSwift.Array.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n1 | generic struct Array {\n2 | @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.Array.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n1 | generic struct Array {\n2 | @inlinable public init(arrayLiteral elements: Element...)}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:258:23: error: value of type 'Solution' has no member 'encode'\n256 | \n257 | let arg0 = toString(valueAt(args, 0))\n258 | let result = solution.encode(arg0)\n    |                       `- error: value of type 'Solution' has no member 'encode'\n259 | let output: Any = result\n260 | print(jsonString(from: output))\n",
      "expected" : "http:\/\/tinyurl.com\/qe9ya5",
      "input" : "long_url = http:\/\/www.example.com",
      "slug" : "encode-and-decode-tinyurl",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class Codec {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:8:27: error: no exact matches in call to initializer \n  6 | \n  7 | class Codec {\n  8 |     let chars: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    |                           `- error: no exact matches in call to initializer \n  9 |     var map: [String: String] = [:]\n 10 |     var map2: [String: String] = [:]\n\nSwift.Array.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n1 | generic struct Array {\n2 | @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.Array.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n1 | generic struct Array {\n2 | @inlinable public init(arrayLiteral elements: Element...)}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_1\/solution.swift:258:23: error: value of type 'Solution' has no member 'encode'\n256 | \n257 | let arg0 = toString(valueAt(args, 0))\n258 | let result = solution.encode(arg0)\n    |                       `- error: value of type 'Solution' has no member 'encode'\n259 | let output: Any = result\n260 | print(jsonString(from: output))\n",
      "expected" : "http:\/\/www.example.com",
      "input" : "short_url = http:\/\/tinyurl.com\/qe9ya5",
      "slug" : "encode-and-decode-tinyurl",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class Codec {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:10:28: error: no exact matches in call to initializer \n  8 |     var map: [String: String] = [:]\n  9 |     let tinyUrl: String = \"http:\/\/tinyurl.com\/\"\n 10 |     let base62: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    |                            `- error: no exact matches in call to initializer \n 11 |     var count: Int = 0\n 12 | \n\nSwift.Array.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n1 | generic struct Array {\n2 | @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.Array.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n1 | generic struct Array {\n2 | @inlinable public init(arrayLiteral elements: Element...)}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:247:23: error: value of type 'Solution' has no member 'encode'\n245 | \n246 | let arg0 = toString(valueAt(args, 0))\n247 | let result = solution.encode(arg0)\n    |                       `- error: value of type 'Solution' has no member 'encode'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "http:\/\/tinyurl.com\/1",
      "input" : "long_url = http:\/\/www.example.com",
      "slug" : "encode-and-decode-tinyurl",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class Codec {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:10:28: error: no exact matches in call to initializer \n  8 |     var map: [String: String] = [:]\n  9 |     let tinyUrl: String = \"http:\/\/tinyurl.com\/\"\n 10 |     let base62: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    |                            `- error: no exact matches in call to initializer \n 11 |     var count: Int = 0\n 12 | \n\nSwift.Array.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n1 | generic struct Array {\n2 | @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Element' == 'S.Element')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String' and 'String.Element' (aka 'Character') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.Array.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n1 | generic struct Array {\n2 | @inlinable public init(arrayLiteral elements: Element...)}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(arrayLiteral:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/encode-and-decode-tinyurl_2\/solution.swift:247:23: error: value of type 'Solution' has no member 'encode'\n245 | \n246 | let arg0 = toString(valueAt(args, 0))\n247 | let result = solution.encode(arg0)\n    |                       `- error: value of type 'Solution' has no member 'encode'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "http:\/\/www.example.com",
      "input" : "short_url = http:\/\/tinyurl.com\/1",
      "slug" : "encode-and-decode-tinyurl",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:122: error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                          `- error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:145: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                 `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:155: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                           `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:214: error: extra argument in call\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                                                                                      `- error: extra argument in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:223: error: pattern cannot match values of type 'Zip2Sequence<[Int], [String]>.Element' (aka '(Array<Int>.Element, Array<String>.Element)')\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                                                                                               `- error: pattern cannot match values of type 'Zip2Sequence<[Int], [String]>.Element' (aka '(Array<Int>.Element, Array<String>.Element)')\n  5 | }\n  6 | \n",
      "expected" : "\"eeecd\"",
      "input" : "S = \"abcd\", indexes = [0], sources = [\"ab\"], targets = [\"eee\"]",
      "slug" : "find-and-replace-in-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:122: error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                          `- error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:145: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                 `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:155: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                           `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:214: error: extra argument in call\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                                                                                      `- error: extra argument in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_1\/solution.swift:4:223: error: pattern cannot match values of type 'Zip2Sequence<[Int], [String]>.Element' (aka '(Array<Int>.Element, Array<String>.Element)')\n  2 | \n  3 | class Solution {\n  4 | func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }\n    |                                                                                                                                                                                                                               `- error: pattern cannot match values of type 'Zip2Sequence<[Int], [String]>.Element' (aka '(Array<Int>.Element, Array<String>.Element)')\n  5 | }\n  6 | \n",
      "expected" : "\"eeefff\"",
      "input" : "S = \"abcd\", indexes = [0, 2], sources = [\"ab\", \"cd\"], targets = [\"eee\", \"fff\"]",
      "slug" : "find-and-replace-in-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:49: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                 `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:80: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:240: error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                `- error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:604: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:307: error: extra argument in call\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                   `- error: extra argument in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:285: error: pattern cannot match values of type '(Array<Int>.Element, Array<String>.Element)'\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                             `- error: pattern cannot match values of type '(Array<Int>.Element, Array<String>.Element)'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:465: error: argument passed to call that takes no arguments\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: argument passed to call that takes no arguments\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:702: warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |- warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- note: use 'firstIndex(where:)' instead\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:742: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:795: warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |- warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- note: use 'firstIndex(where:)' instead\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:835: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:952: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "\"eeecd\"",
      "input" : "S = \"abcd\", indexes = [0], sources = [\"ab\"], targets = [\"eee\"]",
      "slug" : "find-and-replace-in-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:49: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                 `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:80: error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                `- error: 'var' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:240: error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                `- error: 'let' cannot appear nested inside another 'var' or 'let' pattern\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:604: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:307: error: extra argument in call\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                   `- error: extra argument in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:285: error: pattern cannot match values of type '(Array<Int>.Element, Array<String>.Element)'\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                             `- error: pattern cannot match values of type '(Array<Int>.Element, Array<String>.Element)'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:465: error: argument passed to call that takes no arguments\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: argument passed to call that takes no arguments\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:702: warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |- warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- note: use 'firstIndex(where:)' instead\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:742: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:795: warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |- warning: 'index(where:)' is deprecated: renamed to 'firstIndex(where:)' [#DeprecatedDeclaration]\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- note: use 'firstIndex(where:)' instead\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:835: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-in-string_2\/solution.swift:4:952: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "\"eeefff\"",
      "input" : "S = \"abcd\", indexes = [0, 2], sources = [\"ab\", \"cd\"], targets = [\"eee\", \"fff\"]",
      "slug" : "find-and-replace-in-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_1\/solution.swift:4:424: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; for word in words { var mapping: [String: String] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = mapping[String(p)] { if value != String(w) { matched = false; break; } } else { if mapping.values.contains(String(w)) { matched = false; break; } else { mapping[String(p)] = String(w); } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_1\/solution.swift:4:462: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; for word in words { var mapping: [String: String] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = mapping[String(p)] { if value != String(w) { matched = false; break; } } else { if mapping.values.contains(String(w)) { matched = false; break; } else { mapping[String(p)] = String(w); } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"mee\",\"aqq\"]",
      "input" : "words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"",
      "slug" : "find-and-replace-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_1\/solution.swift:4:424: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; for word in words { var mapping: [String: String] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = mapping[String(p)] { if value != String(w) { matched = false; break; } } else { if mapping.values.contains(String(w)) { matched = false; break; } else { mapping[String(p)] = String(w); } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_1\/solution.swift:4:462: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; for word in words { var mapping: [String: String] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = mapping[String(p)] { if value != String(w) { matched = false; break; } } else { if mapping.values.contains(String(w)) { matched = false; break; } else { mapping[String(p)] = String(w); } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"deq\"]",
      "input" : "words = [\"abc\",\"deq\"], pattern = \"abb\"",
      "slug" : "find-and-replace-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:433: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:471: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:111: warning: immutable value 'patternMap' was never used; consider replacing with '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                               `- warning: immutable value 'patternMap' was never used; consider replacing with '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "[\"mee\",\"aqq\"]",
      "input" : "words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"",
      "slug" : "find-and-replace-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:433: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:471: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-and-replace-pattern_2\/solution.swift:4:111: warning: immutable value 'patternMap' was never used; consider replacing with '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }\n    |                                                                                                               `- warning: immutable value 'patternMap' was never used; consider replacing with '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "[\"abc\"]",
      "input" : "words = [\"abc\"], pattern = \"abb\"",
      "slug" : "find-and-replace-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[\"e\",\"ll\",\"ll\"]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[\"e\",\"l\",\"l\"]",
      "input" : "[\"bella\",\"label\",\"roller\"]",
      "slug" : "find-common-characters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"c\",\"o\",\"o\"]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[\"c\",\"o\"]",
      "input" : "[\"cool\",\"lock\",\"cook\"]",
      "slug" : "find-common-characters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[\"e\",\"l\",\"l\"]",
      "input" : "[\"bella\",\"label\",\"roller\"]",
      "slug" : "find-common-characters",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[\"c\",\"o\"]",
      "input" : "[\"cool\",\"lock\",\"cook\"]",
      "slug" : "find-common-characters",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-file-in-system_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findDuplicate(\n",
      "expected" : "[[\"root\/a\/2.txt\",\"root\/c\/d\/4.txt\",\"root\/d\/4.txt\"],[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
      "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\", \"root\/c 4.txt(efgh)\", \"root\/d 4.txt(efgh)\"]",
      "slug" : "find-duplicate-file-in-system",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-file-in-system_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findDuplicate(\n",
      "expected" : "[[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
      "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\"]",
      "slug" : "find-duplicate-file-in-system",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-file-in-system_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findDuplicate(\n",
      "expected" : "[[\"root\/a\/2.txt\",\"root\/c\/4.txt\",\"root\/d\/4.txt\"],[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
      "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\", \"root\/c 4.txt(efgh)\", \"root\/d 4.txt(efgh)\"]",
      "slug" : "find-duplicate-file-in-system",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-file-in-system_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findDuplicate(\n",
      "expected" : "[[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
      "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\"]",
      "slug" : "find-duplicate-file-in-system",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/first-unique-character-in-a-string_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func firstUniqChar(_ s: String) -> Int {\n",
      "expected" : "0",
      "input" : "s = \"leetcode\"",
      "slug" : "first-unique-character-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/first-unique-character-in-a-string_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func firstUniqChar(_ s: String) -> Int {\n",
      "expected" : "2",
      "input" : "s = \"loveleetcode\"",
      "slug" : "first-unique-character-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/first-unique-character-in-a-string_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func firstUniqChar(_ s: String) -> Int {\n",
      "expected" : "0",
      "input" : "s = \"leetcode\"",
      "slug" : "first-unique-character-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/first-unique-character-in-a-string_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func firstUniqChar(_ s: String) -> Int {\n",
      "expected" : "2",
      "input" : "s = \"loveleetcode\"",
      "slug" : "first-unique-character-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "In-place with State Encoding",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/game-of-life_1\/solution.swift:254:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n251 | let solution = Solution()\n252 | \n253 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n254 | let result = solution.gameOfLife(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n255 | let output: Any = NSNull()\n256 | print(jsonString(from: output))\n",
      "expected" : "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
      "input" : "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
      "slug" : "game-of-life",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[[\"tan\",\"nat\"],[\"bat\"],[\"eat\",\"tea\",\"ate\"]]",
      "approachName" : "Hash by Sorted Key",
      "approachOrder" : 1,
      "expected" : "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
      "input" : "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
      "slug" : "group-anagrams",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/groups-of-special-equivalent-strings_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func numSpecialEquivGroups(_ A: [String]) -> Int {\n",
      "expected" : "2",
      "input" : "A = [\"a\",\"b\",\"ab\",\"ba\"]",
      "slug" : "groups-of-special-equivalent-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/groups-of-special-equivalent-strings_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func numSpecialEquivGroups(_ A: [String]) -> Int {\n",
      "expected" : "3",
      "input" : "A = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]",
      "slug" : "groups-of-special-equivalent-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/groups-of-special-equivalent-strings_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func numSpecialEquivGroups(_ A: [String]) -> Int {\n",
      "expected" : "2",
      "input" : "A = [\"a\",\"b\",\"ab\",\"ba\"]",
      "slug" : "groups-of-special-equivalent-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/groups-of-special-equivalent-strings_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func numSpecialEquivGroups(_ A: [String]) -> Int {\n",
      "expected" : "3",
      "input" : "A = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]",
      "slug" : "groups-of-special-equivalent-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "100",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]",
      "slug" : "image-overlap",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[1,1,1],[1,1,1],[1,1,1]]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[[2,2,2],[2,1,2],[2,2,2]]",
      "input" : "M = [[2,2,2],[2,1,2],[2,2,2]]",
      "slug" : "image-smoother",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[1,1,1],[1,1,1],[1,1,1]]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[[2,2,2],[2,1,2],[2,2,2]]",
      "input" : "M = [[2,2,2],[2,1,2],[2,2,2]]",
      "slug" : "image-smoother",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "J = 'aA', S = 'aAAbbbb'",
      "slug" : "jewels-and-stones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "0",
      "input" : "J = 'z', S = 'ZZ'",
      "slug" : "jewels-and-stones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "7",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "J = 'aA', S = 'aAAbbbb'",
      "slug" : "jewels-and-stones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "J = 'z', S = 'ZZ'",
      "slug" : "jewels-and-stones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); for row in rows { if canBeTyped(row, word: lowerWord) { result.append(word); break; } } } return result }; func canBeTyped(_ row: String, word: String) -> Bool { for char in word { if !row.contains(char) { return false } } return true }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_1\/solution.swift:4:404: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); for row in rows { if canBeTyped(row, word: lowerWord) { result.append(word); break; } } } return result }; func canBeTyped(_ row: String, word: String) -> Bool { for char in word { if !row.contains(char) { return false } } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Alaska\", \"Dad\"]",
      "input" : "words = [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]",
      "slug" : "keyboard-row",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); for row in rows { if canBeTyped(row, word: lowerWord) { result.append(word); break; } } } return result }; func canBeTyped(_ row: String, word: String) -> Bool { for char in word { if !row.contains(char) { return false } } return true }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_1\/solution.swift:4:404: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); for row in rows { if canBeTyped(row, word: lowerWord) { result.append(word); break; } } } return result }; func canBeTyped(_ row: String, word: String) -> Bool { for char in word { if !row.contains(char) { return false } } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"omg\", \"fv\", \"pq\"]",
      "input" : "words = [\"omg\", \"fv\", \"pq\"]",
      "slug" : "keyboard-row",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_2\/solution.swift:4:311: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [Set(\"qwertyuiop\"), Set(\"asdfghjkl\"), Set(\"zxcvbnm\")]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); let wordSet = Set(lowerWord); for row in rows { if row.isSuperset(of: wordSet) { result.append(word); break; } } } return result }\n    |                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Alaska\", \"Dad\"]",
      "input" : "words = [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]",
      "slug" : "keyboard-row",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/keyboard-row_2\/solution.swift:4:311: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findWords(_ words: [String]) -> [String] { let rows = [Set(\"qwertyuiop\"), Set(\"asdfghjkl\"), Set(\"zxcvbnm\")]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); let wordSet = Set(lowerWord); for row in rows { if row.isSuperset(of: wordSet) { result.append(word); break; } } } return result }\n    |                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"omg\", \"fv\", \"pq\"]",
      "input" : "words = [\"omg\", \"fv\", \"pq\"]",
      "slug" : "keyboard-row",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums = [1,3,5,4,7]",
      "slug" : "longest-continuous-increasing-subsequence",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[2,1]",
      "approachName" : "Optimized Boyer-Moore Majority Vote",
      "approachOrder" : 2,
      "expected" : "[1,2]",
      "input" : "nums = [1,1,1,3,3,2,2,2]",
      "slug" : "majority-element-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "nums = [1,1,0,1,1,1]",
      "slug" : "max-consecutive-ones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "6",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "nums = [1,1,1,1,0,1,1]",
      "slug" : "max-consecutive-ones",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximize-distance-to-closest-person_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func maxDistToClosest(_ seats: [Int]) -> Int {\n",
      "expected" : "2",
      "input" : "seats = [1,0,0,0,1,0,1]",
      "slug" : "maximize-distance-to-closest-person",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximize-distance-to-closest-person_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func maxDistToClosest(_ seats: [Int]) -> Int {\n",
      "expected" : "3",
      "input" : "seats = [1,0,0,0]",
      "slug" : "maximize-distance-to-closest-person",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximize-distance-to-closest-person_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func maxDistToClosest(_ seats: [Int]) -> Int {\n",
      "expected" : "2",
      "input" : "seats = [1,0,0,0,1,0,1]",
      "slug" : "maximize-distance-to-closest-person",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximize-distance-to-closest-person_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func maxDistToClosest(_ seats: [Int]) -> Int {\n",
      "expected" : "3",
      "input" : "seats = [1,0,0,0]",
      "slug" : "maximize-distance-to-closest-person",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
      "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"]], [1,2]",
      "slug" : "minesweeper",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
      "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], [3,0]",
      "slug" : "minesweeper",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
      "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], [3,0]",
      "slug" : "minesweeper",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
      "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"]], [1,2]",
      "slug" : "minesweeper",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_1\/solution.swift:4:361: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { let len1 = list1.count; let len2 = list2.count; var minSum = Int.max; var result: [Int] = []; for i in 0..<len1 { for j in 0..<len2 { if list1[i] == list2[j] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0]",
      "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
      "slug" : "minimum-index-sum-of-two-lists",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_1\/solution.swift:4:361: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { let len1 = list1.count; let len2 = list2.count; var minSum = Int.max; var result: [Int] = []; for i in 0..<len1 { for j in 0..<len2 { if list1[i] == list2[j] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1,2]",
      "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
      "slug" : "minimum-index-sum-of-two-lists",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_2\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { var dict: [String: Int] = [:]; var minSum = Int.max; var result: [Int] = []; for i in 0..<list1.count { dict[list1[i]] = i; } for j in 0..<list2.count { if let i = dict[list2[j]] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } return result; }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_2\/solution.swift:4:380: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { var dict: [String: Int] = [:]; var minSum = Int.max; var result: [Int] = []; for i in 0..<list1.count { dict[list1[i]] = i; } for j in 0..<list2.count { if let i = dict[list2[j]] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0]",
      "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
      "slug" : "minimum-index-sum-of-two-lists",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_2\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { var dict: [String: Int] = [:]; var minSum = Int.max; var result: [Int] = []; for i in 0..<list1.count { dict[list1[i]] = i; } for j in 0..<list2.count { if let i = dict[list2[j]] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } return result; }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-index-sum-of-two-lists_2\/solution.swift:4:380: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRestaurant(list1: [String], list2: [String]) -> [Int] { var dict: [String: Int] = [:]; var minSum = Int.max; var result: [Int] = []; for i in 0..<list1.count { dict[list1[i]] = i; } for j in 0..<list2.count { if let i = dict[list2[j]] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1,2]",
      "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
      "slug" : "minimum-index-sum-of-two-lists",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"was\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "ball",
      "input" : "paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]",
      "slug" : "most-common-word",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"a.\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "a",
      "input" : "paragraph = \"a.\", banned = []",
      "slug" : "most-common-word",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"hit.\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "ball",
      "input" : "paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]",
      "slug" : "most-common-word",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"a.\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "a",
      "input" : "paragraph = \"a.\", banned = []",
      "slug" : "most-common-word",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func removeStones(_ stones: [[Int]]) -> Int {\n",
      "expected" : "5",
      "input" : "stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]",
      "slug" : "most-stones-removed-with-same-row-or-column",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func removeStones(_ stones: [[Int]]) -> Int {\n",
      "expected" : "3",
      "input" : "stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]",
      "slug" : "most-stones-removed-with-same-row-or-column",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Union-Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            class UnionFind {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_2\/solution.swift:281:23: error: value of type 'Solution' has no member 'find'\n279 | \n280 | let arg0 = toInt(valueAt(args, 0))\n281 | let result = solution.find(arg0)\n    |                       `- error: value of type 'Solution' has no member 'find'\n282 | let output: Any = result\n283 | print(jsonString(from: output))\n",
      "expected" : "5",
      "input" : "stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]",
      "slug" : "most-stones-removed-with-same-row-or-column",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Union-Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            class UnionFind {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-stones-removed-with-same-row-or-column_2\/solution.swift:281:23: error: value of type 'Solution' has no member 'find'\n279 | \n280 | let arg0 = toInt(valueAt(args, 0))\n281 | let result = solution.find(arg0)\n    |                       `- error: value of type 'Solution' has no member 'find'\n282 | let output: Any = result\n283 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]",
      "slug" : "most-stones-removed-with-same-row-or-column",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-repeated-element-in-size-2n-array_1\/solution.swift:4:111: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func repeatedNTimes(_ nums: [Int]) -> Int { let count = [Int:Int](); for num in nums { count[num, default: 0] += 1 }; return Array(count.keys)[Array(count.values).firstIndex(of: nums.count\/2)!] }\n    |                                             |                                                                 `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n    |                                             `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1,2,3,3]",
      "slug" : "n-repeated-element-in-size-2n-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-repeated-element-in-size-2n-array_1\/solution.swift:4:111: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func repeatedNTimes(_ nums: [Int]) -> Int { let count = [Int:Int](); for num in nums { count[num, default: 0] += 1 }; return Array(count.keys)[Array(count.values).firstIndex(of: nums.count\/2)!] }\n    |                                             |                                                                 `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n    |                                             `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [2,1,2,5,3,2]",
      "slug" : "n-repeated-element-in-size-2n-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-repeated-element-in-size-2n-array_2\/solution.swift:4:117: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func repeatedNTimes(_ nums: [Int]) -> Int { for i in 0..<nums.count-1 { if nums[i] == nums[i+1] { return nums[i] } } return -1 }\n    |                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1,2,3,3]",
      "slug" : "n-repeated-element-in-size-2n-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-repeated-element-in-size-2n-array_2\/solution.swift:4:117: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func repeatedNTimes(_ nums: [Int]) -> Int { for i in 0..<nums.count-1 { if nums[i] == nums[i+1] { return nums[i] } } return -1 }\n    |                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [2,1,2,5,3,2]",
      "slug" : "n-repeated-element-in-size-2n-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:251: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:223: error: binary operator '==' cannot be applied to operands of type 'Bool' and '[Int]'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                               |- error: binary operator '==' cannot be applied to operands of type 'Bool' and '[Int]'\n    |                                                                                                                                                                                                                               `- note: overloads for '==' exist with these partially matching parameter lists: (Bool, Bool)\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:214: error: cannot convert value of type '[Int]' to expected argument type 'Bool'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                      `- error: cannot convert value of type '[Int]' to expected argument type 'Bool'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [4,2,3]",
      "slug" : "non-decreasing-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:251: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:223: error: binary operator '==' cannot be applied to operands of type 'Bool' and '[Int]'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                               |- error: binary operator '==' cannot be applied to operands of type 'Bool' and '[Int]'\n    |                                                                                                                                                                                                                               `- note: overloads for '==' exist with these partially matching parameter lists: (Bool, Bool)\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_1\/solution.swift:4:214: error: cannot convert value of type '[Int]' to expected argument type 'Bool'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }\n    |                                                                                                                                                                                                                      `- error: cannot convert value of type '[Int]' to expected argument type 'Bool'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [4,2,1]",
      "slug" : "non-decreasing-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:236: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:255: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:160: error: cannot assign through subscript: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                `- error: cannot assign through subscript: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:190: error: cannot assign through subscript: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                              `- error: cannot assign through subscript: 'nums' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [5,7,1,8]",
      "slug" : "non-decreasing-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:236: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:255: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:160: error: cannot assign through subscript: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                `- error: cannot assign through subscript: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-array_2\/solution.swift:4:190: error: cannot assign through subscript: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }\n    |                                                                                                                                                                                              `- error: cannot assign through subscript: 'nums' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [3,4,2,5]",
      "slug" : "non-decreasing-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-enclaves_2\/solution.swift:10:29: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n  8 |                var grid = grid\n  9 |                var queue = [(Int, Int)]()\n 10 |                var visited: Set<(Int, Int)> = []\n    |                             `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 11 |                \n 12 |                \/\/ Add boundary land cells to the queue\n",
      "expected" : "3",
      "input" : "grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]",
      "slug" : "number-of-enclaves",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-enclaves_2\/solution.swift:10:29: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n  8 |                var grid = grid\n  9 |                var queue = [(Int, Int)]()\n 10 |                var visited: Set<(Int, Int)> = []\n    |                             `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 11 |                \n 12 |                \/\/ Add boundary land cells to the queue\n",
      "expected" : "0",
      "input" : "grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]",
      "slug" : "number-of-enclaves",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[2,8]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[2,4]",
      "input" : "widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaaa\"",
      "slug" : "number-of-lines-to-write-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-lines-to-write-string_2\/solution.swift:10:41: error: binary operator '-' cannot be applied to operands of type 'String.UTF8View.Element' (aka 'UInt8') and 'UInt32'\n  8 |                let aAscii: UInt32 = 97\n  9 |                for c in s.utf8 {\n 10 |                    let w = widths[Int(c - aAscii)]\n    |                                         |- error: binary operator '-' cannot be applied to operands of type 'String.UTF8View.Element' (aka 'UInt8') and 'UInt32'\n    |                                         `- note: overloads for '-' exist with these partially matching parameter lists: (UInt32, UInt32), (UInt8, UInt8)\n 11 |                    if width + w > 100 {\n 12 |                        lines += 1\n",
      "expected" : "[2,4]",
      "input" : "widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaaa\"",
      "slug" : "number-of-lines-to-write-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-lines-to-write-string_2\/solution.swift:10:41: error: binary operator '-' cannot be applied to operands of type 'String.UTF8View.Element' (aka 'UInt8') and 'UInt32'\n  8 |                let aAscii: UInt32 = 97\n  9 |                for c in s.utf8 {\n 10 |                    let w = widths[Int(c - aAscii)]\n    |                                         |- error: binary operator '-' cannot be applied to operands of type 'String.UTF8View.Element' (aka 'UInt8') and 'UInt32'\n    |                                         `- note: overloads for '-' exist with these partially matching parameter lists: (UInt32, UInt32), (UInt8, UInt8)\n 11 |                    if width + w > 100 {\n 12 |                        lines += 1\n",
      "expected" : "[3,60]",
      "input" : "widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\"",
      "slug" : "number-of-lines-to-write-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:240: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:415: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1998: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: expected declaration\n    |       `- note: in declaration of 'Solution'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:2012: error: extraneous '}' at top level\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: extraneous '}' at top level\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:289: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                               `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:701: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:946: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1176: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1489: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1734: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1964: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n",
      "expected" : "\"6\"",
      "input" : "[\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"],\"0202\"",
      "slug" : "open-the-lock",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:240: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:415: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1998: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: expected declaration\n    |       `- note: in declaration of 'Solution'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:2012: error: extraneous '}' at top level\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: extraneous '}' at top level\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:289: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                               `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:701: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:946: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1176: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1489: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1734: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_1\/solution.swift:3:1964: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n",
      "expected" : "\"-1\"",
      "input" : "[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"],\"8888\"",
      "slug" : "open-the-lock",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:416: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:290: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:677: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:975: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n",
      "expected" : "\"6\"",
      "input" : "[\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"],\"0202\"",
      "slug" : "open-the-lock",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:416: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:290: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:677: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/open-the-lock_2\/solution.swift:3:975: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}\n    |                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                                                                                                                                 `- note: change 'let' to 'var' to make it mutable\n  4 | \n  5 | \n",
      "expected" : "\"1\"",
      "input" : "[\"8888\"],\"0009\"",
      "slug" : "open-the-lock",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_1\/solution.swift:9:12: error: cannot assign to value: 'leftMax' is a 'let' constant\n  5 |     let n = nums.count\n  6 |     for i in 0..<n - 1 {\n  7 |         let leftMax = nums[0...i].max()!\n    |         `- note: change 'let' to 'var' to make it mutable\n  8 |         let rightMin = nums[i + 1..<n].min()!\n  9 |         if leftMax = rightMin {\n    |            `- error: cannot assign to value: 'leftMax' is a 'let' constant\n 10 |             return i + 1\n 11 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_1\/solution.swift:9:20: error: use of '=' in a boolean context, did you mean '=='?\n  7 |         let leftMax = nums[0...i].max()!\n  8 |         let rightMin = nums[i + 1..<n].min()!\n  9 |         if leftMax = rightMin {\n    |                    `- error: use of '=' in a boolean context, did you mean '=='?\n 10 |             return i + 1\n 11 |         }\n",
      "expected" : "2",
      "input" : "nums = [5,0,3,8,6]",
      "slug" : "partition-array-into-disjoint-intervals",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_1\/solution.swift:9:12: error: cannot assign to value: 'leftMax' is a 'let' constant\n  5 |     let n = nums.count\n  6 |     for i in 0..<n - 1 {\n  7 |         let leftMax = nums[0...i].max()!\n    |         `- note: change 'let' to 'var' to make it mutable\n  8 |         let rightMin = nums[i + 1..<n].min()!\n  9 |         if leftMax = rightMin {\n    |            `- error: cannot assign to value: 'leftMax' is a 'let' constant\n 10 |             return i + 1\n 11 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_1\/solution.swift:9:20: error: use of '=' in a boolean context, did you mean '=='?\n  7 |         let leftMax = nums[0...i].max()!\n  8 |         let rightMin = nums[i + 1..<n].min()!\n  9 |         if leftMax = rightMin {\n    |                    `- error: use of '=' in a boolean context, did you mean '=='?\n 10 |             return i + 1\n 11 |         }\n",
      "expected" : "4",
      "input" : "nums = [1,1,1,0,6,12]",
      "slug" : "partition-array-into-disjoint-intervals",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_2\/solution.swift:19:23: error: use of '=' in a boolean context, did you mean '=='?\n 17 |     }\n 18 |     for i in 0..<n - 1 {\n 19 |         if leftMax[i] = rightMin[i + 1] {\n    |                       `- error: use of '=' in a boolean context, did you mean '=='?\n 20 |             return i + 1\n 21 |         }\n",
      "expected" : "2",
      "input" : "nums = [5,0,3,8,6]",
      "slug" : "partition-array-into-disjoint-intervals",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/partition-array-into-disjoint-intervals_2\/solution.swift:19:23: error: use of '=' in a boolean context, did you mean '=='?\n 17 |     }\n 18 |     for i in 0..<n - 1 {\n 19 |         if leftMax[i] = rightMin[i + 1] {\n    |                       `- error: use of '=' in a boolean context, did you mean '=='?\n 20 |             return i + 1\n 21 |         }\n",
      "expected" : "4",
      "input" : "nums = [1,1,1,0,6,12]",
      "slug" : "partition-array-into-disjoint-intervals",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:28:18: error: empty collection literal requires an explicit type\n 26 | \n 27 | \/\/ FocusApp LeetCode Runner\n 28 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 29 |     func parseQuotedString(_ input: String) -> String? {\n 30 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'peek'\n245 | \n246 | \n247 | let result = solution.peek()\n    |                       `- error: value of type 'Solution' has no member 'peek'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:11:28: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n  9 |     init(_ arr: [Int]) {\n 10 |         iterator = arr.makeIterator()\n 11 |         current = iterator.next()\n    |                            `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 12 |     }\n 13 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:20:28: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 18 |     func next() -> Int {\n 19 |         let temp = current\n 20 |         current = iterator.next()\n    |                            `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 21 |         return temp!\n 22 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:97:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 95 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 96 |         guard !trimmed.isEmpty else { return [] }\n 97 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 98 |         if !keyValues.isEmpty {\n 99 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1",
      "input" : "nums = [1, 2, 3], PeekingIterator(nums).next()",
      "slug" : "peeking-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:28:18: error: empty collection literal requires an explicit type\n 26 | \n 27 | \/\/ FocusApp LeetCode Runner\n 28 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 29 |     func parseQuotedString(_ input: String) -> String? {\n 30 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'peek'\n245 | \n246 | \n247 | let result = solution.peek()\n    |                       `- error: value of type 'Solution' has no member 'peek'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:11:28: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n  9 |     init(_ arr: [Int]) {\n 10 |         iterator = arr.makeIterator()\n 11 |         current = iterator.next()\n    |                            `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 12 |     }\n 13 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:20:28: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 18 |     func next() -> Int {\n 19 |         let temp = current\n 20 |         current = iterator.next()\n    |                            `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 21 |         return temp!\n 22 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_1\/solution.swift:97:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 95 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 96 |         guard !trimmed.isEmpty else { return [] }\n 97 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 98 |         if !keyValues.isEmpty {\n 99 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1",
      "input" : "nums = [1, 2, 3], PeekingIterator(nums).peek()",
      "slug" : "peeking-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:33:18: error: empty collection literal requires an explicit type\n 31 | \n 32 | \/\/ FocusApp LeetCode Runner\n 33 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 34 |     func parseQuotedString(_ input: String) -> String? {\n 35 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:252:23: error: value of type 'Solution' has no member 'peek'\n250 | \n251 | \n252 | let result = solution.peek()\n    |                       `- error: value of type 'Solution' has no member 'peek'\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:15:32: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 13 |     func peek() -> Int {\n 14 |         if current == nil {\n 15 |             current = iterator.next()\n    |                                `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 16 |         }\n 17 |         return current!\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:22:32: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 20 |     func next() -> Int {\n 21 |         if current == nil {\n 22 |             current = iterator.next()\n    |                                `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 23 |         }\n 24 |         let temp = current\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:102:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n100 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n101 |         guard !trimmed.isEmpty else { return [] }\n102 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n103 |         if !keyValues.isEmpty {\n104 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1",
      "input" : "nums = [1, 2, 3], PeekingIterator(nums).peek()",
      "slug" : "peeking-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:33:18: error: empty collection literal requires an explicit type\n 31 | \n 32 | \/\/ FocusApp LeetCode Runner\n 33 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 34 |     func parseQuotedString(_ input: String) -> String? {\n 35 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:252:23: error: value of type 'Solution' has no member 'peek'\n250 | \n251 | \n252 | let result = solution.peek()\n    |                       `- error: value of type 'Solution' has no member 'peek'\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:15:32: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 13 |     func peek() -> Int {\n 14 |         if current == nil {\n 15 |             current = iterator.next()\n    |                                `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 16 |         }\n 17 |         return current!\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:22:32: error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n  4 | \n  5 | class PeekingIterator {\n  6 |     let iterator: IndexingIterator<[Int]>\n    |     `- note: change 'let' to 'var' to make it mutable\n  7 |     var current: Int?\n  8 | \n    :\n 20 |     func next() -> Int {\n 21 |         if current == nil {\n 22 |             current = iterator.next()\n    |                                `- error: cannot use mutating member on immutable value: 'iterator' is a 'let' constant\n 23 |         }\n 24 |         let temp = current\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peeking-iterator_2\/solution.swift:102:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n100 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n101 |         guard !trimmed.isEmpty else { return [] }\n102 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n103 |         if !keyValues.isEmpty {\n104 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1",
      "input" : "nums = [1, 2, 3], PeekingIterator(nums).next()",
      "slug" : "peeking-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/queue-reconstruction-by-height_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n",
      "expected" : "[[5,0],[7,0],[5,2],[6,1],[7,1],[4,4]]",
      "input" : "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
      "slug" : "queue-reconstruction-by-height",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/queue-reconstruction-by-height_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n",
      "expected" : "[[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
      "input" : "people = [[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
      "slug" : "queue-reconstruction-by-height",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/queue-reconstruction-by-height_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n",
      "expected" : "[[5,0],[7,0],[5,2],[6,1],[7,1],[4,4]]",
      "input" : "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
      "slug" : "queue-reconstruction-by-height",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/queue-reconstruction-by-height_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n",
      "expected" : "[[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
      "input" : "people = [[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
      "slug" : "queue-reconstruction-by-height",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    | `- error: expected 'func' keyword in instance method declaration\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:9: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |         |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |         `- note: join the identifiers together\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:25: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |                         `- error: expected '(' in argument list of function declaration\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:6:7: error: initializers may only be declared within a type\n  4 | __class RangeSumMutable { \n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n    |       `- error: initializers may only be declared within a type\n  7 |     self.nums = nums \n  8 |   } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:240:23: error: value of type 'Solution' has no member 'update'\n238 | let arg0 = toInt(valueAt(args, 0))\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.update(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'update'\n241 | let output: Any = NSNull()\n242 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:7:10: error: value of type 'Solution' has no member 'nums'\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n  7 |     self.nums = nums \n    |          `- error: value of type 'Solution' has no member 'nums'\n  8 |   } \n  9 |   func update(_ i: Int, _ val: Int) { \n",
      "expected" : "8",
      "input" : "nums = [1, 3, 5], update(1, 2), sumRange(0, 2)",
      "slug" : "range-sum-query-mutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    | `- error: expected 'func' keyword in instance method declaration\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:9: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |         |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |         `- note: join the identifiers together\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:4:25: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |                         `- error: expected '(' in argument list of function declaration\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:6:7: error: initializers may only be declared within a type\n  4 | __class RangeSumMutable { \n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n    |       `- error: initializers may only be declared within a type\n  7 |     self.nums = nums \n  8 |   } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:240:23: error: value of type 'Solution' has no member 'update'\n238 | let arg0 = toInt(valueAt(args, 0))\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.update(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'update'\n241 | let output: Any = NSNull()\n242 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_1\/solution.swift:7:10: error: value of type 'Solution' has no member 'nums'\n  5 |   var nums: [Int] \n  6 |   init(_ nums: [Int]) { \n  7 |     self.nums = nums \n    |          `- error: value of type 'Solution' has no member 'nums'\n  8 |   } \n  9 |   func update(_ i: Int, _ val: Int) { \n",
      "expected" : "5",
      "input" : "nums = [1, 3, 5], update(1, 4), sumRange(0, 1)",
      "slug" : "range-sum-query-mutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Segment Tree",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    | `- error: expected 'func' keyword in instance method declaration\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:9: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |         |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |         `- note: join the identifiers together\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:25: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |                         `- error: expected '(' in argument list of function declaration\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:7:7: error: initializers may only be declared within a type\n  5 |   var tree: [Int] \n  6 |   var n: Int \n  7 |   init(_ nums: [Int]) { \n    |       `- error: initializers may only be declared within a type\n  8 |     n = nums.count \n  9 |     tree = [Int](repeating: 0, count: n * 4) \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:278:23: error: value of type 'Solution' has no member 'buildTree'\n276 | let arg2 = toInt(valueAt(args, 2))\n277 | let arg3 = toInt(valueAt(args, 3))\n278 | let result = solution.buildTree(arg0, arg1, arg2, arg3)\n    |                       `- error: value of type 'Solution' has no member 'buildTree'\n279 | let output: Any = NSNull()\n280 | print(jsonString(from: output))\n",
      "expected" : "8",
      "input" : "nums = [1, 3, 5], update(1, 2), sumRange(0, 2)",
      "slug" : "range-sum-query-mutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Segment Tree",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    | `- error: expected 'func' keyword in instance method declaration\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:9: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |         |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |         `- note: join the identifiers together\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:4:25: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | __class RangeSumMutable { \n    |                         `- error: expected '(' in argument list of function declaration\n  5 |   var tree: [Int] \n  6 |   var n: Int \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:7:7: error: initializers may only be declared within a type\n  5 |   var tree: [Int] \n  6 |   var n: Int \n  7 |   init(_ nums: [Int]) { \n    |       `- error: initializers may only be declared within a type\n  8 |     n = nums.count \n  9 |     tree = [Int](repeating: 0, count: n * 4) \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-mutable_2\/solution.swift:278:23: error: value of type 'Solution' has no member 'buildTree'\n276 | let arg2 = toInt(valueAt(args, 2))\n277 | let arg3 = toInt(valueAt(args, 3))\n278 | let result = solution.buildTree(arg0, arg1, arg2, arg3)\n    |                       `- error: value of type 'Solution' has no member 'buildTree'\n279 | let output: Any = NSNull()\n280 | print(jsonString(from: output))\n",
      "expected" : "5",
      "input" : "nums = [1, 3, 5], update(1, 4), sumRange(0, 1)",
      "slug" : "range-sum-query-mutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:294: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                      `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:375: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                       `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                      `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:300: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot find 'union' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:329: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: cannot find 'union' in scope\n  4 | \n  5 | \n",
      "expected" : "4",
      "input" : "grid = [\" \/\",\"\/ \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:294: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                      `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:375: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                       `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                      `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:300: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot find 'union' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:329: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: cannot find 'union' in scope\n  4 | \n  5 | \n",
      "expected" : "8",
      "input" : "grid = [\" \/\",\"\/ \",\"\/ \",\"\/ \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:294: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                      `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:375: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                       `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                      `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:300: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot find 'union' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_1\/solution.swift:3:329: error: cannot find 'union' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: cannot find 'union' in scope\n  4 | \n  5 | \n",
      "expected" : "1",
      "input" : "grid = [\" \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Union-Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:297: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:466: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:625: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:697: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:838: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n",
      "expected" : "4",
      "input" : "grid = [\" \/\",\"\/ \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Union-Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:297: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:466: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:625: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:697: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:838: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n",
      "expected" : "8",
      "input" : "grid = [\" \/\",\"\/ \",\"\/ \",\"\/ \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Union-Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:297: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:466: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:625: error: single-quoted string literal found, use '\"'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: single-quoted string literal found, use '\"'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:697: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:3:838: error: unterminated string literal\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: unterminated string literal\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' at end of brace statement\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                                                                 `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/regions-cut-by-slashes_2\/solution.swift:228:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }\n    |                `- note: to match this opening '{'\n  4 | \n  5 | \n    :\n226 | let result = solution.regionsBySlashes(arg0)\n227 | let output: Any = result\n228 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n",
      "expected" : "1",
      "input" : "grid = [\" \"]",
      "slug" : "regions-cut-by-slashes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:211: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                   `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:231: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                       `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:321: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                 `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:341: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                     `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:441: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:461: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:529: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:586: error: unterminated string literal\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: unterminated string literal\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:6:1: error: unterminated string literal\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    | `- error: unterminated string literal\n  7 | }\n  8 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:232:32: error: expected '}' at end of brace statement\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                   `- note: to match this opening '{'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    :\n230 | let result = solution.removeComments(arg0)\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:232:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n  5 | \" { result += \"\n    :\n230 | let result = solution.removeComments(arg0)\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:200: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:218: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                          `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:310: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:328: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:373: error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                     `- error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:430: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:448: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:230:5: error: invalid redeclaration of 'result'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                     `- note: 'result' previously declared here\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    :\n228 | \n229 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n230 | let result = solution.removeComments(arg0)\n    |     `- error: invalid redeclaration of 'result'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "No comment here",
      "input" : "source = [\"\/*Block\", \"   comments\", \" *\/\", \"No comment here\"]",
      "slug" : "remove-comments",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:211: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                   `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:231: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                       `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:321: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                 `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:341: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                     `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:441: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:461: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: single-quoted string literal found, use '\"'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:529: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:586: error: unterminated string literal\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: unterminated string literal\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:6:1: error: unterminated string literal\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    | `- error: unterminated string literal\n  7 | }\n  8 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:232:32: error: expected '}' at end of brace statement\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                   `- note: to match this opening '{'\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    :\n230 | let result = solution.removeComments(arg0)\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n    |                                `- error: expected '}' at end of brace statement\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:232:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n  5 | \" { result += \"\n    :\n230 | let result = solution.removeComments(arg0)\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:200: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:218: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                          `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:310: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:328: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:373: error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                     `- error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:430: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:4:448: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-comments_2\/solution.swift:230:5: error: invalid redeclaration of 'result'\n  2 | \n  3 | class Solution {\n  4 | func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n    |                                                                                     `- note: 'result' previously declared here\n  5 | \" { result += \"\n  6 | \"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }\n    :\n228 | \n229 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n230 | let result = solution.removeComments(arg0)\n    |     `- error: invalid redeclaration of 'result'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "No comment here",
      "input" : "source = [\"\/\/Line comment\", \"No comment here\"]",
      "slug" : "remove-comments",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:152: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:250: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:353: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:102: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                      `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ content: Unicode.Scalar)}\n  |                   `- note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ s: String)}\n  |                   `- note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:200: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                        `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ content: Unicode.Scalar)}\n  |                   `- note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ s: String)}\n  |                   `- note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n",
      "expected" : "[\"let1 art can\", \"let3 art zero\", \"let2 own kit dig\", \"dig1 8 1 5 1\", \"dig2 3 6\"]",
      "input" : "logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 own kit dig\", \"let3 art zero\"]",
      "slug" : "reorder-data-in-log-files",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:152: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:250: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:353: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:102: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                      `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ content: Unicode.Scalar)}\n  |                   `- note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ s: String)}\n  |                   `- note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_1\/solution.swift:4:200: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }\n    |                                                                                                                                                                                                        `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ content: Unicode.Scalar)}\n  |                   `- note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n\nSwift.Character.init:2:19: note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n1 | struct Character {\n2 | @inlinable public init(_ s: String)}\n  |                   `- note: candidate expects value of type 'String' for parameter #1 (got 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'))\n3 | \n",
      "expected" : "[\"g1 act car\", \"zo4 4 7\", \"a1 9 2 3 1\", \"g1 act car\", \"a10 t3 0\"]",
      "input" : "logs = [\"a1 9 2 3 1\", \"g1 act car\", \"zo4 4 7\", \"ze0 2 1 2 3\", \"a10 t3 0\"]",
      "slug" : "reorder-data-in-log-files",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:148: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:276: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:344: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:358: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                                      `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:397: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                             `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n",
      "expected" : "[\"let1 art can\", \"let3 art zero\", \"let2 own kit dig\", \"dig1 8 1 5 1\", \"dig2 3 6\"]",
      "input" : "logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 own kit dig\", \"let3 art zero\"]",
      "slug" : "reorder-data-in-log-files",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:148: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:276: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:344: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:358: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                                      `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reorder-data-in-log-files_2\/solution.swift:4:397: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                             `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n",
      "expected" : "[\"g1 act car\", \"a1 9 2 3 1\", \"ze0 2 1 2 3\", \"zo4 4 7\", \"a10 t3 0\"]",
      "input" : "logs = [\"a1 9 2 3 1\", \"g1 act car\", \"zo4 4 7\", \"ze0 2 1 2 3\", \"a10 t3 0\"]",
      "slug" : "reorder-data-in-log-files",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[],[],[],[]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[1,2,3,4]]",
      "input" : "nums = [[1,2],[3,4]], r = 1, c = 4",
      "slug" : "reshape-the-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[],[],[],[]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[1,2],[3,4]]",
      "input" : "nums = [[1,2],[3,4]], r = 2, c = 4",
      "slug" : "reshape-the-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[1,2,3,4]]",
      "input" : "nums = [[1,2],[3,4]], r = 1, c = 4",
      "slug" : "reshape-the-matrix",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[1,2],[3,4]]",
      "input" : "nums = [[1,2],[3,4]], r = 2, c = 4",
      "slug" : "reshape-the-matrix",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[2,11,3,13,5,17,7]",
      "approachName" : "Baseline\/Brute Force",
      "approachOrder" : 1,
      "expected" : "[2,13,3,11,5,17,7]",
      "input" : "deck = [17,13,11,2,3,5,7]",
      "slug" : "reveal-cards-in-increasing-order",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[2,70,10,100,30]",
      "approachName" : "Baseline\/Brute Force",
      "approachOrder" : 1,
      "expected" : "[2, 100, 10, 70, 30]",
      "input" : "deck = [100, 70, 30, 2, 10]",
      "slug" : "reveal-cards-in-increasing-order",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[2,100,10,70,30]",
      "approachName" : "Optimized\/Queue-Based",
      "approachOrder" : 2,
      "expected" : "[2, 100, 10, 70, 30]",
      "input" : "deck = [100, 70, 30, 2, 10]",
      "slug" : "reveal-cards-in-increasing-order",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:247: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:294: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'next'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:222: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                              `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[8, 8, 5, false, 0, true, 0, -1, false]",
      "input" : "RLEIterator([3,8,0,9,2,5]) next(2) next(1) next(1) hasNext(2) next(3) hasNext(1) next(1) next(2) hasNext(2)",
      "slug" : "rle-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:247: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:294: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'next'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_1\/solution.swift:4:222: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }\n    |                                                                                                                                                                                                                              `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[1, 1, -1]",
      "input" : "RLEIterator([1,1,2,2]) next(1) next(1) next(1)",
      "slug" : "rle-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:112: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:298: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'next'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:261: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                                                                                                                                                                     `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[8, 8, 5, false, 0, true, 0, -1, false]",
      "input" : "RLEIterator([3,8,0,9,2,5]) next(2) next(1) next(1) hasNext(2) next(3) hasNext(1) next(1) next(2) hasNext(2)",
      "slug" : "rle-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:112: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:298: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'next'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rle-iterator_2\/solution.swift:4:261: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }\n    |                                                                                                                                                                                                                                                                     `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[1, 1, -1]",
      "input" : "RLEIterator([1,1,2,2]) next(1) next(1) next(1)",
      "slug" : "rle-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Transpose + Reverse",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-image_1\/solution.swift:244:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let solution = Solution()\n242 | \n243 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n244 | let result = solution.rotate(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n245 | let output: Any = NSNull()\n246 | print(jsonString(from: output))\n",
      "expected" : "[[7,4,1],[8,5,2],[9,6,3]]",
      "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
      "slug" : "rotate-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Transpose + Reverse",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-image_1\/solution.swift:244:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let solution = Solution()\n242 | \n243 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n244 | let result = solution.rotate(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n245 | let output: Any = NSNull()\n246 | print(jsonString(from: output))\n",
      "expected" : "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
      "input" : "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
      "slug" : "rotate-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Rotate Four Cells at a Time",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-image_2\/solution.swift:254:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n251 | let solution = Solution()\n252 | \n253 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n254 | let result = solution.rotate(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n255 | let output: Any = NSNull()\n256 | print(jsonString(from: output))\n",
      "expected" : "[[3,1],[4,2]]",
      "input" : "matrix = [[1,2],[3,4]]",
      "slug" : "rotate-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Rotate Four Cells at a Time",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-image_2\/solution.swift:254:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n251 | let solution = Solution()\n252 | \n253 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n254 | let result = solution.rotate(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n255 | let output: Any = NSNull()\n256 | print(jsonString(from: output))\n",
      "expected" : "[[1]]",
      "input" : "matrix = [[1]]",
      "slug" : "rotate-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:11:34: error: expected '{' after 'if' condition\n  9 |         var isSatisfied = true \n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n    |                                  `- error: expected '{' after 'if' condition\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:31: error: consecutive statements on a line must be separated by ';'\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                               `- error: consecutive statements on a line must be separated by ';'\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:32: error: consecutive statements on a line must be separated by ';'\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                `- error: consecutive statements on a line must be separated by ';'\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:31: error: consecutive statements on a line must be separated by ';'\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                               `- error: consecutive statements on a line must be separated by ';'\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:32: error: consecutive statements on a line must be separated by ';'\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                `- error: consecutive statements on a line must be separated by ';'\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:11:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         var isSatisfied = true \n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:28: error: expected member name or initializer call after type name\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                            |- error: expected member name or initializer call after type name\n    |                            |- note: add arguments after the type to construct a value of the type\n    |                            `- note: use '.self' to reference the type object\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:52: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:64: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                                `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:29: error: expected member name or initializer call after type name\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                             |- error: expected member name or initializer call after type name\n    |                             |- note: add arguments after the type to construct a value of the type\n    |                             `- note: use '.self' to reference the type object\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:53: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:65: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                                                 `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:14:37: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n    |                                     |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                     |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                     `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 15 |                     isSatisfied = false \n 16 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:14:72: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n    |                                                                        |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                                                        |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                        `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 15 |                     isSatisfied = false \n 16 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:28: error: expected member name or initializer call after type name\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                            |- error: expected member name or initializer call after type name\n    |                            |- note: add arguments after the type to construct a value of the type\n    |                            `- note: use '.self' to reference the type object\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:52: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:64: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                                `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:29: error: expected member name or initializer call after type name\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                             |- error: expected member name or initializer call after type name\n    |                             |- note: add arguments after the type to construct a value of the type\n    |                             `- note: use '.self' to reference the type object\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:53: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:65: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                                                 `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:21:37: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n    |                                     |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                     |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                     `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 22 |                     isSatisfied = false \n 23 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:21:72: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n    |                                                                        |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                                                        |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                        `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 22 |                     isSatisfied = false \n 23 |                     break \n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "false",
      "input" : "equations = [\"a==b\",\"b!=a\"]",
      "slug" : "satisfiability-of-equality-equations",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:11:34: error: expected '{' after 'if' condition\n  9 |         var isSatisfied = true \n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n    |                                  `- error: expected '{' after 'if' condition\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:31: error: consecutive statements on a line must be separated by ';'\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                               `- error: consecutive statements on a line must be separated by ';'\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:32: error: consecutive statements on a line must be separated by ';'\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                `- error: consecutive statements on a line must be separated by ';'\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:31: error: consecutive statements on a line must be separated by ';'\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                               `- error: consecutive statements on a line must be separated by ';'\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:32: error: consecutive statements on a line must be separated by ';'\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                `- error: consecutive statements on a line must be separated by ';'\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:11:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         var isSatisfied = true \n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:28: error: expected member name or initializer call after type name\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                            |- error: expected member name or initializer call after type name\n    |                            |- note: add arguments after the type to construct a value of the type\n    |                            `- note: use '.self' to reference the type object\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:52: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:12:64: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 10 |         for equation in equations { \n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                                `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:29: error: expected member name or initializer call after type name\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                             |- error: expected member name or initializer call after type name\n    |                             |- note: add arguments after the type to construct a value of the type\n    |                             `- note: use '.self' to reference the type object\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:53: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:13:65: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 11 |             if equation[1] == \"!\") { \n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n    |                                                                 `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n 15 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:14:37: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n    |                                     |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                     |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                     `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 15 |                     isSatisfied = false \n 16 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:14:72: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 12 |                 let left = Int vars.firstIndex(of: equation[0])! \n 13 |                 let right = Int vars.firstIndex(of: equation[3])! \n 14 |                 if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n    |                                                                        |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                                                        |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                        `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 15 |                     isSatisfied = false \n 16 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:28: error: expected member name or initializer call after type name\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                            |- error: expected member name or initializer call after type name\n    |                            |- note: add arguments after the type to construct a value of the type\n    |                            `- note: use '.self' to reference the type object\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:52: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:19:64: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 17 |                 } \n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n    |                                                                `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:29: error: expected member name or initializer call after type name\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                             |- error: expected member name or initializer call after type name\n    |                             |- note: add arguments after the type to construct a value of the type\n    |                             `- note: use '.self' to reference the type object\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:53: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:20:65: warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 18 |             } else { \n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n    |                                                                 `- warning: expression of type 'Array<Character>.Index' (aka 'Int') is unused [#no-usage]\n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n 22 |                     isSatisfied = false \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:21:37: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n    |                                     |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                     |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                     `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 22 |                     isSatisfied = false \n 23 |                     break \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_1\/solution.swift:21:72: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n 19 |                 let left = Int vars.firstIndex(of: equation[0])! \n 20 |                 let right = Int vars.firstIndex(of: equation[2])! \n 21 |                 if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n    |                                                                        |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                                                                        |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                        `- note: required by operator function '<<' where 'RHS' = 'Int.Type'\n 22 |                     isSatisfied = false \n 23 |                     break \n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "true",
      "input" : "equations = [\"b==a\",\"a==b\"]",
      "slug" : "satisfiability-of-equality-equations",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Union Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:32:30: error: expected '{' after 'if' condition\n 30 |     var equationsWithoutNot: [String] = [] \n 31 |     for equation in equations { \n 32 |         if equation[1] == \"!\") { \n    |                              `- error: expected '{' after 'if' condition\n 33 |             continue \n 34 |         } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:39:30: error: expected '{' after 'if' condition\n 37 |     } \n 38 |     for equation in equations { \n 39 |         if equation[1] != \"!\") { \n    |                              `- error: expected '{' after 'if' condition\n 40 |             continue \n 41 |         } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:271:23: error: value of type 'Solution' has no member 'find'\n269 | \n270 | let arg0 = toInt(valueAt(args, 0))\n271 | let result = solution.find(arg0)\n    |                       `- error: value of type 'Solution' has no member 'find'\n272 | let output: Any = result\n273 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:32:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 30 |     var equationsWithoutNot: [String] = [] \n 31 |     for equation in equations { \n 32 |         if equation[1] == \"!\") { \n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:35:22: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n 35 |         uf.union(Int(equation[0].asciiValue! - 97), Int(equation[3].asciiValue! - 97)) \n    |                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |         equationsWithoutNot.append(equation) \n 37 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:35:57: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n 35 |         uf.union(Int(equation[0].asciiValue! - 97), Int(equation[3].asciiValue! - 97)) \n    |                                                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |         equationsWithoutNot.append(equation) \n 37 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:39:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 37 |     } \n 38 |     for equation in equations { \n 39 |         if equation[1] != \"!\") { \n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:42:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n 42 |         if uf.find(Int(equation[0].asciiValue! - 97)) == uf.find(Int(equation[3].asciiValue! - 97)) { \n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 43 |             return false \n 44 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:42:70: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n 42 |         if uf.find(Int(equation[0].asciiValue! - 97)) == uf.find(Int(equation[3].asciiValue! - 97)) { \n    |                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 43 |             return false \n 44 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "equations = [\"a==b\",\"b!=a\"]",
      "slug" : "satisfiability-of-equality-equations",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Union Find",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:32:30: error: expected '{' after 'if' condition\n 30 |     var equationsWithoutNot: [String] = [] \n 31 |     for equation in equations { \n 32 |         if equation[1] == \"!\") { \n    |                              `- error: expected '{' after 'if' condition\n 33 |             continue \n 34 |         } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:39:30: error: expected '{' after 'if' condition\n 37 |     } \n 38 |     for equation in equations { \n 39 |         if equation[1] != \"!\") { \n    |                              `- error: expected '{' after 'if' condition\n 40 |             continue \n 41 |         } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:271:23: error: value of type 'Solution' has no member 'find'\n269 | \n270 | let arg0 = toInt(valueAt(args, 0))\n271 | let result = solution.find(arg0)\n    |                       `- error: value of type 'Solution' has no member 'find'\n272 | let output: Any = result\n273 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:32:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 30 |     var equationsWithoutNot: [String] = [] \n 31 |     for equation in equations { \n 32 |         if equation[1] == \"!\") { \n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:35:22: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n 35 |         uf.union(Int(equation[0].asciiValue! - 97), Int(equation[3].asciiValue! - 97)) \n    |                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |         equationsWithoutNot.append(equation) \n 37 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:35:57: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |             continue \n 34 |         } \n 35 |         uf.union(Int(equation[0].asciiValue! - 97), Int(equation[3].asciiValue! - 97)) \n    |                                                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |         equationsWithoutNot.append(equation) \n 37 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:39:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 37 |     } \n 38 |     for equation in equations { \n 39 |         if equation[1] != \"!\") { \n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:42:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n 42 |         if uf.find(Int(equation[0].asciiValue! - 97)) == uf.find(Int(equation[3].asciiValue! - 97)) { \n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 43 |             return false \n 44 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/satisfiability-of-equality-equations_2\/solution.swift:42:70: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 40 |             continue \n 41 |         } \n 42 |         if uf.find(Int(equation[0].asciiValue! - 97)) == uf.find(Int(equation[3].asciiValue! - 97)) { \n    |                                                                      `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 43 |             return false \n 44 |         } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "true",
      "input" : "equations = [\"b==a\",\"a==b\"]",
      "slug" : "satisfiability-of-equality-equations",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Extra Space with Sets",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/set-matrix-zeroes_1\/solution.swift:252:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n249 | let solution = Solution()\n250 | \n251 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n252 | let result = solution.setZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n253 | let output: Any = NSNull()\n254 | print(jsonString(from: output))\n",
      "expected" : "[[1,0,1],[0,0,0],[1,0,1]]",
      "input" : "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
      "slug" : "set-matrix-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Extra Space with Sets",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/set-matrix-zeroes_1\/solution.swift:252:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n249 | let solution = Solution()\n250 | \n251 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n252 | let result = solution.setZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n253 | let output: Any = NSNull()\n254 | print(jsonString(from: output))\n",
      "expected" : "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
      "input" : "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
      "slug" : "set-matrix-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "O(1) Space - First Row\/Col as Markers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/set-matrix-zeroes_2\/solution.swift:268:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n265 | let solution = Solution()\n266 | \n267 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n268 | let result = solution.setZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n269 | let output: Any = NSNull()\n270 | print(jsonString(from: output))\n",
      "expected" : "[[1,0,1],[0,0,0],[1,0,1]]",
      "input" : "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
      "slug" : "set-matrix-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "O(1) Space - First Row\/Col as Markers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/set-matrix-zeroes_2\/solution.swift:268:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n265 | let solution = Solution()\n266 | \n267 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n268 | let result = solution.setZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n269 | let output: Any = NSNull()\n270 | print(jsonString(from: output))\n",
      "expected" : "[[0,0],[0,0]]",
      "input" : "matrix = [[1,0],[0,1]]",
      "slug" : "set-matrix-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n  6 |     var chars = Array(S)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_1\/solution.swift:10:9: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n  8 |     for i in (0..<shifts.count).reversed() {\n  9 |         totalShifts += shifts[i]\n 10 |         chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + totalShifts) % 26 + 97)!)\n    |         `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 11 |     }\n 12 |     return String(chars)\n",
      "expected" : "\"rpl\"",
      "input" : "S = \"abc\", shifts = [3, 5, 9]",
      "slug" : "shifting-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n  6 |     var chars = Array(S)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_1\/solution.swift:10:9: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n  8 |     for i in (0..<shifts.count).reversed() {\n  9 |         totalShifts += shifts[i]\n 10 |         chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + totalShifts) % 26 + 97)!)\n    |         `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 11 |     }\n 12 |     return String(chars)\n",
      "expected" : "\"dpw\"",
      "input" : "S = \"aaa\", shifts = [3, 5, 9]",
      "slug" : "shifting-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n  6 |     var chars = Array(S)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_2\/solution.swift:12:9: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 10 |     }\n 11 |     for i in 0..<chars.count {\n 12 |         chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + prefixSum[i]) % 26 + 97)!)    \n    |         `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 13 |     }\n 14 |     return String(chars)\n",
      "expected" : "\"rpl\"",
      "input" : "S = \"abc\", shifts = [3, 5, 9]",
      "slug" : "shifting-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n  6 |     var chars = Array(S)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shifting-letters_2\/solution.swift:12:9: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 10 |     }\n 11 |     for i in 0..<chars.count {\n 12 |         chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + prefixSum[i]) % 26 + 97)!)    \n    |         `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 13 |     }\n 14 |     return String(chars)\n",
      "expected" : "\"dpw\"",
      "input" : "S = \"aaa\", shifts = [3, 5, 9]",
      "slug" : "shifting-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "A = [[0,1,0],[0,0,0],[0,0,1]]",
      "slug" : "shortest-bridge",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "3",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "A = [[0,1,0],[0,0,0],[0,0,1]]",
      "slug" : "shortest-bridge",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]",
      "slug" : "shortest-bridge",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_1\/solution.swift:4:513: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; for word in words { let wordCount: [Character: Int] = word.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_1\/solution.swift:4:407: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; for word in words { let wordCount: [Character: Int] = word.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                       `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  5 | }\n  6 | \n",
      "expected" : "steps",
      "input" : "licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]",
      "slug" : "shortest-completing-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_1\/solution.swift:4:513: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; for word in words { let wordCount: [Character: Int] = word.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_1\/solution.swift:4:407: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; for word in words { let wordCount: [Character: Int] = word.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                       `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  5 | }\n  6 | \n",
      "expected" : "pest",
      "input" : "licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]",
      "slug" : "shortest-completing-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_2\/solution.swift:4:544: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; var wordCount: [Character: Int] = [:]; for word in words { wordCount.removeAll(); for char in word.lowercased() { wordCount[char, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_2\/solution.swift:4:438: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; var wordCount: [Character: Int] = [:]; for word in words { wordCount.removeAll(); for char in word.lowercased() { wordCount[char, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  5 | }\n  6 | \n",
      "expected" : "steps",
      "input" : "licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]",
      "slug" : "shortest-completing-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_2\/solution.swift:4:544: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; var wordCount: [Character: Int] = [:]; for word in words { wordCount.removeAll(); for char in word.lowercased() { wordCount[char, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shortest-completing-word_2\/solution.swift:4:438: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  2 | \n  3 | class Solution {\n  4 | func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; var wordCount: [Character: Int] = [:]; for word in words { wordCount.removeAll(); for char in word.lowercased() { wordCount[char, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n  5 | }\n  6 | \n",
      "expected" : "pest",
      "input" : "licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]",
      "slug" : "shortest-completing-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[1,2,3],[8,9,4],[7,6,5]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
      "input" : "n = 3",
      "slug" : "spiral-matrix-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]",
      "input" : "n = 4",
      "slug" : "spiral-matrix-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[1,2,3],[8,9,4],[7,6,5]]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
      "input" : "n = 3",
      "slug" : "spiral-matrix-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]",
      "input" : "n = 4",
      "slug" : "spiral-matrix-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[14,25,26,17,18,19],[13,24,27,22,21,20],[12,0,28,0,0,3],[11,30,29,0,0,4],[10,9,8,7,6,5]]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
      "input" : "R = 5, C = 6, r0 = 1, c0 = 4",
      "slug" : "spiral-matrix-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[14,25,26,17,18,19],[13,24,27,22,21,20],[12,0,28,0,0,3],[11,30,29,0,0,4],[10,9,8,7,6,5]]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
      "input" : "R = 5, C = 6, r0 = 1, c0 = 4",
      "slug" : "spiral-matrix-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "nums = [4,5,0,-2,-3,1], k = 10",
      "slug" : "subarray-sums-divisible-by-k",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Prefix Sum with Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:234: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:285: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:60: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                            `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "7",
      "input" : "nums = [4,5,0,-2,-3,1], k = 5",
      "slug" : "subarray-sums-divisible-by-k",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Prefix Sum with Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:234: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:285: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subarray-sums-divisible-by-k_2\/solution.swift:4:60: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }\n    |                                                            `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [4,5,0,-2,-3,1], k = 10",
      "slug" : "subarray-sums-divisible-by-k",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:181: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:211: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:266: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:288: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:560: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:438: warning: variable 'currCount' was never mutated; consider changing to 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- warning: variable 'currCount' was never mutated; consider changing to 'let' constant\n  4 | \n  5 | \n",
      "expected" : "[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"]",
      "input" : "cpdomains = [\"9001 discuss.leetcode.com\"]",
      "slug" : "subdomain-visit-count",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:181: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:211: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:266: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:288: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:560: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_1\/solution.swift:3:438: warning: variable 'currCount' was never mutated; consider changing to 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- warning: variable 'currCount' was never mutated; consider changing to 'let' constant\n  4 | \n  5 | \n",
      "expected" : "[\"900 google.mail.com\",\"50 yahoo.com\",\"10 intel.mail.com\",\"5 wiki.org\",\"5 org\",\"10 mail.com\",\"900 mail.com\"]",
      "input" : "cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]",
      "slug" : "subdomain-visit-count",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:107: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:181: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:211: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:266: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:288: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:479: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"]",
      "input" : "cpdomains = [\"9001 discuss.leetcode.com\"]",
      "slug" : "subdomain-visit-count",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:107: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:181: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:211: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:266: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:288: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/subdomain-visit-count_2\/solution.swift:3:479: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "[\"900 google.mail.com\",\"50 yahoo.com\",\"10 intel.mail.com\",\"5 wiki.org\",\"5 org\",\"10 mail.com\",\"900 mail.com\"]",
      "input" : "cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]",
      "slug" : "subdomain-visit-count",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[8,6,2,4]",
      "approachName" : "Brute-force Approach",
      "approachOrder" : 1,
      "expected" : "[8, 6, 2, 4]",
      "input" : "A = [1, 2, 3, 4], queries = [[1, 0], [-3, 1], [-4, 0], [2, 3]]",
      "slug" : "sum-of-even-numbers-after-queries",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,0,18]",
      "approachName" : "Brute-force Approach",
      "approachOrder" : 1,
      "expected" : "[8, 6, 14]",
      "input" : "A = [2, 7, 11, 15], queries = [[-2, 0], [-4, 3], [7, 2]]",
      "slug" : "sum-of-even-numbers-after-queries",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[8,6,2,4]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[8, 6, 2, 4]",
      "input" : "A = [1, 2, 3, 4], queries = [[1, 0], [-3, 1], [-4, 0], [2, 3]]",
      "slug" : "sum-of-even-numbers-after-queries",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,0,18]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[8, 6, 14]",
      "input" : "A = [2, 7, 11, 15], queries = [[-2, 0], [-4, 3], [7, 2]]",
      "slug" : "sum-of-even-numbers-after-queries",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_1\/solution.swift:3:332: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for (index, num) in nums.enumerated() { if start == nil { start = num } else if num != start! + (index - (nums.firstIndex(of: start!) ?? 0)) { result.append(String(format: \"%d->%d\", start!, num - 1)); start = num } } if let start = start, let lastIndex = nums.lastIndex(of: start) { result.append(String(format: \"%d->%d\", start, nums[lastIndex])) } return result } }\n    |                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_1\/solution.swift:3:464: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for (index, num) in nums.enumerated() { if start == nil { start = num } else if num != start! + (index - (nums.firstIndex(of: start!) ?? 0)) { result.append(String(format: \"%d->%d\", start!, num - 1)); start = num } } if let start = start, let lastIndex = nums.lastIndex(of: start) { result.append(String(format: \"%d->%d\", start, nums[lastIndex])) } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "[\"0->2\",\"4->5\",\"7\"]",
      "input" : "nums = [0,1,2,4,5,7]",
      "slug" : "summary-ranges",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_1\/solution.swift:3:332: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for (index, num) in nums.enumerated() { if start == nil { start = num } else if num != start! + (index - (nums.firstIndex(of: start!) ?? 0)) { result.append(String(format: \"%d->%d\", start!, num - 1)); start = num } } if let start = start, let lastIndex = nums.lastIndex(of: start) { result.append(String(format: \"%d->%d\", start, nums[lastIndex])) } return result } }\n    |                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_1\/solution.swift:3:464: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for (index, num) in nums.enumerated() { if start == nil { start = num } else if num != start! + (index - (nums.firstIndex(of: start!) ?? 0)) { result.append(String(format: \"%d->%d\", start!, num - 1)); start = num } } if let start = start, let lastIndex = nums.lastIndex(of: start) { result.append(String(format: \"%d->%d\", start, nums[lastIndex])) } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "[\"0\",\"2->4\",\"6\",\"8->9\"]",
      "input" : "nums = [0,2,3,4,6,8,9]",
      "slug" : "summary-ranges",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:321: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:337: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:486: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:213: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                     `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:310: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:378: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:475: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n",
      "expected" : "[\"0->2\",\"4->5\",\"7\"]",
      "input" : "nums = [0,1,2,4,5,7]",
      "slug" : "summary-ranges",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:321: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:337: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:486: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:213: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                     `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:310: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:378: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/summary-ranges_2\/solution.swift:3:475: error: cannot force unwrap value of non-optional type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: cannot force unwrap value of non-optional type 'Int'\n  4 | \n  5 | \n",
      "expected" : "[\"0\",\"2->4\",\"6\",\"8->9\"]",
      "input" : "nums = [0,2,3,4,6,8,9]",
      "slug" : "summary-ranges",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/teemo-attacking_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n",
      "expected" : "4",
      "input" : "timeSeries = [1,4], duration = 2",
      "slug" : "teemo-attacking",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/teemo-attacking_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n",
      "expected" : "3",
      "input" : "timeSeries = [1,2], duration = 2",
      "slug" : "teemo-attacking",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/teemo-attacking_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n",
      "expected" : "4",
      "input" : "timeSeries = [1,4], duration = 2",
      "slug" : "teemo-attacking",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/teemo-attacking_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n",
      "expected" : "3",
      "input" : "timeSeries = [1,2], duration = 2",
      "slug" : "teemo-attacking",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "nums = [1,2]",
      "slug" : "third-maximum-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Single Pass",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "nums = [1,2]",
      "slug" : "third-maximum-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/uncommon-words-from-two-sentences_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n",
      "expected" : "[\"sweet\", \"sour\"]",
      "input" : "sentence1 = \"this apple is sweet\", sentence2 = \"this apple is sour\"",
      "slug" : "uncommon-words-from-two-sentences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/uncommon-words-from-two-sentences_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n",
      "expected" : "[\"banana\"]",
      "input" : "sentence1 = \"apple apple\", sentence2 = \"banana\" ",
      "slug" : "uncommon-words-from-two-sentences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/uncommon-words-from-two-sentences_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n",
      "expected" : "[\"sweet\", \"sour\"]",
      "input" : "sentence1 = \"this apple is sweet\", sentence2 = \"this apple is sour\"",
      "slug" : "uncommon-words-from-two-sentences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/uncommon-words-from-two-sentences_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n",
      "expected" : "[\"banana\"]",
      "input" : "sentence1 = \"apple apple\", sentence2 = \"banana\" ",
      "slug" : "uncommon-words-from-two-sentences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:85: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:150: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                      `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:154: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:244: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:304: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:410: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:449: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:384: error: cannot find '__email__' in scope\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- error: cannot find '__email__' in scope\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
      "slug" : "unique-email-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:85: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:150: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                      `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:154: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:244: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:304: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:410: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:449: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_1\/solution.swift:4:384: error: cannot find '__email__' in scope\n  2 | \n  3 | class Solution {\n  4 | func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- error: cannot find '__email__' in scope\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
      "slug" : "unique-email-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:18: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                  `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:103: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:231: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:279: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:408: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:459: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:500: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:236: warning: initialization of immutable value 'domain' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                            `- warning: initialization of immutable value 'domain' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:284: warning: initialization of immutable value 'normalizedLocal' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                            `- warning: initialization of immutable value 'normalizedLocal' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
      "slug" : "unique-email-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:18: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                  `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:103: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:231: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:279: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:408: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:459: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:500: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:236: warning: initialization of immutable value 'domain' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                            `- warning: initialization of immutable value 'domain' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-email-addresses_2\/solution.swift:4:284: warning: initialization of immutable value 'normalizedLocal' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }\n    |                                                                                                                                                                                                                                                                                            `- warning: initialization of immutable value 'normalizedLocal' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
      "slug" : "unique-email-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "false",
      "input" : "nums = [2,1]",
      "slug" : "valid-mountain-array",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "false",
      "input" : "nums = [3,5,5]",
      "slug" : "valid-mountain-array",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "nums = [0,3,2,1]",
      "slug" : "valid-mountain-array",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "true",
      "input" : "board with valid partial fill",
      "slug" : "valid-sudoku",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "false",
      "input" : "board with duplicate in box",
      "slug" : "valid-sudoku",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:38:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |                var col = [Character]()\n 37 |                for i in 0..<size {\n 38 |                   col.append(board[i][j])\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 39 |                }\n 40 |                if Set(col).count == 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:53:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 51 |             var diagonal2 = [Character]()\n 52 |             for i in 0..<size {\n 53 |                diagonal1.append(board[i][i])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 54 |                diagonal2.append(board[i][size-i-1])\n 55 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:54:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 52 |             for i in 0..<size {\n 53 |                diagonal1.append(board[i][i])\n 54 |                diagonal2.append(board[i][size-i-1])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 55 |             }\n 56 |             if Set(diagonal1).count == 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "board = [\"XOX\", \"OXO\", \"XOX\"]",
      "slug" : "valid-tic-tac-toe-state",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:38:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |                var col = [Character]()\n 37 |                for i in 0..<size {\n 38 |                   col.append(board[i][j])\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 39 |                }\n 40 |                if Set(col).count == 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:53:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 51 |             var diagonal2 = [Character]()\n 52 |             for i in 0..<size {\n 53 |                diagonal1.append(board[i][i])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 54 |                diagonal2.append(board[i][size-i-1])\n 55 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_1\/solution.swift:54:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 52 |             for i in 0..<size {\n 53 |                diagonal1.append(board[i][i])\n 54 |                diagonal2.append(board[i][size-i-1])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 55 |             }\n 56 |             if Set(diagonal1).count == 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "board = [\"XOX\", \" X \", \"   \"]",
      "slug" : "valid-tic-tac-toe-state",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:16:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |                var row = [Character]()\n 15 |                for j in 0..<size {\n 16 |                   let mark = board[i][j]\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                   row.append(mark)\n 18 |                   if mark == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:35:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |                var col = [Character]()\n 34 |                for i in 0..<size {\n 35 |                   col.append(board[i][j])\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |                }\n 37 |                if Set(col).count == 1 && col.first == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:48:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 46 |             var diagonal2 = [Character]()\n 47 |             for i in 0..<size {\n 48 |                diagonal1.append(board[i][i])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 49 |                diagonal2.append(board[i][size-i-1])\n 50 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:49:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 47 |             for i in 0..<size {\n 48 |                diagonal1.append(board[i][i])\n 49 |                diagonal2.append(board[i][size-i-1])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 50 |             }\n 51 |             if Set(diagonal1).count == 1 && diagonal1.first == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "board = [\"XXO\", \"XOX\", \"OXO\"]",
      "slug" : "valid-tic-tac-toe-state",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:16:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 14 |                var row = [Character]()\n 15 |                for j in 0..<size {\n 16 |                   let mark = board[i][j]\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                   row.append(mark)\n 18 |                   if mark == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:35:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 33 |                var col = [Character]()\n 34 |                for i in 0..<size {\n 35 |                   col.append(board[i][j])\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 36 |                }\n 37 |                if Set(col).count == 1 && col.first == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:48:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 46 |             var diagonal2 = [Character]()\n 47 |             for i in 0..<size {\n 48 |                diagonal1.append(board[i][i])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 49 |                diagonal2.append(board[i][size-i-1])\n 50 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-tic-tac-toe-state_2\/solution.swift:49:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 47 |             for i in 0..<size {\n 48 |                diagonal1.append(board[i][i])\n 49 |                diagonal2.append(board[i][size-i-1])\n    |                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 50 |             }\n 51 |             if Set(diagonal1).count == 1 && diagonal1.first == \"X\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "board = [\"XOX\", \"OXO\", \"   \"]",
      "slug" : "valid-tic-tac-toe-state",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verifying-an-alien-dictionary_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isAlienSorted(_ words: [String], _ order: String) -> Bool {\n",
      "expected" : "true",
      "input" : "words = [\"kuvbz\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\"",
      "slug" : "verifying-an-alien-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verifying-an-alien-dictionary_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isAlienSorted(_ words: [String], _ order: String) -> Bool {\n",
      "expected" : "false",
      "input" : "words = [\"word\",\"world\",\"row\"] , order = \"worldabcefghijkmnpqstuvxyz\"",
      "slug" : "verifying-an-alien-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verifying-an-alien-dictionary_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isAlienSorted(_ words: [String], _ order: String) -> Bool {\n",
      "expected" : "true",
      "input" : "words = [\"hello\",\"leetcode\"] , order = \"hlabcdefgijkmnopqrstuvwxyz\"",
      "slug" : "verifying-an-alien-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verifying-an-alien-dictionary_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isAlienSorted(_ words: [String], _ order: String) -> Bool {\n",
      "expected" : "false",
      "input" : "words = [\"word\",\"world\",\"row\"] , order = \"worldabcefghijkmnpqstuvxyz\"",
      "slug" : "verifying-an-alien-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:463: error: expected ',' separator\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: expected ',' separator\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:458: error: cannot find 'with' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot find 'with' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:448: error: missing argument labels 'with:options:' in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: missing argument labels 'with:options:' in call\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:463: error: cannot convert value of type 'String' to expected argument type 'String.CompareOptions' (aka 'NSString.CompareOptions')\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot convert value of type 'String' to expected argument type 'String.CompareOptions' (aka 'NSString.CompareOptions')\n  4 | \n  5 | \n",
      "expected" : "[\"apple\"]",
      "input" : "wordlist = [\"apple\"], queries = [\"apple\"]",
      "slug" : "vowel-spellchecker",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:463: error: expected ',' separator\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: expected ',' separator\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:458: error: cannot find 'with' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot find 'with' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:448: error: missing argument labels 'with:options:' in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: missing argument labels 'with:options:' in call\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_1\/solution.swift:3:463: error: cannot convert value of type 'String' to expected argument type 'String.CompareOptions' (aka 'NSString.CompareOptions')\n  1 | import Foundation\n  2 | \n  3 | class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot convert value of type 'String' to expected argument type 'String.CompareOptions' (aka 'NSString.CompareOptions')\n  4 | \n  5 | \n",
      "expected" : "[\"apple\"]",
      "input" : "wordlist = [\"apple\"], queries = [\"appel\"]",
      "slug" : "vowel-spellchecker",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_2\/solution.swift:3:574: error: expected expression after operator\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [TrieNode?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil]; var word: String? = nil; }; class Trie { var root = TrieNode(); func insert(_ word: String) { var node = root; for char in word.utf8 { node.children[Int(char) - 97] = node.children[Int(char) - 97] ?? TrieNode(); node = node.children[Int(char) - 97]! }; node.word = word; }; func search(_ word: String) -> String? { var node = root; for char in word.utf8 { node = node.children[Int(char) - 97] ?? return nil; }; return node.word; }; }; class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { let trie = Trie(); for word in wordlist { trie.insert(word); trie.insert(word.lowercased()); let vowelWord = word.lowercased().replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); trie.insert(vowelWord); }; var result = [String](); for query in queries { if let word = trie.search(query) { result.append(word); } else if let word = trie.search(query.lowercased()) { result.append(word); } else { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if let word = trie.search(queryVowel) { result.append(word); } }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected expression after operator\n  4 | \n  5 | \n",
      "expected" : "[\"apple\"]",
      "input" : "wordlist = [\"apple\"], queries = [\"apple\"]",
      "slug" : "vowel-spellchecker",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/vowel-spellchecker_2\/solution.swift:3:574: error: expected expression after operator\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [TrieNode?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil]; var word: String? = nil; }; class Trie { var root = TrieNode(); func insert(_ word: String) { var node = root; for char in word.utf8 { node.children[Int(char) - 97] = node.children[Int(char) - 97] ?? TrieNode(); node = node.children[Int(char) - 97]! }; node.word = word; }; func search(_ word: String) -> String? { var node = root; for char in word.utf8 { node = node.children[Int(char) - 97] ?? return nil; }; return node.word; }; }; class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { let trie = Trie(); for word in wordlist { trie.insert(word); trie.insert(word.lowercased()); let vowelWord = word.lowercased().replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); trie.insert(vowelWord); }; var result = [String](); for query in queries { if let word = trie.search(query) { result.append(word); } else if let word = trie.search(query.lowercased()) { result.append(word); } else { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if let word = trie.search(queryVowel) { result.append(word); } }; }; return result; } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected expression after operator\n  4 | \n  5 | \n",
      "expected" : "[\"apple\"]",
      "input" : "wordlist = [\"apple\"], queries = [\"appel\"]",
      "slug" : "vowel-spellchecker",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[4,1]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[-1,4]",
      "input" : "commands = [4,-1,3]",
      "slug" : "walking-robot-simulation",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[-4,0]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[-1,8]",
      "input" : "commands = [4,-1,4,-2,4]",
      "slug" : "walking-robot-simulation",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[4,1]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[1,4]",
      "input" : "commands = [4,-1,3]",
      "slug" : "walking-robot-simulation",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[-4,0]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[3,8]",
      "input" : "commands = [4,-1,4,-2,4]",
      "slug" : "walking-robot-simulation",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_1\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "true",
      "input" : "pattern = \"abba\", s = \"dog cat cat dog\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_1\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "false",
      "input" : "pattern = \"abba\", s = \"dog cat cat fish\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_1\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "false",
      "input" : "pattern = \"aaaa\", s = \"dog cat cat dog\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_2\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "true",
      "input" : "pattern = \"abba\", s = \"dog cat cat dog\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_2\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "false",
      "input" : "pattern = \"abba\", s = \"dog cat cat fish\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-pattern_2\/solution.swift:5:10: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |          import Foundation\n    |          `- error: declaration is only valid at file scope\n  6 | \n  7 |          func wordPattern(_ pattern: String, _ s: String) -> Bool {\n",
      "expected" : "false",
      "input" : "pattern = \"aaaa\", s = \"dog cat cat dog\"",
      "slug" : "word-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "20",
      "input" : "nums = [1,1,2,2,2,2,3,3,4,4,8,8], target = 6",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "4",
      "input" : "nums = [1,1,2,2,3,3,4,4,5,5], target = 8",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "0",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "20",
      "input" : "nums = [1,1,2,2,2,2,3,3,4,4,8,8], target = 6",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "4",
      "input" : "nums = [1,1,2,2,3,3,4,4,5,5], target = 8",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/3sum-with-multiplicity_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func threeSumMulti(_ nums: [Int], _ target: Int) -> Int {\n",
      "expected" : "0",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "3sum-with-multiplicity",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "[[-1,0,0,1],[-2,-1,1,2],[-2,0,0,2]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
      "input" : "nums = [1, 0, -1, 0, -2, 2], target = 0",
      "slug" : "4sum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[2,2,2,2]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[2, 2, 2, 2]]",
      "input" : "nums = [2, 2, 2, 2, 2], target = 8",
      "slug" : "4sum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]",
      "input" : "nums = [1, 0, -1, 0, -2, 2], target = 0",
      "slug" : "4sum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[2,2,2,2]]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[[2, 2, 2, 2]]",
      "input" : "nums = [2, 2, 2, 2, 2], target = 8",
      "slug" : "4sum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:8:9: warning: variable 'res' was never used; consider replacing with '_' or removing it [#no-usage]\n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n  7 |     let n = A.count\n  8 |     var res: [Int] = Array(repeating: 0, count: n)\n    |         `- warning: variable 'res' was never used; consider replacing with '_' or removing it [#no-usage]\n  9 |     var permutations = getPermutations(arr: B)\n 10 |     var maxDiff: Int = Int.min\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:9:9: warning: variable 'permutations' was never mutated; consider changing to 'let' constant\n  7 |     let n = A.count\n  8 |     var res: [Int] = Array(repeating: 0, count: n)\n  9 |     var permutations = getPermutations(arr: B)\n    |         `- warning: variable 'permutations' was never mutated; consider changing to 'let' constant\n 10 |     var maxDiff: Int = Int.min\n 11 |     var maxDiffPermutation: [Int] = []\n",
      "expected" : "[2,11,7,15]",
      "input" : "A = [2,7,11,15], B = [1,10,4,11]",
      "slug" : "advantage-shuffle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:8:9: warning: variable 'res' was never used; consider replacing with '_' or removing it [#no-usage]\n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n  7 |     let n = A.count\n  8 |     var res: [Int] = Array(repeating: 0, count: n)\n    |         `- warning: variable 'res' was never used; consider replacing with '_' or removing it [#no-usage]\n  9 |     var permutations = getPermutations(arr: B)\n 10 |     var maxDiff: Int = Int.min\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_1\/solution.swift:9:9: warning: variable 'permutations' was never mutated; consider changing to 'let' constant\n  7 |     let n = A.count\n  8 |     var res: [Int] = Array(repeating: 0, count: n)\n  9 |     var permutations = getPermutations(arr: B)\n    |         `- warning: variable 'permutations' was never mutated; consider changing to 'let' constant\n 10 |     var maxDiff: Int = Int.min\n 11 |     var maxDiffPermutation: [Int] = []\n",
      "expected" : "[24,8,12,32]",
      "input" : "A = [12,24,8,32], B = [13,25,32,11]",
      "slug" : "advantage-shuffle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n",
      "expected" : "[2,11,7,15]",
      "input" : "A = [2,7,11,15], B = [1,10,4,11]",
      "slug" : "advantage-shuffle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/advantage-shuffle_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\n",
      "expected" : "[24,8,12,32]",
      "input" : "A = [12,24,8,32], B = [13,25,32,11]",
      "slug" : "advantage-shuffle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_1\/solution.swift:4:272: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(g: [Int], s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var satisfiedChildren = 0; for cookie in sortedS { for i in 0..<sortedG.count { if cookie >= sortedG[i] { satisfiedChildren += 1; sortedG.remove(at: i); break; } } } return satisfiedChildren; }\n    |                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_1\/solution.swift:4:245: error: cannot use mutating member on immutable value: 'sortedG' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(g: [Int], s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var satisfiedChildren = 0; for cookie in sortedS { for i in 0..<sortedG.count { if cookie >= sortedG[i] { satisfiedChildren += 1; sortedG.remove(at: i); break; } } } return satisfiedChildren; }\n    |                                                       |                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'sortedG' is a 'let' constant\n    |                                                       `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "g = [1,2,3], s = [1,2]",
      "slug" : "assign-cookies",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_1\/solution.swift:4:272: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(g: [Int], s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var satisfiedChildren = 0; for cookie in sortedS { for i in 0..<sortedG.count { if cookie >= sortedG[i] { satisfiedChildren += 1; sortedG.remove(at: i); break; } } } return satisfiedChildren; }\n    |                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_1\/solution.swift:4:245: error: cannot use mutating member on immutable value: 'sortedG' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(g: [Int], s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var satisfiedChildren = 0; for cookie in sortedS { for i in 0..<sortedG.count { if cookie >= sortedG[i] { satisfiedChildren += 1; sortedG.remove(at: i); break; } } } return satisfiedChildren; }\n    |                                                       |                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'sortedG' is a 'let' constant\n    |                                                       `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "g = [1,2], s = [1,2,3]",
      "slug" : "assign-cookies",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_2\/solution.swift:4:285: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(_ g: [Int], _ s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var childIndex = 0; var cookieIndex = 0; while childIndex < sortedG.count && cookieIndex < sortedS.count { if sortedS[cookieIndex] >= sortedG[childIndex] { childIndex += 1; } cookieIndex += 1; } return childIndex; }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_2\/solution.swift:4:305: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(_ g: [Int], _ s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var childIndex = 0; var cookieIndex = 0; while childIndex < sortedG.count && cookieIndex < sortedS.count { if sortedS[cookieIndex] >= sortedG[childIndex] { childIndex += 1; } cookieIndex += 1; } return childIndex; }\n    |                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "g = [1,2,3], s = [1,2]",
      "slug" : "assign-cookies",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_2\/solution.swift:4:285: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(_ g: [Int], _ s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var childIndex = 0; var cookieIndex = 0; while childIndex < sortedG.count && cookieIndex < sortedS.count { if sortedS[cookieIndex] >= sortedG[childIndex] { childIndex += 1; } cookieIndex += 1; } return childIndex; }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/assign-cookies_2\/solution.swift:4:305: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findContentChildren(_ g: [Int], _ s: [Int]) -> Int { let sortedG = g.sorted(); let sortedS = s.sorted(); var childIndex = 0; var cookieIndex = 0; while childIndex < sortedG.count && cookieIndex < sortedS.count { if sortedS[cookieIndex] >= sortedG[childIndex] { childIndex += 1; } cookieIndex += 1; } return childIndex; }\n    |                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "g = [1,2], s = [1,2,3]",
      "slug" : "assign-cookies",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:123: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:146: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:112: warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                `- warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"ab#c\", t = \"ad#c\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:123: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:146: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:112: warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                `- warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"ab##\", t = \"c#d#\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:123: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:146: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_1\/solution.swift:4:112: warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let processString = { (str: String) -> String in var result = \"\" var stack = [String]() for char in str { if char != \"#\" { stack.append(String(char)) } else if !stack.isEmpty { stack.removeLast() } } return stack.joined() }; return processString(s) == processString(t) }\n    |                                                                                                                `- warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"a##c\", t = \"#a#c\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:315: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:431: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:494: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"ab#c\", t = \"ad#c\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:315: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:431: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:494: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"ab##\", t = \"c#d#\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:315: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:431: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/backspace-string-compare_2\/solution.swift:4:494: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func backspaceCompare(_ s: String, _ t: String) -> Bool { let sArray = Array(s), tArray = Array(t); var i = sArray.count - 1, j = tArray.count - 1; var skipS = 0, skipT = 0; while i >= 0 || j >= 0 { while i >= 0 { if sArray[i] == \"#\" { skipS += 1; i -= 1 } else if skipS > 0 { skipS -= 1; i -= 1 } else { break } } while j >= 0 { if tArray[j] == \"#\" { skipT += 1; j -= 1 } else if skipT > 0 { skipT -= 1; j -= 1 } else { break } } if i >= 0 && j >= 0 && sArray[i] != tArray[j] { return false } if (i >= 0) != (j >= 0) { return false }; i -= 1; j -= 1 }; return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"a##c\", t = \"#a#c\"",
      "slug" : "backspace-string-compare",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_1\/solution.swift:3:285: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; let tokens = tokens.sorted(); for token in tokens { if points >= token { points -= token; score += 1; maxScore = max(maxScore, score); } } return maxScore } }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_1\/solution.swift:3:80: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; let tokens = tokens.sorted(); for token in tokens { if points >= token { points -= token; score += 1; maxScore = max(maxScore, score); } } return maxScore } }\n    |                                                                                `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  4 | \n  5 | \n",
      "expected" : "0",
      "input" : "tokens = [100], P = 50",
      "slug" : "bag-of-tokens",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_1\/solution.swift:3:285: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; let tokens = tokens.sorted(); for token in tokens { if points >= token { points -= token; score += 1; maxScore = max(maxScore, score); } } return maxScore } }\n    |                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_1\/solution.swift:3:80: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; let tokens = tokens.sorted(); for token in tokens { if points >= token { points -= token; score += 1; maxScore = max(maxScore, score); } } return maxScore } }\n    |                                                                                `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  4 | \n  5 | \n",
      "expected" : "1",
      "input" : "tokens = [100, 200], P = 150",
      "slug" : "bag-of-tokens",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_2\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; var left = 0; var right = n - 1; let tokens = tokens.sorted(); while left <= right { if points >= tokens[left] { points -= tokens[left]; score += 1; left += 1; maxScore = max(maxScore, score); } else if score > 0 { points += tokens[right]; score -= 1; right -= 1; } else { break; } } return maxScore } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "1",
      "input" : "tokens = [100, 200, 300, 400], P = 200",
      "slug" : "bag-of-tokens",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bag-of-tokens_2\/solution.swift:3:430: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func bagOfTokensScore(_ tokens: [Int], _ P: Int) -> Int { let n = tokens.count; var maxScore = 0; var score = 0; var points = P; var left = 0; var right = n - 1; let tokens = tokens.sorted(); while left <= right { if points >= tokens[left] { points -= tokens[left]; score += 1; left += 1; maxScore = max(maxScore, score); } else if score > 0 { points += tokens[right]; score -= 1; right -= 1; } else { break; } } return maxScore } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "0",
      "input" : "tokens = [71, 55, 82], P = 54",
      "slug" : "bag-of-tokens",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/camelcase-matching_1\/solution.swift:4:298: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); for i in 0..<queryArray.count { for j in i..<queryArray.count { if compareSubString(start: i, end: j, queryArray: queryArray, patternArray: patternArray) { return true } } } return false }; func compareSubString(start: Int, end: Int, queryArray: [Character], patternArray: [Character]) -> Bool { if start == 0 && queryArray[start] != patternArray[0] { return false }; var queryIndex = start; var patternIndex = 0; while queryIndex <= end && patternIndex < patternArray.count { if queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; if queryArray[queryIndex].isUppercase && queryArray[queryIndex] != patternArray[patternIndex] { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };\n    |                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "query = \"FooBarTest\", pattern = \"FBT\"",
      "slug" : "camelcase-matching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/camelcase-matching_1\/solution.swift:4:298: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); for i in 0..<queryArray.count { for j in i..<queryArray.count { if compareSubString(start: i, end: j, queryArray: queryArray, patternArray: patternArray) { return true } } } return false }; func compareSubString(start: Int, end: Int, queryArray: [Character], patternArray: [Character]) -> Bool { if start == 0 && queryArray[start] != patternArray[0] { return false }; var queryIndex = start; var patternIndex = 0; while queryIndex <= end && patternIndex < patternArray.count { if queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; if queryArray[queryIndex].isUppercase && queryArray[queryIndex] != patternArray[patternIndex] { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };\n    |                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "query = \"fooBarTest\", pattern = \"FBT\"",
      "slug" : "camelcase-matching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/camelcase-matching_2\/solution.swift:4:321: error: expected expression\n  2 | \n  3 | class Solution {\n  4 | func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); var queryIndex = 0; var patternIndex = 0; while queryIndex < queryArray.count { if patternIndex < patternArray.count && queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; else if queryArray[queryIndex].isUppercase { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };\n    |                                                                                                                                                                                                                                                                                                                                 `- error: expected expression\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "query = \"FooBarTest\", pattern = \"FBT\"",
      "slug" : "camelcase-matching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/camelcase-matching_2\/solution.swift:4:321: error: expected expression\n  2 | \n  3 | class Solution {\n  4 | func camelMatch(query: String, pattern: String) -> Bool { let queryArray = Array(query); let patternArray = Array(pattern); var queryIndex = 0; var patternIndex = 0; while queryIndex < queryArray.count { if patternIndex < patternArray.count && queryArray[queryIndex] == patternArray[patternIndex] { patternIndex += 1 }; else if queryArray[queryIndex].isUppercase { return false }; queryIndex += 1 }; return patternIndex == patternArray.count };\n    |                                                                                                                                                                                                                                                                                                                                 `- error: expected expression\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "query = \"fooBarTest\", pattern = \"FBT\"",
      "slug" : "camelcase-matching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:575: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:592: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:97: warning: variable 'dir' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                 `- warning: variable 'dir' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:130: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                  `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [2,-1,1,2,2]",
      "slug" : "circular-array-loop",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:575: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:592: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:97: warning: variable 'dir' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                 `- warning: variable 'dir' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_1\/solution.swift:4:130: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; var slow = 0, fast = 0; var dir = nums[0] >= 0 ? 1 : -1; for i in 0..<n { slow = (slow + nums[slow]) % n; if slow < 0 { slow += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; fast = (fast + nums[fast]) % n; if fast < 0 { fast += n }; if slow == fast { if slow == 0 || nums[slow] == 0 { return false }; var p = (slow + nums[slow]) % n; if p < 0 { p += n }; if p == slow { return false }; while p != slow { if nums[p] * dir < 0 { return false }; p = (p + nums[p]) % n; if p < 0 { p += n }; } return true; } } return false; }\n    |                                                                                                                                  `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [1,2,3,4,-5]",
      "slug" : "circular-array-loop",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Floyd's Cycle Detection Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:120: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:702: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:447: error: cannot assign to value: 'i' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot assign to value: 'i' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [2,7,11,13]",
      "slug" : "circular-array-loop",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Floyd's Cycle Detection Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:120: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:702: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/circular-array-loop_2\/solution.swift:4:447: error: cannot assign to value: 'i' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func circularArrayLoop(_ nums: [Int]) -> Bool { let n = nums.count; func find(_ x: Int) -> Int { var x = x; var val = 1 if x < 0 { val = -1 }; x = (x % n + n) % n; while x != 0 && nums[x] * val > 0 { x = (x + nums[x]) % n; if x < 0 { x += n }; if x == 0 { return -1 }; }; return x; }; var hash = [Int](repeating: -1, count: n); var slow = 0, fast = 0; for i in 0..<n { while hash[i] == -1 { hash[i] = i; slow = find(i); if slow != -1 { break; }; i = slow; }; if slow == -1 { continue; }; slow = i; fast = find(slow); while fast != -1 && fast != slow { fast = find(fast); if fast == -1 { break; }; if nums[slow] * nums[fast] <= 0 { slow = -1; break; }; slow = fast; }; if slow != -1 { return true; }; } return false; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot assign to value: 'i' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [2,-1,1,2,2]",
      "slug" : "circular-array-loop",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/compare-version-numbers_2\/solution.swift:11:34: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  9 |         var n1 = 0\n 10 |         while i < v1.count && v1[v1.index(v1.startIndex, offsetBy: i)] != \".\" {\n 11 |             n1 = n1 * 10 + Int(v1[v1.index(v1.startIndex, offsetBy: i)])!\n    |                                  `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 12 |             i += 1\n 13 |         }\n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/compare-version-numbers_2\/solution.swift:17:34: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 15 |         var n2 = 0\n 16 |         while j < v2.count && v2[v2.index(v2.startIndex, offsetBy: j)] != \".\" {\n 17 |             n2 = n2 * 10 + Int(v2[v2.index(v2.startIndex, offsetBy: j)])!\n    |                                  `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 18 |             j += 1\n 19 |         }\n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n",
      "expected" : "-1",
      "input" : "version1 = \"0.1\", version2 = \"1.0\"",
      "slug" : "compare-version-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/compare-version-numbers_2\/solution.swift:11:34: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  9 |         var n1 = 0\n 10 |         while i < v1.count && v1[v1.index(v1.startIndex, offsetBy: i)] != \".\" {\n 11 |             n1 = n1 * 10 + Int(v1[v1.index(v1.startIndex, offsetBy: i)])!\n    |                                  `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 12 |             i += 1\n 13 |         }\n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/compare-version-numbers_2\/solution.swift:17:34: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 15 |         var n2 = 0\n 16 |         while j < v2.count && v2[v2.index(v2.startIndex, offsetBy: j)] != \".\" {\n 17 |             n2 = n2 * 10 + Int(v2[v2.index(v2.startIndex, offsetBy: j)])!\n    |                                  `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n 18 |             j += 1\n 19 |         }\n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n",
      "expected" : "1",
      "input" : "version1 = \"1.0.1\", version2 = \"1\"",
      "slug" : "compare-version-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:101: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:135: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:169: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:185: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                         `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:307: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:346: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:391: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:422: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:448: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:540: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:563: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:749: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:65: warning: variable 'result' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                 `- warning: variable 'result' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:276: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                    `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:324: error: cannot find 'S' in scope\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: cannot find 'S' in scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:329: error: cannot assign to value: 'result' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: cannot assign to value: 'result' is a 'let' constant\n  5 | }\n  6 | \n    :\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let result = solution.diStringMatch(arg0)\n    | `- note: change 'let' to 'var' to make it mutable\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:624: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  5 | }\n  6 | \n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:703: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  5 | }\n  6 | \n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n",
      "expected" : "[0,4,1,3,2]",
      "input" : "S = \"IDID\"",
      "slug" : "di-string-match",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:101: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:135: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:169: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:185: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                         `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:307: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:346: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:391: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:422: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:448: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:540: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:563: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:749: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:65: warning: variable 'result' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                 `- warning: variable 'result' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:276: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                    `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:324: error: cannot find 'S' in scope\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: cannot find 'S' in scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:329: error: cannot assign to value: 'result' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: cannot assign to value: 'result' is a 'let' constant\n  5 | }\n  6 | \n    :\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let result = solution.diStringMatch(arg0)\n    | `- note: change 'let' to 'var' to make it mutable\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:624: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  5 | }\n  6 | \n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_1\/solution.swift:4:703: error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var result = [Int](); var temp = [Int]() for i in 0...n { temp.append(i) } permute(&temp, 0, temp.count - 1) return result } func permute(_ nums: inout [Int], _ start: Int, _ end: Int) { if start == end { let str = String(nums.map { String($0) }) if isValid(str, S) { result = nums } } for i in start...end { nums.swapAt(start, i) permute(&nums, start + 1, end) nums.swapAt(start, i) } } func isValid(_ str: String, _ S: String) -> Bool { if str.count != S.count { return false } var sumD = 0, sumI = 0 for (i, c) in S.enumerated() { if c == \"D\" { sumD += Int(str[str.index(str.startIndex, offsetBy: i)])! } else if c == \"I\" { sumI += Int(str[str.index(str.startIndex, offsetBy: i)])! } } return sumD == sumI }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n  5 | }\n  6 | \n\nSwift.Collection.subscript:2:19: note: where 'R' = 'String.Index'\n1 | protocol Collection {\n2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}\n  |                   `- note: where 'R' = 'String.Index'\n3 | \n",
      "expected" : "[0,1,2]",
      "input" : "S = \"III\"",
      "slug" : "di-string-match",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_2\/solution.swift:4:217: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var low = 0, high = n; var result = [Int](); for c in S { if c == \"D\" { result.append(low); low += 1 } else if c == \"I\" { result.append(high); high -= 1 } } if S.last == \"D\" { result.append(low) } else { result.append(high) } return result }\n    |                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var low = 0, high = n; var result = [Int](); for c in S { if c == \"D\" { result.append(low); low += 1 } else if c == \"I\" { result.append(high); high -= 1 } } if S.last == \"D\" { result.append(low) } else { result.append(high) } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0,4,1,3,2]",
      "input" : "S = \"IDID\"",
      "slug" : "di-string-match",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_2\/solution.swift:4:217: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var low = 0, high = n; var result = [Int](); for c in S { if c == \"D\" { result.append(low); low += 1 } else if c == \"I\" { result.append(high); high -= 1 } } if S.last == \"D\" { result.append(low) } else { result.append(high) } return result }\n    |                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/di-string-match_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func diStringMatch(_ S: String) -> [Int] { let n = S.count; var low = 0, high = n; var result = [Int](); for c in S { if c == \"D\" { result.append(low); low += 1 } else if c == \"I\" { result.append(high); high -= 1 } } if S.last == \"D\" { result.append(low) } else { result.append(high) } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0,1,2,3]",
      "input" : "S = \"III\"",
      "slug" : "di-string-match",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func expressiveWords(_ S: String, _ words: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:24:49: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 | \n 23 |                while sIndex < S.count {\n 24 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:24:68: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 | \n 23 |                while sIndex < S.count {\n 24 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:27:44: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n 27 |                    } else if sIndex > 0 && S[sIndex] == S[sIndex - 1] {\n    |                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 28 |                        let charCountInS = countConsecutive(S, at: sIndex)\n 29 |                        if charCountInS > 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:27:57: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n 27 |                    } else if sIndex > 0 && S[sIndex] == S[sIndex - 1] {\n    |                                                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 28 |                        let charCountInS = countConsecutive(S, at: sIndex)\n 29 |                        if charCountInS > 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1",
      "input" : "S = \"abcd\", words = [\"abdb\",\"bcdc\",\"ac\",\"ba\",\"b\",\"a\"]",
      "slug" : "expressive-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func expressiveWords(_ S: String, _ words: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:24:49: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 | \n 23 |                while sIndex < S.count {\n 24 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:24:68: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 | \n 23 |                while sIndex < S.count {\n 24 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:27:44: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n 27 |                    } else if sIndex > 0 && S[sIndex] == S[sIndex - 1] {\n    |                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 28 |                        let charCountInS = countConsecutive(S, at: sIndex)\n 29 |                        if charCountInS > 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_1\/solution.swift:27:57: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                        wordIndex += 1\n 26 |                        sIndex += 1\n 27 |                    } else if sIndex > 0 && S[sIndex] == S[sIndex - 1] {\n    |                                                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 28 |                        let charCountInS = countConsecutive(S, at: sIndex)\n 29 |                        if charCountInS > 1 {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "0",
      "input" : "S = \"abcd\", words = [\"abc\",\"abdb\",\"bcdc\",\"ac\"]",
      "slug" : "expressive-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func expressiveWords(_ S: String, _ words: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:22:49: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 | \n 21 |                while sIndex < S.count {\n 22 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                        let wordCount = countConsecutive(word, at: wordIndex)\n 24 |                        let sCount = countConsecutive(S, at: sIndex)\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:22:68: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 | \n 21 |                while sIndex < S.count {\n 22 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                        let wordCount = countConsecutive(word, at: wordIndex)\n 24 |                        let sCount = countConsecutive(S, at: sIndex)\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1",
      "input" : "S = \"heeellooo\", words = [\"hello\", \"hi\", \"helolo\"]",
      "slug" : "expressive-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func expressiveWords(_ S: String, _ words: [String]) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:22:49: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 | \n 21 |                while sIndex < S.count {\n 22 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                 `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                        let wordCount = countConsecutive(word, at: wordIndex)\n 24 |                        let sCount = countConsecutive(S, at: sIndex)\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/expressive-words_2\/solution.swift:22:68: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 | \n 21 |                while sIndex < S.count {\n 22 |                    if wordIndex < word.count && word[wordIndex] == S[sIndex] {\n    |                                                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                        let wordCount = countConsecutive(word, at: wordIndex)\n 24 |                        let sCount = countConsecutive(S, at: sIndex)\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1",
      "input" : "S = \"abcd\", words = [\"abdb\",\"bcdc\",\"ac\",\"ba\",\"b\",\"a\"]",
      "slug" : "expressive-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-closest-elements_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findKClosestElementsBruteForce(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n",
      "expected" : "[1,2,3,4]",
      "input" : "nums = [1,2,3,4,5], k = 4, x = 3",
      "slug" : "find-k-closest-elements",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-closest-elements_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findKClosestElementsBruteForce(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n",
      "expected" : "[5,10]",
      "input" : "nums = [1,5,10,15], k = 2, x = 10",
      "slug" : "find-k-closest-elements",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-closest-elements_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findKClosestElementsOptimized(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n",
      "expected" : "[1,2,3,4]",
      "input" : "nums = [1,2,3,4,5], k = 4, x = 3",
      "slug" : "find-k-closest-elements",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-closest-elements_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findKClosestElementsOptimized(_ nums: [Int], _ k: Int, _ x: Int) -> [Int] {\n",
      "expected" : "[5,10]",
      "input" : "nums = [1,5,10,15], k = 2, x = 10",
      "slug" : "find-k-closest-elements",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized KMP (Knuth-Morris-Pratt) Algorithm",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:1: error: expected 'func' keyword in instance method declaration\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:7: error: expected parameter name followed by ':'\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func strStr(_ haystack: String, _ needle: String) -> Int { let haystack = Array(haystack), needle = Array(needle); if needle.count == 0 { return 0 } else { let lps = computeLPS(needle); var i = 0, j = 0; while i < haystack.count { if needle[j] == haystack[i] { i += 1; j += 1; if j == needle.count { return i - j } } else if j != 0 { j = lps[j-1] } else { i += 1 } }; return -1 }; func computeLPS(_ pattern: [Character]) -> [Int] { var lps = Array(repeating: 0, count: pattern.count); var length = 0; var i = 1; while i < pattern.count { if pattern[i] == pattern[length] { length += 1; lps[i] = length; i += 1 } else if length != 0 { length = lps[length-1] } else { lps[i] = 0; i += 1 } }; return lps }\n  5 | }\n    :\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:222:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n220 | }\n221 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n222 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n223 | let args = parseArgs(from: input, expectedCount: 2)\n224 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:223:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n221 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n222 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n223 | let args = parseArgs(from: input, expectedCount: 2)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n224 | let hasInput = !args.isEmpty\n225 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:227:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n225 | let solution = Solution()\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:227:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n225 | let solution = Solution()\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:228:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:228:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:229:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:1: error: expected '{' in body of function declaration\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "2",
      "input" : "haystack = \"hello\", needle = \"ll\"",
      "slug" : "find-the-index-of-the-first-occurrence-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized KMP (Knuth-Morris-Pratt) Algorithm",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:1: error: expected 'func' keyword in instance method declaration\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:7: error: expected parameter name followed by ':'\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func strStr(_ haystack: String, _ needle: String) -> Int { let haystack = Array(haystack), needle = Array(needle); if needle.count == 0 { return 0 } else { let lps = computeLPS(needle); var i = 0, j = 0; while i < haystack.count { if needle[j] == haystack[i] { i += 1; j += 1; if j == needle.count { return i - j } } else if j != 0 { j = lps[j-1] } else { i += 1 } }; return -1 }; func computeLPS(_ pattern: [Character]) -> [Int] { var lps = Array(repeating: 0, count: pattern.count); var length = 0; var i = 1; while i < pattern.count { if pattern[i] == pattern[length] { length += 1; lps[i] = length; i += 1 } else if length != 0 { length = lps[length-1] } else { lps[i] = 0; i += 1 } }; return lps }\n  5 | }\n    :\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:222:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n220 | }\n221 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n222 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n223 | let args = parseArgs(from: input, expectedCount: 2)\n224 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:223:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n221 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n222 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n223 | let args = parseArgs(from: input, expectedCount: 2)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n224 | let hasInput = !args.isEmpty\n225 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:227:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n225 | let solution = Solution()\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:227:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n225 | let solution = Solution()\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:228:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:228:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n226 | \n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:229:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n227 | let arg0 = toString(valueAt(args, 0))\n228 | let arg1 = toString(valueAt(args, 1))\n229 | let result = solution.strStr(arg0, arg1)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-index-of-the-first-occurrence-in-a-string_2\/solution.swift:231:1: error: expected '{' in body of function declaration\n229 | let result = solution.strStr(arg0, arg1)\n230 | let output: Any = result\n231 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "0",
      "input" : "haystack = \"abcabc\", needle = \"abc\"",
      "slug" : "find-the-index-of-the-first-occurrence-in-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_1\/solution.swift:4:295: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { var left = 0; var right = result[i].count - 1; while left <= right { if result[i][left] == result[i][right] { result[i][left] = 1 - result[i][left]; result[i][right] = 1 - result[i][right]; } left += 1; right -= 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { var left = 0; var right = result[i].count - 1; while left <= right { if result[i][left] == result[i][right] { result[i][left] = 1 - result[i][left]; result[i][right] = 1 - result[i][right]; } left += 1; right -= 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,0,0],[0,1,0],[1,1,1]]",
      "input" : "image = [[1,1,0],[1,0,1],[0,0,0]]",
      "slug" : "flipping-an-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_1\/solution.swift:4:295: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { var left = 0; var right = result[i].count - 1; while left <= right { if result[i][left] == result[i][right] { result[i][left] = 1 - result[i][left]; result[i][right] = 1 - result[i][right]; } left += 1; right -= 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { var left = 0; var right = result[i].count - 1; while left <= right { if result[i][left] == result[i][right] { result[i][left] = 1 - result[i][left]; result[i][right] = 1 - result[i][right]; } left += 1; right -= 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]",
      "input" : "image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]",
      "slug" : "flipping-an-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_2\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { for j in 0..<result[i].count\/2 { result[i].swapAt(j, result[i].count - j - 1); result[i][j] = result[i][j] ^ 1; result[i][result[i].count - j - 1] = result[i][result[i].count - j - 1] ^ 1; } if result[i].count % 2 == 1 { result[i][result[i].count\/2] = result[i][result[i].count\/2] ^ 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_2\/solution.swift:4:393: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { for j in 0..<result[i].count\/2 { result[i].swapAt(j, result[i].count - j - 1); result[i][j] = result[i][j] ^ 1; result[i][result[i].count - j - 1] = result[i][result[i].count - j - 1] ^ 1; } if result[i].count % 2 == 1 { result[i][result[i].count\/2] = result[i][result[i].count\/2] ^ 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,0,0],[0,1,0],[1,1,1]]",
      "input" : "image = [[1,1,0],[1,0,1],[0,0,0]]",
      "slug" : "flipping-an-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_2\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { for j in 0..<result[i].count\/2 { result[i].swapAt(j, result[i].count - j - 1); result[i][j] = result[i][j] ^ 1; result[i][result[i].count - j - 1] = result[i][result[i].count - j - 1] ^ 1; } if result[i].count % 2 == 1 { result[i][result[i].count\/2] = result[i][result[i].count\/2] ^ 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flipping-an-image_2\/solution.swift:4:393: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func flipAndInvertImage(_ image: [[Int]]) -> [[Int]] { var result = image; for i in 0..<result.count { for j in 0..<result[i].count\/2 { result[i].swapAt(j, result[i].count - j - 1); result[i][j] = result[i][j] ^ 1; result[i][result[i].count - j - 1] = result[i][result[i].count - j - 1] ^ 1; } if result[i].count % 2 == 1 { result[i][result[i].count\/2] = result[i][result[i].count\/2] ^ 1; } } return result; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]",
      "input" : "image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]",
      "slug" : "flipping-an-image",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friends-of-appropriate-ages_1\/solution.swift:9:23: error: cannot convert value of type 'Double' to expected argument type 'Int'\n  7 |         for j in 0..<i {\n  8 |             let ageB = ages[j]\n  9 |             if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n    |                       `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |                 count += 1\n 11 |             }\n",
      "expected" : "2",
      "input" : "ages = [16,16]",
      "slug" : "friends-of-appropriate-ages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friends-of-appropriate-ages_1\/solution.swift:9:23: error: cannot convert value of type 'Double' to expected argument type 'Int'\n  7 |         for j in 0..<i {\n  8 |             let ageB = ages[j]\n  9 |             if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n    |                       `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |                 count += 1\n 11 |             }\n",
      "expected" : "2",
      "input" : "ages = [16,17,18]",
      "slug" : "friends-of-appropriate-ages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friends-of-appropriate-ages_2\/solution.swift:12:23: error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |     for ageA in freq.keys {\n 11 |         for ageB in freq.keys {\n 12 |             if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n    |                       `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 13 |                 count += freq[ageA]! * freq[ageB]!\n 14 |             }\n",
      "expected" : "2",
      "input" : "ages = [16,16]",
      "slug" : "friends-of-appropriate-ages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friends-of-appropriate-ages_2\/solution.swift:12:23: error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |     for ageA in freq.keys {\n 11 |         for ageB in freq.keys {\n 12 |             if ageA * 0.5 + 7 <= ageB && ageB <= ageA {\n    |                       `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 13 |                 count += freq[ageA]! * freq[ageB]!\n 14 |             }\n",
      "expected" : "4",
      "input" : "ages = [13,19,9,5,15,14]",
      "slug" : "friends-of-appropriate-ages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_1\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; for house in houses { var minDistance = Int.max; for heater in heaters { minDistance = min(minDistance, abs(house - heater)); } radius = max(radius, minDistance); } return radius; }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_1\/solution.swift:4:303: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; for house in houses { var minDistance = Int.max; for heater in heaters { minDistance = min(minDistance, abs(house - heater)); } radius = max(radius, minDistance); } return radius; }\n    |                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "houses = [1,2,3], heaters = [2]",
      "slug" : "heaters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_1\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; for house in houses { var minDistance = Int.max; for heater in heaters { minDistance = min(minDistance, abs(house - heater)); } radius = max(radius, minDistance); } return radius; }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_1\/solution.swift:4:303: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; for house in houses { var minDistance = Int.max; for heater in heaters { minDistance = min(minDistance, abs(house - heater)); } radius = max(radius, minDistance); } return radius; }\n    |                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "houses = [1,2,3,4], heaters = [1,4]",
      "slug" : "heaters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_2\/solution.swift:4:319: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; var heaterIndex = 0; for house in houses { while heaterIndex + 1 < heaters.count && abs(house - heaters[heaterIndex + 1]) <= abs(house - heaters[heaterIndex]) { heaterIndex += 1; } radius = max(radius, abs(house - heaters[heaterIndex])); } return radius; }\n    |                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_2\/solution.swift:4:378: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; var heaterIndex = 0; for house in houses { while heaterIndex + 1 < heaters.count && abs(house - heaters[heaterIndex + 1]) <= abs(house - heaters[heaterIndex]) { heaterIndex += 1; } radius = max(radius, abs(house - heaters[heaterIndex])); } return radius; }\n    |                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "houses = [1,5], heaters = [2,3]",
      "slug" : "heaters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_2\/solution.swift:4:319: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; var heaterIndex = 0; for house in houses { while heaterIndex + 1 < heaters.count && abs(house - heaters[heaterIndex + 1]) <= abs(house - heaters[heaterIndex]) { heaterIndex += 1; } radius = max(radius, abs(house - heaters[heaterIndex])); } return radius; }\n    |                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/heaters_2\/solution.swift:4:378: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int { let houses = houses.sorted(); let heaters = heaters.sorted(); var radius = 0; var heaterIndex = 0; for house in houses { while heaterIndex + 1 < heaters.count && abs(house - heaters[heaterIndex + 1]) <= abs(house - heaters[heaterIndex]) { heaterIndex += 1; } radius = max(radius, abs(house - heaters[heaterIndex])); } return radius; }\n    |                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "houses = [1,2,3], heaters = [2]",
      "slug" : "heaters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[9,4]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[4,9]",
      "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
      "slug" : "intersection-of-two-arrays",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:124: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:195: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
      "input" : "A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]",
      "slug" : "interval-list-intersections",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:124: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:195: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_1\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var result: [[Int]] = [] for i in 0..<n { for j in 0..<m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } } } return result }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[5,7]]",
      "input" : "A = [[1,3],[5,7],[9,12]], B = [[5,10]]",
      "slug" : "interval-list-intersections",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:109: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:119: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:144: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:239: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:299: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
      "input" : "A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]",
      "slug" : "interval-list-intersections",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:109: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:119: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:144: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:239: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:299: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interval-list-intersections_2\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func intervalIntersection(_ A: [[Int]], _ B: [[Int]]) -> [[Int]] { let n = A.count let m = B.count var i = 0 var j = 0 var result: [[Int]] = [] while i < n && j < m { let maxStart = max(A[i][0], B[j][0]) let minEnd = min(A[i][1], B[j][1]) if maxStart <= minEnd { result.append([maxStart, minEnd]) } if A[i][1] < B[j][1] { i += 1 } else { j += 1 } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[5,7]]",
      "input" : "A = [[1,3],[5,7],[9,12]], B = [[5,10]]",
      "slug" : "interval-list-intersections",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:251: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:265: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"abc\", t = \"ahbgdc\"",
      "slug" : "is-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:251: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_1\/solution.swift:4:265: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var tIndex = 0; for char in sChars { while tIndex < tChars.count && tChars[tIndex] != char { tIndex += 1 } if tIndex == tChars.count { return false } tIndex += 1 } return true }\n    |                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "s = \"axc\", t = \"ahbgdc\"",
      "slug" : "is-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_2\/solution.swift:4:240: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var sIndex = 0; var tIndex = 0; while sIndex < sChars.count && tIndex < tChars.count { if sChars[sIndex] == tChars[tIndex] { sIndex += 1 } tIndex += 1 } return sIndex == sChars.count }\n    |                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_2\/solution.swift:4:254: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var sIndex = 0; var tIndex = 0; while sIndex < sChars.count && tIndex < tChars.count { if sChars[sIndex] == tChars[tIndex] { sIndex += 1 } tIndex += 1 } return sIndex == sChars.count }\n    |                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"abc\", t = \"ahbgdc\"",
      "slug" : "is-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_2\/solution.swift:4:240: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var sIndex = 0; var tIndex = 0; while sIndex < sChars.count && tIndex < tChars.count { if sChars[sIndex] == tChars[tIndex] { sIndex += 1 } tIndex += 1 } return sIndex == sChars.count }\n    |                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/is-subsequence_2\/solution.swift:4:254: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isSubsequence(_ s: String, _ t: String) -> Bool { let sChars = Array(s); let tChars = Array(t); var sIndex = 0; var tIndex = 0; while sIndex < sChars.count && tIndex < tChars.count { if sChars[sIndex] == tChars[tIndex] { sIndex += 1 } tIndex += 1 } return sIndex == sChars.count }\n    |                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "s = \"axc\", t = \"ahbgdc\"",
      "slug" : "is-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:181: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [3, 1, 4, 1, 5], k = 2",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:181: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "nums = [1, 2, 3, 4, 5], k = 1",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:181: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { let numSet = Set(nums); var count = 0; for num in nums { if num + k >= 0 && num + k != num, numSet.contains(num + k) { count += 1 } if num - k >= 0 && num - k != num, numSet.contains(num - k) { count += 1 } } return count \/ 2; }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "nums = [1, 3, 1, 5, 4], k = 0",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:396: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:417: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [3, 1, 4, 1, 5], k = 2",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:396: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:417: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "nums = [1, 2, 3, 4, 5], k = 1",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:396: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-diff-pairs-in-an-array_2\/solution.swift:4:417: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findPairs(_ nums: [Int], _ k: Int) -> Int { var numSet = Set<Int>(); var pairSet = Set<String>(); var count = 0; for num in nums { if num - k >= 0, numSet.contains(num - k), !pairSet.contains(\"(num - k),(num)\") { pairSet.insert(\"(num - k),(num)\"); count += 1 } if num + k >= 0, numSet.contains(num + k), !pairSet.contains(\"(num),(num + k)\") { pairSet.insert(\"(num),(num + k)\"); count += 1 } numSet.insert(num) } return count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "nums = [1, 3, 1, 5, 4], k = 0",
      "slug" : "k-diff-pairs-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n",
      "expected" : "2\/5",
      "input" : "arr = [1,2,3,5], k = 3",
      "slug" : "k-th-smallest-prime-fraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n",
      "expected" : "1\/7",
      "input" : "arr = [1,7], k = 1",
      "slug" : "k-th-smallest-prime-fraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized with Min-Heap",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_2\/solution.swift:18:14: warning: immutable value 'val' was never used; consider replacing with '_' or removing it [#no-usage]\n 16 |     while !pq.isEmpty {\n 17 |         pq.sort { $0.val < $1.val }\n 18 |         let (val, i, j) = pq.removeFirst()\n    |              `- warning: immutable value 'val' was never used; consider replacing with '_' or removing it [#no-usage]\n 19 |         count += 1\n 20 |         if count == k {\n",
      "expected" : "2\/5",
      "input" : "arr = [1,2,3,5], k = 3",
      "slug" : "k-th-smallest-prime-fraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized with Min-Heap",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-smallest-prime-fraction_2\/solution.swift:18:14: warning: immutable value 'val' was never used; consider replacing with '_' or removing it [#no-usage]\n 16 |     while !pq.isEmpty {\n 17 |         pq.sort { $0.val < $1.val }\n 18 |         let (val, i, j) = pq.removeFirst()\n    |              `- warning: immutable value 'val' was never used; consider replacing with '_' or removing it [#no-usage]\n 19 |         count += 1\n 20 |         if count == k {\n",
      "expected" : "1\/7",
      "input" : "arr = [1,7], k = 1",
      "slug" : "k-th-smallest-prime-fraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"bab\"",
      "approachName" : "Expand Around Center",
      "approachOrder" : 1,
      "expected" : "\"bab\" or \"aba\"",
      "input" : "\"babad\"",
      "slug" : "longest-palindromic-substring",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-uncommon-subsequence-ii_1\/solution.swift:4:299: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLUSlength(_ strs: [String]) -> Int { let strsSet = Set(strs); var longestUncommonSubsequenceLength = -1; for str in strsSet { let isCommon = strs.allSatisfy { $0.range(of: str) != nil }; if !isCommon { longestUncommonSubsequenceLength = max(longestUncommonSubsequenceLength, str.count) } } return longestUncommonSubsequenceLength }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "strs = [\"aba\",\"cdc\",\"eae\"]",
      "slug" : "longest-uncommon-subsequence-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-uncommon-subsequence-ii_1\/solution.swift:4:299: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLUSlength(_ strs: [String]) -> Int { let strsSet = Set(strs); var longestUncommonSubsequenceLength = -1; for str in strsSet { let isCommon = strs.allSatisfy { $0.range(of: str) != nil }; if !isCommon { longestUncommonSubsequenceLength = max(longestUncommonSubsequenceLength, str.count) } } return longestUncommonSubsequenceLength }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "-1",
      "input" : "strs = [\"aaa\",\"aaa\",\"aa\"]",
      "slug" : "longest-uncommon-subsequence-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-uncommon-subsequence-ii_2\/solution.swift:4:291: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLUSlength(_ strs: [String]) -> Int { let sortedStrs = strs.sorted(by: { $0.count > $1.count }); for (index, str) in sortedStrs.enumerated() { let isCommon = (0...strs.count-1).filter { $0 != index }.allSatisfy { strs[$0].range(of: str) != nil }; if !isCommon { return str.count } } return -1 }\n    |                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "strs = [\"un\",\"iq\",\"ue\"]",
      "slug" : "longest-uncommon-subsequence-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-uncommon-subsequence-ii_2\/solution.swift:4:291: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLUSlength(_ strs: [String]) -> Int { let sortedStrs = strs.sorted(by: { $0.count > $1.count }); for (index, str) in sortedStrs.enumerated() { let isCommon = (0...strs.count-1).filter { $0 != index }.allSatisfy { strs[$0].range(of: str) != nil }; if !isCommon { return str.count } } return -1 }\n    |                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "strs = [\"abc\",\"acd\",\"bc\",\"a\",\"a\"]",
      "slug" : "longest-uncommon-subsequence-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findLongestWord(_ s: String, _ d: [String]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:12:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         var i = 0, j = 0\n 11 |         while i < s.count && j < word.count {\n 12 |             if s[i] == word[j] {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 j += 1\n 14 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:12:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         var i = 0, j = 0\n 11 |         while i < s.count && j < word.count {\n 12 |             if s[i] == word[j] {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 j += 1\n 14 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "\"apple\"",
      "input" : "s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]",
      "slug" : "longest-word-in-dictionary-through-deleting",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findLongestWord(_ s: String, _ d: [String]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:12:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         var i = 0, j = 0\n 11 |         while i < s.count && j < word.count {\n 12 |             if s[i] == word[j] {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 j += 1\n 14 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_1\/solution.swift:12:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |         var i = 0, j = 0\n 11 |         while i < s.count && j < word.count {\n 12 |             if s[i] == word[j] {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                 j += 1\n 14 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "\"a\"",
      "input" : "s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]",
      "slug" : "longest-word-in-dictionary-through-deleting",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findLongestWord(_ s: String, _ d: [String]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "\"apple\"",
      "input" : "s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]",
      "slug" : "longest-word-in-dictionary-through-deleting",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findLongestWord(_ s: String, _ d: [String]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "\"a\"",
      "input" : "s = \"abpcplea\", d = [\"a\",\"b\",\"c\"]",
      "slug" : "longest-word-in-dictionary-through-deleting",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func findLongestWord(_ s: String, _ d: [String]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary-through-deleting_2\/solution.swift:19:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |         var i = 0, j = 0\n 18 |         while i < s.count && j < word.count {\n 19 |             if s[i] == word[j] {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                 j += 1\n 21 |             }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "\"ab\"",
      "input" : "s = \"abpcplea\", d = [\"ab\",\"ale\",\"apple\",\"b\"]",
      "slug" : "longest-word-in-dictionary-through-deleting",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "3",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "n = 4",
      "slug" : "magical-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Optimized Monotonic Stack",
      "approachOrder" : 2,
      "expected" : "4",
      "input" : "nums = [6,0,8,2,1,5]",
      "slug" : "maximum-width-ramp",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "3",
      "approachName" : "Optimized Monotonic Stack",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "nums = [9,8,1,0,1,9,4,0,4,1]",
      "slug" : "maximum-width-ramp",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[0,0,0,1,2,2,3,5,6]",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "[1,2,2,3,5,6]",
      "input" : "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
      "slug" : "merge-sorted-array",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "60",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "100",
      "input" : "difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]",
      "slug" : "most-profit-assigning-work",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "11",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "10",
      "input" : "difficulty = [1,2,3], profit = [2,3,4], worker = [1,2,3,4,5]",
      "slug" : "most-profit-assigning-work",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "60",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "100",
      "input" : "difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]",
      "slug" : "most-profit-assigning-work",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (Overwrite + Fill)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/move-zeroes_1\/solution.swift:244:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let solution = Solution()\n242 | \n243 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n244 | let result = solution.moveZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n245 | let output: Any = NSNull()\n246 | print(jsonString(from: output))\n",
      "expected" : "[1,3,12,0,0]",
      "input" : "nums = [0,1,0,3,12]",
      "slug" : "move-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (Overwrite + Fill)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/move-zeroes_1\/solution.swift:244:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let solution = Solution()\n242 | \n243 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n244 | let result = solution.moveZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n245 | let output: Any = NSNull()\n246 | print(jsonString(from: output))\n",
      "expected" : "[0]",
      "input" : "nums = [0]",
      "slug" : "move-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (Swap)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/move-zeroes_2\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n237 | let solution = Solution()\n238 | \n239 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n240 | let result = solution.moveZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = NSNull()\n242 | print(jsonString(from: output))\n",
      "expected" : "[1,3,12,0,0]",
      "input" : "nums = [0,1,0,3,12]",
      "slug" : "move-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (Swap)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/move-zeroes_2\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n237 | let solution = Solution()\n238 | \n239 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n240 | let result = solution.moveZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = NSNull()\n242 | print(jsonString(from: output))\n",
      "expected" : "[1,2,3]",
      "input" : "nums = [1,2,3]",
      "slug" : "move-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (Swap)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/move-zeroes_2\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n237 | let solution = Solution()\n238 | \n239 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n240 | let result = solution.moveZeroes(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = NSNull()\n242 | print(jsonString(from: output))\n",
      "expected" : "[1,0,0]",
      "input" : "nums = [0,0,1]",
      "slug" : "move-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Linear Scan",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-permutation_1\/solution.swift:238:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n235 | let solution = Solution()\n236 | \n237 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n238 | let result = solution.nextPermutation(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n239 | let output: Any = NSNull()\n240 | print(jsonString(from: output))\n",
      "expected" : "[1,3,2]",
      "input" : "[1,2,3]",
      "slug" : "next-permutation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "1",
      "approachName" : "Optimized Sliding Window Approach",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums = [2,1,4,3], left = 2, right = 3",
      "slug" : "number-of-subarrays-with-bounded-maximum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Optimized Sliding Window Approach",
      "approachOrder" : 2,
      "expected" : "22",
      "input" : "nums = [73,55,36,5,55,14,9,7,72,52], left = 32, right = 69",
      "slug" : "number-of-subarrays-with-bounded-maximum",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:11:38: error: single-quoted string literal found, use '\"'\n  9 | \n 10 |                while i < dominoes.count {\n 11 |                    if dominoes[i] == '.' {\n    |                                      `- error: single-quoted string literal found, use '\"'\n 12 |                        i += 1\n 13 |                        continue\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:15:44: error: single-quoted string literal found, use '\"'\n 13 |                        continue\n 14 |                    }\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n    |                                            `- error: single-quoted string literal found, use '\"'\n 16 | \n 17 |                    j = i\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:63: error: single-quoted string literal found, use '\"'\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                               `- error: single-quoted string literal found, use '\"'\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:27:46: error: single-quoted string literal found, use '\"'\n 25 |                }\n 26 | \n 27 |                var result = Array(repeating: '.', count: dominoes.count)\n    |                                              `- error: single-quoted string literal found, use '\"'\n 28 | \n 29 |                for i in 0..<dominoes.count {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:11:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 | \n 10 |                while i < dominoes.count {\n 11 |                    if dominoes[i] == '.' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                        i += 1\n 13 |                        continue\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:15:29: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        continue\n 14 |                    }\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n    |                             `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 | \n 17 |                    j = i\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:17:20: error: cannot find 'j' in scope\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n 16 | \n 17 |                    j = i\n    |                    `- error: cannot find 'j' in scope\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n 19 |                        forces[j] += force\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:26: error: cannot find 'j' in scope\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                          `- error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:57: error: cannot find 'j' in scope\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                         `- error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:19:31: error: cannot find 'j' in scope\n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n 19 |                        forces[j] += force\n    |                               `- error: cannot find 'j' in scope\n 20 |                        force += (force > 0) ? -1 : 1\n 21 |                        j += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:21:24: error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n 21 |                        j += 1\n    |                        `- error: cannot find 'j' in scope\n 22 |                    }\n 23 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:24:24: error: cannot find 'j' in scope\n 22 |                    }\n 23 | \n 24 |                    i = j\n    |                        `- error: cannot find 'j' in scope\n 25 |                }\n 26 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:37:23: error: no exact matches in call to initializer \n 35 |                }\n 36 | \n 37 |                return String(result)\n    |                       `- error: no exact matches in call to initializer \n 38 |            }\n 39 |            \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "LL.RR.LL..",
      "input" : ".L.R...L..",
      "slug" : "push-dominoes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:11:38: error: single-quoted string literal found, use '\"'\n  9 | \n 10 |                while i < dominoes.count {\n 11 |                    if dominoes[i] == '.' {\n    |                                      `- error: single-quoted string literal found, use '\"'\n 12 |                        i += 1\n 13 |                        continue\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:15:44: error: single-quoted string literal found, use '\"'\n 13 |                        continue\n 14 |                    }\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n    |                                            `- error: single-quoted string literal found, use '\"'\n 16 | \n 17 |                    j = i\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:63: error: single-quoted string literal found, use '\"'\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                               `- error: single-quoted string literal found, use '\"'\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:27:46: error: single-quoted string literal found, use '\"'\n 25 |                }\n 26 | \n 27 |                var result = Array(repeating: '.', count: dominoes.count)\n    |                                              `- error: single-quoted string literal found, use '\"'\n 28 | \n 29 |                for i in 0..<dominoes.count {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:11:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 | \n 10 |                while i < dominoes.count {\n 11 |                    if dominoes[i] == '.' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                        i += 1\n 13 |                        continue\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:15:29: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        continue\n 14 |                    }\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n    |                             `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 | \n 17 |                    j = i\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:17:20: error: cannot find 'j' in scope\n 15 |                    force = (dominoes[i] == 'R') ? 1 : -1\n 16 | \n 17 |                    j = i\n    |                    `- error: cannot find 'j' in scope\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n 19 |                        forces[j] += force\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:26: error: cannot find 'j' in scope\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                          `- error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:18:57: error: cannot find 'j' in scope\n 16 | \n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                         `- error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:19:31: error: cannot find 'j' in scope\n 17 |                    j = i\n 18 |                    while j < dominoes.count && dominoes[j] == '.' {\n 19 |                        forces[j] += force\n    |                               `- error: cannot find 'j' in scope\n 20 |                        force += (force > 0) ? -1 : 1\n 21 |                        j += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:21:24: error: cannot find 'j' in scope\n 19 |                        forces[j] += force\n 20 |                        force += (force > 0) ? -1 : 1\n 21 |                        j += 1\n    |                        `- error: cannot find 'j' in scope\n 22 |                    }\n 23 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:24:24: error: cannot find 'j' in scope\n 22 |                    }\n 23 | \n 24 |                    i = j\n    |                        `- error: cannot find 'j' in scope\n 25 |                }\n 26 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_1\/solution.swift:37:23: error: no exact matches in call to initializer \n 35 |                }\n 36 | \n 37 |                return String(result)\n    |                       `- error: no exact matches in call to initializer \n 38 |            }\n 39 |            \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "RR.L",
      "input" : "RR.L",
      "slug" : "push-dominoes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:6:46: error: single-quoted string literal found, use '\"'\n  4 | \n  5 |            func pushDominoes(dominoes: String) -> String {\n  6 |                var result = Array(repeating: '.', count: dominoes.count)\n    |                                              `- error: single-quoted string literal found, use '\"'\n  7 |                var i = 0\n  8 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:10:38: error: single-quoted string literal found, use '\"'\n  8 | \n  9 |                while i < dominoes.count {\n 10 |                    if dominoes[i] == '.' {\n    |                                      `- error: single-quoted string literal found, use '\"'\n 11 |                        i += 1\n 12 |                        continue\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:63: error: single-quoted string literal found, use '\"'\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                               `- error: single-quoted string literal found, use '\"'\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:29:36: error: single-quoted string literal found, use '\"'\n 27 | \n 28 |                for i in 0..<dominoes.count {\n 29 |                    if result[i] == '.' {\n    |                                    `- error: single-quoted string literal found, use '\"'\n 30 |                        result[i] = dominoes[i]\n 31 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 | \n  9 |                while i < dominoes.count {\n 10 |                    if dominoes[i] == '.' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        i += 1\n 12 |                        continue\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:15:20: error: cannot find 'j' in scope\n 13 |                    }\n 14 | \n 15 |                    j = i\n    |                    `- error: cannot find 'j' in scope\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:26: error: cannot find 'j' in scope\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                          `- error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:57: error: cannot find 'j' in scope\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                         `- error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:17:27: error: cannot find 'j' in scope\n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n    |                           `- error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:17:36: error: cannot find 'j' in scope\n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n    |                                    `- error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:18:35: error: cannot find 'j' in scope\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n    |                                   `- error: cannot find 'j' in scope\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:18:48: error: no 'subscript' candidates produce the expected contextual result type 'String'\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n    |                                                `- error: no 'subscript' candidates produce the expected contextual result type 'String'\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          |- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n  |          `- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'ArraySlice<String>'\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:19:34: error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n    |                                  `- error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:19:42: error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n    |                                          `- error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:20:35: error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n    |                                   `- error: cannot find 'j' in scope\n 21 |                        }\n 22 |                        j += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:20:48: error: no 'subscript' candidates produce the expected contextual result type 'String'\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n    |                                                `- error: no 'subscript' candidates produce the expected contextual result type 'String'\n 21 |                        }\n 22 |                        j += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          |- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n  |          `- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'ArraySlice<String>'\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:22:24: error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n 22 |                        j += 1\n    |                        `- error: cannot find 'j' in scope\n 23 |                    }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:25:24: error: cannot find 'j' in scope\n 23 |                    }\n 24 | \n 25 |                    i = j\n    |                        `- error: cannot find 'j' in scope\n 26 |                }\n 27 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:30:44: error: cannot assign value of type 'Character' to subscript of type 'String'\n 28 |                for i in 0..<dominoes.count {\n 29 |                    if result[i] == '.' {\n 30 |                        result[i] = dominoes[i]\n    |                                            `- error: cannot assign value of type 'Character' to subscript of type 'String'\n 31 |                    }\n 32 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:34:23: error: no exact matches in call to initializer \n 32 |                }\n 33 | \n 34 |                return String(result)\n    |                       `- error: no exact matches in call to initializer \n 35 |            }\n 36 |            \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "LL.RR.LL..",
      "input" : ".L.R...L..",
      "slug" : "push-dominoes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:6:46: error: single-quoted string literal found, use '\"'\n  4 | \n  5 |            func pushDominoes(dominoes: String) -> String {\n  6 |                var result = Array(repeating: '.', count: dominoes.count)\n    |                                              `- error: single-quoted string literal found, use '\"'\n  7 |                var i = 0\n  8 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:10:38: error: single-quoted string literal found, use '\"'\n  8 | \n  9 |                while i < dominoes.count {\n 10 |                    if dominoes[i] == '.' {\n    |                                      `- error: single-quoted string literal found, use '\"'\n 11 |                        i += 1\n 12 |                        continue\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:63: error: single-quoted string literal found, use '\"'\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                               `- error: single-quoted string literal found, use '\"'\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:29:36: error: single-quoted string literal found, use '\"'\n 27 | \n 28 |                for i in 0..<dominoes.count {\n 29 |                    if result[i] == '.' {\n    |                                    `- error: single-quoted string literal found, use '\"'\n 30 |                        result[i] = dominoes[i]\n 31 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 | \n  9 |                while i < dominoes.count {\n 10 |                    if dominoes[i] == '.' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        i += 1\n 12 |                        continue\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:15:20: error: cannot find 'j' in scope\n 13 |                    }\n 14 | \n 15 |                    j = i\n    |                    `- error: cannot find 'j' in scope\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:26: error: cannot find 'j' in scope\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                          `- error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:16:57: error: cannot find 'j' in scope\n 14 | \n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n    |                                                         `- error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:17:27: error: cannot find 'j' in scope\n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n    |                           `- error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:17:36: error: cannot find 'j' in scope\n 15 |                    j = i\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n    |                                    `- error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:18:35: error: cannot find 'j' in scope\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n    |                                   `- error: cannot find 'j' in scope\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:18:48: error: no 'subscript' candidates produce the expected contextual result type 'String'\n 16 |                    while j < dominoes.count && dominoes[j] == '.' {\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n    |                                                `- error: no 'subscript' candidates produce the expected contextual result type 'String'\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          |- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n  |          `- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'ArraySlice<String>'\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:19:34: error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n    |                                  `- error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:19:42: error: cannot find 'j' in scope\n 17 |                        if j - i == j - dominoes.count + 1 {\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n    |                                          `- error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:20:35: error: cannot find 'j' in scope\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n    |                                   `- error: cannot find 'j' in scope\n 21 |                        }\n 22 |                        j += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:20:48: error: no 'subscript' candidates produce the expected contextual result type 'String'\n 18 |                            result[j] = dominoes[i]\n 19 |                        } else if j - i < j - dominoes.count + 1 {\n 20 |                            result[j] = dominoes[i]\n    |                                                `- error: no 'subscript' candidates produce the expected contextual result type 'String'\n 21 |                        }\n 22 |                        j += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          |- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'String'\n  |          `- note: 'subscript(_:)' produces 'Character', not the expected contextual result type 'ArraySlice<String>'\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:22:24: error: cannot find 'j' in scope\n 20 |                            result[j] = dominoes[i]\n 21 |                        }\n 22 |                        j += 1\n    |                        `- error: cannot find 'j' in scope\n 23 |                    }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:25:24: error: cannot find 'j' in scope\n 23 |                    }\n 24 | \n 25 |                    i = j\n    |                        `- error: cannot find 'j' in scope\n 26 |                }\n 27 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:30:44: error: cannot assign value of type 'Character' to subscript of type 'String'\n 28 |                for i in 0..<dominoes.count {\n 29 |                    if result[i] == '.' {\n 30 |                        result[i] = dominoes[i]\n    |                                            `- error: cannot assign value of type 'Character' to subscript of type 'String'\n 31 |                    }\n 32 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/push-dominoes_2\/solution.swift:34:23: error: no exact matches in call to initializer \n 32 |                }\n 33 | \n 34 |                return String(result)\n    |                       `- error: no exact matches in call to initializer \n 35 |            }\n 36 |            \n\nSwift.String.init:2:8: note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'String' and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "RR.L",
      "input" : "RR.L",
      "slug" : "push-dominoes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (In-Place)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_1\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "2, nums = [1,2,_]",
      "input" : "nums = [1,1,2]",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (In-Place)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_1\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "5, nums = [0,1,2,3,4,_,_,_,_,_]",
      "input" : "nums = [0,0,1,1,1,2,2,3,3,4]",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (In-Place)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_1\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "1, nums = [1]",
      "input" : "nums = [1]",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Two Pointers (Compare with Write Position)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_2\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "2, nums = [1,2,_]",
      "input" : "nums = [1,1,2]",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (Compare with Write Position)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_2\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "0",
      "input" : "nums = []",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (Compare with Write Position)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array_2\/solution.swift:241:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n238 | let solution = Solution()\n239 | \n240 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n241 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "3, nums = [1,2,3]",
      "input" : "nums = [1,2,3]",
      "slug" : "remove-duplicates-from-sorted-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array-ii_1\/solution.swift:246:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n243 | let solution = Solution()\n244 | \n245 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n246 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n247 | let output: Any = result\n248 | print(jsonString(from: output))\n",
      "expected" : "5",
      "input" : "nums = [1,1,1,2,2,3]",
      "slug" : "remove-duplicates-from-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array-ii_1\/solution.swift:246:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n243 | let solution = Solution()\n244 | \n245 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n246 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n247 | let output: Any = result\n248 | print(jsonString(from: output))\n",
      "expected" : "7",
      "input" : "nums = [0,0,1,1,1,1,2,3,3]",
      "slug" : "remove-duplicates-from-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array-ii_2\/solution.swift:242:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n239 | let solution = Solution()\n240 | \n241 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n242 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n243 | let output: Any = result\n244 | print(jsonString(from: output))\n",
      "expected" : "5",
      "input" : "nums = [1,1,1,2,2,3]",
      "slug" : "remove-duplicates-from-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-array-ii_2\/solution.swift:242:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n239 | let solution = Solution()\n240 | \n241 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n242 | let result = solution.removeDuplicates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n243 | let output: Any = result\n244 | print(jsonString(from: output))\n",
      "expected" : "7",
      "input" : "nums = [0,0,1,1,1,1,2,3,3]",
      "slug" : "remove-duplicates-from-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-element_1\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n236 | let solution = Solution()\n237 | \n238 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.removeElement(arg0, arg1)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = result\n242 | print(jsonString(from: output))\n",
      "expected" : "4",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "remove-element",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-element_1\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n236 | let solution = Solution()\n237 | \n238 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.removeElement(arg0, arg1)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = result\n242 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "nums = [3,2,2,3], target = 3",
      "slug" : "remove-element",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-element_2\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n236 | let solution = Solution()\n237 | \n238 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.removeElement(arg0, arg1)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = result\n242 | print(jsonString(from: output))\n",
      "expected" : "4",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "remove-element",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-element_2\/solution.swift:240:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n236 | let solution = Solution()\n237 | \n238 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n239 | let arg1 = toInt(valueAt(args, 1))\n240 | let result = solution.removeElement(arg0, arg1)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n241 | let output: Any = result\n242 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "nums = [3,2,2,3], target = 3",
      "slug" : "remove-element",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"dc-ba\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "dc-ba",
      "input" : "ab-cd",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"a-bC-ba\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "a-bc-ba",
      "input" : "a-bC-ba",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"7_28]\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "7_28]",
      "input" : "7_28]",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "\"dc-ba\"",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "dc-ba",
      "input" : "ab-cd",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"a-bC-ba\"",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "a-bc-ba",
      "input" : "a-bC-ba",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"7_28]\"",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "7_28]",
      "input" : "7_28]",
      "slug" : "reverse-only-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "\"badcfeg\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"bacdfeg\"",
      "input" : "s = \"abcdefg\", k = 2",
      "slug" : "reverse-string-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"badc\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"bacd\"",
      "input" : "s = \"abcd\", k = 2",
      "slug" : "reverse-string-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"bacddceffegg\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"bacdfeg\"",
      "input" : "s = \"abcdefg\", k = 2",
      "slug" : "reverse-string-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"bacddc\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"bacd\"",
      "input" : "s = \"abcd\", k = 2",
      "slug" : "reverse-string-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-vowels-of-a-string_1\/solution.swift:4:416: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"holle\"",
      "input" : "s = \"hello\"",
      "slug" : "reverse-vowels-of-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-vowels-of-a-string_1\/solution.swift:4:416: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"uoiea\"",
      "input" : "s = \"aeiou\"",
      "slug" : "reverse-vowels-of-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two-Pointer Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-vowels-of-a-string_2\/solution.swift:4:416: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"leotcede\"",
      "input" : "s = \"leetcode\"",
      "slug" : "reverse-vowels-of-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two-Pointer Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-vowels-of-a-string_2\/solution.swift:4:416: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseVowels(_ s: String) -> String { let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; var chars = Array(s); var left = 0; var right = chars.count - 1; while left < right { if !vowels.contains(chars[left]) { left += 1 } else if !vowels.contains(chars[right]) { right -= 1 } else { let temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left += 1; right -= 1; } } return String(chars) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"racecar\"",
      "input" : "s = \"racecar\"",
      "slug" : "reverse-vowels-of-a-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\" world! hello  \"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"world! hello\"",
      "input" : "s = \"  hello world! \"",
      "slug" : "reverse-words-in-a-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"example   good a\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"example good a\"",
      "input" : "s = \"a good   example\"",
      "slug" : "reverse-words-in-a-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"example   good a\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"example good a\"",
      "input" : "s = \"a good   example\"",
      "slug" : "reverse-words-in-a-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-words-in-a-string-iii_1\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseWords(_ s: String) -> String { let words = s.components(separatedBy: \" \"); var result = \"\"; for i in 0..<words.count { let word = String(words[i].reversed()); result += word; if i < words.count - 1 { result += \" \" } } return result }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"s'Let ekat edoCteeL tsetnoc\"",
      "input" : "s = \"Let's take LeetCode contest\"",
      "slug" : "reverse-words-in-a-string-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reverse-words-in-a-string-iii_1\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func reverseWords(_ s: String) -> String { let words = s.components(separatedBy: \" \"); var result = \"\"; for i in 0..<words.count { let word = String(words[i].reversed()); result += word; if i < words.count - 1 { result += \" \" } } return result }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "\"doG gniD\"",
      "input" : "s = \"God ding\"",
      "slug" : "reverse-words-in-a-string-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"s'teL ekat edoCteeL tsetnoc\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"s'Let ekat edoCteeL tsetnoc\"",
      "input" : "s = \"Let's take LeetCode contest\"",
      "slug" : "reverse-words-in-a-string-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"doG gnid\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"doG gniD\"",
      "input" : "s = \"God ding\"",
      "slug" : "reverse-words-in-a-string-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Three Reverses",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-array_1\/solution.swift:244:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n240 | let solution = Solution()\n241 | \n242 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n243 | let arg1 = toInt(valueAt(args, 1))\n244 | let result = solution.rotate(arg0, arg1)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n245 | let output: Any = NSNull()\n246 | print(jsonString(from: output))\n",
      "expected" : "[5,6,7,1,2,3,4]",
      "input" : "nums = [1,2,3,4,5,6,7], k = 3",
      "slug" : "rotate-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807]",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "[3,2,1,0,1,0,0,1,2,2,1,0]",
      "input" : "s = \"loveleetcode\", c = 'e'",
      "slug" : "shortest-distance-to-a-character",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807]",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "[3,2,1,0,0,0]",
      "input" : "s = \"aaabbb\", c = 'b'",
      "slug" : "shortest-distance-to-a-character",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807]",
      "approachName" : "Two-Pass",
      "approachOrder" : 2,
      "expected" : "[3,2,1,0,1,0,0,1,2,2,1,0]",
      "input" : "s = \"loveleetcode\", c = 'e'",
      "slug" : "shortest-distance-to-a-character",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807,9223372036854775807]",
      "approachName" : "Two-Pass",
      "approachOrder" : 2,
      "expected" : "[3,2,1,0,0,0]",
      "input" : "s = \"aaabbb\", c = 'b'",
      "slug" : "shortest-distance-to-a-character",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "0",
      "input" : "nums = [1,2,3,4]",
      "slug" : "shortest-unsorted-continuous-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[2,4,3,1]",
      "input" : "nums = [3,1,2,4]",
      "slug" : "sort-array-by-parity",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[0]",
      "input" : "nums = [0]",
      "slug" : "sort-array-by-parity",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "expected" : "[2,4,3,1]",
      "input" : "nums = [3,1,2,4]",
      "slug" : "sort-array-by-parity",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Two Pointers Approach",
      "approachOrder" : 2,
      "expected" : "[0]",
      "input" : "nums = [0]",
      "slug" : "sort-array-by-parity",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[2,7,9,1]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[2,9,7,1]",
      "input" : "nums = [2,7,9,1]",
      "slug" : "sort-array-by-parity-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[4,2,5,7]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[4,5,2,7]",
      "input" : "nums = [4,2,5,7]",
      "slug" : "sort-array-by-parity-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[2,7,9,1]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[2,9,7,1]",
      "input" : "nums = [2,7,9,1]",
      "slug" : "sort-array-by-parity-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Dutch National Flag (3 Pointers)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-colors_1\/solution.swift:249:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n246 | let solution = Solution()\n247 | \n248 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n249 | let result = solution.sortColors(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n250 | let output: Any = NSNull()\n251 | print(jsonString(from: output))\n",
      "expected" : "[0,0,1,1,2,2]",
      "input" : "nums = [2,0,2,1,1,0]",
      "slug" : "sort-colors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dutch National Flag (3 Pointers)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-colors_1\/solution.swift:249:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n246 | let solution = Solution()\n247 | \n248 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n249 | let result = solution.sortColors(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n250 | let output: Any = NSNull()\n251 | print(jsonString(from: output))\n",
      "expected" : "[0,1,2]",
      "input" : "nums = [2,0,1]",
      "slug" : "sort-colors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dutch National Flag (3 Pointers)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-colors_1\/solution.swift:249:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n246 | let solution = Solution()\n247 | \n248 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n249 | let result = solution.sortColors(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n250 | let output: Any = NSNull()\n251 | print(jsonString(from: output))\n",
      "expected" : "[0]",
      "input" : "nums = [0]",
      "slug" : "sort-colors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Counting Sort",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-colors_2\/solution.swift:242:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n239 | let solution = Solution()\n240 | \n241 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n242 | let result = solution.sortColors(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n243 | let output: Any = NSNull()\n244 | print(jsonString(from: output))\n",
      "expected" : "[0,0,1,1,2,2]",
      "input" : "nums = [2,0,2,1,1,0]",
      "slug" : "sort-colors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_1\/solution.swift:251:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n248 | let solution = Solution()\n249 | \n250 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n251 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n",
      "expected" : "4",
      "input" : "['a', 'a', 'b', 'b', 'c', 'c', 'c']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_1\/solution.swift:251:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n248 | let solution = Solution()\n249 | \n250 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n251 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "['a']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_1\/solution.swift:251:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n248 | let solution = Solution()\n249 | \n250 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n251 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "['a', 'b', 'c']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_2\/solution.swift:252:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n249 | let solution = Solution()\n250 | \n251 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n252 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n",
      "expected" : "6",
      "input" : "['a', 'a', 'b', 'b', 'c', 'c', 'c']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_2\/solution.swift:252:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n249 | let solution = Solution()\n250 | \n251 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n252 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "['a']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Two Pointer Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-compression_2\/solution.swift:252:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n249 | let solution = Solution()\n250 | \n251 | let arg0 = toArray(valueAt(args, 0)) { toCharacter($0) }\n    | `- note: change 'let' to 'var' to make it mutable\n252 | let result = solution.compress(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "['a', 'b', 'c']",
      "slug" : "string-compression",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_1\/solution.swift:4:602: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { let s1 = Array(start); let s2 = Array(end); var i = 0; var j = 0; while i < s1.count && j < s2.count { if s1[i] == s2[j] { i += 1; j += 1 } else if s1[i] == \"L\" && s2[j] == \"R\" { return false } else if s1[i] == \"R\" && s2[j] == \"L\" { if j + 1 < s2.count && s2[j + 1] == \"L\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"L\" { i += 1 } else if s1[i] == \"R\" && s2[j] == \"X\" { if j + 1 < s2.count && s2[j + 1] == \"R\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"R\" { i += 1 } else { return false } } return i == s1.count && j == s2.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "True",
      "input" : "start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"",
      "slug" : "swap-adjacent-in-lr-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_1\/solution.swift:4:602: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { let s1 = Array(start); let s2 = Array(end); var i = 0; var j = 0; while i < s1.count && j < s2.count { if s1[i] == s2[j] { i += 1; j += 1 } else if s1[i] == \"L\" && s2[j] == \"R\" { return false } else if s1[i] == \"R\" && s2[j] == \"L\" { if j + 1 < s2.count && s2[j + 1] == \"L\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"L\" { i += 1 } else if s1[i] == \"R\" && s2[j] == \"X\" { if j + 1 < s2.count && s2[j + 1] == \"R\" { j += 1 } else { return false } } else if s1[i] == \"X\" && s2[j] == \"R\" { i += 1 } else { return false } } return i == s1.count && j == s2.count }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "False",
      "input" : "start = \"LLR\", end = \"RLL\"",
      "slug" : "swap-adjacent-in-lr-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:216: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:301: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:355: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:410: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:527: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:686: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:703: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "True",
      "input" : "start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"",
      "slug" : "swap-adjacent-in-lr-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:216: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:301: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:355: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:410: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:527: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:686: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/swap-adjacent-in-lr-string_2\/solution.swift:4:703: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func canTransform(_ start: String, _ end: String) -> Bool { var i = 0; var j = 0; while i < start.count && j < end.count { while i < start.count && start[start.index(start.startIndex, offsetBy: i)] == \"X\" { i += 1 } while j < end.count && end[end.index(end.startIndex, offsetBy: j)] == \"X\" { j += 1 } if i == start.count && j == end.count { return true } if i == start.count || j == end.count { return false } if start[start.index(start.startIndex, offsetBy: i)] != end[end.index(end.startIndex, offsetBy: j)] { return false } if (start[start.index(start.startIndex, offsetBy: i)] == \"L\" && i < j) || (start[start.index(start.startIndex, offsetBy: i)] == \"R\" && i > j) { return false } i += 1; j += 1 } return true }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "False",
      "input" : "start = \"LLR\", end = \"RLL\"",
      "slug" : "swap-adjacent-in-lr-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[0,1]",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "two-sum-ii-input-array-is-sorted",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[0,1]",
      "input" : "nums = [2,3,4], target = 6",
      "slug" : "two-sum-ii-input-array-is-sorted",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[0,1]",
      "input" : "nums = [2,7,11,15], target = 9",
      "slug" : "two-sum-ii-input-array-is-sorted",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "[0,2]",
      "input" : "nums = [2,3,4], target = 6",
      "slug" : "two-sum-ii-input-array-is-sorted",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:12:13: error: missing argument label 'node:' in call\n 10 |         }\n 11 |         values.insert(node!.val)\n 12 |         dfs(node!.left)\n    |             `- error: missing argument label 'node:' in call\n 13 |         dfs(node!.right)\n 14 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:13:13: error: missing argument label 'node:' in call\n 11 |         values.insert(node!.val)\n 12 |         dfs(node!.left)\n 13 |         dfs(node!.right)\n    |             `- error: missing argument label 'node:' in call\n 14 |     }\n 15 |     dfs(root)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:15:9: error: missing argument label 'node:' in call\n 13 |         dfs(node!.right)\n 14 |     }\n 15 |     dfs(root)\n    |         `- error: missing argument label 'node:' in call\n 16 |     for value in values {\n 17 |         if values.contains(target - value) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:230:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n",
      "expected" : "true",
      "input" : "root = [5,3,6,2,4,null,7], target = 9",
      "slug" : "two-sum-iv-input-is-a-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:12:13: error: missing argument label 'node:' in call\n 10 |         }\n 11 |         values.insert(node!.val)\n 12 |         dfs(node!.left)\n    |             `- error: missing argument label 'node:' in call\n 13 |         dfs(node!.right)\n 14 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:13:13: error: missing argument label 'node:' in call\n 11 |         values.insert(node!.val)\n 12 |         dfs(node!.left)\n 13 |         dfs(node!.right)\n    |             `- error: missing argument label 'node:' in call\n 14 |     }\n 15 |     dfs(root)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:15:9: error: missing argument label 'node:' in call\n 13 |         dfs(node!.right)\n 14 |     }\n 15 |     dfs(root)\n    |         `- error: missing argument label 'node:' in call\n 16 |     for value in values {\n 17 |         if values.contains(target - value) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_1\/solution.swift:230:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n",
      "expected" : "false",
      "input" : "root = [5,3,6,2,4,null,7], target = 28",
      "slug" : "two-sum-iv-input-is-a-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:16:13: error: missing argument label 'node:' in call\n 14 |         }\n 15 |         values.insert(node!.val)\n 16 |         dfs(node!.left)\n    |             `- error: missing argument label 'node:' in call\n 17 |         dfs(node!.right)\n 18 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:17:13: error: missing argument label 'node:' in call\n 15 |         values.insert(node!.val)\n 16 |         dfs(node!.left)\n 17 |         dfs(node!.right)\n    |             `- error: missing argument label 'node:' in call\n 18 |     }\n 19 |     dfs(root)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:19:9: error: missing argument label 'node:' in call\n 17 |         dfs(node!.right)\n 18 |     }\n 19 |     dfs(root)\n    |         `- error: missing argument label 'node:' in call\n 20 |     return result\n 21 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:228:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n226 | func toTreeNode(_ value: Any) -> TreeNode? {\n227 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n228 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n229 |         if item is NSNull { return nil }\n230 |         return TreeNode(toInt(item))\n",
      "expected" : "true",
      "input" : "root = [5,3,6,2,4,null,7], target = 9",
      "slug" : "two-sum-iv-input-is-a-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:16:13: error: missing argument label 'node:' in call\n 14 |         }\n 15 |         values.insert(node!.val)\n 16 |         dfs(node!.left)\n    |             `- error: missing argument label 'node:' in call\n 17 |         dfs(node!.right)\n 18 |     }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:17:13: error: missing argument label 'node:' in call\n 15 |         values.insert(node!.val)\n 16 |         dfs(node!.left)\n 17 |         dfs(node!.right)\n    |             `- error: missing argument label 'node:' in call\n 18 |     }\n 19 |     dfs(root)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:19:9: error: missing argument label 'node:' in call\n 17 |         dfs(node!.right)\n 18 |     }\n 19 |     dfs(root)\n    |         `- error: missing argument label 'node:' in call\n 20 |     return result\n 21 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/two-sum-iv-input-is-a-bst_2\/solution.swift:228:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n226 | func toTreeNode(_ value: Any) -> TreeNode? {\n227 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n228 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n229 |         if item is NSNull { return nil }\n230 |         return TreeNode(toInt(item))\n",
      "expected" : "false",
      "input" : "root = [5,3,6,2,4,null,7], target = 28",
      "slug" : "two-sum-iv-input-is-a-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_1\/solution.swift:4:194: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var result = false; for i in 0..<str.count { var temp = str; temp.remove(at: i); if isPalindrome(temp) { result = true; break } } return result || isPalindrome(str); func isPalindrome(_ str: [Character]) -> Bool { let str = String(str); return String(str.reversed()) == str } }\n    |                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"aba\"",
      "slug" : "valid-palindrome-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_1\/solution.swift:4:194: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var result = false; for i in 0..<str.count { var temp = str; temp.remove(at: i); if isPalindrome(temp) { result = true; break } } return result || isPalindrome(str); func isPalindrome(_ str: [Character]) -> Bool { let str = String(str); return String(str.reversed()) == str } }\n    |                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"abca\"",
      "slug" : "valid-palindrome-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:237: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:261: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:450: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"aba\"",
      "slug" : "valid-palindrome-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:237: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:261: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:450: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-palindrome-ii_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func validPalindrome(_ s: String) -> Bool { let str = Array(s); var left = 0; var right = str.count - 1; while left < right { if str[left] != str[right] { return isPalindrome(str, left + 1, right) || isPalindrome(str, left, right - 1) } left += 1; right -= 1 } return true; func isPalindrome(_ str: [Character], _ left: Int, _ right: Int) -> Bool { var left = left; var right = right; while left < right { if str[left] != str[right] { return false } left += 1; right -= 1 } return true } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = \"abca\"",
      "slug" : "valid-palindrome-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "4",
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums = [2,2,3,4]",
      "slug" : "valid-triangle-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:246: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "5",
      "input" : "nums = [1,3,2,2,5,2,3,7]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:246: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [1,2,3,4]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_1\/solution.swift:4:246: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { var maxLen = 0; for i in 0..<nums.count { for j in i..<nums.count { var minNum = Int.max, maxNum = Int.min; for k in i...j { if nums[k] < minNum { minNum = nums[k] } if nums[k] > maxNum { maxNum = nums[k] } } if maxNum - minNum == 1 { maxLen = max(maxLen, j - i + 1) } } }; return maxLen }\n    |                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "nums = [1,1,1,1]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:61: error: cannot find 'grouping' in scope\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                             `- error: cannot find 'grouping' in scope\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:50: error: generic parameter 'Key' could not be inferred\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                  |- error: generic parameter 'Key' could not be inferred\n    |                                                  `- note: explicitly specify the generic arguments to fix this issue\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:6:92: error: cannot convert value of type 'String' to expected argument type 'Int'\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n    |                                                                                            `- error: cannot convert value of type 'String' to expected argument type 'Int'\n  7 | return maxLen }\n  8 | }\n",
      "expected" : "5",
      "input" : "nums = [1,3,2,2,5,2,3,7]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:61: error: cannot find 'grouping' in scope\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                             `- error: cannot find 'grouping' in scope\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:50: error: generic parameter 'Key' could not be inferred\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                  |- error: generic parameter 'Key' could not be inferred\n    |                                                  `- note: explicitly specify the generic arguments to fix this issue\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:6:92: error: cannot convert value of type 'String' to expected argument type 'Int'\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n    |                                                                                            `- error: cannot convert value of type 'String' to expected argument type 'Int'\n  7 | return maxLen }\n  8 | }\n",
      "expected" : "2",
      "input" : "nums = [1,2,3,4]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:61: error: cannot find 'grouping' in scope\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                             `- error: cannot find 'grouping' in scope\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:4:50: error: generic parameter 'Key' could not be inferred\n  2 | \n  3 | class Solution {\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n    |                                                  |- error: generic parameter 'Key' could not be inferred\n    |                                                  `- note: explicitly specify the generic arguments to fix this issue\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-harmonious-subsequence_2\/solution.swift:6:92: error: cannot convert value of type 'String' to expected argument type 'Int'\n  4 | func findLHS(_ nums: [Int]) -> Int { let count = Dictionary\/grouping(by: { $0 })\n  5 | var maxLen = 0\n  6 | for (num, freq) in count { if let freqPlusOne = count[num + 1] { maxLen = max(maxLen, freq + freqPlusOne) } }\n    |                                                                                            `- error: cannot convert value of type 'String' to expected argument type 'Int'\n  7 | return maxLen }\n  8 | }\n",
      "expected" : "0",
      "input" : "nums = [1,1,1,1]",
      "slug" : "longest-harmonious-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Divide and Conquer",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:298: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                          |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                                                                                                                                                                                                          |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:490: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:938: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:986: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:1129: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n",
      "expected" : "\"aa\"",
      "input" : "s = \"aa\", k = 1",
      "slug" : "longest-substring-with-at-least-k-repeating-characters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Divide and Conquer",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:298: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                          |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                                                                                                                                                                                                          |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:490: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:938: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:986: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-substring-with-at-least-k-repeating-characters_2\/solution.swift:3:1129: error: cannot call value of non-function type 'String'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func longestSubstring(_ s: String, _ k: Int) -> String { let sArray = Array(s); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; var splitIndex = -1; for i in 0..<sArray.count { if charFrequency[sArray[i]] < k { splitIndex = i; break } }; if splitIndex == -1 { return String(sArray) }; var longestSubstring = \"\"; for i in 0..<sArray.count { if i > splitIndex { break }; let substring = longestSubstring(String(sArray[0...i]), k); if substring.count > longestSubstring.count { longestSubstring = substring } }; return longestSubstring }; func longestSubstring(_ sArray: [Character], _ k: Int) -> String { var longestSubstring = \"\"; let s = String(sArray); var charFrequency = [Character:Int](); for char in sArray { charFrequency[char, default: 0] += 1 }; if sArray.count < k { return \"\" }; for i in 0..<sArray.count { if charFrequency[sArray[i]] >= k { continue }; let substring1 = longestSubstring(Array(s.dropFirst(i+1)), k); if substring1.count > longestSubstring.count { longestSubstring = substring1 }; let substring2 = longestSubstring(Array(s.dropLast(sArray.count - i)), k); if substring2.count > longestSubstring.count { longestSubstring = substring2 } }; return longestSubstring } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: cannot call value of non-function type 'String'\n  4 | \n  5 | \n",
      "expected" : "\"ababb\"",
      "input" : "s = \"ababbc\", k = 2",
      "slug" : "longest-substring-with-at-least-k-repeating-characters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "5.0",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "5",
      "input" : "nums = [5], k = 1",
      "slug" : "maximum-average-subarray-i",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5.0",
      "approachName" : "Sliding Window",
      "approachOrder" : 2,
      "expected" : "5",
      "input" : "nums = [5], k = 1",
      "slug" : "maximum-average-subarray-i",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "8",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "27",
      "input" : "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
      "slug" : "baseball-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "15",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "30",
      "input" : "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
      "slug" : "baseball-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "8",
      "approachName" : "Optimized Stack Approach",
      "approachOrder" : 2,
      "expected" : "27",
      "input" : "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
      "slug" : "baseball-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "15",
      "approachName" : "Optimized Stack Approach",
      "approachOrder" : 2,
      "expected" : "30",
      "input" : "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
      "slug" : "baseball-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:243:34: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:261:30: error: cannot find type 'TreeNode' in scope\n259 | }\n260 | \n261 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:299:23: error: value of type 'Solution' has no member 'inOrderTraversal'\n297 | \n298 | let arg0 = toTreeNode(valueAt(args, 0))\n299 | let result = solution.inOrderTraversal(arg0)\n    |                       `- error: value of type 'Solution' has no member 'inOrderTraversal'\n300 | let output: Any = NSNull()\n301 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:245:17: error: cannot find type 'TreeNode' in scope\n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n246 |         if item is NSNull { return nil }\n247 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:264:17: error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n264 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n265 |     while !queue.isEmpty {\n266 |         let node = queue.removeFirst()\n",
      "expected" : "3",
      "input" : "root = [7,3,15,9,20], next()",
      "slug" : "binary-search-tree-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:243:34: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:261:30: error: cannot find type 'TreeNode' in scope\n259 | }\n260 | \n261 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:299:23: error: value of type 'Solution' has no member 'inOrderTraversal'\n297 | \n298 | let arg0 = toTreeNode(valueAt(args, 0))\n299 | let result = solution.inOrderTraversal(arg0)\n    |                       `- error: value of type 'Solution' has no member 'inOrderTraversal'\n300 | let output: Any = NSNull()\n301 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:245:17: error: cannot find type 'TreeNode' in scope\n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n246 |         if item is NSNull { return nil }\n247 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_1\/solution.swift:264:17: error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n264 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n265 |     while !queue.isEmpty {\n266 |         let node = queue.removeFirst()\n",
      "expected" : "3",
      "input" : "root = [7,3,15,9,20], next()",
      "slug" : "binary-search-tree-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:243:34: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:261:30: error: cannot find type 'TreeNode' in scope\n259 | }\n260 | \n261 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:299:23: error: value of type 'Solution' has no member 'pushLeft'\n297 | \n298 | let arg0 = toTreeNode(valueAt(args, 0))\n299 | let result = solution.pushLeft(arg0)\n    |                       `- error: value of type 'Solution' has no member 'pushLeft'\n300 | let output: Any = NSNull()\n301 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:245:17: error: cannot find type 'TreeNode' in scope\n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n246 |         if item is NSNull { return nil }\n247 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:264:17: error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n264 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n265 |     while !queue.isEmpty {\n266 |         let node = queue.removeFirst()\n",
      "expected" : "3",
      "input" : "root = [7,3,15,9,20], next()",
      "slug" : "binary-search-tree-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:243:34: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:261:30: error: cannot find type 'TreeNode' in scope\n259 | }\n260 | \n261 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:299:23: error: value of type 'Solution' has no member 'pushLeft'\n297 | \n298 | let arg0 = toTreeNode(valueAt(args, 0))\n299 | let result = solution.pushLeft(arg0)\n    |                       `- error: value of type 'Solution' has no member 'pushLeft'\n300 | let output: Any = NSNull()\n301 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:245:17: error: cannot find type 'TreeNode' in scope\n243 | func toTreeNode(_ value: Any) -> TreeNode? {\n244 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n245 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n246 |         if item is NSNull { return nil }\n247 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-search-tree-iterator_2\/solution.swift:264:17: error: cannot find type 'TreeNode' in scope\n262 |     guard let root else { return [] }\n263 |     var result: [Any] = []\n264 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n265 |     while !queue.isEmpty {\n266 |         let node = queue.removeFirst()\n",
      "expected" : "3",
      "input" : "root = [7,3,15,9,20], next()",
      "slug" : "binary-search-tree-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:259: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                   |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                   |- note: chain the optional using '?' to access member 'val' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:284: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                            |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                            |- note: chain the optional using '?' to access member 'left' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                            `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:334: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                                                                              |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                                                                              |- note: chain the optional using '?' to access member 'right' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                                                                              `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[3,2,1]",
      "input" : "root = [1,null,2,3]",
      "slug" : "binary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:259: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                   |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                   |- note: chain the optional using '?' to access member 'val' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:284: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                            |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                            |- note: chain the optional using '?' to access member 'left' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                            `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:334: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                                                                              |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                                                                              |- note: chain the optional using '?' to access member 'right' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                                                                              `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[]",
      "input" : "root = []",
      "slug" : "binary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:259: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                   |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'val' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                   |- note: chain the optional using '?' to access member 'val' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:284: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                            |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'left' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                            |- note: chain the optional using '?' to access member 'left' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                            `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:3:334: error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func postorderTraversal(_ root: TreeNode?) -> [Int] { var result = [Int](); var stack1 = [TreeNode?](); var stack2 = [Int](); if let root = root { stack1.append(root) }; while !stack1.isEmpty { if let node = stack1.popLast() { stack2.append(node.val); if let left = node.left { stack1.append(left) }; if let right = node.right { stack1.append(right) } } }; result = Array(stack2.reversed()); return result } }\n    |                                                                                                                                                                                                                                                                                                                                              |- error: value of optional type 'TreeNode?' must be unwrapped to refer to member 'right' of wrapped base type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                                                                              |- note: chain the optional using '?' to access member 'right' only for non-'nil' base values\n    |                                                                                                                                                                                                                                                                                                                                              `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-tree-postorder-traversal_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[4,5,2,6,7,3,1]",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "binary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "false",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "word = \"aabcb\"",
      "slug" : "check-if-word-is-valid-after-substitutions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "word = \"aabcb\"",
      "slug" : "check-if-word-is-valid-after-substitutions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "false",
      "input" : "word = \"abc\"",
      "slug" : "check-if-word-is-valid-after-substitutions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[8,5,10,1,7,null,12]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[8,5,10,1,7,12]",
      "input" : "preorder = [8,5,1,7,10,12]",
      "slug" : "construct-binary-search-tree-from-preorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-binary-search-tree-from-preorder-traversal_2\/solution.swift:22:54: error: cannot convert value of type 'Int?' to expected argument type 'Int'\n 20 |                for val in preorder {\n 21 |                    var node = TreeNode(val)\n 22 |                    while !stack.isEmpty, stack.last?.val < val {\n    |                                                      `- error: cannot convert value of type 'Int?' to expected argument type 'Int'\n 23 |                        node.left = stack.removeLast()\n 24 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-binary-search-tree-from-preorder-traversal_2\/solution.swift:233:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n",
      "expected" : "[8,5,10,1,7,12]",
      "input" : "preorder = [8,5,1,7,10,12]",
      "slug" : "construct-binary-search-tree-from-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-binary-search-tree-from-preorder-traversal_2\/solution.swift:22:54: error: cannot convert value of type 'Int?' to expected argument type 'Int'\n 20 |                for val in preorder {\n 21 |                    var node = TreeNode(val)\n 22 |                    while !stack.isEmpty, stack.last?.val < val {\n    |                                                      `- error: cannot convert value of type 'Int?' to expected argument type 'Int'\n 23 |                        node.left = stack.removeLast()\n 24 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-binary-search-tree-from-preorder-traversal_2\/solution.swift:233:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n",
      "expected" : "[2,1]",
      "input" : "preorder = [2,1]",
      "slug" : "construct-binary-search-tree-from-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/decoded-string-at-index_1\/solution.swift:23:48: error: cannot convert return expression of type 'Character' to return type 'String'\n 21 |                 remainder %= newStr.count\n 22 |             }\n 23 |             return String(newStr[remainder...])[0]\n    |                                                `- error: cannot convert return expression of type 'Character' to return type 'String'\n 24 |         }\n 25 |         size += newStr.count * num\n",
      "expected" : "o",
      "input" : "s = \"leet2code3\", k = 10",
      "slug" : "decoded-string-at-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/decoded-string-at-index_1\/solution.swift:23:48: error: cannot convert return expression of type 'Character' to return type 'String'\n 21 |                 remainder %= newStr.count\n 22 |             }\n 23 |             return String(newStr[remainder...])[0]\n    |                                                `- error: cannot convert return expression of type 'Character' to return type 'String'\n 24 |         }\n 25 |         size += newStr.count * num\n",
      "expected" : "h",
      "input" : "s = \"ha22\", k = 5",
      "slug" : "decoded-string-at-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/decoded-string-at-index_2\/solution.swift:22:52: error: cannot convert return expression of type 'Character' to return type 'String'\n 20 |                     remainder %= newStr.count\n 21 |                 }\n 22 |                 return String(newStr[remainder...])[0]\n    |                                                    `- error: cannot convert return expression of type 'Character' to return type 'String'\n 23 |             }\n 24 |             size += newStr.count\n",
      "expected" : "o",
      "input" : "s = \"leet2code3\", k = 10",
      "slug" : "decoded-string-at-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/decoded-string-at-index_2\/solution.swift:22:52: error: cannot convert return expression of type 'Character' to return type 'String'\n 20 |                     remainder %= newStr.count\n 21 |                 }\n 22 |                 return String(newStr[remainder...])[0]\n    |                                                    `- error: cannot convert return expression of type 'Character' to return type 'String'\n 23 |             }\n 24 |             size += newStr.count\n",
      "expected" : "h",
      "input" : "s = \"ha22\", k = 5",
      "slug" : "decoded-string-at-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[4,4]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[3,4]",
      "input" : "n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]",
      "slug" : "exclusive-time-of-functions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[8,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[7,1]",
      "input" : "n = 2, logs = [\"0:start:0\",\"0:start:2\",\"1:end:5\",\"0:end:6\"]",
      "slug" : "exclusive-time-of-functions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "[4,4]",
      "approachName" : "Stack-Based",
      "approachOrder" : 2,
      "expected" : "[3,4]",
      "input" : "n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]",
      "slug" : "exclusive-time-of-functions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[8,0]",
      "approachName" : "Stack-Based",
      "approachOrder" : 2,
      "expected" : "[7,1]",
      "input" : "n = 2, logs = [\"0:start:0\",\"0:start:2\",\"1:end:5\",\"0:end:6\"]",
      "slug" : "exclusive-time-of-functions",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:9:36: error: cannot find type 'NestedInteger' in scope\n  7 |                var index: Int\n  8 | \n  9 |                init(_ nestedList: [NestedInteger]) {\n    |                                    `- error: cannot find type 'NestedInteger' in scope\n 10 |                   var flattened = [Int]()\n 11 |                   flatten(nestedList, &flattened)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:26:44: error: cannot find type 'NestedInteger' in scope\n 24 |                }\n 25 | \n 26 |                func flatten(_ nestedList: [NestedInteger], _ result: inout [Int]) {\n    |                                            `- error: cannot find type 'NestedInteger' in scope\n 27 |                   for element in nestedList {\n 28 |                      if element.isInteger() {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:41:18: error: empty collection literal requires an explicit type\n 39 | \n 40 | \/\/ FocusApp LeetCode Runner\n 41 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 42 |     func parseQuotedString(_ input: String) -> String? {\n 43 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:260:23: error: value of type 'Solution' has no member 'next'\n258 | \n259 | \n260 | let result = solution.next()\n    |                       `- error: value of type 'Solution' has no member 'next'\n261 | let output: Any = result\n262 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:110:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n108 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n109 |         guard !trimmed.isEmpty else { return [] }\n110 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n111 |         if !keyValues.isEmpty {\n112 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1,1,2,3,5,6,4",
      "input" : "[[1,1],2,[3,[5,6]],4]",
      "slug" : "flatten-nested-list-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:9:36: error: cannot find type 'NestedInteger' in scope\n  7 |                var index: Int\n  8 | \n  9 |                init(_ nestedList: [NestedInteger]) {\n    |                                    `- error: cannot find type 'NestedInteger' in scope\n 10 |                   var flattened = [Int]()\n 11 |                   flatten(nestedList, &flattened)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:26:44: error: cannot find type 'NestedInteger' in scope\n 24 |                }\n 25 | \n 26 |                func flatten(_ nestedList: [NestedInteger], _ result: inout [Int]) {\n    |                                            `- error: cannot find type 'NestedInteger' in scope\n 27 |                   for element in nestedList {\n 28 |                      if element.isInteger() {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:41:18: error: empty collection literal requires an explicit type\n 39 | \n 40 | \/\/ FocusApp LeetCode Runner\n 41 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 42 |     func parseQuotedString(_ input: String) -> String? {\n 43 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:260:23: error: value of type 'Solution' has no member 'next'\n258 | \n259 | \n260 | let result = solution.next()\n    |                       `- error: value of type 'Solution' has no member 'next'\n261 | let output: Any = result\n262 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_1\/solution.swift:110:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n108 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n109 |         guard !trimmed.isEmpty else { return [] }\n110 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n111 |         if !keyValues.isEmpty {\n112 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1,4,6",
      "input" : "[1,[4,[6]]]",
      "slug" : "flatten-nested-list-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:6:29: error: cannot find type 'NestedInteger' in scope\n  4 | \n  5 |             class NestedIterator {\n  6 |                var stack: [[NestedInteger]]\n    |                             `- error: cannot find type 'NestedInteger' in scope\n  7 | \n  8 |                init(_ nestedList: [NestedInteger]) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:8:36: error: cannot find type 'NestedInteger' in scope\n  6 |                var stack: [[NestedInteger]]\n  7 | \n  8 |                init(_ nestedList: [NestedInteger]) {\n    |                                    `- error: cannot find type 'NestedInteger' in scope\n  9 |                   stack = [nestedList]\n 10 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:53:18: error: empty collection literal requires an explicit type\n 51 | \n 52 | \/\/ FocusApp LeetCode Runner\n 53 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 54 |     func parseQuotedString(_ input: String) -> String? {\n 55 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:272:23: error: value of type 'Solution' has no member 'next'\n270 | \n271 | \n272 | let result = solution.next()\n    |                       `- error: value of type 'Solution' has no member 'next'\n273 | let output: Any = result\n274 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:122:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n120 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n121 |         guard !trimmed.isEmpty else { return [] }\n122 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n123 |         if !keyValues.isEmpty {\n124 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1,1,2,3,5,6,4",
      "input" : "[[1,1],2,[3,[5,6]],4]",
      "slug" : "flatten-nested-list-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:6:29: error: cannot find type 'NestedInteger' in scope\n  4 | \n  5 |             class NestedIterator {\n  6 |                var stack: [[NestedInteger]]\n    |                             `- error: cannot find type 'NestedInteger' in scope\n  7 | \n  8 |                init(_ nestedList: [NestedInteger]) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:8:36: error: cannot find type 'NestedInteger' in scope\n  6 |                var stack: [[NestedInteger]]\n  7 | \n  8 |                init(_ nestedList: [NestedInteger]) {\n    |                                    `- error: cannot find type 'NestedInteger' in scope\n  9 |                   stack = [nestedList]\n 10 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:53:18: error: empty collection literal requires an explicit type\n 51 | \n 52 | \/\/ FocusApp LeetCode Runner\n 53 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 54 |     func parseQuotedString(_ input: String) -> String? {\n 55 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:272:23: error: value of type 'Solution' has no member 'next'\n270 | \n271 | \n272 | let result = solution.next()\n    |                       `- error: value of type 'Solution' has no member 'next'\n273 | let output: Any = result\n274 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-nested-list-iterator_2\/solution.swift:122:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n120 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n121 |         guard !trimmed.isEmpty else { return [] }\n122 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n123 |         if !keyValues.isEmpty {\n124 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1,4,6",
      "input" : "[1,[4,[6]]]",
      "slug" : "flatten-nested-list-iterator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-queue-using-stacks_1\/solution.swift:248:23: error: value of type 'Solution' has no member 'enqueue'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.enqueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enqueue'\n249 | let output: Any = NSNull()\n250 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "MyQueue().enqueue(1).enqueue(2).enqueue(3)",
      "slug" : "implement-queue-using-stacks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-queue-using-stacks_1\/solution.swift:248:23: error: value of type 'Solution' has no member 'enqueue'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.enqueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enqueue'\n249 | let output: Any = NSNull()\n250 | print(jsonString(from: output))\n",
      "expected" : "true",
      "input" : "MyQueue().enqueue(1).dequeue().empty()",
      "slug" : "implement-queue-using-stacks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-queue-using-stacks_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'enqueue'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.enqueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enqueue'\n249 | let output: Any = NSNull()\n250 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "MyQueue().enqueue(1).enqueue(2).enqueue(3)",
      "slug" : "implement-queue-using-stacks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-queue-using-stacks_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'enqueue'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.enqueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enqueue'\n249 | let output: Any = NSNull()\n250 | print(jsonString(from: output))\n",
      "expected" : "true",
      "input" : "MyQueue().enqueue(1).dequeue().empty()",
      "slug" : "implement-queue-using-stacks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-stack-using-queues_1\/solution.swift:257:23: error: value of type 'Solution' has no member 'push'\n255 | \n256 | let arg0 = toInt(valueAt(args, 0))\n257 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n258 | let output: Any = NSNull()\n259 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "push(1), push(2), pop()",
      "slug" : "implement-stack-using-queues",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-stack-using-queues_1\/solution.swift:257:23: error: value of type 'Solution' has no member 'push'\n255 | \n256 | let arg0 = toInt(valueAt(args, 0))\n257 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n258 | let output: Any = NSNull()\n259 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "push(1), top()",
      "slug" : "implement-stack-using-queues",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-stack-using-queues_2\/solution.swift:250:23: error: value of type 'Solution' has no member 'push'\n248 | \n249 | let arg0 = toInt(valueAt(args, 0))\n250 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n251 | let output: Any = NSNull()\n252 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "push(1), push(2), pop()",
      "slug" : "implement-stack-using-queues",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-stack-using-queues_2\/solution.swift:250:23: error: value of type 'Solution' has no member 'push'\n248 | \n249 | let arg0 = toInt(valueAt(args, 0))\n250 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n251 | let output: Any = NSNull()\n252 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "push(1), top()",
      "slug" : "implement-stack-using-queues",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "Tree with values in ascending order: 1 -> 5 -> 7",
      "input" : "nums = [5,1,7], target = None",
      "slug" : "increasing-order-search-tree",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "Tree with values in ascending order: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8",
      "input" : "nums = [5,3,6,2,4,8,1], target = None",
      "slug" : "increasing-order-search-tree",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "Tree with values in ascending order: 1 -> 5 -> 7",
      "input" : "nums = [5,1,7], target = None",
      "slug" : "increasing-order-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "Tree with values in ascending order: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8",
      "input" : "nums = [5,3,6,2,4,8,1], target = None",
      "slug" : "increasing-order-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "39",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "20",
      "input" : "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext",
      "slug" : "longest-absolute-file-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "67",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "32",
      "input" : "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir3",
      "slug" : "longest-absolute-file-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-absolute-file-path_2\/solution.swift:10:58: error: value of type 'String.Index' has no member 'distance'\n  8 |                let lines = input.components(separatedBy: \"\\n\")\n  9 |                for line in lines {\n 10 |                    let level = line.firstIndex(of: \" \")?.distance(from: line.startIndex) ?? 0\n    |                                                          `- error: value of type 'String.Index' has no member 'distance'\n 11 |                    while stack.count > level + 1 {\n 12 |                        stack.removeLast()\n",
      "expected" : "20",
      "input" : "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext",
      "slug" : "longest-absolute-file-path",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-absolute-file-path_2\/solution.swift:10:58: error: value of type 'String.Index' has no member 'distance'\n  8 |                let lines = input.components(separatedBy: \"\\n\")\n  9 |                for line in lines {\n 10 |                    let level = line.firstIndex(of: \" \")?.distance(from: line.startIndex) ?? 0\n    |                                                          `- error: value of type 'String.Index' has no member 'distance'\n 11 |                    while stack.count > level + 1 {\n 12 |                        stack.removeLast()\n",
      "expected" : "32",
      "input" : "dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir3",
      "slug" : "longest-absolute-file-path",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "arr = [4,3,2,1,0]",
      "slug" : "max-chunks-to-make-sorted",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "arr = [1,0,2,3,4]",
      "slug" : "max-chunks-to-make-sorted",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[6,3,5,null,2,0,null,null,1]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "TreeNode with value 6 as the root, and the left and right subtrees constructed accordingly.",
      "input" : "nums = [3,2,1,6,0,5]",
      "slug" : "maximum-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "nil",
      "input" : "nums = []",
      "slug" : "maximum-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[6,3,5,null,2,0,null,null,1]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "TreeNode with value 6 as the root, and the left and right subtrees constructed accordingly.",
      "input" : "nums = [3,2,1,6,0,5]",
      "slug" : "maximum-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "nil",
      "input" : "nums = []",
      "slug" : "maximum-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Stacks",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/min-stack_1\/solution.swift:252:23: error: value of type 'Solution' has no member 'push'\n250 | \n251 | let arg0 = toInt(valueAt(args, 0))\n252 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n253 | let output: Any = NSNull()\n254 | print(jsonString(from: output))\n",
      "expected" : "-3, 0, -2",
      "input" : "push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()",
      "slug" : "min-stack",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Single Stack with Pairs",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/min-stack_2\/solution.swift:249:23: error: value of type 'Solution' has no member 'push'\n247 | \n248 | let arg0 = toInt(valueAt(args, 0))\n249 | let result = solution.push(arg0)\n    |                       `- error: value of type 'Solution' has no member 'push'\n250 | let output: Any = NSNull()\n251 | print(jsonString(from: output))\n",
      "expected" : "1, -1, 1",
      "input" : "push(1), push(2), getMin(), push(-1), getMin(), pop(), getMin()",
      "slug" : "min-stack",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "solution.NestedInteger",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "324",
      "input" : "s = \"324\"",
      "slug" : "mini-parser",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "solution.NestedInteger",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[123,[456,[789]]]",
      "input" : "s = \"[123,[456,[789]]]\"",
      "slug" : "mini-parser",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "solution.NestedInteger",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "324",
      "input" : "s = \"324\"",
      "slug" : "mini-parser",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "solution.NestedInteger",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[123,[456,[789]]]",
      "input" : "s = \"[123,[456,[789]]]\"",
      "slug" : "mini-parser",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "())",
      "slug" : "minimum-add-to-make-parentheses-valid",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_1\/solution.swift:4:28: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 |     func postorder(_ root: Node?) -> [Int] {\n    |                            `- error: cannot find type 'Node' in scope\n  5 |         guard let root = root else { return [] }\n  6 |         var result = [Int]()\n",
      "expected" : "[2,6,8,3,9,10,7,4,11,5,1]",
      "input" : "root = [1,null,3,2,4,5,6,null,null,7,8,9,10,null,null,null,null,11]",
      "slug" : "n-ary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_1\/solution.swift:4:28: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 |     func postorder(_ root: Node?) -> [Int] {\n    |                            `- error: cannot find type 'Node' in scope\n  5 |         guard let root = root else { return [] }\n  6 |         var result = [Int]()\n",
      "expected" : "[2,3,4,5,6,7,8,1]",
      "input" : "root = [1,null,2,3,4,5,null,null,6,7,null,8]",
      "slug" : "n-ary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_2\/solution.swift:4:28: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 |     func postorder(_ root: Node?) -> [Int] {\n    |                            `- error: cannot find type 'Node' in scope\n  5 |         var result = [Int]()\n  6 |         guard let root = root else { return result }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_2\/solution.swift:7:22: error: cannot find type 'Node' in scope\n  5 |         var result = [Int]()\n  6 |         guard let root = root else { return result }\n  7 |         var stack: [(Node, Bool)] = [(root, false)]\n    |                      `- error: cannot find type 'Node' in scope\n  8 |         while !stack.isEmpty {\n  9 |             let (node, visited) = stack.removeLast()\n",
      "expected" : "[2,6,8,3,9,10,7,4,11,5,1]",
      "input" : "root = [1,null,3,2,4,5,6,null,null,7,8,9,10,null,null,null,null,11]",
      "slug" : "n-ary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_2\/solution.swift:4:28: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 |     func postorder(_ root: Node?) -> [Int] {\n    |                            `- error: cannot find type 'Node' in scope\n  5 |         var result = [Int]()\n  6 |         guard let root = root else { return result }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-postorder-traversal_2\/solution.swift:7:22: error: cannot find type 'Node' in scope\n  5 |         var result = [Int]()\n  6 |         guard let root = root else { return result }\n  7 |         var stack: [(Node, Bool)] = [(root, false)]\n    |                      `- error: cannot find type 'Node' in scope\n  8 |         while !stack.isEmpty {\n  9 |             let (node, visited) = stack.removeLast()\n",
      "expected" : "[2,3,4,5,6,7,8,1]",
      "input" : "root = [1,null,2,3,4,5,null,null,6,7,null,8]",
      "slug" : "n-ary-tree-postorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_1\/solution.swift:3:40: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); func traverse(_ node: Node?) { guard let node = node else { return }; result.append(node.val); node.children.forEach { traverse($0) } }; traverse(root); return result } }\n    |                                        `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_1\/solution.swift:3:102: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); func traverse(_ node: Node?) { guard let node = node else { return }; result.append(node.val); node.children.forEach { traverse($0) } }; traverse(root); return result } }\n    |                                                                                                      `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[1, 3, 5, 2, 2]",
      "input" : "root = [1, [3, 5, 2], [2, 2]]",
      "slug" : "n-ary-tree-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_1\/solution.swift:3:40: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); func traverse(_ node: Node?) { guard let node = node else { return }; result.append(node.val); node.children.forEach { traverse($0) } }; traverse(root); return result } }\n    |                                        `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_1\/solution.swift:3:102: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); func traverse(_ node: Node?) { guard let node = node else { return }; result.append(node.val); node.children.forEach { traverse($0) } }; traverse(root); return result } }\n    |                                                                                                      `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
      "input" : "root = [1, [2, 3, 4, 5, 6, 7, 8, 9, 10]]",
      "slug" : "n-ary-tree-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Stack-Based Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:40: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                        `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:93: error: cannot find 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                                                                             `- error: cannot find 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:92: error: cannot call value of non-function type '[Any]'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                                                                            `- error: cannot call value of non-function type '[Any]'\n  4 | \n  5 | \n",
      "expected" : "[1, 3, 5, 2, 2]",
      "input" : "root = [1, [3, 5, 2], [2, 2]]",
      "slug" : "n-ary-tree-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Iterative Stack-Based Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:40: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                        `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:93: error: cannot find 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                                                                             `- error: cannot find 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-preorder-traversal_2\/solution.swift:3:92: error: cannot call value of non-function type '[Any]'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func preorder(_ root: Node?) -> [Int] { var result = [Int](); var stack = [Node](); if let root = root { stack.append(root) }; while !stack.isEmpty { let node = stack.removeLast(); result.append(node.val); for child in node.children.reversed() { stack.append(child) } }; return result } }\n    |                                                                                            `- error: cannot call value of non-function type '[Any]'\n  4 | \n  5 | \n",
      "expected" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
      "input" : "root = [1, [2, 3, 4, 5, 6, 7, 8, 9, 10]]",
      "slug" : "n-ary-tree-preorder-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func nextGreaterElements(_ nums: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_1\/solution.swift:11:39: error: value of type 'Range<Int>' has no member 'append'\n  9 |     for i in 0..<nums.count {\n 10 |         var found = false\n 11 |         for j in (i + 1..<nums.count).append(contentsOf: 0...i) {\n    |                                       `- error: value of type 'Range<Int>' has no member 'append'\n 12 |             if nums[j] > nums[i] {\n 13 |                 result.append(nums[j])\n",
      "expected" : "[2,-1,2]",
      "input" : "nums = [1,2,1]",
      "slug" : "next-greater-element-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func nextGreaterElements(_ nums: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_1\/solution.swift:11:39: error: value of type 'Range<Int>' has no member 'append'\n  9 |     for i in 0..<nums.count {\n 10 |         var found = false\n 11 |         for j in (i + 1..<nums.count).append(contentsOf: 0...i) {\n    |                                       `- error: value of type 'Range<Int>' has no member 'append'\n 12 |             if nums[j] > nums[i] {\n 13 |                 result.append(nums[j])\n",
      "expected" : "[2,3,4,-1,-1]",
      "input" : "nums = [1,2,3,4,3]",
      "slug" : "next-greater-element-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Monotonic Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func nextGreaterElements(_ nums: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: function produces expected type 'Int'; did you mean to call it with '()'?\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: function produces expected type 'Int'; did you mean to call it with '()'?\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: cannot reference 'mutating' method as function value\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: cannot reference 'mutating' method as function value\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:36: error: cannot force unwrap value of non-optional type '() -> Int'\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                                    `- error: cannot force unwrap value of non-optional type '() -> Int'\n 16 |         }\n 17 |         stack.append(i % n)\n",
      "expected" : "[2,-1,2]",
      "input" : "nums = [1,2,1]",
      "slug" : "next-greater-element-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Monotonic Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func nextGreaterElements(_ nums: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: function produces expected type 'Int'; did you mean to call it with '()'?\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: function produces expected type 'Int'; did you mean to call it with '()'?\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: cannot reference 'mutating' method as function value\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: cannot reference 'mutating' method as function value\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:36: error: cannot force unwrap value of non-optional type '() -> Int'\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                                    `- error: cannot force unwrap value of non-optional type '() -> Int'\n 16 |         }\n 17 |         stack.append(i % n)\n",
      "expected" : "[2,3,4,-1,-1]",
      "input" : "nums = [1,2,3,4,3]",
      "slug" : "next-greater-element-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Monotonic Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func nextGreaterElements(_ nums: [Int]) -> [Int] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: function produces expected type 'Int'; did you mean to call it with '()'?\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: function produces expected type 'Int'; did you mean to call it with '()'?\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:26: error: cannot reference 'mutating' method as function value\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                          `- error: cannot reference 'mutating' method as function value\n 16 |         }\n 17 |         stack.append(i % n)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-ii_2\/solution.swift:15:36: error: cannot force unwrap value of non-optional type '() -> Int'\n 13 |         let num = nums[i % n]\n 14 |         while !stack.isEmpty && nums[stack.last!] < num {\n 15 |             result[stack.removeLast!] = num\n    |                                    `- error: cannot force unwrap value of non-optional type '() -> Int'\n 16 |         }\n 17 |         stack.append(i % n)\n",
      "expected" : "[5,5,4,3,5,-1,5]",
      "input" : "nums = [5,4,3,2,3,5,1]",
      "slug" : "next-greater-element-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-stock-span_1\/solution.swift:230:23: error: value of type 'Solution' has no member 'next'\n228 | \n229 | let arg0 = toInt(valueAt(args, 0))\n230 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "1; 1; 1; 2; 1; 4; 6",
      "input" : "StockSpanner().next(100); StockSpanner().next(80); StockSpanner().next(60); StockSpanner().next(70); StockSpanner().next(60); StockSpanner().next(75); StockSpanner().next(85)",
      "slug" : "online-stock-span",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-stock-span_1\/solution.swift:230:23: error: value of type 'Solution' has no member 'next'\n228 | \n229 | let arg0 = toInt(valueAt(args, 0))\n230 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "1; 1; 2; 4; 5",
      "input" : "StockSpanner().next(10); StockSpanner().next(4); StockSpanner().next(5); StockSpanner().next(9); StockSpanner().next(0)",
      "slug" : "online-stock-span",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach using a Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-stock-span_2\/solution.swift:230:23: error: value of type 'Solution' has no member 'next'\n228 | \n229 | let arg0 = toInt(valueAt(args, 0))\n230 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "1; 1; 1; 2; 1; 4; 6",
      "input" : "StockSpanner().next(100); StockSpanner().next(80); StockSpanner().next(60); StockSpanner().next(70); StockSpanner().next(60); StockSpanner().next(75); StockSpanner().next(85)",
      "slug" : "online-stock-span",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach using a Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-stock-span_2\/solution.swift:230:23: error: value of type 'Solution' has no member 'next'\n228 | \n229 | let arg0 = toInt(valueAt(args, 0))\n230 | let result = solution.next(arg0)\n    |                       `- error: value of type 'Solution' has no member 'next'\n231 | let output: Any = result\n232 | print(jsonString(from: output))\n",
      "expected" : "1; 1; 2; 4; 5",
      "input" : "StockSpanner().next(10); StockSpanner().next(4); StockSpanner().next(5); StockSpanner().next(9); StockSpanner().next(0)",
      "slug" : "online-stock-span",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicate-letters_1\/solution.swift:12:27: error: missing argument label 'where:' in call\n 10 |             minStack.remove(at: index)\n 11 |         }\n 12 |         if !seen.contains(char) {\n    |                           `- error: missing argument label 'where:' in call\n 13 |             seen[char] = true\n 14 |             minStack.append(char)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicate-letters_1\/solution.swift:12:27: error: cannot convert value of type 'Character' to expected argument type '(Dictionary<Character, Bool>.Element) throws -> Bool' (aka '((key: Character, value: Bool)) throws -> Bool')\n 10 |             minStack.remove(at: index)\n 11 |         }\n 12 |         if !seen.contains(char) {\n    |                           `- error: cannot convert value of type 'Character' to expected argument type '(Dictionary<Character, Bool>.Element) throws -> Bool' (aka '((key: Character, value: Bool)) throws -> Bool')\n 13 |             seen[char] = true\n 14 |             minStack.append(char)\n",
      "expected" : "abc",
      "input" : "bcabc",
      "slug" : "remove-duplicate-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicate-letters_1\/solution.swift:12:27: error: missing argument label 'where:' in call\n 10 |             minStack.remove(at: index)\n 11 |         }\n 12 |         if !seen.contains(char) {\n    |                           `- error: missing argument label 'where:' in call\n 13 |             seen[char] = true\n 14 |             minStack.append(char)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicate-letters_1\/solution.swift:12:27: error: cannot convert value of type 'Character' to expected argument type '(Dictionary<Character, Bool>.Element) throws -> Bool' (aka '((key: Character, value: Bool)) throws -> Bool')\n 10 |             minStack.remove(at: index)\n 11 |         }\n 12 |         if !seen.contains(char) {\n    |                           `- error: cannot convert value of type 'Character' to expected argument type '(Dictionary<Character, Bool>.Element) throws -> Bool' (aka '((key: Character, value: Bool)) throws -> Bool')\n 13 |             seen[char] = true\n 14 |             minStack.append(char)\n",
      "expected" : "acdb",
      "input" : "cbacdcbc",
      "slug" : "remove-duplicate-letters",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"abc\"",
      "approachName" : "Monotonic Stack Approach",
      "approachOrder" : 2,
      "expected" : "abc",
      "input" : "bcabc",
      "slug" : "remove-duplicate-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"acdb\"",
      "approachName" : "Monotonic Stack Approach",
      "approachOrder" : 2,
      "expected" : "acdb",
      "input" : "cbacdcbc",
      "slug" : "remove-duplicate-letters",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_1\/solution.swift:4:417: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { let count = num.count; if k >= count { return \"0\" }; var nums = Array(num); var res = \"\"; for i in 0..<num.count-k { var maxNum = 0; var maxIndex = 0; for j in 0..<k+i+1 { if nums[j] > Character(\"0\") && Int(String(nums[j]))! > maxNum { maxNum = Int(String(nums[j]))!; maxIndex = j } }; res += String(nums[maxIndex]); for j in 0..<maxIndex { nums[j] = \"0\" }; k -= maxIndex; if k == 0 { break } }; while res.count > 1 && res.first == \"0\" { res = String(res.dropFirst()) }; return res.isEmpty ? \"0\" : res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"1219\"",
      "input" : "num = \"1432219\", k = \"3\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_1\/solution.swift:4:417: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { let count = num.count; if k >= count { return \"0\" }; var nums = Array(num); var res = \"\"; for i in 0..<num.count-k { var maxNum = 0; var maxIndex = 0; for j in 0..<k+i+1 { if nums[j] > Character(\"0\") && Int(String(nums[j]))! > maxNum { maxNum = Int(String(nums[j]))!; maxIndex = j } }; res += String(nums[maxIndex]); for j in 0..<maxIndex { nums[j] = \"0\" }; k -= maxIndex; if k == 0 { break } }; while res.count > 1 && res.first == \"0\" { res = String(res.dropFirst()) }; return res.isEmpty ? \"0\" : res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"200\"",
      "input" : "num = \"10200\", k = \"1\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_1\/solution.swift:4:417: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { let count = num.count; if k >= count { return \"0\" }; var nums = Array(num); var res = \"\"; for i in 0..<num.count-k { var maxNum = 0; var maxIndex = 0; for j in 0..<k+i+1 { if nums[j] > Character(\"0\") && Int(String(nums[j]))! > maxNum { maxNum = Int(String(nums[j]))!; maxIndex = j } }; res += String(nums[maxIndex]); for j in 0..<maxIndex { nums[j] = \"0\" }; k -= maxIndex; if k == 0 { break } }; while res.count > 1 && res.first == \"0\" { res = String(res.dropFirst()) }; return res.isEmpty ? \"0\" : res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"0\"",
      "input" : "num = \"10\", k = \"2\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:174: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                              `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:237: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                                                                                             `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"1219\"",
      "input" : "num = \"1432219\", k = \"3\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:174: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                              `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:237: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                                                                                             `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"200\"",
      "input" : "num = \"10200\", k = \"1\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:174: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                              `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-k-digits_2\/solution.swift:4:237: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func removeKdigits(_ num: String, _ k: Int) -> String { var stack: [Character] = []; for c in num { while !stack.isEmpty && k > 0 && stack.last! > c { stack.removeLast(); k -= 1 }; stack.append(c) }; while k > 0 { stack.removeLast(); k -= 1 }; while !stack.isEmpty && stack.first == \"0\" { stack.removeFirst() }; return stack.isEmpty ? \"0\" : String(stack) }\n    |                                                                                                                                                                                                                                             `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "\"0\"",
      "input" : "num = \"10\", k = \"2\"",
      "slug" : "remove-k-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:9:25: error: single-quoted string literal found, use '\"'\n  7 |            var res = 0\n  8 |            for ch in S {\n  9 |                if ch == '(' {\n    |                         `- error: single-quoted string literal found, use '\"'\n 10 |                    stack.append(String(ch))\n 11 |                } else if ch == ')' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:11:32: error: single-quoted string literal found, use '\"'\n  9 |                if ch == '(' {\n 10 |                    stack.append(String(ch))\n 11 |                } else if ch == ')' {\n    |                                `- error: single-quoted string literal found, use '\"'\n 12 |                    _ = stack.popLast()\n 13 |                    if !stack.isEmpty && stack.last == String('(') {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:13:62: error: single-quoted string literal found, use '\"'\n 11 |                } else if ch == ')' {\n 12 |                    _ = stack.popLast()\n 13 |                    if !stack.isEmpty && stack.last == String('(') {\n    |                                                              `- error: single-quoted string literal found, use '\"'\n 14 |                        stack[stack.count-1] = String(1)\n 15 |                    } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:18:69: error: single-quoted string literal found, use '\"'\n 16 |                        var val = 0\n 17 |                        var temp: [String] = []\n 18 |                        while !stack.isEmpty && stack.last != String('(') {\n    |                                                                     `- error: single-quoted string literal found, use '\"'\n 19 |                            val += Int(stack.last ?? \"\") ?? 0\n 20 |                            temp.append(stack.last ?? \"\")\n",
      "expected" : "1",
      "input" : "S = \"()\"",
      "slug" : "score-of-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:9:25: error: single-quoted string literal found, use '\"'\n  7 |            var res = 0\n  8 |            for ch in S {\n  9 |                if ch == '(' {\n    |                         `- error: single-quoted string literal found, use '\"'\n 10 |                    stack.append(String(ch))\n 11 |                } else if ch == ')' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:11:32: error: single-quoted string literal found, use '\"'\n  9 |                if ch == '(' {\n 10 |                    stack.append(String(ch))\n 11 |                } else if ch == ')' {\n    |                                `- error: single-quoted string literal found, use '\"'\n 12 |                    _ = stack.popLast()\n 13 |                    if !stack.isEmpty && stack.last == String('(') {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:13:62: error: single-quoted string literal found, use '\"'\n 11 |                } else if ch == ')' {\n 12 |                    _ = stack.popLast()\n 13 |                    if !stack.isEmpty && stack.last == String('(') {\n    |                                                              `- error: single-quoted string literal found, use '\"'\n 14 |                        stack[stack.count-1] = String(1)\n 15 |                    } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_1\/solution.swift:18:69: error: single-quoted string literal found, use '\"'\n 16 |                        var val = 0\n 17 |                        var temp: [String] = []\n 18 |                        while !stack.isEmpty && stack.last != String('(') {\n    |                                                                     `- error: single-quoted string literal found, use '\"'\n 19 |                            val += Int(stack.last ?? \"\") ?? 0\n 20 |                            temp.append(stack.last ?? \"\")\n",
      "expected" : "2",
      "input" : "S = \",(())\"",
      "slug" : "score-of-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:8:25: error: single-quoted string literal found, use '\"'\n  6 |            var stack: [Int] = [0]\n  7 |            for ch in S {\n  8 |                if ch == '(' {\n    |                         `- error: single-quoted string literal found, use '\"'\n  9 |                    stack.append(0)\n 10 |                } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:11:24: warning: variable 'v' was never mutated; consider changing to 'let' constant\n  9 |                    stack.append(0)\n 10 |                } else {\n 11 |                    var v = stack.popLast() ?? 0\n    |                        `- warning: variable 'v' was never mutated; consider changing to 'let' constant\n 12 |                    stack[stack.count-1] += max(2*v, 1)\n 13 |                }\n",
      "expected" : "1",
      "input" : "S = \"()\"",
      "slug" : "score-of-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:8:25: error: single-quoted string literal found, use '\"'\n  6 |            var stack: [Int] = [0]\n  7 |            for ch in S {\n  8 |                if ch == '(' {\n    |                         `- error: single-quoted string literal found, use '\"'\n  9 |                    stack.append(0)\n 10 |                } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:11:24: warning: variable 'v' was never mutated; consider changing to 'let' constant\n  9 |                    stack.append(0)\n 10 |                } else {\n 11 |                    var v = stack.popLast() ?? 0\n    |                        `- warning: variable 'v' was never mutated; consider changing to 'let' constant\n 12 |                    stack[stack.count-1] += max(2*v, 1)\n 13 |                }\n",
      "expected" : "2",
      "input" : "S = \",(())\"",
      "slug" : "score-of-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:8:25: error: single-quoted string literal found, use '\"'\n  6 |            var stack: [Int] = [0]\n  7 |            for ch in S {\n  8 |                if ch == '(' {\n    |                         `- error: single-quoted string literal found, use '\"'\n  9 |                    stack.append(0)\n 10 |                } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/score-of-parentheses_2\/solution.swift:11:24: warning: variable 'v' was never mutated; consider changing to 'let' constant\n  9 |                    stack.append(0)\n 10 |                } else {\n 11 |                    var v = stack.popLast() ?? 0\n    |                        `- warning: variable 'v' was never mutated; consider changing to 'let' constant\n 12 |                    stack[stack.count-1] += max(2*v, 1)\n 13 |                }\n",
      "expected" : "4",
      "input" : "S = \"(())()\"",
      "slug" : "score-of-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "\"\\\/home\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\/home",
      "input" : "\/home\/",
      "slug" : "simplify-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"\\\/\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\/",
      "input" : "\/..\/",
      "slug" : "simplify-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"\\\/home\\\/foo\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\/home\/foo",
      "input" : "\/home\/\/foo\/",
      "slug" : "simplify-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"\\\/c\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\/c",
      "input" : "\/a\/.\/b\/..\/..\/c\/",
      "slug" : "simplify-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_1\/solution.swift:20:20: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n 18 | \n 19 |            func isValidSerialization(_ preorder: String) -> Bool {\n 20 |                var nodes = preorder.components(separatedBy: \",\")\n    |                    `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n 21 |                var stack: [String] = []\n 22 | \n",
      "expected" : "true",
      "input" : "9,#,3,#,7,#,#,#",
      "slug" : "verify-preorder-serialization-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            class TreeNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_1\/solution.swift:20:20: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n 18 | \n 19 |            func isValidSerialization(_ preorder: String) -> Bool {\n 20 |                var nodes = preorder.components(separatedBy: \",\")\n    |                    `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n 21 |                var stack: [String] = []\n 22 | \n",
      "expected" : "false",
      "input" : "1,#,#,#,#",
      "slug" : "verify-preorder-serialization-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func isValidSerialization(_ preorder: String) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_2\/solution.swift:8:20: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |            func isValidSerialization(_ preorder: String) -> Bool {\n  8 |                var nodes = preorder.components(separatedBy: \",\")\n    |                    `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n  9 |                var count = 1\n 10 | \n",
      "expected" : "true",
      "input" : "9,#,3,#,7,#,#,#",
      "slug" : "verify-preorder-serialization-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func isValidSerialization(_ preorder: String) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/verify-preorder-serialization-of-a-binary-tree_2\/solution.swift:8:20: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |            func isValidSerialization(_ preorder: String) -> Bool {\n  8 |                var nodes = preorder.components(separatedBy: \",\")\n    |                    `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n  9 |                var count = 1\n 10 | \n",
      "expected" : "false",
      "input" : "9,#,3,#,7,#,#,#,#",
      "slug" : "verify-preorder-serialization-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie + DFS Wildcard",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-add-and-search-words-data-structure_1\/solution.swift:265:23: error: value of type 'Solution' has no member 'addWord'\n263 | \n264 | let arg0 = toString(valueAt(args, 0))\n265 | let result = solution.addWord(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addWord'\n266 | let output: Any = NSNull()\n267 | print(jsonString(from: output))\n",
      "expected" : "[null,null,null,null,false,true,true,true]",
      "input" : "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
      "slug" : "design-add-and-search-words-data-structure",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'buildDictionary'\n226 | \n227 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n228 | let result = solution.buildDictionary(arg0)\n    |                       `- error: value of type 'Solution' has no member 'buildDictionary'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_1\/solution.swift:4:300: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class MagicDictionary { var dictionary: [String] = []; func buildDictionary(_ dictionary: [String]) { self.dictionary = dictionary }; func search(_ searchWord: String) -> Bool { for word in dictionary { if word.count == searchWord.count { var diff = 0; for (i, char) in searchWord.enumerated() { if word[i] != char { diff += 1 } }; if diff == 1 { return true } } }; return false }; }\n    |                                                                                                                                                                                                                                                                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "MagicDictionary().buildDictionary([\"hello\",\"leetcode\"]).search(\"hello\")",
      "slug" : "implement-magic-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'buildDictionary'\n226 | \n227 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n228 | let result = solution.buildDictionary(arg0)\n    |                       `- error: value of type 'Solution' has no member 'buildDictionary'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_1\/solution.swift:4:300: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | class MagicDictionary { var dictionary: [String] = []; func buildDictionary(_ dictionary: [String]) { self.dictionary = dictionary }; func search(_ searchWord: String) -> Bool { for word in dictionary { if word.count == searchWord.count { var diff = 0; for (i, char) in searchWord.enumerated() { if word[i] != char { diff += 1 } }; if diff == 1 { return true } } }; return false }; }\n    |                                                                                                                                                                                                                                                                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "false",
      "input" : "MagicDictionary().buildDictionary([\"hello\",\"leetcode\"]).search(\"hell\")",
      "slug" : "implement-magic-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'buildDictionary'\n226 | \n227 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n228 | let result = solution.buildDictionary(arg0)\n    |                       `- error: value of type 'Solution' has no member 'buildDictionary'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MagicDictionary().buildDictionary([\"hello\",\"leetcode\"]).search(\"hello\")",
      "slug" : "implement-magic-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Trie",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-magic-dictionary_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'buildDictionary'\n226 | \n227 | let arg0 = toArray(valueAt(args, 0)) { toString($0) }\n228 | let result = solution.buildDictionary(arg0)\n    |                       `- error: value of type 'Solution' has no member 'buildDictionary'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MagicDictionary().buildDictionary([\"hello\",\"leetcode\"]).search(\"hell\")",
      "slug" : "implement-magic-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Array-Backed Trie",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-trie-prefix-tree_1\/solution.swift:266:23: error: value of type 'Solution' has no member 'insert'\n264 | \n265 | let arg0 = toString(valueAt(args, 0))\n266 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n267 | let output: Any = NSNull()\n268 | print(jsonString(from: output))\n",
      "expected" : "[null,null,true,false,true,null,true]",
      "input" : "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]",
      "slug" : "implement-trie-prefix-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[1,10,11,12,13]",
      "approachName" : "Optimized DFS",
      "approachOrder" : 2,
      "expected" : "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "input" : "n = 13",
      "slug" : "lexicographical-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1]",
      "approachName" : "Optimized DFS",
      "approachOrder" : 2,
      "expected" : "[1,2]",
      "input" : "n = 2",
      "slug" : "lexicographical-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func longestWord(_ words: [String]) -> String {\n",
      "expected" : "\"word\"",
      "input" : "words = [\"w\",\"wo\",\"wor\",\"word\"]",
      "slug" : "longest-word-in-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func longestWord(_ words: [String]) -> String {\n",
      "expected" : "\"apple\"",
      "input" : "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
      "slug" : "longest-word-in-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie-Based",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TrieNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_2\/solution.swift:286:23: error: value of type 'Solution' has no member 'insert'\n284 | \n285 | let arg0 = toString(valueAt(args, 0))\n286 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n287 | let output: Any = NSNull()\n288 | print(jsonString(from: output))\n",
      "expected" : "\"word\"",
      "input" : "words = [\"w\",\"wo\",\"wor\",\"word\"]",
      "slug" : "longest-word-in-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Trie-Based",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TrieNode {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/longest-word-in-dictionary_2\/solution.swift:286:23: error: value of type 'Solution' has no member 'insert'\n284 | \n285 | let arg0 = toString(valueAt(args, 0))\n286 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n287 | let output: Any = NSNull()\n288 | print(jsonString(from: output))\n",
      "expected" : "\"apple\"",
      "input" : "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
      "slug" : "longest-word-in-dictionary",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'insert'\n245 | let arg0 = toString(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.insert(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n248 | let output: Any = NSNull()\n249 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_1\/solution.swift:15:35: error: value of type 'String' has no member 'startsWith'\n 13 |                        var sum = 0\n 14 |                        for key in map.keys {\n 15 |                            if key.startsWith(prefix) {\n    |                                   `- error: value of type 'String' has no member 'startsWith'\n 16 |                                sum += map[key] ?? 0\n 17 |                            }\n",
      "expected" : "3",
      "input" : "insert(\"apple\", 3), sum(\"ap\")",
      "slug" : "map-sum-pairs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'insert'\n245 | let arg0 = toString(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.insert(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n248 | let output: Any = NSNull()\n249 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_1\/solution.swift:15:35: error: value of type 'String' has no member 'startsWith'\n 13 |                        var sum = 0\n 14 |                        for key in map.keys {\n 15 |                            if key.startsWith(prefix) {\n    |                                   `- error: value of type 'String' has no member 'startsWith'\n 16 |                                sum += map[key] ?? 0\n 17 |                            }\n",
      "expected" : "5",
      "input" : "insert(\"apple\", 3), insert(\"app\", 2), sum(\"ap\")",
      "slug" : "map-sum-pairs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_2\/solution.swift:263:23: error: value of type 'Solution' has no member 'insert'\n261 | let arg0 = toString(valueAt(args, 0))\n262 | let arg1 = toInt(valueAt(args, 1))\n263 | let result = solution.insert(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "insert(\"apple\", 3), sum(\"ap\")",
      "slug" : "map-sum-pairs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Trie Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/map-sum-pairs_2\/solution.swift:263:23: error: value of type 'Solution' has no member 'insert'\n261 | let arg0 = toString(valueAt(args, 0))\n262 | let arg1 = toInt(valueAt(args, 1))\n263 | let result = solution.insert(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n",
      "expected" : "5",
      "input" : "insert(\"apple\", 3), insert(\"app\", 2), sum(\"ap\")",
      "slug" : "map-sum-pairs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:29: error: expected expression after unary operator\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                             `- error: expected expression after unary operator\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:32: error: expected expression in container literal\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                `- error: expected expression in container literal\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:331: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:425: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:390: error: cannot find 'dictWord' in scope\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: cannot find 'dictWord' in scope\n  5 | }\n  6 | \n",
      "expected" : "the cat was rat by the bat",
      "input" : "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
      "slug" : "replace-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:29: error: expected expression after unary operator\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                             `- error: expected expression after unary operator\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:32: error: expected expression in container literal\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                `- error: expected expression in container literal\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:331: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:425: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_1\/solution.swift:4:390: error: cannot find 'dictWord' in scope\n  2 | \n  3 | class Solution {\n  4 | let dictionary: [String] = [...]; let sentence: String = \"...\"; func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { for dictWord in dictionary { if word.hasPrefix(dictWord) { result.append(dictWord); break; } } if result.count == words.count { break; } else if word != dictWord { result.append(word); } } return result.joined(separator: \" \"); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: cannot find 'dictWord' in scope\n  5 | }\n  6 | \n",
      "expected" : "a a b a",
      "input" : "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf abbfa wef bbbbbbbbbbbbbb b bb a a\"",
      "slug" : "replace-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie-Based Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:88: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:331: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:362: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:384: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:600: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:680: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:723: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "the cat was rat by the bat",
      "input" : "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
      "slug" : "replace-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Trie-Based Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:88: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:331: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:362: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:384: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:600: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:680: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/replace-words_2\/solution.swift:3:723: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class TrieNode { var children: [Character: TrieNode] = [:]; var isWord: Bool = false; } class Solution { func replaceWords(_ dictionary: [String], _ sentence: String) -> String { let trie = TrieNode(); for word in dictionary { var node = trie; for char in word { if node.children[char] == nil { node.children[char] = TrieNode(); } node = node.children[char]!; } node.isWord = true; } let words = sentence.components(separatedBy: \" \"); var result: [String] = []; for word in words { var node = trie; var prefix = \"\"; for char in word { prefix += String(char); if node.children[char] == nil { break; } node = node.children[char]!; if node.isWord { result.append(prefix); break; } } if !node.isWord { result.append(word); } } return result.joined(separator: \" \"); } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "a a b a",
      "input" : "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf abbfa wef bbbbbbbbbbbbbb b bb a a\"",
      "slug" : "replace-words",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Trie Approach",
      "approachOrder" : 2,
      "expected" : "10",
      "input" : "words = [\"time\", \"me\", \"bell\"]",
      "slug" : "short-encoding-of-words",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "1",
      "approachName" : "Trie Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "words = [\"t\"]",
      "slug" : "short-encoding-of-words",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[\"oath\",\"eat\"]",
      "approachName" : "Trie + DFS",
      "approachOrder" : 1,
      "expected" : "[\"eat\",\"oath\"]",
      "input" : "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
      "slug" : "word-search-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_1\/solution.swift:4:220: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { for i in nums.indices { for j in nums.indices { for k in nums.indices { if i < j && j < k && nums[i] < nums[j] && nums[i] < nums[k] && nums[j] > nums[k] { return true } } } } return false }\n    |                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [1, 2, 3, 4]",
      "slug" : "132-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_1\/solution.swift:4:220: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { for i in nums.indices { for j in nums.indices { for k in nums.indices { if i < j && j < k && nums[i] < nums[j] && nums[i] < nums[k] && nums[j] > nums[k] { return true } } } } return false }\n    |                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [3, 1, 4, 2]",
      "slug" : "132-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:144: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:212: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [1, 2, 3, 4]",
      "slug" : "132-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Stack",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:144: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:212: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/132-pattern_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func find132pattern(_ nums: [Int]) -> Bool { var stack: [Int] = [], s3: Int = Int.min; for num in nums.reversed() { if num < s3 { return true } while !stack.isEmpty, stack.last! < num { s3 = stack.removeLast() } stack.append(num) } return false }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [3, 1, 4, 2]",
      "slug" : "132-pattern",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:312: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:340: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:507: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:62: warning: variable 'maxCapacity' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                              `- warning: variable 'maxCapacity' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "15",
      "input" : "weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
      "slug" : "capacity-to-ship-packages-within-d-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:312: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:340: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:507: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_1\/solution.swift:4:62: warning: variable 'maxCapacity' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { var maxCapacity = weights.reduce(0, +); func canShip(_ capacity: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }; var minCapacity = maxCapacity; for capacity in stride(from: maxCapacity, to: 0, by: -1) { if canShip(capacity) { minCapacity = capacity; break } } return minCapacity }\n    |                                                              `- warning: variable 'maxCapacity' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "weights = [3,2,2,4,1,4], D = 3",
      "slug" : "capacity-to-ship-packages-within-d-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:292: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:476: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:550: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:578: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "15",
      "input" : "weights = [1,2,3,4,5,6,7,8,9,10], D = 5",
      "slug" : "capacity-to-ship-packages-within-d-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:292: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:476: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:550: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/capacity-to-ship-packages-within-d-days_2\/solution.swift:4:578: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func shipWithinDays(_ weights: [Int], _ D: Int) -> Int { let total = weights.reduce(0, +); let maxWeight = weights.max()!; var left = maxWeight; var right = total; while left < right { let mid = left + (right - left) \/ 2; if canShip(weights, mid, D) { right = mid } else { left = mid + 1 } } return left }; func canShip(_ weights: [Int], _ capacity: Int, _ D: Int) -> Bool { var currentCapacity = 0; var days = 1; for weight in weights { if weight > capacity { return false } if currentCapacity + weight > capacity { days += 1; currentCapacity = 0 } currentCapacity += weight } return days <= D }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "weights = [3,2,2,4,1,4], D = 3",
      "slug" : "capacity-to-ship-packages-within-d-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "6",
      "input" : "root = [1,2,3,4,5,6]",
      "slug" : "count-complete-tree-nodes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_1\/solution.swift:4:348: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); for (index, aliceSize) in aliceSizes.enumerated() { for (bobIndex, bobSize) in bobSizes.enumerated() { if (aliceSum - aliceSize + bobSize) == (bobSum - bobSize + aliceSize) { return [index, bobIndex] } } } return [] }\n    |                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0,1]",
      "input" : "aliceSizes = [1,1], bobSizes = [2,2]",
      "slug" : "fair-candy-swap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_1\/solution.swift:4:348: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); for (index, aliceSize) in aliceSizes.enumerated() { for (bobIndex, bobSize) in bobSizes.enumerated() { if (aliceSum - aliceSize + bobSize) == (bobSum - bobSize + aliceSize) { return [index, bobIndex] } } } return [] }\n    |                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[0,0]",
      "input" : "aliceSizes = [1,2,5], bobSizes = [2,4]",
      "slug" : "fair-candy-swap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Hash Table Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_2\/solution.swift:4:367: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); var bobSet: Set<Int> = Set(bobSizes); for (index, aliceSize) in aliceSizes.enumerated() { let bobSize = aliceSize + (bobSum - aliceSum) \/ 2; if bobSet.contains(bobSize) { return [index, bobSizes.firstIndex(of: bobSize)!] } } return [] }\n    |                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_2\/solution.swift:4:147: warning: variable 'bobSet' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); var bobSet: Set<Int> = Set(bobSizes); for (index, aliceSize) in aliceSizes.enumerated() { let bobSize = aliceSize + (bobSum - aliceSum) \/ 2; if bobSet.contains(bobSize) { return [index, bobSizes.firstIndex(of: bobSize)!] } } return [] }\n    |                                                                                                                                                   `- warning: variable 'bobSet' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[0,1]",
      "input" : "aliceSizes = [1,1], bobSizes = [2,2]",
      "slug" : "fair-candy-swap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Hash Table Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_2\/solution.swift:4:367: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); var bobSet: Set<Int> = Set(bobSizes); for (index, aliceSize) in aliceSizes.enumerated() { let bobSize = aliceSize + (bobSum - aliceSum) \/ 2; if bobSet.contains(bobSize) { return [index, bobSizes.firstIndex(of: bobSize)!] } } return [] }\n    |                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fair-candy-swap_2\/solution.swift:4:147: warning: variable 'bobSet' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fairCandySwap(aliceSizes: [Int], bobSizes: [Int]) -> [Int] { let aliceSum = aliceSizes.reduce(0, +); let bobSum = bobSizes.reduce(0, +); var bobSet: Set<Int> = Set(bobSizes); for (index, aliceSize) in aliceSizes.enumerated() { let bobSize = aliceSize + (bobSum - aliceSum) \/ 2; if bobSet.contains(bobSize) { return [index, bobSizes.firstIndex(of: bobSize)!] } } return [] }\n    |                                                                                                                                                   `- warning: variable 'bobSet' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "[0,0]",
      "input" : "aliceSizes = [1,2,5], bobSizes = [2,4]",
      "slug" : "fair-candy-swap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[-1]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "-1",
      "input" : "intervals = [[1,2]]",
      "slug" : "find-right-interval",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[3,0,1,-1]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "-1,0,1,-1",
      "input" : "intervals = [[3,4],[2,3],[1,2],[4,5]]",
      "slug" : "find-right-interval",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[-1]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "-1",
      "input" : "intervals = [[1,2]]",
      "slug" : "find-right-interval",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[3,0,1,-1]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "-1,0,1,-1",
      "input" : "intervals = [[3,4],[2,3],[1,2],[4,5]]",
      "slug" : "find-right-interval",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "c",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"c\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "f",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"f\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"d\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "c",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"c\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"j\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "c",
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "expected" : "\"c\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "f",
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "expected" : "\"f\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"d\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "c",
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "expected" : "\"c\"",
      "input" : "letters = [\"c\",\"f\",\"j\"], target = \"j\"",
      "slug" : "find-smallest-letter-greater-than-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Binary Search",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/first-bad-version_1\/solution.swift:8:12: error: cannot find 'isBadVersion' in scope\n  6 |     while left < right {\n  7 |         let mid = left + (right - left) \/ 2\n  8 |         if isBadVersion(mid) {\n    |            `- error: cannot find 'isBadVersion' in scope\n  9 |             right = mid\n 10 |         } else {\n",
      "expected" : "4",
      "input" : "n = 5, bad = 4",
      "slug" : "first-bad-version",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:85: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:57: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                         `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "n = 10, pick = 6",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:85: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:57: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                         `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "n = 1, pick = 1",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:85: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_1\/solution.swift:4:57: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { for i in 1...n { if guess(i) == 0 { return i } } return -1 }\n    |                                                         `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 2, pick = 2",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:241: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:134: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                      `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "n = 10, pick = 6",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:241: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:134: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                      `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "n = 1, pick = 1",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:241: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower_2\/solution.swift:4:134: error: cannot find 'guess' in scope\n  2 | \n  3 | class Solution {\n  4 | func guessNumber(_ n: Int) -> Int { var left = 1, right = n; while left <= right { let mid = left + (right - left) \/ 2; let result = guess(mid); if result == 0 { return mid } else if result == 1 { left = mid + 1 } else { right = mid - 1 } } return -1 }\n    |                                                                                                                                      `- error: cannot find 'guess' in scope\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 2, pick = 2",
      "slug" : "guess-number-higher-or-lower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_1\/solution.swift:4:198: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let sortedCitations = citations.sorted(by: >); var hIndex = 0; for (i, citation) in sortedCitations.enumerated() { if citation >= i + 1 { hIndex = i + 1 } } return hIndex }\n    |                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "citations = [1,3,1]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_1\/solution.swift:4:198: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let sortedCitations = citations.sorted(by: >); var hIndex = 0; for (i, citation) in sortedCitations.enumerated() { if citation >= i + 1 { hIndex = i + 1 } } return hIndex }\n    |                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "citations = [1,3,7,4,1]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let n = citations.count; var low = 0; var high = n; while low <= high { let mid = low + (high - low) \/ 2; if citations.count - mid <= mid && citations[citations.count - mid] >= mid { low = mid + 1 } else { high = mid - 1 } } return low }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "citations = [1,3,1]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let n = citations.count; var low = 0; var high = n; while low <= high { let mid = low + (high - low) \/ 2; if citations.count - mid <= mid && citations[citations.count - mid] >= mid { low = mid + 1 } else { high = mid - 1 } } return low }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "citations = [100]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let n = citations.count; var low = 0; var high = n; while low <= high { let mid = low + (high - low) \/ 2; if citations.count - mid <= mid && citations[citations.count - mid] >= mid { low = mid + 1 } else { high = mid - 1 } } return low }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "citations = [1,3,7,4,1]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/h-index-ii_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func hIndex(_ citations: [Int]) -> Int { let n = citations.count; var low = 0; var high = n; while low <= high { let mid = low + (high - low) \/ 2; if citations.count - mid <= mid && citations[citations.count - mid] >= mid { low = mid + 1 } else { high = mid - 1 } } return low }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "citations = [0,0,0,1]",
      "slug" : "h-index-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 3
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-smallest-element-in-a-sorted-matrix_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n",
      "expected" : "13",
      "input" : "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
      "slug" : "kth-smallest-element-in-a-sorted-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-smallest-element-in-a-sorted-matrix_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n",
      "expected" : "11",
      "input" : "matrix = [[1,3,5],[6,7,12],[11,14,14]], k = 6",
      "slug" : "kth-smallest-element-in-a-sorted-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Min-Heap Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-smallest-element-in-a-sorted-matrix_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n",
      "expected" : "13",
      "input" : "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
      "slug" : "kth-smallest-element-in-a-sorted-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Min-Heap Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-smallest-element-in-a-sorted-matrix_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n",
      "expected" : "11",
      "input" : "matrix = [[1,3,5],[6,7,12],[11,14,14]], k = 6",
      "slug" : "kth-smallest-element-in-a-sorted-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Optimized with Hashing",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
      "slug" : "maximum-length-of-repeated-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'book'\n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "true, false",
      "input" : "let cal = MyCalendar(); cal.book(10, 20); cal.book(15, 25)",
      "slug" : "my-calendar-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'book'\n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "true, true",
      "input" : "let cal = MyCalendar(); cal.book(10, 20); cal.book(25, 35)",
      "slug" : "my-calendar-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class MyCalendar {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'book'\n249 | let arg0 = toInt(valueAt(args, 0))\n250 | let arg1 = toInt(valueAt(args, 1))\n251 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n",
      "expected" : "true, false",
      "input" : "let cal = MyCalendar(); cal.book(10, 20); cal.book(15, 25)",
      "slug" : "my-calendar-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class MyCalendar {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-i_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'book'\n249 | let arg0 = toInt(valueAt(args, 0))\n250 | let arg1 = toInt(valueAt(args, 1))\n251 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n",
      "expected" : "true, true",
      "input" : "let cal = MyCalendar(); cal.book(10, 20); cal.book(25, 35)",
      "slug" : "my-calendar-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-ii_1\/solution.swift:241:23: error: value of type 'Solution' has no member 'book'\n239 | let arg0 = toInt(valueAt(args, 0))\n240 | let arg1 = toInt(valueAt(args, 1))\n241 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MyCalendarTwo(), book(10, 20), book(50, 60), book(10, 40)",
      "slug" : "my-calendar-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-ii_1\/solution.swift:241:23: error: value of type 'Solution' has no member 'book'\n239 | let arg0 = toInt(valueAt(args, 0))\n240 | let arg1 = toInt(valueAt(args, 1))\n241 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n242 | let output: Any = result\n243 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MyCalendarTwo(), book(5, 15), book(7, 9)",
      "slug" : "my-calendar-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Segment Tree",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-ii_2\/solution.swift:247:23: error: value of type 'Solution' has no member 'book'\n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MyCalendarTwo(), book(10, 20), book(50, 60), book(10, 40)",
      "slug" : "my-calendar-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Segment Tree",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/my-calendar-ii_2\/solution.swift:247:23: error: value of type 'Solution' has no member 'book'\n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let arg1 = toInt(valueAt(args, 1))\n247 | let result = solution.book(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'book'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "MyCalendarTwo(), book(5, 15), book(7, 9)",
      "slug" : "my-calendar-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_1\/solution.swift:253:23: error: value of type 'Solution' has no member 'q'\n251 | \n252 | let arg0 = toInt(valueAt(args, 0))\n253 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n254 | let output: Any = result\n255 | print(jsonString(from: output))\n",
      "expected" : "0",
      "input" : "person = [0], times = [0], t = 0",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_1\/solution.swift:253:23: error: value of type 'Solution' has no member 'q'\n251 | \n252 | let arg0 = toInt(valueAt(args, 0))\n253 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n254 | let output: Any = result\n255 | print(jsonString(from: output))\n",
      "expected" : "0",
      "input" : "person = [0,1,1], times = [0,5,10], t = 5",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_1\/solution.swift:253:23: error: value of type 'Solution' has no member 'q'\n251 | \n252 | let arg0 = toInt(valueAt(args, 0))\n253 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n254 | let output: Any = result\n255 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "person = [0,1,1], times = [0,5,10], t = 10",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:274:23: error: value of type 'Solution' has no member 'q'\n272 | \n273 | let arg0 = toInt(valueAt(args, 0))\n274 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n275 | let output: Any = result\n276 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:17:33: warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 15 |                    personTime = zip(person, times).sorted { $0.1 < $1.1 }\n 16 | \n 17 |                    for (person, time) in personTime {\n    |                                 `- warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 18 |                        votes[person, default: 0] += 1\n 19 |                        if votes[person]! > maxVote {\n",
      "expected" : "0",
      "input" : "person = [0], times = [0], t = 0",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:274:23: error: value of type 'Solution' has no member 'q'\n272 | \n273 | let arg0 = toInt(valueAt(args, 0))\n274 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n275 | let output: Any = result\n276 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:17:33: warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 15 |                    personTime = zip(person, times).sorted { $0.1 < $1.1 }\n 16 | \n 17 |                    for (person, time) in personTime {\n    |                                 `- warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 18 |                        votes[person, default: 0] += 1\n 19 |                        if votes[person]! > maxVote {\n",
      "expected" : "0",
      "input" : "person = [0,1,1], times = [0,5,10], t = 5",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:274:23: error: value of type 'Solution' has no member 'q'\n272 | \n273 | let arg0 = toInt(valueAt(args, 0))\n274 | let result = solution.q(arg0)\n    |                       `- error: value of type 'Solution' has no member 'q'\n275 | let output: Any = result\n276 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/online-election_2\/solution.swift:17:33: warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 15 |                    personTime = zip(person, times).sorted { $0.1 < $1.1 }\n 16 | \n 17 |                    for (person, time) in personTime {\n    |                                 `- warning: immutable value 'time' was never used; consider replacing with '_' or removing it [#no-usage]\n 18 |                        votes[person, default: 0] += 1\n 19 |                        if votes[person]! > maxVote {\n",
      "expected" : "1",
      "input" : "person = [0,1,1], times = [0,5,10], t = 10",
      "slug" : "online-election",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peak-index-in-a-mountain-array_1\/solution.swift:4:124: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func peakIndexInMountainArray(_ A: [Int]) -> Int { for i in 1..<A.count-1 where A[i-1] < A[i] && A[i] > A[i+1] { return i } return -1 }\n    |                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "nums = [0,1,2,1,2,3,5,4,3,1,0]",
      "slug" : "peak-index-in-a-mountain-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peak-index-in-a-mountain-array_1\/solution.swift:4:124: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func peakIndexInMountainArray(_ A: [Int]) -> Int { for i in 1..<A.count-1 where A[i-1] < A[i] && A[i] > A[i+1] { return i } return -1 }\n    |                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "nums = [0,2,1,0]",
      "slug" : "peak-index-in-a-mountain-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peak-index-in-a-mountain-array_2\/solution.swift:4:209: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func peakIndexInMountainArray(_ A: [Int]) -> Int { var left = 0, right = A.count - 1; while left < right { let mid = left + (right - left) \/ 2; if A[mid] < A[mid + 1] { left = mid + 1 } else { right = mid } } return left }\n    |                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "nums = [0,3,2,1]",
      "slug" : "peak-index-in-a-mountain-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Binary Search Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/peak-index-in-a-mountain-array_2\/solution.swift:4:209: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func peakIndexInMountainArray(_ A: [Int]) -> Int { var left = 0, right = A.count - 1; while left < right { let mid = left + (right - left) \/ 2; if A[mid] < A[mid + 1] { left = mid + 1 } else { right = mid } } return left }\n    |                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "nums = [3,5,6,2,1,0]",
      "slug" : "peak-index-in-a-mountain-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-rotated-sorted-array-ii_1\/solution.swift:4:105: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func search(_ nums: [Int], _ target: Int) -> Bool { for num in nums { if num == target { return true } } return false }\n    |                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [2,5,6,0,0,1,2], target = 0",
      "slug" : "search-in-rotated-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-rotated-sorted-array-ii_1\/solution.swift:4:105: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func search(_ nums: [Int], _ target: Int) -> Bool { for num in nums { if num == target { return true } } return false }\n    |                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [2,5,6,0,0,1,2], target = 3",
      "slug" : "search-in-rotated-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Modified Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-rotated-sorted-array-ii_2\/solution.swift:4:465: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func search(_ nums: [Int], _ target: Int) -> Bool { var left = 0; var right = nums.count - 1; while left <= right { let mid = left + (right - left) \/ 2; if nums[mid] == target { return true } else if nums[left] == nums[mid] { left += 1 } else if nums[left] < nums[mid] { if nums[left] <= target && target < nums[mid] { right = mid - 1 } else { left = mid + 1 } } else { if nums[mid] < target && target <= nums[right] { left = mid + 1 } else { right = mid - 1 } } } return false }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [2,5,6,0,0,1,2], target = 0",
      "slug" : "search-in-rotated-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Modified Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-rotated-sorted-array-ii_2\/solution.swift:4:465: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func search(_ nums: [Int], _ target: Int) -> Bool { var left = 0; var right = nums.count - 1; while left <= right { let mid = left + (right - left) \/ 2; if nums[mid] == target { return true } else if nums[left] == nums[mid] { left += 1 } else if nums[left] < nums[mid] { if nums[left] <= target && target < nums[mid] { right = mid - 1 } else { left = mid + 1 } } else { if nums[mid] < target && target <= nums[right] { left = mid + 1 } else { right = mid - 1 } } } return false }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [2,5,6,0,0,1,2], target = 3",
      "slug" : "search-in-rotated-sorted-array-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "9",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "13",
      "input" : "nums = [1,2,3,4,5], k = 20",
      "slug" : "subarray-product-less-than-k",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "9",
      "approachName" : "Sliding Window Approach",
      "approachOrder" : 2,
      "expected" : "13",
      "input" : "nums = [1,2,3,4,5], k = 20",
      "slug" : "subarray-product-less-than-k",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_1\/solution.swift:251:23: error: value of type 'Solution' has no member 'set'\n249 | let arg1 = toString(valueAt(args, 1))\n250 | let arg2 = toInt(valueAt(args, 2))\n251 | let result = solution.set(arg0, arg1, arg2)\n    |                       `- error: value of type 'Solution' has no member 'set'\n252 | let output: Any = NSNull()\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_1\/solution.swift:18:101: error: value of tuple type 'EnumeratedSequence<[(String, Int)]>.Element' (aka '(offset: Int, element: (String, Int))') has no member 'index'\n 16 |                        return \"\"\n 17 |                    }\n 18 |                    let index = store[key]!.enumerated().first(where: { $0.element.1 > timestamp })?.index ?? store[key]!.count\n    |                                                                                                     `- error: value of tuple type 'EnumeratedSequence<[(String, Int)]>.Element' (aka '(offset: Int, element: (String, Int))') has no member 'index'\n 19 |                    if index == 0 {\n 20 |                        return \"\"\n",
      "expected" : "\"bar\"",
      "input" : "TimeKeyValStore().set(\"foo\", \"bar\", 1); TimeKeyValStore().get(\"foo\", 1);",
      "slug" : "time-based-key-value-store",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_1\/solution.swift:251:23: error: value of type 'Solution' has no member 'set'\n249 | let arg1 = toString(valueAt(args, 1))\n250 | let arg2 = toInt(valueAt(args, 2))\n251 | let result = solution.set(arg0, arg1, arg2)\n    |                       `- error: value of type 'Solution' has no member 'set'\n252 | let output: Any = NSNull()\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_1\/solution.swift:18:101: error: value of tuple type 'EnumeratedSequence<[(String, Int)]>.Element' (aka '(offset: Int, element: (String, Int))') has no member 'index'\n 16 |                        return \"\"\n 17 |                    }\n 18 |                    let index = store[key]!.enumerated().first(where: { $0.element.1 > timestamp })?.index ?? store[key]!.count\n    |                                                                                                     `- error: value of tuple type 'EnumeratedSequence<[(String, Int)]>.Element' (aka '(offset: Int, element: (String, Int))') has no member 'index'\n 19 |                    if index == 0 {\n 20 |                        return \"\"\n",
      "expected" : "\"baz\"",
      "input" : "TimeKeyValStore().set(\"foo\", \"bar\", 1); TimeKeyValStore().set(\"foo\", \"baz\", 2); TimeKeyValStore().get(\"foo\", 3);",
      "slug" : "time-based-key-value-store",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_2\/solution.swift:268:23: error: value of type 'Solution' has no member 'set'\n266 | let arg1 = toString(valueAt(args, 1))\n267 | let arg2 = toInt(valueAt(args, 2))\n268 | let result = solution.set(arg0, arg1, arg2)\n    |                       `- error: value of type 'Solution' has no member 'set'\n269 | let output: Any = NSNull()\n270 | print(jsonString(from: output))\n",
      "expected" : "\"bar\"",
      "input" : "TimeKeyValStore().set(\"foo\", \"bar\", 1); TimeKeyValStore().get(\"foo\", 1);",
      "slug" : "time-based-key-value-store",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/time-based-key-value-store_2\/solution.swift:268:23: error: value of type 'Solution' has no member 'set'\n266 | let arg1 = toString(valueAt(args, 1))\n267 | let arg2 = toInt(valueAt(args, 2))\n268 | let result = solution.set(arg0, arg1, arg2)\n    |                       `- error: value of type 'Solution' has no member 'set'\n269 | let output: Any = NSNull()\n270 | print(jsonString(from: output))\n",
      "expected" : "\"baz\"",
      "input" : "TimeKeyValStore().set(\"foo\", \"bar\", 1); TimeKeyValStore().set(\"foo\", \"baz\", 2); TimeKeyValStore().get(\"foo\", 3);",
      "slug" : "time-based-key-value-store",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "nums = [3, 1, 3, 6]",
      "slug" : "array-of-doubled-pairs",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "nums = [2, 1, 2, 6]",
      "slug" : "array-of-doubled-pairs",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "false",
      "input" : "nums = [3, 1, 3, 6]",
      "slug" : "array-of-doubled-pairs",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "false",
      "input" : "nums = [2, 1, 2, 6]",
      "slug" : "array-of-doubled-pairs",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/array-partition_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func arrayPairSum(_ nums: [Int]) -> Int {\n",
      "expected" : "4",
      "input" : "nums = [1,4,3,2]",
      "slug" : "array-partition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/array-partition_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func arrayPairSum(_ nums: [Int]) -> Int {\n",
      "expected" : "1",
      "input" : "nums = [1,2]",
      "slug" : "array-partition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/array-partition_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func arrayPairSum(_ nums: [Int]) -> Int {\n",
      "expected" : "4",
      "input" : "nums = [1,4,3,2]",
      "slug" : "array-partition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/array-partition_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func arrayPairSum(_ nums: [Int]) -> Int {\n",
      "expected" : "1",
      "input" : "nums = [1,2]",
      "slug" : "array-partition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/can-place-flowers_2\/solution.swift:8:22: error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  6 |     for i in 0..<flowerbed.count { \n  7 |         if flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.count-1 || flowerbed[i+1] == 0) { \n  8 |             flowerbed[i] = 1 \n    |                      `- error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  9 |             count += 1 \n 10 |         } \n",
      "expected" : "true",
      "input" : "flowerbed = [1,0,0,0,1], n = 1",
      "slug" : "can-place-flowers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/can-place-flowers_2\/solution.swift:8:22: error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  6 |     for i in 0..<flowerbed.count { \n  7 |         if flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.count-1 || flowerbed[i+1] == 0) { \n  8 |             flowerbed[i] = 1 \n    |                      `- error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  9 |             count += 1 \n 10 |         } \n",
      "expected" : "false",
      "input" : "flowerbed = [1,0,0,0,1], n = 2",
      "slug" : "can-place-flowers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/can-place-flowers_2\/solution.swift:8:22: error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  6 |     for i in 0..<flowerbed.count { \n  7 |         if flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.count-1 || flowerbed[i+1] == 0) { \n  8 |             flowerbed[i] = 1 \n    |                      `- error: cannot assign through subscript: 'flowerbed' is a 'let' constant\n  9 |             count += 1 \n 10 |         } \n",
      "expected" : "true",
      "input" : "flowerbed = [0,0,0,0,0], n = 3",
      "slug" : "can-place-flowers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minDeletionSize(_ strs: [String]) -> Int {\n",
      "expected" : "1",
      "input" : "strs = [\"cba\",\"daf\",\"ghi\"]",
      "slug" : "delete-columns-to-make-sorted-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minDeletionSize(_ strs: [String]) -> Int {\n",
      "expected" : "0",
      "input" : "strs = [\"a\",\"b\"]",
      "slug" : "delete-columns-to-make-sorted-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minDeletionSize(_ strs: [String]) -> Int {\n",
      "expected" : "1",
      "input" : "strs = [\"cba\",\"daf\",\"ghi\"]",
      "slug" : "delete-columns-to-make-sorted-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-columns-to-make-sorted-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minDeletionSize(_ strs: [String]) -> Int {\n",
      "expected" : "0",
      "input" : "strs = [\"a\",\"b\"]",
      "slug" : "delete-columns-to-make-sorted-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"Radiant\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "Radiant",
      "input" : "senate = \"RD\"",
      "slug" : "dota2-senate",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"Radiant\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "Radiant",
      "input" : "senate = \"RDRD\"",
      "slug" : "dota2-senate",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"Radiant\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "Radiant",
      "input" : "senate = \"RD\"",
      "slug" : "dota2-senate",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"Radiant\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "Radiant",
      "input" : "senate = \"RDRD\"",
      "slug" : "dota2-senate",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "hand = [1,2,3,6,2,3,4,7,8], W = 3",
      "slug" : "hand-of-straights",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/hand-of-straights_2\/solution.swift:22:41: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  6 |            class Solution {\n  7 |                func isNStraightHand(_ hand: [Int], _ W: Int) -> Bool {\n  8 |                    let count = Dictionary(grouping: hand, by: { $0 }).mapValues { $0.count }\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    let sortedKeys = count.keys.sorted()\n 10 |                    var index = 0\n    :\n 20 |                                return false\n 21 |                            }\n 22 |                            count[next]! -= 1\n    |                                         `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n 23 |                        }\n 24 |                        index += 1\n",
      "expected" : "true",
      "input" : "hand = [1,2,3,6,2,3,4,7,8], W = 3",
      "slug" : "hand-of-straights",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/hand-of-straights_2\/solution.swift:22:41: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  6 |            class Solution {\n  7 |                func isNStraightHand(_ hand: [Int], _ W: Int) -> Bool {\n  8 |                    let count = Dictionary(grouping: hand, by: { $0 }).mapValues { $0.count }\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    let sortedKeys = count.keys.sorted()\n 10 |                    var index = 0\n    :\n 20 |                                return false\n 21 |                            }\n 22 |                            count[next]! -= 1\n    |                                         `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n 23 |                        }\n 24 |                        index += 1\n",
      "expected" : "false",
      "input" : "hand = [1,2,3,4,5], W = 4",
      "slug" : "hand-of-straights",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:7:9: warning: variable 'numsStr' was never mutated; consider changing to 'let' constant\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n  7 |     var numsStr = nums.map { String($0) }\n    |         `- warning: variable 'numsStr' was never mutated; consider changing to 'let' constant\n  8 |     var maxNum = \"\"\n  9 |     let count = numsStr.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:9:9: warning: initialization of immutable value 'count' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  7 |     var numsStr = nums.map { String($0) }\n  8 |     var maxNum = \"\"\n  9 |     let count = numsStr.count\n    |         `- warning: initialization of immutable value 'count' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n 10 |     var permutations: [[String]] = [[]]\n 11 |     for num in numsStr {\n",
      "expected" : "9534330",
      "input" : "nums = [3,30,34,5,9]",
      "slug" : "largest-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:7:9: warning: variable 'numsStr' was never mutated; consider changing to 'let' constant\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n  7 |     var numsStr = nums.map { String($0) }\n    |         `- warning: variable 'numsStr' was never mutated; consider changing to 'let' constant\n  8 |     var maxNum = \"\"\n  9 |     let count = numsStr.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_1\/solution.swift:9:9: warning: initialization of immutable value 'count' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  7 |     var numsStr = nums.map { String($0) }\n  8 |     var maxNum = \"\"\n  9 |     let count = numsStr.count\n    |         `- warning: initialization of immutable value 'count' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n 10 |     var permutations: [[String]] = [[]]\n 11 |     for num in numsStr {\n",
      "expected" : "77641510",
      "input" : "nums = [10,7,76,415]",
      "slug" : "largest-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n",
      "expected" : "9534330",
      "input" : "nums = [3,30,34,5,9]",
      "slug" : "largest-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-number_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func largestNumber(_ nums: [Int]) -> String {\n",
      "expected" : "77641510",
      "input" : "nums = [10,7,76,415]",
      "slug" : "largest-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "bills = [5,5,10,20]",
      "slug" : "lemonade-change",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/lemonade-change_2\/solution.swift:10:26: error: expected '{' after 'if' condition\n  8 |             five += 1\n  9 |         } else if bill == 10 {\n 10 |             if five == 0 return false\n    |                          `- error: expected '{' after 'if' condition\n 11 |             five -= 1; ten += 1\n 12 |         } else if bill == 20 {\n",
      "expected" : "true",
      "input" : "bills = [5,5,5,10,20]",
      "slug" : "lemonade-change",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/lemonade-change_2\/solution.swift:10:26: error: expected '{' after 'if' condition\n  8 |             five += 1\n  9 |         } else if bill == 10 {\n 10 |             if five == 0 return false\n    |                          `- error: expected '{' after 'if' condition\n 11 |             five -= 1; ten += 1\n 12 |         } else if bill == 20 {\n",
      "expected" : "true",
      "input" : "bills = [5,5,10]",
      "slug" : "lemonade-change",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "4",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "8",
      "input" : "s = \"abccccdd\"",
      "slug" : "longest-palindrome",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "7",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "8",
      "input" : "s = \"abccccdd\"",
      "slug" : "longest-palindrome",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "-41",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "35",
      "input" : "grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]",
      "slug" : "max-increase-to-keep-city-skyline",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "17",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "22",
      "input" : "nums = [2,7,11,15], k = 2",
      "slug" : "maximize-sum-of-array-after-k-negations",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "-35",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "28",
      "input" : "nums = [2,7,11,15], k = 4",
      "slug" : "maximize-sum-of-array-after-k-negations",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "nums = [4,2,3], k = 1",
      "slug" : "maximize-sum-of-array-after-k-negations",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "brute-force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:218: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:249: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:325: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:357: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:422: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:471: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "people = [1,0,0,0,1,0,0,1]",
      "slug" : "maximum-distance-in-arrays",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "brute-force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:218: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:249: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:325: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:357: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:422: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_1\/solution.swift:4:471: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(people: [Int]) -> Int { let n = people.count; var left = [Int](repeating: n, count: n); var right = [Int](repeating: -1, count: n); var index = n; for i in 0..<n { if people[i] == 1 { index = 0 } left[i] = index; index += 1; } index = -1; for i in (0...n-1).reversed() { if people[i] == 1 { index = 0 } right[i] = index; index += 1; } var maxDist = 0; for i in 0..<n { if people[i] == 1 { continue } maxDist = max(maxDist, min(left[i], right[i])) } return maxDist }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "people = [1,0,0,0]",
      "slug" : "maximum-distance-in-arrays",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_2\/solution.swift:4:218: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(seats: [Int]) -> Int { var maxDist = 0; var last1 = -1; for i in 0..<seats.count { if seats[i] == 1 { if last1 == -1 { maxDist = max(maxDist, i) } else { maxDist = max(maxDist, (i - last1) \/ 2) } last1 = i } } maxDist = max(maxDist, seats.count - 1 - last1); return maxDist }\n    |                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(seats: [Int]) -> Int { var maxDist = 0; var last1 = -1; for i in 0..<seats.count { if seats[i] == 1 { if last1 == -1 { maxDist = max(maxDist, i) } else { maxDist = max(maxDist, (i - last1) \/ 2) } last1 = i } } maxDist = max(maxDist, seats.count - 1 - last1); return maxDist }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "seats = [1,0,0,0,1,0,0,1]",
      "slug" : "maximum-distance-in-arrays",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_2\/solution.swift:4:218: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(seats: [Int]) -> Int { var maxDist = 0; var last1 = -1; for i in 0..<seats.count { if seats[i] == 1 { if last1 == -1 { maxDist = max(maxDist, i) } else { maxDist = max(maxDist, (i - last1) \/ 2) } last1 = i } } maxDist = max(maxDist, seats.count - 1 - last1); return maxDist }\n    |                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-distance-in-arrays_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxDistToClosest(seats: [Int]) -> Int { var maxDist = 0; var last1 = -1; for i in 0..<seats.count { if seats[i] == 1 { if last1 == -1 { maxDist = max(maxDist, i) } else { maxDist = max(maxDist, (i - last1) \/ 2) } last1 = i } } maxDist = max(maxDist, seats.count - 1 - last1); return maxDist }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "seats = [1,0,0,0]",
      "slug" : "maximum-distance-in-arrays",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "-1",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]",
      "slug" : "minimum-domino-rotations-for-equal-row",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-increment-to-make-array-unique_1\/solution.swift:11:23: error: left side of mutating operator isn't mutable: 'sorted' is a 'let' constant\n  3 | class Solution {\n  4 | func minIncrementForUnique(_ A: [Int]) -> Int { \n  5 |     let sorted = A.sorted() \n    |     `- note: change 'let' to 'var' to make it mutable\n  6 |     var result = 0 \n  7 |     for i in 1..<sorted.count { \n    :\n  9 |             let increment = sorted[i-1] - sorted[i] + 1 \n 10 |             result += increment \n 11 |             sorted[i] += increment \n    |                       `- error: left side of mutating operator isn't mutable: 'sorted' is a 'let' constant\n 12 |         } \n 13 |     } \n",
      "expected" : "6",
      "input" : "nums = [3, 2, 1, 2, 1, 7]",
      "slug" : "minimum-increment-to-make-array-unique",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-increment-to-make-array-unique_1\/solution.swift:11:23: error: left side of mutating operator isn't mutable: 'sorted' is a 'let' constant\n  3 | class Solution {\n  4 | func minIncrementForUnique(_ A: [Int]) -> Int { \n  5 |     let sorted = A.sorted() \n    |     `- note: change 'let' to 'var' to make it mutable\n  6 |     var result = 0 \n  7 |     for i in 1..<sorted.count { \n    :\n  9 |             let increment = sorted[i-1] - sorted[i] + 1 \n 10 |             result += increment \n 11 |             sorted[i] += increment \n    |                       `- error: left side of mutating operator isn't mutable: 'sorted' is a 'let' constant\n 12 |         } \n 13 |     } \n",
      "expected" : "2",
      "input" : "nums = [1, 1, 2]",
      "slug" : "minimum-increment-to-make-array-unique",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Greedy Approach",
      "approachOrder" : 2,
      "expected" : "6",
      "input" : "nums = [3, 2, 1, 2, 1, 7]",
      "slug" : "minimum-increment-to-make-array-unique",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Greedy Approach",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums = [1,1,1]",
      "slug" : "minimum-increment-to-make-array-unique",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-number-of-arrows-to-burst-balloons_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func findMinArrowShots(_ points: [[Int]]) -> Int {\n",
      "expected" : "2",
      "input" : "points = [[10,16],[2,8],[1,6],[7,12]]",
      "slug" : "minimum-number-of-arrows-to-burst-balloons",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-number-of-arrows-to-burst-balloons_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func findMinArrowShots(_ points: [[Int]]) -> Int {\n",
      "expected" : "4",
      "input" : "points = [[1,2],[3,4],[5,6],[7,8]]",
      "slug" : "minimum-number-of-arrows-to-burst-balloons",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-number-of-arrows-to-burst-balloons_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func findMinArrowShots(_ points: [[Int]]) -> Int {\n",
      "expected" : "2",
      "input" : "points = [[10,16],[2,8],[1,6],[7,12]]",
      "slug" : "minimum-number-of-arrows-to-burst-balloons",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-number-of-arrows-to-burst-balloons_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func findMinArrowShots(_ points: [[Int]]) -> Int {\n",
      "expected" : "4",
      "input" : "points = [[1,2],[3,4],[5,6],[7,8]]",
      "slug" : "minimum-number-of-arrows-to-burst-balloons",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "10",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "39",
      "input" : "[[0,0,1,1],[1,0,1,0],[1,1,0,0]]",
      "slug" : "score-after-flipping-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "10",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "33",
      "input" : "[[0,1,1,0],[1,1,1,1],[0,1,0,0]]",
      "slug" : "score-after-flipping-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "10",
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "expected" : "39",
      "input" : "[[0,0,1,1],[1,0,1,0],[1,1,0,0]]",
      "slug" : "score-after-flipping-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "10",
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "expected" : "33",
      "input" : "[[0,1,1,0],[1,1,1,1],[0,1,0,0]]",
      "slug" : "score-after-flipping-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "9",
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "expected" : "30",
      "input" : "[[0,0,0,0],[1,0,1,0],[1,1,0,0]]",
      "slug" : "score-after-flipping-matrix",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-consecutive-subsequences_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isPossible(_ nums: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "nums = [1,2,3,3,4,5]",
      "slug" : "split-array-into-consecutive-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-consecutive-subsequences_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isPossible(_ nums: [Int]) -> Bool {\n",
      "expected" : "false",
      "input" : "nums = [1,2,3,4,4,5]",
      "slug" : "split-array-into-consecutive-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-consecutive-subsequences_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isPossible(_ nums: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "nums = [1,2,3,3,4,5]",
      "slug" : "split-array-into-consecutive-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-consecutive-subsequences_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func isPossible(_ nums: [Int]) -> Bool {\n",
      "expected" : "false",
      "input" : "nums = [1,2,3,4,4,5]",
      "slug" : "split-array-into-consecutive-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:554: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:488: error: cannot use mutating member on immutable value: 'a' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot use mutating member on immutable value: 'a' is a 'let' constant\n    |                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:527: error: cannot use mutating member on immutable value: 'b' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'b' is a 'let' constant\n    |                                                                                               `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "BAB",
      "input" : "A = 1, B = 2",
      "slug" : "string-without-aaa-or-bbb",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:554: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:488: error: cannot use mutating member on immutable value: 'a' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot use mutating member on immutable value: 'a' is a 'let' constant\n    |                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_1\/solution.swift:4:527: error: cannot use mutating member on immutable value: 'b' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { let a = String(repeating: \"A\", count: A); let b = String(repeating: \"B\", count: B); let n = a.count + b.count; var result = \"\/\"; var idx = 0; while idx < n { if result.count >= 2 && result[result.index(result.startIndex, offsetBy: result.count - 1)] == result[result.index(result.startIndex, offsetBy: result.count - 2)] { if result.last == \"A\" { result += \"B\" } else { result += \"A\" } } else { if a.count > b.count { result += \"A\"; a.removeLast() } else { result += \"B\"; b.removeLast() } } idx += 1 } return String(result.dropFirst()) }\n    |                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'b' is a 'let' constant\n    |                                                                                               `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "AABB",
      "input" : "A = 2, B = 2",
      "slug" : "string-without-aaa-or-bbb",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_2\/solution.swift:4:458: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { var res = String(); var a = A; var b = B; while a > 0 || b > 0 { if res.count >= 2, res.last == res[res.index(before: res.index(before: res.endIndex))] { if res.last == \"A\" { if b > 0 { res += \"B\"; b -= 1 } else { res += \"A\"; a -= 1 } } else { if a > 0 { res += \"A\"; a -= 1 } else { res += \"B\"; b -= 1 } } } else { if a >= b { if a > 0 { res += \"A\"; a -= 1 } } else { if b > 0 { res += \"B\"; b -= 1 } } } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "BAB",
      "input" : "A = 1, B = 2",
      "slug" : "string-without-aaa-or-bbb",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/string-without-aaa-or-bbb_2\/solution.swift:4:458: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func strWithout3a3b(_ A: Int, _ B: Int) -> String { var res = String(); var a = A; var b = B; while a > 0 || b > 0 { if res.count >= 2, res.last == res[res.index(before: res.index(before: res.endIndex))] { if res.last == \"A\" { if b > 0 { res += \"B\"; b -= 1 } else { res += \"A\"; a -= 1 } } else { if a > 0 { res += \"A\"; a -= 1 } else { res += \"B\"; b -= 1 } } } else { if a >= b { if a > 0 { res += \"A\"; a -= 1 } } else { if b > 0 { res += \"B\"; b -= 1 } } } } return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "ABABABAA",
      "input" : "A = 4, B = 1",
      "slug" : "string-without-aaa-or-bbb",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_1\/solution.swift:31:35: error: ambiguous use of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: found this candidate \n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    |                                   `- error: ambiguous use of 'solution'\n 32 |            print(wiggleSortedNums)\n 33 |            \n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- note: found this candidate \n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_1\/solution.swift:253:5: error: invalid redeclaration of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: 'solution' previously declared here\n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- error: invalid redeclaration of 'solution'\n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n",
      "expected" : "[1,6,1,5,1,4]",
      "input" : "nums = [1,5,1,1,6,4]",
      "slug" : "wiggle-sort-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_1\/solution.swift:31:35: error: ambiguous use of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: found this candidate \n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    |                                   `- error: ambiguous use of 'solution'\n 32 |            print(wiggleSortedNums)\n 33 |            \n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- note: found this candidate \n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_1\/solution.swift:253:5: error: invalid redeclaration of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: 'solution' previously declared here\n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- error: invalid redeclaration of 'solution'\n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n",
      "expected" : "[2,1,3,2,3,1]",
      "input" : "nums = [1,3,2,2,3,1]",
      "slug" : "wiggle-sort-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_2\/solution.swift:31:35: error: ambiguous use of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: found this candidate \n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    |                                   `- error: ambiguous use of 'solution'\n 32 |            print(wiggleSortedNums)\n 33 |            \n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- note: found this candidate \n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_2\/solution.swift:253:5: error: invalid redeclaration of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: 'solution' previously declared here\n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- error: invalid redeclaration of 'solution'\n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n",
      "expected" : "[1,6,1,5,1,4]",
      "input" : "nums = [1,5,1,1,6,4]",
      "slug" : "wiggle-sort-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_2\/solution.swift:31:35: error: ambiguous use of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: found this candidate \n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    |                                   `- error: ambiguous use of 'solution'\n 32 |            print(wiggleSortedNums)\n 33 |            \n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- note: found this candidate \n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/wiggle-sort-ii_2\/solution.swift:253:5: error: invalid redeclaration of 'solution'\n 27 |            }\n 28 | \n 29 |            let solution = Solution()\n    |                `- note: 'solution' previously declared here\n 30 |            let nums = [1, 5, 1, 1, 6, 4]\n 31 |            let wiggleSortedNums = solution.wiggleSort(nums)\n    :\n251 | let args = parseArgs(from: input, expectedCount: 1)\n252 | let hasInput = !args.isEmpty\n253 | let solution = Solution()\n    |     `- error: invalid redeclaration of 'solution'\n254 | \n255 | let arg0 = toArray(valueAt(args, 0)) { toInt($0) }\n",
      "expected" : "[1,3,1,3,2,2]",
      "input" : "nums = [1,3,2,2,3,1]",
      "slug" : "wiggle-sort-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "1 -> 0 -> 8 -> 6",
      "input" : "nums = [7,3,9], nums = [8,6,4]",
      "slug" : "add-two-numbers-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "5 -> 8 -> 19",
      "input" : "nums = [2,7,11,15], nums = [3,1,8]",
      "slug" : "add-two-numbers-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:20:24: error: cannot assign to value: 'l1' is a 'let' constant\n 18 |                    let maxHeight = max(length1, length2)\n 19 |                    if length1 < length2 {\n 20 |                        l1 = padWithZeros(l1, length2 - length1)\n    |                        `- error: cannot assign to value: 'l1' is a 'let' constant\n 21 |                    } else if length2 < length1 {\n 22 |                        l2 = padWithZeros(l2, length1 - length2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:22:24: error: cannot assign to value: 'l2' is a 'let' constant\n 20 |                        l1 = padWithZeros(l1, length2 - length1)\n 21 |                    } else if length2 < length1 {\n 22 |                        l2 = padWithZeros(l2, length1 - length2)\n    |                        `- error: cannot assign to value: 'l2' is a 'let' constant\n 23 |                    }\n 24 |                    let solution = addTwoNumbersRecursive(l1, l2, maxHeight, 0, 0)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:34:28: error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 30 |                        return nil\n 31 |                    }\n 32 |                    let sum = carry\n    |                    `- note: change 'let' to 'var' to make it mutable\n 33 |                    if l1 != nil {\n 34 |                        sum += l1!.val\n    |                            `- error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 35 |                    }\n 36 |                    if l2 != nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:37:28: error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 30 |                        return nil\n 31 |                    }\n 32 |                    let sum = carry\n    |                    `- note: change 'let' to 'var' to make it mutable\n 33 |                    if l1 != nil {\n 34 |                        sum += l1!.val\n 35 |                    }\n 36 |                    if l2 != nil {\n 37 |                        sum += l2!.val\n    |                            `- error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 38 |                    }\n 39 |                    let newNode = ListNode(sum % 10)\n",
      "expected" : "7 -> 0 -> 8",
      "input" : "nums = [2,4,3], nums = [5,6,4]",
      "slug" : "add-two-numbers-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:20:24: error: cannot assign to value: 'l1' is a 'let' constant\n 18 |                    let maxHeight = max(length1, length2)\n 19 |                    if length1 < length2 {\n 20 |                        l1 = padWithZeros(l1, length2 - length1)\n    |                        `- error: cannot assign to value: 'l1' is a 'let' constant\n 21 |                    } else if length2 < length1 {\n 22 |                        l2 = padWithZeros(l2, length1 - length2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:22:24: error: cannot assign to value: 'l2' is a 'let' constant\n 20 |                        l1 = padWithZeros(l1, length2 - length1)\n 21 |                    } else if length2 < length1 {\n 22 |                        l2 = padWithZeros(l2, length1 - length2)\n    |                        `- error: cannot assign to value: 'l2' is a 'let' constant\n 23 |                    }\n 24 |                    let solution = addTwoNumbersRecursive(l1, l2, maxHeight, 0, 0)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:34:28: error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 30 |                        return nil\n 31 |                    }\n 32 |                    let sum = carry\n    |                    `- note: change 'let' to 'var' to make it mutable\n 33 |                    if l1 != nil {\n 34 |                        sum += l1!.val\n    |                            `- error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 35 |                    }\n 36 |                    if l2 != nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-two-numbers-ii_2\/solution.swift:37:28: error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 30 |                        return nil\n 31 |                    }\n 32 |                    let sum = carry\n    |                    `- note: change 'let' to 'var' to make it mutable\n 33 |                    if l1 != nil {\n 34 |                        sum += l1!.val\n 35 |                    }\n 36 |                    if l2 != nil {\n 37 |                        sum += l2!.val\n    |                            `- error: left side of mutating operator isn't mutable: 'sum' is a 'let' constant\n 38 |                    }\n 39 |                    let newNode = ListNode(sum % 10)\n",
      "expected" : "0",
      "input" : "nums = [0], nums = [0]",
      "slug" : "add-two-numbers-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[0,-10,5,null,-3,null,9]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "a balanced BST",
      "input" : "[-10, -3, 0, 5, 9]",
      "slug" : "convert-sorted-list-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1,null,2]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "a balanced BST",
      "input" : "[1, 2]",
      "slug" : "convert-sorted-list-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:10:28: error: operator function '==' requires that 'ListNode' conform to 'Equatable'\n  8 |                \n  9 |                func findMiddle(_ head: ListNode?, _ tail: ListNode?) -> TreeNode? {\n 10 |                    if head == tail {\n    |                            `- error: operator function '==' requires that 'ListNode' conform to 'Equatable'\n 11 |                        return nil\n 12 |                    }\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:16:37: error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 14 |                    var fast = head\n 15 |                    var prev: ListNode?\n 16 |                    while fast?.next != tail && fast?.next?.next != tail {\n    |                                     `- error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 17 |                        prev = slow\n 18 |                        slow = slow?.next\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:16:65: error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 14 |                    var fast = head\n 15 |                    var prev: ListNode?\n 16 |                    while fast?.next != tail && fast?.next?.next != tail {\n    |                                                                 `- error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 17 |                        prev = slow\n 18 |                        slow = slow?.next\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:291:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n289 | func toTreeNode(_ value: Any) -> TreeNode? {\n290 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n291 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n292 |         if item is NSNull { return nil }\n293 |         return TreeNode(toInt(item))\n",
      "expected" : "a balanced BST",
      "input" : "[-10, -3, 0, 5, 9]",
      "slug" : "convert-sorted-list-to-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:10:28: error: operator function '==' requires that 'ListNode' conform to 'Equatable'\n  8 |                \n  9 |                func findMiddle(_ head: ListNode?, _ tail: ListNode?) -> TreeNode? {\n 10 |                    if head == tail {\n    |                            `- error: operator function '==' requires that 'ListNode' conform to 'Equatable'\n 11 |                        return nil\n 12 |                    }\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:16:37: error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 14 |                    var fast = head\n 15 |                    var prev: ListNode?\n 16 |                    while fast?.next != tail && fast?.next?.next != tail {\n    |                                     `- error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 17 |                        prev = slow\n 18 |                        slow = slow?.next\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:16:65: error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 14 |                    var fast = head\n 15 |                    var prev: ListNode?\n 16 |                    while fast?.next != tail && fast?.next?.next != tail {\n    |                                                                 `- error: operator function '!=' requires that 'ListNode' conform to 'Equatable'\n 17 |                        prev = slow\n 18 |                        slow = slow?.next\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n1 | extension Optional : Equatable where Wrapped : Equatable {\n  |           `- note: requirement from conditional conformance of 'ListNode?' to 'Equatable'\n2 |     public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool\n3 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-sorted-list-to-binary-search-tree_2\/solution.swift:291:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n289 | func toTreeNode(_ value: Any) -> TreeNode? {\n290 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n291 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n292 |         if item is NSNull { return nil }\n293 |         return TreeNode(toInt(item))\n",
      "expected" : "a balanced BST",
      "input" : "[1, 2]",
      "slug" : "convert-sorted-list-to-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Hash Map (Two Pass)",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_1\/solution.swift:4:39: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func copyRandomList(_ head: Node?) -> Node? {\n    |                                       `- error: cannot find type 'Node' in scope\n  5 |     guard let head = head else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_1\/solution.swift:4:29: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func copyRandomList(_ head: Node?) -> Node? {\n    |                             `- error: cannot find type 'Node' in scope\n  5 |     guard let head = head else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_1\/solution.swift:7:33: error: cannot find type 'Node' in scope\n  5 |     guard let head = head else { return nil }\n  6 |     \n  7 |     var map: [ObjectIdentifier: Node] = [:]\n    |                                 `- error: cannot find type 'Node' in scope\n  8 |     \n  9 |     \/\/ First pass: create all nodes\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_1\/solution.swift:10:15: error: cannot find type 'Node' in scope\n  8 |     \n  9 |     \/\/ First pass: create all nodes\n 10 |     var curr: Node? = head\n    |               `- error: cannot find type 'Node' in scope\n 11 |     while let node = curr {\n 12 |         map[ObjectIdentifier(node)] = Node(node.val)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_1\/solution.swift:12:39: error: cannot find 'Node' in scope\n 10 |     var curr: Node? = head\n 11 |     while let node = curr {\n 12 |         map[ObjectIdentifier(node)] = Node(node.val)\n    |                                       `- error: cannot find 'Node' in scope\n 13 |         curr = node.next\n 14 |     }\n",
      "expected" : "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
      "input" : "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
      "slug" : "copy-list-with-random-pointer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Interleaving (O(1) Space)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_2\/solution.swift:4:39: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func copyRandomList(_ head: Node?) -> Node? {\n    |                                       `- error: cannot find type 'Node' in scope\n  5 |     guard head != nil else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_2\/solution.swift:4:29: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func copyRandomList(_ head: Node?) -> Node? {\n    |                             `- error: cannot find type 'Node' in scope\n  5 |     guard head != nil else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_2\/solution.swift:10:20: error: cannot find 'Node' in scope\n  8 |     var curr = head\n  9 |     while let node = curr {\n 10 |         let copy = Node(node.val)\n    |                    `- error: cannot find 'Node' in scope\n 11 |         copy.next = node.next\n 12 |         node.next = copy\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/copy-list-with-random-pointer_2\/solution.swift:25:17: error: cannot find 'Node' in scope\n 23 |     \n 24 |     \/\/ Phase 3: Separate lists\n 25 |     let dummy = Node(0)\n    |                 `- error: cannot find 'Node' in scope\n 26 |     var copyTail = dummy\n 27 |     curr = head\n",
      "expected" : "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
      "input" : "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
      "slug" : "copy-list-with-random-pointer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:92: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:118: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:282:5: warning: constant 'result' inferred to have type '()', which may be unexpected\n280 | let cyclePos = parseCyclePos(from: input)\n281 | let arg0 = toListNode(valueAt(args, 0), pos: cyclePos)\n282 | let result = solution.deleteNode(arg0)\n    |     |- warning: constant 'result' inferred to have type '()', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n283 | let output: Any = NSNull()\n284 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:115: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                                                   |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n",
      "expected" : "3 -> 5",
      "input" : "node = 3 -> 4 -> 5, delete node 4",
      "slug" : "delete-node-in-a-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:92: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:118: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:282:5: warning: constant 'result' inferred to have type '()', which may be unexpected\n280 | let cyclePos = parseCyclePos(from: input)\n281 | let arg0 = toListNode(valueAt(args, 0), pos: cyclePos)\n282 | let result = solution.deleteNode(arg0)\n    |     |- warning: constant 'result' inferred to have type '()', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n283 | let output: Any = NSNull()\n284 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_1\/solution.swift:3:115: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node else { return } node.val = node.next?.val node.next = node.next?.next } }\n    |                                                                                                                   |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                                                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n",
      "expected" : "1 -> 3",
      "input" : "node = 1 -> 2 -> 3, delete node 2",
      "slug" : "delete-node-in-a-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:118: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:157: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:252: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:282:5: warning: constant 'result' inferred to have type '()', which may be unexpected\n280 | let cyclePos = parseCyclePos(from: input)\n281 | let arg0 = toListNode(valueAt(args, 0), pos: cyclePos)\n282 | let result = solution.deleteNode(arg0)\n    |     |- warning: constant 'result' inferred to have type '()', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n283 | let output: Any = NSNull()\n284 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:82: warning: immutable value 'nextNode' was never used; consider replacing with '_' or removing it [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                  `- warning: immutable value 'nextNode' was never used; consider replacing with '_' or removing it [#no-usage]\n  4 | \n  5 | \n",
      "expected" : "3 -> 5",
      "input" : "node = 3 -> 4 -> 5, delete node 4",
      "slug" : "delete-node-in-a-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:118: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:157: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:252: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:282:5: warning: constant 'result' inferred to have type '()', which may be unexpected\n280 | let cyclePos = parseCyclePos(from: input)\n281 | let arg0 = toListNode(valueAt(args, 0), pos: cyclePos)\n282 | let result = solution.deleteNode(arg0)\n    |     |- warning: constant 'result' inferred to have type '()', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n283 | let output: Any = NSNull()\n284 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-node-in-a-linked-list_2\/solution.swift:3:82: warning: immutable value 'nextNode' was never used; consider replacing with '_' or removing it [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func deleteNode(_ node: ListNode?) { guard let node = node, let nextNode = node.next else { return } var currentNode: ListNode? = node.next while let tempNode = currentNode { if tempNode.next == nil { tempNode.val = node.val; return } currentNode = tempNode.next; tempNode.val = tempNode.next!.val } } }\n    |                                                                                  `- warning: immutable value 'nextNode' was never used; consider replacing with '_' or removing it [#no-usage]\n  4 | \n  5 | \n",
      "expected" : "1 -> 3",
      "input" : "node = 1 -> 2 -> 3, delete node 2",
      "slug" : "delete-node-in-a-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-deque_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'insertFront'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insertFront(value: arg0)\n    |                       `- error: value of type 'Solution' has no member 'insertFront'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "deque.isEmpty() == false, deque.isFull() == true",
      "input" : "let deque = MyCircularDeque(3); deque.insertLast(1); deque.insertLast(2); deque.insertFront(3); deque.insertFront(4); deque.insertRear(5); deque.insertFront(6)",
      "slug" : "design-circular-deque",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-deque_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'insertFront'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insertFront(value: arg0)\n    |                       `- error: value of type 'Solution' has no member 'insertFront'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "deque.getFront() == 2, deque.getRear() == 3",
      "input" : "let deque = MyCircularDeque(3); deque.insertFront(1); deque.insertFront(2); deque.insertFront(3); deque.deleteFront(); deque.deleteRear()",
      "slug" : "design-circular-deque",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-deque_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'insertFront'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insertFront(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insertFront'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "deque.isEmpty() == false, deque.isFull() == true",
      "input" : "let deque = MyCircularDeque(3); deque.insertFront(1); deque.insertRear(2); deque.insertFront(3); deque.insertRear(4); deque.insertFront(5)",
      "slug" : "design-circular-deque",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-deque_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'insertFront'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insertFront(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insertFront'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "deque.getFront() == 2, deque.getRear() == 3",
      "input" : "let deque = MyCircularDeque(3); deque.insertFront(1); deque.insertFront(2); deque.insertFront(3); deque.deleteFront(); deque.deleteRear()",
      "slug" : "design-circular-deque",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-queue_1\/solution.swift:282:23: error: value of type 'Solution' has no member 'enQueue'\n280 | \n281 | let arg0 = toInt(valueAt(args, 0))\n282 | let result = solution.enQueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enQueue'\n283 | let output: Any = result\n284 | print(jsonString(from: output))\n",
      "expected" : "2, true, 4",
      "input" : "MyCircularQueue queue = new MyCircularQueue(3); queue.enQueue(1); queue.enQueue(2); queue.enQueue(3); queue.enQueue(4); queue.Rear(); queue.isFull(); queue.deQueue(); queue.enQueue(4); queue.Rear();",
      "slug" : "design-circular-queue",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-queue_1\/solution.swift:282:23: error: value of type 'Solution' has no member 'enQueue'\n280 | \n281 | let arg0 = toInt(valueAt(args, 0))\n282 | let result = solution.enQueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enQueue'\n283 | let output: Any = result\n284 | print(jsonString(from: output))\n",
      "expected" : "1, -1",
      "input" : "MyCircularQueue queue = new MyCircularQueue(3); queue.enQueue(1); queue.enQueue(2); queue.deQueue(); queue.Front(); queue.deQueue();",
      "slug" : "design-circular-queue",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-queue_2\/solution.swift:284:23: error: value of type 'Solution' has no member 'enQueue'\n282 | \n283 | let arg0 = toInt(valueAt(args, 0))\n284 | let result = solution.enQueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enQueue'\n285 | let output: Any = result\n286 | print(jsonString(from: output))\n",
      "expected" : "2, true, 4",
      "input" : "MyCircularQueue queue = new MyCircularQueue(3); queue.enQueue(1); queue.enQueue(2); queue.enQueue(3); queue.enQueue(4); queue.Rear(); queue.isFull(); queue.deQueue(); queue.enQueue(4); queue.Rear();",
      "slug" : "design-circular-queue",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-circular-queue_2\/solution.swift:284:23: error: value of type 'Solution' has no member 'enQueue'\n282 | \n283 | let arg0 = toInt(valueAt(args, 0))\n284 | let result = solution.enQueue(arg0)\n    |                       `- error: value of type 'Solution' has no member 'enQueue'\n285 | let output: Any = result\n286 | print(jsonString(from: output))\n",
      "expected" : "5, -1, false",
      "input" : "MyCircularQueue queue = new MyCircularQueue(3); queue.enQueue(5); queue.Front(); queue.rear(); queue.deQueue(); queue.Front(); queue.isEmpty();",
      "slug" : "design-circular-queue",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_1\/solution.swift:229:23: error: value of type 'Solution' has no member 'put'\n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let arg1 = toInt(valueAt(args, 1))\n229 | let result = solution.put(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'put'\n230 | let output: Any = NSNull()\n231 | print(jsonString(from: output))\n",
      "expected" : "1, 1, -1",
      "input" : "myHashMap.put(1, 1); myHashMap.get(1); myHashMap.put(2, 2); myHashMap.get(1); myHashMap.remove(2); myHashMap.get(2);",
      "slug" : "design-hashmap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_1\/solution.swift:229:23: error: value of type 'Solution' has no member 'put'\n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let arg1 = toInt(valueAt(args, 1))\n229 | let result = solution.put(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'put'\n230 | let output: Any = NSNull()\n231 | print(jsonString(from: output))\n",
      "expected" : "1, -1",
      "input" : "myHashMap.put(1, 1); myHashMap.put(2, 2); myHashMap.get(1); myHashMap.remove(2); myHashMap.get(2);",
      "slug" : "design-hashmap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_2\/solution.swift:4:94: error: cannot use instance member 'size' within property initializer; property initializers run before 'self' is available\n  2 | \n  3 | class Solution {\n  4 | class MyHashMap { let size = 1000; var buckets: [[(Int, Int)]] = Array(repeating: [], count: size); func _hash(_ key: Int) -> Int { return abs(key) % size }; func put(_ key: Int, _ value: Int) { let index = _hash(key); for (i, node) in buckets[index].enumerated() { if node.0 == key { buckets[index][i].1 = value; return } }; buckets[index].append((key, value)) }; func get(_ key: Int) -> Int { let index = _hash(key); for node in buckets[index] { if node.0 == key { return node.1 } }; return -1 }; func remove(_ key: Int) { let index = _hash(key); for (i, node) in buckets[index].enumerated() { if node.0 == key { buckets[index].remove(at: i); return } } } }\n    |                                                                                              `- error: cannot use instance member 'size' within property initializer; property initializers run before 'self' is available\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_2\/solution.swift:228:23: error: value of type 'Solution' has no member '_hash'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution._hash(arg0)\n    |                       `- error: value of type 'Solution' has no member '_hash'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "1, 1, -1",
      "input" : "myHashMap.put(1, 1); myHashMap.get(1); myHashMap.put(2, 2); myHashMap.get(1); myHashMap.remove(2); myHashMap.get(2);",
      "slug" : "design-hashmap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_2\/solution.swift:4:94: error: cannot use instance member 'size' within property initializer; property initializers run before 'self' is available\n  2 | \n  3 | class Solution {\n  4 | class MyHashMap { let size = 1000; var buckets: [[(Int, Int)]] = Array(repeating: [], count: size); func _hash(_ key: Int) -> Int { return abs(key) % size }; func put(_ key: Int, _ value: Int) { let index = _hash(key); for (i, node) in buckets[index].enumerated() { if node.0 == key { buckets[index][i].1 = value; return } }; buckets[index].append((key, value)) }; func get(_ key: Int) -> Int { let index = _hash(key); for node in buckets[index] { if node.0 == key { return node.1 } }; return -1 }; func remove(_ key: Int) { let index = _hash(key); for (i, node) in buckets[index].enumerated() { if node.0 == key { buckets[index].remove(at: i); return } } } }\n    |                                                                                              `- error: cannot use instance member 'size' within property initializer; property initializers run before 'self' is available\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashmap_2\/solution.swift:228:23: error: value of type 'Solution' has no member '_hash'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution._hash(arg0)\n    |                       `- error: value of type 'Solution' has no member '_hash'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "1, -1",
      "input" : "myHashMap.put(1, 1); myHashMap.put(2, 2); myHashMap.get(1); myHashMap.remove(2); myHashMap.get(2);",
      "slug" : "design-hashmap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:4:121: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Int] = []; func add(_ key: Int) { if !elements.contains(key) { elements.append(key) } } func remove(_ key: Int) { elements = elements.filter { $0 != key } } func contains(_ key: Int) -> Bool { return elements.contains(key) } }\n    |                                                                                                                         `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:4:190: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Int] = []; func add(_ key: Int) { if !elements.contains(key) { elements.append(key) } } func remove(_ key: Int) { elements = elements.filter { $0 != key } } func contains(_ key: Int) -> Bool { return elements.contains(key) } }\n    |                                                                                                                                                                                              `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'add'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "true",
      "input" : "add(1), add(2), contains(1)",
      "slug" : "design-hashset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:4:121: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Int] = []; func add(_ key: Int) { if !elements.contains(key) { elements.append(key) } } func remove(_ key: Int) { elements = elements.filter { $0 != key } } func contains(_ key: Int) -> Bool { return elements.contains(key) } }\n    |                                                                                                                         `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:4:190: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Int] = []; func add(_ key: Int) { if !elements.contains(key) { elements.append(key) } } func remove(_ key: Int) { elements = elements.filter { $0 != key } } func contains(_ key: Int) -> Bool { return elements.contains(key) } }\n    |                                                                                                                                                                                              `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'add'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "remove(2), contains(2)",
      "slug" : "design-hashset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Hash Table Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:4:129: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Bool] = [Bool](repeating: false, count: 1000000); func add(_ key: Int) { elements[key] = true } func remove(_ key: Int) { elements[key] = false } func contains(_ key: Int) -> Bool { return elements[key] } }\n    |                                                                                                                                 `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:4:179: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Bool] = [Bool](repeating: false, count: 1000000); func add(_ key: Int) { elements[key] = true } func remove(_ key: Int) { elements[key] = false } func contains(_ key: Int) -> Bool { return elements[key] } }\n    |                                                                                                                                                                                   `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'add'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "true",
      "input" : "add(1), add(2), contains(1)",
      "slug" : "design-hashset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Hash Table Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:4:129: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Bool] = [Bool](repeating: false, count: 1000000); func add(_ key: Int) { elements[key] = true } func remove(_ key: Int) { elements[key] = false } func contains(_ key: Int) -> Bool { return elements[key] } }\n    |                                                                                                                                 `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:4:179: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class MyHashSet { var elements: [Bool] = [Bool](repeating: false, count: 1000000); func add(_ key: Int) { elements[key] = true } func remove(_ key: Int) { elements[key] = false } func contains(_ key: Int) -> Bool { return elements[key] } }\n    |                                                                                                                                                                                   `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-hashset_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'add'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n229 | let output: Any = NSNull()\n230 | print(jsonString(from: output))\n",
      "expected" : "false",
      "input" : "remove(2), contains(2)",
      "slug" : "design-hashset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_1\/solution.swift:330:23: error: value of type 'Solution' has no member 'addAtHead'\n328 | \n329 | let arg0 = toInt(valueAt(args, 0))\n330 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n331 | let output: Any = NSNull()\n332 | print(jsonString(from: output))\n",
      "expected" : "2, 2",
      "input" : "addAtHead(1), addAtTail(3), addAtIndex(1, 2), get(1), deleteAtIndex(1)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_1\/solution.swift:330:23: error: value of type 'Solution' has no member 'addAtHead'\n328 | \n329 | let arg0 = toInt(valueAt(args, 0))\n330 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n331 | let output: Any = NSNull()\n332 | print(jsonString(from: output))\n",
      "expected" : "1, 1",
      "input" : "addAtHead(1), addAtHead(2), get(1), deleteAtIndex(0)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_1\/solution.swift:330:23: error: value of type 'Solution' has no member 'addAtHead'\n328 | \n329 | let arg0 = toInt(valueAt(args, 0))\n330 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n331 | let output: Any = NSNull()\n332 | print(jsonString(from: output))\n",
      "expected" : "20, 30, 10",
      "input" : "addAtIndex(0, 10), addAtIndex(0, 20), addAtIndex(1, 30), get(0), get(1), get(2)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_2\/solution.swift:327:23: error: value of type 'Solution' has no member 'addAtHead'\n325 | \n326 | let arg0 = toInt(valueAt(args, 0))\n327 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n328 | let output: Any = NSNull()\n329 | print(jsonString(from: output))\n",
      "expected" : "2, 2",
      "input" : "addAtHead(1), addAtTail(3), addAtIndex(1, 2), get(1), deleteAtIndex(1)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_2\/solution.swift:327:23: error: value of type 'Solution' has no member 'addAtHead'\n325 | \n326 | let arg0 = toInt(valueAt(args, 0))\n327 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n328 | let output: Any = NSNull()\n329 | print(jsonString(from: output))\n",
      "expected" : "1, 1",
      "input" : "addAtHead(1), addAtHead(2), get(1), deleteAtIndex(0)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-linked-list_2\/solution.swift:327:23: error: value of type 'Solution' has no member 'addAtHead'\n325 | \n326 | let arg0 = toInt(valueAt(args, 0))\n327 | let result = solution.addAtHead(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addAtHead'\n328 | let output: Any = NSNull()\n329 | print(jsonString(from: output))\n",
      "expected" : "20, 30, 10",
      "input" : "addAtIndex(0, 10), addAtIndex(0, 20), addAtIndex(1, 30), get(0), get(1), get(2)",
      "slug" : "design-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:31: error: expected 'func' keyword in instance method declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:35: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                                   |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                   |- note: join the identifiers together\n    |                                   `- note: join the identifiers together with camel-case\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:38: error: expected '(' in argument list of function declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                                      `- error: expected '(' in argument list of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:31: error: expected 'func' keyword in instance method declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:40: error: expected '(' in argument list of function declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                                        `- error: expected '(' in argument list of function declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:31: error: expected 'func' keyword in instance method declaration\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:40: error: expected '(' in argument list of function declaration\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                                        `- error: expected '(' in argument list of function declaration\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:31: error: expected 'func' keyword in instance method declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                               `- error: expected 'func' keyword in instance method declaration\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:41: error: expected '(' in argument list of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                                         `- error: expected '(' in argument list of function declaration\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:11:31: error: expected 'func' keyword in instance method declaration\n  9 |                        public Node child;\n 10 | \n 11 |                        public Node() {}\n    |                               `- error: expected 'func' keyword in instance method declaration\n 12 | \n 13 |                        public Node(int _val) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:13:31: error: expected 'func' keyword in instance method declaration\n 11 |                        public Node() {}\n 12 | \n 13 |                        public Node(int _val) {\n    |                               `- error: expected 'func' keyword in instance method declaration\n 14 |                            val = _val;\n 15 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:13:44: error: expected ':' following argument label and parameter name\n 11 |                        public Node() {}\n 12 | \n 13 |                        public Node(int _val) {\n    |                                            `- error: expected ':' following argument label and parameter name\n 14 |                            val = _val;\n 15 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:31: error: expected 'func' keyword in instance method declaration\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                               `- error: expected 'func' keyword in instance method declaration\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:44: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                            `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:56: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                        `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:68: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                                    `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:81: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                                                 `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n    |                               `- error: invalid redeclaration of 'Node()'\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                               `- error: invalid redeclaration of 'Node()'\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:11:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n  9 |                        public Node child;\n 10 | \n 11 |                        public Node() {}\n    |                               `- error: invalid redeclaration of 'Node()'\n 12 | \n 13 |                        public Node(int _val) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:278:31: error: cannot convert value of type 'Any' to expected argument type 'Node'\n276 | \n277 | let arg0 = valueAt(args, 0)\n278 | let result = solution.flatten(arg0)\n    |                               `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n279 | let output: Any = result\n280 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:31: error: expected '{' in body of function declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                               `- error: expected '{' in body of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:31: error: expected '{' in body of function declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- error: expected '{' in body of function declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:14:28: error: cannot find 'val' in scope\n 12 | \n 13 |                        public Node(int _val) {\n 14 |                            val = _val;\n    |                            `- error: cannot find 'val' in scope\n 15 |                        }\n 16 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:18:28: error: cannot find 'val' in scope\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n 18 |                            val = _val;\n    |                            `- error: cannot find 'val' in scope\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:19:28: error: cannot find 'prev' in scope\n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n    |                            `- error: cannot find 'prev' in scope\n 20 |                            next = _next;\n 21 |                            child = _child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:20:28: error: cannot find 'next' in scope\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n    |                            `- error: cannot find 'next' in scope\n 21 |                            child = _child;\n 22 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:21:28: error: cannot find 'child' in scope\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n 21 |                            child = _child;\n    |                            `- error: cannot find 'child' in scope\n 22 |                        }\n 23 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:37:41: error: value of type 'Node' has no member 'child'\n 35 |                            var curr: Node? = head\n 36 |                            while curr != nil {\n 37 |                                if curr?.child != nil {\n    |                                         `- error: value of type 'Node' has no member 'child'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:38:70: error: value of type 'Node' has no member 'child'\n 36 |                            while curr != nil {\n 37 |                                if curr?.child != nil {\n 38 |                                    let childTail = flattenList(curr?.child)\n    |                                                                      `- error: value of type 'Node' has no member 'child'\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:39:57: error: value of type 'Node' has no member 'next'\n 37 |                                if curr?.child != nil {\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n    |                                                         `- error: value of type 'Node' has no member 'next'\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:40:42: error: value of type 'Node' has no member 'next'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n    |                                          `- error: value of type 'Node' has no member 'next'\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:40:55: error: value of type 'Node' has no member 'child'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n    |                                                       `- error: value of type 'Node' has no member 'child'\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:41:42: error: value of type 'Node' has no member 'child'\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n    |                                          `- error: value of type 'Node' has no member 'child'\n 42 |                                    curr?.child = nil\n 43 |                                    childTail?.next = tempNext\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:42:42: error: value of type 'Node' has no member 'child'\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n    |                                          `- error: value of type 'Node' has no member 'child'\n 43 |                                    childTail?.next = tempNext\n 44 |                                    if tempNext != nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:49:49: error: value of type 'Node' has no member 'next'\n 47 |                                    curr = childTail\n 48 |                                } else {\n 49 |                                    curr = curr?.next\n    |                                                 `- error: value of type 'Node' has no member 'next'\n 50 |                                }\n 51 |                            }\n",
      "expected" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6",
      "input" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6",
      "slug" : "flatten-a-multilevel-doubly-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:31: error: expected 'func' keyword in instance method declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:35: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                                   |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                   |- note: join the identifiers together\n    |                                   `- note: join the identifiers together with camel-case\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:38: error: expected '(' in argument list of function declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                                      `- error: expected '(' in argument list of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:31: error: expected 'func' keyword in instance method declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:40: error: expected '(' in argument list of function declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                                        `- error: expected '(' in argument list of function declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:31: error: expected 'func' keyword in instance method declaration\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                               `- error: expected 'func' keyword in instance method declaration\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:40: error: expected '(' in argument list of function declaration\n  6 |                        public int val;\n  7 |                        public Node prev;\n  8 |                        public Node next;\n    |                                        `- error: expected '(' in argument list of function declaration\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:31: error: expected 'func' keyword in instance method declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                               `- error: expected 'func' keyword in instance method declaration\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:36: error: found an unexpected second identifier in function declaration; is there an accidental break?\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                                    |- error: found an unexpected second identifier in function declaration; is there an accidental break?\n    |                                    |- note: join the identifiers together\n    |                                    `- note: join the identifiers together with camel-case\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:41: error: expected '(' in argument list of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                                         `- error: expected '(' in argument list of function declaration\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:11:31: error: expected 'func' keyword in instance method declaration\n  9 |                        public Node child;\n 10 | \n 11 |                        public Node() {}\n    |                               `- error: expected 'func' keyword in instance method declaration\n 12 | \n 13 |                        public Node(int _val) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:13:31: error: expected 'func' keyword in instance method declaration\n 11 |                        public Node() {}\n 12 | \n 13 |                        public Node(int _val) {\n    |                               `- error: expected 'func' keyword in instance method declaration\n 14 |                            val = _val;\n 15 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:13:44: error: expected ':' following argument label and parameter name\n 11 |                        public Node() {}\n 12 | \n 13 |                        public Node(int _val) {\n    |                                            `- error: expected ':' following argument label and parameter name\n 14 |                            val = _val;\n 15 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:31: error: expected 'func' keyword in instance method declaration\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                               `- error: expected 'func' keyword in instance method declaration\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:44: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                            `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:56: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                        `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:68: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                                    `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:17:81: error: expected ':' following argument label and parameter name\n 15 |                        }\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n    |                                                                                 `- error: expected ':' following argument label and parameter name\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:8:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n    |                               `- error: invalid redeclaration of 'Node()'\n  9 |                        public Node child;\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:9:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n  9 |                        public Node child;\n    |                               `- error: invalid redeclaration of 'Node()'\n 10 | \n 11 |                        public Node() {}\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:11:31: error: invalid redeclaration of 'Node()'\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- note: 'Node()' previously declared here\n  8 |                        public Node next;\n  9 |                        public Node child;\n 10 | \n 11 |                        public Node() {}\n    |                               `- error: invalid redeclaration of 'Node()'\n 12 | \n 13 |                        public Node(int _val) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:278:31: error: cannot convert value of type 'Any' to expected argument type 'Node'\n276 | \n277 | let arg0 = valueAt(args, 0)\n278 | let result = solution.flatten(arg0)\n    |                               `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n279 | let output: Any = result\n280 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:6:31: error: expected '{' in body of function declaration\n  4 |                    \/\/ Definition for a Node.\n  5 |                    public class Node {\n  6 |                        public int val;\n    |                               `- error: expected '{' in body of function declaration\n  7 |                        public Node prev;\n  8 |                        public Node next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:7:31: error: expected '{' in body of function declaration\n  5 |                    public class Node {\n  6 |                        public int val;\n  7 |                        public Node prev;\n    |                               `- error: expected '{' in body of function declaration\n  8 |                        public Node next;\n  9 |                        public Node child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:14:28: error: cannot find 'val' in scope\n 12 | \n 13 |                        public Node(int _val) {\n 14 |                            val = _val;\n    |                            `- error: cannot find 'val' in scope\n 15 |                        }\n 16 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:18:28: error: cannot find 'val' in scope\n 16 | \n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n 18 |                            val = _val;\n    |                            `- error: cannot find 'val' in scope\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:19:28: error: cannot find 'prev' in scope\n 17 |                        public Node(int _val, Node _prev, Node _next, Node _child) {\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n    |                            `- error: cannot find 'prev' in scope\n 20 |                            next = _next;\n 21 |                            child = _child;\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:20:28: error: cannot find 'next' in scope\n 18 |                            val = _val;\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n    |                            `- error: cannot find 'next' in scope\n 21 |                            child = _child;\n 22 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:21:28: error: cannot find 'child' in scope\n 19 |                            prev = _prev;\n 20 |                            next = _next;\n 21 |                            child = _child;\n    |                            `- error: cannot find 'child' in scope\n 22 |                        }\n 23 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:37:41: error: value of type 'Node' has no member 'child'\n 35 |                            var curr: Node? = head\n 36 |                            while curr != nil {\n 37 |                                if curr?.child != nil {\n    |                                         `- error: value of type 'Node' has no member 'child'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:38:70: error: value of type 'Node' has no member 'child'\n 36 |                            while curr != nil {\n 37 |                                if curr?.child != nil {\n 38 |                                    let childTail = flattenList(curr?.child)\n    |                                                                      `- error: value of type 'Node' has no member 'child'\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:39:57: error: value of type 'Node' has no member 'next'\n 37 |                                if curr?.child != nil {\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n    |                                                         `- error: value of type 'Node' has no member 'next'\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:40:42: error: value of type 'Node' has no member 'next'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n    |                                          `- error: value of type 'Node' has no member 'next'\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:40:55: error: value of type 'Node' has no member 'child'\n 38 |                                    let childTail = flattenList(curr?.child)\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n    |                                                       `- error: value of type 'Node' has no member 'child'\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:41:42: error: value of type 'Node' has no member 'child'\n 39 |                                    let tempNext = curr?.next\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n    |                                          `- error: value of type 'Node' has no member 'child'\n 42 |                                    curr?.child = nil\n 43 |                                    childTail?.next = tempNext\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:42:42: error: value of type 'Node' has no member 'child'\n 40 |                                    curr?.next = curr?.child\n 41 |                                    curr?.child?.prev = curr\n 42 |                                    curr?.child = nil\n    |                                          `- error: value of type 'Node' has no member 'child'\n 43 |                                    childTail?.next = tempNext\n 44 |                                    if tempNext != nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_1\/solution.swift:49:49: error: value of type 'Node' has no member 'next'\n 47 |                                    curr = childTail\n 48 |                                } else {\n 49 |                                    curr = curr?.next\n    |                                                 `- error: value of type 'Node' has no member 'next'\n 50 |                                }\n 51 |                            }\n",
      "expected" : "1 <-> 2 <-> 3 <-> 7 <-> 8 <-> 9 <-> 4 <-> 5 <-> 6",
      "input" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 with 3 -> 7 <-> 8 <-> 9",
      "slug" : "flatten-a-multilevel-doubly-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:5:55: error: cannot find type 'Node' in scope\n  3 | \n  4 |                    class Solution {\n  5 |                        func flatten(_ head: Node?) -> Node? {\n    |                                                       `- error: cannot find type 'Node' in scope\n  6 |                            if head == nil {\n  7 |                                return nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:5:45: error: cannot find type 'Node' in scope\n  3 | \n  4 |                    class Solution {\n  5 |                        func flatten(_ head: Node?) -> Node? {\n    |                                             `- error: cannot find type 'Node' in scope\n  6 |                            if head == nil {\n  7 |                                return nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:10:40: error: cannot find type 'Node' in scope\n  8 |                            }\n  9 | \n 10 |                            var stack: [Node] = [head!]\n    |                                        `- error: cannot find type 'Node' in scope\n 11 |                            var prev: Node? = nil\n 12 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:11:38: error: cannot find type 'Node' in scope\n  9 | \n 10 |                            var stack: [Node] = [head!]\n 11 |                            var prev: Node? = nil\n    |                                      `- error: cannot find type 'Node' in scope\n 12 | \n 13 |                            while !stack.isEmpty {\n",
      "expected" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6",
      "input" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6",
      "slug" : "flatten-a-multilevel-doubly-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:5:55: error: cannot find type 'Node' in scope\n  3 | \n  4 |                    class Solution {\n  5 |                        func flatten(_ head: Node?) -> Node? {\n    |                                                       `- error: cannot find type 'Node' in scope\n  6 |                            if head == nil {\n  7 |                                return nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:5:45: error: cannot find type 'Node' in scope\n  3 | \n  4 |                    class Solution {\n  5 |                        func flatten(_ head: Node?) -> Node? {\n    |                                             `- error: cannot find type 'Node' in scope\n  6 |                            if head == nil {\n  7 |                                return nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:10:40: error: cannot find type 'Node' in scope\n  8 |                            }\n  9 | \n 10 |                            var stack: [Node] = [head!]\n    |                                        `- error: cannot find type 'Node' in scope\n 11 |                            var prev: Node? = nil\n 12 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flatten-a-multilevel-doubly-linked-list_2\/solution.swift:11:38: error: cannot find type 'Node' in scope\n  9 | \n 10 |                            var stack: [Node] = [head!]\n 11 |                            var prev: Node? = nil\n    |                                      `- error: cannot find type 'Node' in scope\n 12 | \n 13 |                            while !stack.isEmpty {\n",
      "expected" : "1 <-> 2 <-> 3 <-> 7 <-> 8 <-> 9 <-> 4 <-> 5 <-> 6",
      "input" : "1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 with 3 -> 7 <-> 8 <-> 9",
      "slug" : "flatten-a-multilevel-doubly-linked-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Iterative",
      "approachOrder" : 1,
      "expected" : "[1,null,2,null,3,null,4,null,5,null,6]",
      "input" : "root = [1,2,5,3,4,null,6]",
      "slug" : "flatten-binary-tree-to-linked-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "The node with value 8",
      "input" : "listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], intersection at node 8",
      "slug" : "intersection-of-two-linked-lists",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "nil",
      "input" : "listA = [2,6,4], listB = [1,5], no intersection",
      "slug" : "intersection-of-two-linked-lists",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Two-Pointer Approach",
      "approachOrder" : 2,
      "expected" : "The node with value 8",
      "input" : "listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], intersection at node 8",
      "slug" : "intersection-of-two-linked-lists",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Two-Pointer Approach",
      "approachOrder" : 2,
      "expected" : "nil",
      "input" : "listA = [2,6,4], listB = [1,5], no intersection",
      "slug" : "intersection-of-two-linked-lists",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Two-Pointer Approach",
      "approachOrder" : 2,
      "expected" : "The node with value 2",
      "input" : "listA = [1,9,1,2,4], listB = [3,2,4], intersection at node 2",
      "slug" : "intersection-of-two-linked-lists",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-components_1\/solution.swift:3:290: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func numComponents(_ head: ListNode?, _ G: [Int]) -> Int { var count = 0; var current = head; while current != nil { if G.contains(current!.val) { count += 1; while current != nil && G.contains(current!.val) { current = current!.next } } else { current = current!.next } } return count } }\n    |                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "2",
      "input" : "head = [0,1,2,3], G = [0,1,3]",
      "slug" : "linked-list-components",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-components_1\/solution.swift:3:290: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func numComponents(_ head: ListNode?, _ G: [Int]) -> Int { var count = 0; var current = head; while current != nil { if G.contains(current!.val) { count += 1; while current != nil && G.contains(current!.val) { current = current!.next } } else { current = current!.next } } return count } }\n    |                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "2",
      "input" : "head = [0,1,2,3,4], G = [0,3,1,4]",
      "slug" : "linked-list-components",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-components_2\/solution.swift:3:312: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func numComponents(_ head: ListNode?, _ G: [Int]) -> Int { let set = Set(G); var count = 0; var current = head; while current != nil { if set.contains(current!.val) { count += 1; while current != nil && set.contains(current!.val) { current = current!.next } } else { current = current!.next } } return count } }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "2",
      "input" : "head = [0,1,2,3], G = [0,1,3]",
      "slug" : "linked-list-components",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-components_2\/solution.swift:3:312: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func numComponents(_ head: ListNode?, _ G: [Int]) -> Int { let set = Set(G); var count = 0; var current = head; while current != nil { if set.contains(current!.val) { count += 1; while current != nil && set.contains(current!.val) { current = current!.next } } else { current = current!.next } } return count } }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "2",
      "input" : "head = [0,1,2,3,4], G = [0,3,1,4]",
      "slug" : "linked-list-components",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Floyd's Cycle Detection",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "[3,2,0,-4], pos = 1",
      "slug" : "linked-list-cycle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Hash Set",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "[3,2,0,-4], pos = 1",
      "slug" : "linked-list-cycle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[2,0,-4]",
      "approachName" : "Floyd's Algorithm Extended",
      "approachOrder" : 1,
      "expected" : "Node at index 1",
      "input" : "head = [3,2,0,-4], pos = 1",
      "slug" : "linked-list-cycle-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Floyd's Algorithm Extended",
      "approachOrder" : 1,
      "expected" : "null",
      "input" : "head = [1,2], pos = -1",
      "slug" : "linked-list-cycle-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:5:26: error: cannot find type 'ListNode' in scope\n  3 | \n  4 |            class Solution {\n  5 |                var list: ListNode?\n    |                          `- error: cannot find type 'ListNode' in scope\n  6 |                init(_ head: ListNode?) {\n  7 |                    list = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:6:29: error: cannot find type 'ListNode' in scope\n  4 |            class Solution {\n  5 |                var list: ListNode?\n  6 |                init(_ head: ListNode?) {\n    |                             `- error: cannot find type 'ListNode' in scope\n  7 |                    list = head\n  8 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:24:18: error: empty collection literal requires an explicit type\n 22 | \n 23 | \/\/ FocusApp LeetCode Runner\n 24 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 25 |     func parseQuotedString(_ input: String) -> String? {\n 26 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:93:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 91 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 92 |         guard !trimmed.isEmpty else { return [] }\n 93 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 94 |         if !keyValues.isEmpty {\n 95 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1 or 2 or 3",
      "input" : "head = [1,2,3], getRandom()",
      "slug" : "linked-list-random-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:5:26: error: cannot find type 'ListNode' in scope\n  3 | \n  4 |            class Solution {\n  5 |                var list: ListNode?\n    |                          `- error: cannot find type 'ListNode' in scope\n  6 |                init(_ head: ListNode?) {\n  7 |                    list = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:6:29: error: cannot find type 'ListNode' in scope\n  4 |            class Solution {\n  5 |                var list: ListNode?\n  6 |                init(_ head: ListNode?) {\n    |                             `- error: cannot find type 'ListNode' in scope\n  7 |                    list = head\n  8 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:24:18: error: empty collection literal requires an explicit type\n 22 | \n 23 | \/\/ FocusApp LeetCode Runner\n 24 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 25 |     func parseQuotedString(_ input: String) -> String? {\n 26 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_1\/solution.swift:93:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 91 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 92 |         guard !trimmed.isEmpty else { return [] }\n 93 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 94 |         if !keyValues.isEmpty {\n 95 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1 or 2 or 3 or 4 or 5",
      "input" : "head = [1,2,3,4,5], getRandom()",
      "slug" : "linked-list-random-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Reservoir Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:5:26: error: cannot find type 'ListNode' in scope\n  3 | \n  4 |            class Solution {\n  5 |                var list: ListNode?\n    |                          `- error: cannot find type 'ListNode' in scope\n  6 |                init(_ head: ListNode?) {\n  7 |                    list = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:6:29: error: cannot find type 'ListNode' in scope\n  4 |            class Solution {\n  5 |                var list: ListNode?\n  6 |                init(_ head: ListNode?) {\n    |                             `- error: cannot find type 'ListNode' in scope\n  7 |                    list = head\n  8 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:27:18: error: empty collection literal requires an explicit type\n 25 | \n 26 | \/\/ FocusApp LeetCode Runner\n 27 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 28 |     func parseQuotedString(_ input: String) -> String? {\n 29 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:96:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 94 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 95 |         guard !trimmed.isEmpty else { return [] }\n 96 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 97 |         if !keyValues.isEmpty {\n 98 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1 or 2 or 3",
      "input" : "head = [1,2,3], getRandom()",
      "slug" : "linked-list-random-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Reservoir Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:5:26: error: cannot find type 'ListNode' in scope\n  3 | \n  4 |            class Solution {\n  5 |                var list: ListNode?\n    |                          `- error: cannot find type 'ListNode' in scope\n  6 |                init(_ head: ListNode?) {\n  7 |                    list = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:6:29: error: cannot find type 'ListNode' in scope\n  4 |            class Solution {\n  5 |                var list: ListNode?\n  6 |                init(_ head: ListNode?) {\n    |                             `- error: cannot find type 'ListNode' in scope\n  7 |                    list = head\n  8 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:27:18: error: empty collection literal requires an explicit type\n 25 | \n 26 | \/\/ FocusApp LeetCode Runner\n 27 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 28 |     func parseQuotedString(_ input: String) -> String? {\n 29 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/linked-list-random-node_2\/solution.swift:96:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 94 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 95 |         guard !trimmed.isEmpty else { return [] }\n 96 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 97 |         if !keyValues.isEmpty {\n 98 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "1 or 2 or 3 or 4 or 5",
      "input" : "head = [1,2,3,4,5], getRandom()",
      "slug" : "linked-list-random-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Hash Map + Doubly Linked List",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/lru-cache_1\/solution.swift:296:23: error: value of type 'Solution' has no member 'get'\n294 | \n295 | let arg0 = toInt(valueAt(args, 0))\n296 | let result = solution.get(arg0)\n    |                       `- error: value of type 'Solution' has no member 'get'\n297 | let output: Any = result\n298 | print(jsonString(from: output))\n",
      "expected" : "[null,null,null,1,null,-1,null,-1,3,4]",
      "input" : "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]",
      "slug" : "lru-cache",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1 -> 2 -> 2 -> 4 -> 3 -> 5",
      "input" : "1 -> 4 -> 3 -> 2 -> 5 -> 2, x = 3",
      "slug" : "partition-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1 -> 7 -> 9 -> 6 -> 8",
      "input" : "7 -> 9 -> 1 -> 6 -> 8, x = 5",
      "slug" : "partition-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "1 -> 2 -> 2 -> 4 -> 3 -> 5",
      "input" : "1 -> 4 -> 3 -> 2 -> 5 -> 2, x = 3",
      "slug" : "partition-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "1 -> 7 -> 9 -> 6 -> 8",
      "input" : "7 -> 9 -> 1 -> 6 -> 8, x = 5",
      "slug" : "partition-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Level Order",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node_1\/solution.swift:4:32: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func connect(_ root: Node?) -> Node? {\n    |                                `- error: cannot find type 'Node' in scope\n  5 |     var leftmost = root\n  6 |     while leftmost?.left != nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node_1\/solution.swift:4:22: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func connect(_ root: Node?) -> Node? {\n    |                      `- error: cannot find type 'Node' in scope\n  5 |     var leftmost = root\n  6 |     while leftmost?.left != nil {\n",
      "expected" : "Connected tree",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "populating-next-right-pointers-in-each-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_1\/solution.swift:3:49: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var queue = [root]; while !queue.isEmpty { var levelSize = queue.count; for i in 0..<levelSize { if i < levelSize - 1 { queue[i].next = queue[i + 1] }; if let left = queue[i].left { queue.append(left) }; if let right = queue[i].right { queue.append(right) } }; queue.removeFirst(levelSize); }; return root }; }\n    |                                                 `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_1\/solution.swift:3:39: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var queue = [root]; while !queue.isEmpty { var levelSize = queue.count; for i in 0..<levelSize { if i < levelSize - 1 { queue[i].next = queue[i + 1] }; if let left = queue[i].left { queue.append(left) }; if let right = queue[i].right { queue.append(right) } }; queue.removeFirst(levelSize); }; return root }; }\n    |                                       `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[1,#,2,3,#,4,5,6,7,#]",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "populating-next-right-pointers-in-each-node-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_1\/solution.swift:3:49: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var queue = [root]; while !queue.isEmpty { var levelSize = queue.count; for i in 0..<levelSize { if i < levelSize - 1 { queue[i].next = queue[i + 1] }; if let left = queue[i].left { queue.append(left) }; if let right = queue[i].right { queue.append(right) } }; queue.removeFirst(levelSize); }; return root }; }\n    |                                                 `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_1\/solution.swift:3:39: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var queue = [root]; while !queue.isEmpty { var levelSize = queue.count; for i in 0..<levelSize { if i < levelSize - 1 { queue[i].next = queue[i + 1] }; if let left = queue[i].left { queue.append(left) }; if let right = queue[i].right { queue.append(right) } }; queue.removeFirst(levelSize); }; return root }; }\n    |                                       `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[]",
      "input" : "root = []",
      "slug" : "populating-next-right-pointers-in-each-node-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_2\/solution.swift:3:49: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var leftmost = root; while let leftmostLeft = leftmost.left { var head = leftmost; while let head = head { if let headLeft = head.left { headLeft.next = head.right }; if let headRight = head.right, let headNext = head.next { headRight.next = headNext.left }; head = head.next }; leftmost = leftmostLeft }; return root }; }\n    |                                                 `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_2\/solution.swift:3:39: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var leftmost = root; while let leftmostLeft = leftmost.left { var head = leftmost; while let head = head { if let headLeft = head.left { headLeft.next = head.right }; if let headRight = head.right, let headNext = head.next { headRight.next = headNext.left }; head = head.next }; leftmost = leftmostLeft }; return root }; }\n    |                                       `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[1,#,2,3,#,4,5,6,7,#]",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "populating-next-right-pointers-in-each-node-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_2\/solution.swift:3:49: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var leftmost = root; while let leftmostLeft = leftmost.left { var head = leftmost; while let head = head { if let headLeft = head.left { headLeft.next = head.right }; if let headRight = head.right, let headNext = head.next { headRight.next = headNext.left }; head = head.next }; leftmost = leftmostLeft }; return root }; }\n    |                                                 `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/populating-next-right-pointers-in-each-node-ii_2\/solution.swift:3:39: error: cannot find type 'Node' in scope\n  1 | import Foundation\n  2 | \n  3 | class Solution { func connect(_ root: Node?) -> Node? { guard let root = root else { return nil }; var leftmost = root; while let leftmostLeft = leftmost.left { var head = leftmost; while let head = head { if let headLeft = head.left { headLeft.next = head.right }; if let headRight = head.right, let headNext = head.next { headRight.next = headNext.left }; head = head.next }; leftmost = leftmostLeft }; return root }; }\n    |                                       `- error: cannot find type 'Node' in scope\n  4 | \n  5 | \n",
      "expected" : "[]",
      "input" : "root = []",
      "slug" : "populating-next-right-pointers-in-each-node-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "1 -> 2",
      "input" : "1 -> 1 -> 2",
      "slug" : "remove-duplicates-from-sorted-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "1 -> 2 -> 3",
      "input" : "1 -> 1 -> 2 -> 3 -> 3",
      "slug" : "remove-duplicates-from-sorted-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1 -> 2",
      "input" : "1 -> 1 -> 2",
      "slug" : "remove-duplicates-from-sorted-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1 -> 2 -> 3",
      "input" : "1 -> 1 -> 2 -> 3 -> 3",
      "slug" : "remove-duplicates-from-sorted-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:230:51: error: cannot find type 'ListNode' in scope\n228 |     return [:]\n229 | }\n230 | func toListNode(_ value: Any, pos: Int? = nil) -> ListNode? {\n    |                                                   `- error: cannot find type 'ListNode' in scope\n231 |     let payload = listNodePayload(from: value)\n232 |     let array = payload.values\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:265:30: error: cannot find type 'ListNode' in scope\n263 | }\n264 | \n265 | func listNodeToArray(_ node: ListNode?, maxNodes: Int = 10_000) -> [Int] {\n    |                              `- error: cannot find type 'ListNode' in scope\n266 |     var result: [Int] = []\n267 |     var current = node\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:234:17: error: cannot find 'ListNode' in scope\n232 |     let array = payload.values\n233 |     guard !array.isEmpty else { return nil }\n234 |     let dummy = ListNode(0)\n    |                 `- error: cannot find 'ListNode' in scope\n235 |     var current: ListNode? = dummy\n236 |     var tail: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:235:18: error: cannot find type 'ListNode' in scope\n233 |     guard !array.isEmpty else { return nil }\n234 |     let dummy = ListNode(0)\n235 |     var current: ListNode? = dummy\n    |                  `- error: cannot find type 'ListNode' in scope\n236 |     var tail: ListNode?\n237 |     var index = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:236:15: error: cannot find type 'ListNode' in scope\n234 |     let dummy = ListNode(0)\n235 |     var current: ListNode? = dummy\n236 |     var tail: ListNode?\n    |               `- error: cannot find type 'ListNode' in scope\n237 |     var index = 0\n238 |     var cycleTarget: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:238:22: error: cannot find type 'ListNode' in scope\n236 |     var tail: ListNode?\n237 |     var index = 0\n238 |     var cycleTarget: ListNode?\n    |                      `- error: cannot find type 'ListNode' in scope\n239 |     let resolvedPos = pos ?? payload.pos\n240 |     for item in array {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:241:20: error: cannot find 'ListNode' in scope\n239 |     let resolvedPos = pos ?? payload.pos\n240 |     for item in array {\n241 |         let node = ListNode(toInt(item))\n    |                    `- error: cannot find 'ListNode' in scope\n242 |         current?.next = node\n243 |         current = node\n",
      "expected" : "[1,2,5]",
      "input" : "head = [1,2,3,3,4,4,5]",
      "slug" : "remove-duplicates-from-sorted-list-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:230:51: error: cannot find type 'ListNode' in scope\n228 |     return [:]\n229 | }\n230 | func toListNode(_ value: Any, pos: Int? = nil) -> ListNode? {\n    |                                                   `- error: cannot find type 'ListNode' in scope\n231 |     let payload = listNodePayload(from: value)\n232 |     let array = payload.values\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:265:30: error: cannot find type 'ListNode' in scope\n263 | }\n264 | \n265 | func listNodeToArray(_ node: ListNode?, maxNodes: Int = 10_000) -> [Int] {\n    |                              `- error: cannot find type 'ListNode' in scope\n266 |     var result: [Int] = []\n267 |     var current = node\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:234:17: error: cannot find 'ListNode' in scope\n232 |     let array = payload.values\n233 |     guard !array.isEmpty else { return nil }\n234 |     let dummy = ListNode(0)\n    |                 `- error: cannot find 'ListNode' in scope\n235 |     var current: ListNode? = dummy\n236 |     var tail: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:235:18: error: cannot find type 'ListNode' in scope\n233 |     guard !array.isEmpty else { return nil }\n234 |     let dummy = ListNode(0)\n235 |     var current: ListNode? = dummy\n    |                  `- error: cannot find type 'ListNode' in scope\n236 |     var tail: ListNode?\n237 |     var index = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:236:15: error: cannot find type 'ListNode' in scope\n234 |     let dummy = ListNode(0)\n235 |     var current: ListNode? = dummy\n236 |     var tail: ListNode?\n    |               `- error: cannot find type 'ListNode' in scope\n237 |     var index = 0\n238 |     var cycleTarget: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:238:22: error: cannot find type 'ListNode' in scope\n236 |     var tail: ListNode?\n237 |     var index = 0\n238 |     var cycleTarget: ListNode?\n    |                      `- error: cannot find type 'ListNode' in scope\n239 |     let resolvedPos = pos ?? payload.pos\n240 |     for item in array {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_1\/solution.swift:241:20: error: cannot find 'ListNode' in scope\n239 |     let resolvedPos = pos ?? payload.pos\n240 |     for item in array {\n241 |         let node = ListNode(toInt(item))\n    |                    `- error: cannot find 'ListNode' in scope\n242 |         current?.next = node\n243 |         current = node\n",
      "expected" : "[2,3]",
      "input" : "head = [1,1,1,2,3]",
      "slug" : "remove-duplicates-from-sorted-list-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:231:51: error: cannot find type 'ListNode' in scope\n229 |     return [:]\n230 | }\n231 | func toListNode(_ value: Any, pos: Int? = nil) -> ListNode? {\n    |                                                   `- error: cannot find type 'ListNode' in scope\n232 |     let payload = listNodePayload(from: value)\n233 |     let array = payload.values\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:266:30: error: cannot find type 'ListNode' in scope\n264 | }\n265 | \n266 | func listNodeToArray(_ node: ListNode?, maxNodes: Int = 10_000) -> [Int] {\n    |                              `- error: cannot find type 'ListNode' in scope\n267 |     var result: [Int] = []\n268 |     var current = node\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:235:17: error: cannot find 'ListNode' in scope\n233 |     let array = payload.values\n234 |     guard !array.isEmpty else { return nil }\n235 |     let dummy = ListNode(0)\n    |                 `- error: cannot find 'ListNode' in scope\n236 |     var current: ListNode? = dummy\n237 |     var tail: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:236:18: error: cannot find type 'ListNode' in scope\n234 |     guard !array.isEmpty else { return nil }\n235 |     let dummy = ListNode(0)\n236 |     var current: ListNode? = dummy\n    |                  `- error: cannot find type 'ListNode' in scope\n237 |     var tail: ListNode?\n238 |     var index = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:237:15: error: cannot find type 'ListNode' in scope\n235 |     let dummy = ListNode(0)\n236 |     var current: ListNode? = dummy\n237 |     var tail: ListNode?\n    |               `- error: cannot find type 'ListNode' in scope\n238 |     var index = 0\n239 |     var cycleTarget: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:239:22: error: cannot find type 'ListNode' in scope\n237 |     var tail: ListNode?\n238 |     var index = 0\n239 |     var cycleTarget: ListNode?\n    |                      `- error: cannot find type 'ListNode' in scope\n240 |     let resolvedPos = pos ?? payload.pos\n241 |     for item in array {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:242:20: error: cannot find 'ListNode' in scope\n240 |     let resolvedPos = pos ?? payload.pos\n241 |     for item in array {\n242 |         let node = ListNode(toInt(item))\n    |                    `- error: cannot find 'ListNode' in scope\n243 |         current?.next = node\n244 |         current = node\n",
      "expected" : "[1,2,5]",
      "input" : "head = [1,2,3,3,4,4,5]",
      "slug" : "remove-duplicates-from-sorted-list-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:231:51: error: cannot find type 'ListNode' in scope\n229 |     return [:]\n230 | }\n231 | func toListNode(_ value: Any, pos: Int? = nil) -> ListNode? {\n    |                                                   `- error: cannot find type 'ListNode' in scope\n232 |     let payload = listNodePayload(from: value)\n233 |     let array = payload.values\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:266:30: error: cannot find type 'ListNode' in scope\n264 | }\n265 | \n266 | func listNodeToArray(_ node: ListNode?, maxNodes: Int = 10_000) -> [Int] {\n    |                              `- error: cannot find type 'ListNode' in scope\n267 |     var result: [Int] = []\n268 |     var current = node\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:235:17: error: cannot find 'ListNode' in scope\n233 |     let array = payload.values\n234 |     guard !array.isEmpty else { return nil }\n235 |     let dummy = ListNode(0)\n    |                 `- error: cannot find 'ListNode' in scope\n236 |     var current: ListNode? = dummy\n237 |     var tail: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:236:18: error: cannot find type 'ListNode' in scope\n234 |     guard !array.isEmpty else { return nil }\n235 |     let dummy = ListNode(0)\n236 |     var current: ListNode? = dummy\n    |                  `- error: cannot find type 'ListNode' in scope\n237 |     var tail: ListNode?\n238 |     var index = 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:237:15: error: cannot find type 'ListNode' in scope\n235 |     let dummy = ListNode(0)\n236 |     var current: ListNode? = dummy\n237 |     var tail: ListNode?\n    |               `- error: cannot find type 'ListNode' in scope\n238 |     var index = 0\n239 |     var cycleTarget: ListNode?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:239:22: error: cannot find type 'ListNode' in scope\n237 |     var tail: ListNode?\n238 |     var index = 0\n239 |     var cycleTarget: ListNode?\n    |                      `- error: cannot find type 'ListNode' in scope\n240 |     let resolvedPos = pos ?? payload.pos\n241 |     for item in array {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/remove-duplicates-from-sorted-list-ii_2\/solution.swift:242:20: error: cannot find 'ListNode' in scope\n240 |     let resolvedPos = pos ?? payload.pos\n241 |     for item in array {\n242 |         let node = ListNode(toInt(item))\n    |                    `- error: cannot find 'ListNode' in scope\n243 |         current?.next = node\n244 |         current = node\n",
      "expected" : "[2,3]",
      "input" : "head = [1,1,1,2,3]",
      "slug" : "remove-duplicates-from-sorted-list-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Three-Step Approach",
      "approachOrder" : 1,
      "expected" : "[1,4,2,3]",
      "input" : "[1,2,3,4]",
      "slug" : "reorder-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "null",
      "approachName" : "Three-Step Approach",
      "approachOrder" : 1,
      "expected" : "[1,5,2,4,3]",
      "input" : "[1,2,3,4,5]",
      "slug" : "reorder-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Stack-Based",
      "approachOrder" : 2,
      "expected" : "[1,4,2,3]",
      "input" : "[1,2,3,4]",
      "slug" : "reorder-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "null",
      "approachName" : "Stack-Based",
      "approachOrder" : 2,
      "expected" : "[1,5,2,4,3]",
      "input" : "[1,2,3,4,5]",
      "slug" : "reorder-list",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:9:22: error: cannot use optional chaining on non-optional value of type 'ListNode'\n  7 |            var count = 1\n  8 |            var tail = head\n  9 |            while tail?.next != nil {\n    |                      `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 10 |              count += 1\n 11 |              tail = tail?.next\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:11:27: error: value of optional type 'ListNode?' must be unwrapped to a value of type 'ListNode'\n  9 |            while tail?.next != nil {\n 10 |              count += 1\n 11 |              tail = tail?.next\n    |                           |- error: value of optional type 'ListNode?' must be unwrapped to a value of type 'ListNode'\n    |                           |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                           `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 12 |            }\n 13 |            tail?.next = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:11:25: error: cannot use optional chaining on non-optional value of type 'ListNode'\n  9 |            while tail?.next != nil {\n 10 |              count += 1\n 11 |              tail = tail?.next\n    |                         `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 12 |            }\n 13 |            tail?.next = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:13:16: error: cannot use optional chaining on non-optional value of type 'ListNode'\n 11 |              tail = tail?.next\n 12 |            }\n 13 |            tail?.next = head\n    |                `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 14 |            let newTail = getNewTail(head, count, k)\n 15 |            let newHead = newTail?.next\n",
      "expected" : "[4,5,1,2,3]",
      "input" : "head = [1,2,3,4,5], k = 2",
      "slug" : "rotate-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:9:22: error: cannot use optional chaining on non-optional value of type 'ListNode'\n  7 |            var count = 1\n  8 |            var tail = head\n  9 |            while tail?.next != nil {\n    |                      `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 10 |              count += 1\n 11 |              tail = tail?.next\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:11:27: error: value of optional type 'ListNode?' must be unwrapped to a value of type 'ListNode'\n  9 |            while tail?.next != nil {\n 10 |              count += 1\n 11 |              tail = tail?.next\n    |                           |- error: value of optional type 'ListNode?' must be unwrapped to a value of type 'ListNode'\n    |                           |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                           `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 12 |            }\n 13 |            tail?.next = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:11:25: error: cannot use optional chaining on non-optional value of type 'ListNode'\n  9 |            while tail?.next != nil {\n 10 |              count += 1\n 11 |              tail = tail?.next\n    |                         `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 12 |            }\n 13 |            tail?.next = head\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-list_1\/solution.swift:13:16: error: cannot use optional chaining on non-optional value of type 'ListNode'\n 11 |              tail = tail?.next\n 12 |            }\n 13 |            tail?.next = head\n    |                `- error: cannot use optional chaining on non-optional value of type 'ListNode'\n 14 |            let newTail = getNewTail(head, count, k)\n 15 |            let newHead = newTail?.next\n",
      "expected" : "[1,2,3,4,5]",
      "input" : "head = [1,2,3,4,5], k = 5",
      "slug" : "rotate-list",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Approach 1: Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:30:32: error: cannot assign to value: 'node' is a 'let' constant\n 28 |                        for _ in 1..<(partSize + (remainder > 0 ? 1 : 0)) {\n 29 |                            if let nextNode = node.next {\n 30 |                                node = nextNode\n    |                                `- error: cannot assign to value: 'node' is a 'let' constant\n 31 |                            } else {\n 32 |                                break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:39:28: error: cannot assign to value: 'node' is a 'let' constant\n 37 |                        if let nextNode = node.next {\n 38 |                            node.next = nil\n 39 |                            node = nextNode\n    |                            `- error: cannot assign to value: 'node' is a 'let' constant\n 40 |                        } else {\n 41 |                            node = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:41:28: error: cannot assign to value: 'node' is a 'let' constant\n 39 |                            node = nextNode\n 40 |                        } else {\n 41 |                            node = nil\n    |                            `- error: cannot assign to value: 'node' is a 'let' constant\n 42 |                        }\n 43 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:41:35: error: 'nil' cannot be assigned to type 'ListNode'\n 39 |                            node = nextNode\n 40 |                        } else {\n 41 |                            node = nil\n    |                                   `- error: 'nil' cannot be assigned to type 'ListNode'\n 42 |                        }\n 43 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:47:34: error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 15 |                \/\/ Calculate the size of each part\n 16 |                let partSize = length \/ k\n 17 |                let remainder = length % k\n    |                `- note: change 'let' to 'var' to make it mutable\n 18 | \n 19 |                var parts = [ListNode?]()\n    :\n 45 |                    \/\/ Decrease the remainder\n 46 |                    if remainder > 0 {\n 47 |                        remainder -= 1\n    |                                  `- error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 48 |                    }\n 49 |                }\n",
      "expected" : "[[1],[2],[3],[],[],[]]",
      "input" : "head = [1,2,3], k = 5",
      "slug" : "split-linked-list-in-parts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Approach 1: Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:30:32: error: cannot assign to value: 'node' is a 'let' constant\n 28 |                        for _ in 1..<(partSize + (remainder > 0 ? 1 : 0)) {\n 29 |                            if let nextNode = node.next {\n 30 |                                node = nextNode\n    |                                `- error: cannot assign to value: 'node' is a 'let' constant\n 31 |                            } else {\n 32 |                                break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:39:28: error: cannot assign to value: 'node' is a 'let' constant\n 37 |                        if let nextNode = node.next {\n 38 |                            node.next = nil\n 39 |                            node = nextNode\n    |                            `- error: cannot assign to value: 'node' is a 'let' constant\n 40 |                        } else {\n 41 |                            node = nil\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:41:28: error: cannot assign to value: 'node' is a 'let' constant\n 39 |                            node = nextNode\n 40 |                        } else {\n 41 |                            node = nil\n    |                            `- error: cannot assign to value: 'node' is a 'let' constant\n 42 |                        }\n 43 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:41:35: error: 'nil' cannot be assigned to type 'ListNode'\n 39 |                            node = nextNode\n 40 |                        } else {\n 41 |                            node = nil\n    |                                   `- error: 'nil' cannot be assigned to type 'ListNode'\n 42 |                        }\n 43 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_1\/solution.swift:47:34: error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 15 |                \/\/ Calculate the size of each part\n 16 |                let partSize = length \/ k\n 17 |                let remainder = length % k\n    |                `- note: change 'let' to 'var' to make it mutable\n 18 | \n 19 |                var parts = [ListNode?]()\n    :\n 45 |                    \/\/ Decrease the remainder\n 46 |                    if remainder > 0 {\n 47 |                        remainder -= 1\n    |                                  `- error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 48 |                    }\n 49 |                }\n",
      "expected" : "[[1,2,3,4],[5,6,7],[8,9,10]]",
      "input" : "head = [1,2,3,4,5,6,7,8,9,10], k = 3",
      "slug" : "split-linked-list-in-parts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Approach 2: Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_2\/solution.swift:49:34: error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 15 |                \/\/ Calculate the size of each part\n 16 |                let partSize = length \/ k\n 17 |                let remainder = length % k\n    |                `- note: change 'let' to 'var' to make it mutable\n 18 | \n 19 |                var parts = [ListNode?]()\n    :\n 47 |                    \/\/ Decrease the remainder\n 48 |                    if remainder > 0 {\n 49 |                        remainder -= 1\n    |                                  `- error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 50 |                    }\n 51 |                }\n",
      "expected" : "[[1],[2],[3],[],[],[]]",
      "input" : "head = [1,2,3], k = 5",
      "slug" : "split-linked-list-in-parts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Approach 2: Two Pointers",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-linked-list-in-parts_2\/solution.swift:49:34: error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 15 |                \/\/ Calculate the size of each part\n 16 |                let partSize = length \/ k\n 17 |                let remainder = length % k\n    |                `- note: change 'let' to 'var' to make it mutable\n 18 | \n 19 |                var parts = [ListNode?]()\n    :\n 47 |                    \/\/ Decrease the remainder\n 48 |                    if remainder > 0 {\n 49 |                        remainder -= 1\n    |                                  `- error: left side of mutating operator isn't mutable: 'remainder' is a 'let' constant\n 50 |                    }\n 51 |                }\n",
      "expected" : "[[1,2,3,4],[5,6,7],[8,9,10]]",
      "input" : "head = [1,2,3,4,5,6,7,8,9,10], k = 3",
      "slug" : "split-linked-list-in-parts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[4,1,1,1,null,null,1,2]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[4,1,1,null,null,1,2]",
      "input" : "root = [4,1,1,2,null,null,null], val = 1, depth = 2",
      "slug" : "add-one-row-to-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[4,1,1,2,null,null,null,2,2]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[4,1,1,2-null-2,2,2-null-2]",
      "input" : "root = [4,1,1,2,null,null,null], val = 2, depth = 4",
      "slug" : "add-one-row-to-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[4,1,1,1,null,null,1,2]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[4,1,1,null,null,1,2]",
      "input" : "root = [4,1,1,2,null,null,null], val = 1, depth = 2",
      "slug" : "add-one-row-to-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[4,1,1,2,null,null,null,2,2]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[4,1,1,2-null-2,2,2-null-2]",
      "input" : "root = [4,1,1,2,null,null,null], val = 2, depth = 4",
      "slug" : "add-one-row-to-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[7,4,1]",
      "input" : "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2",
      "slug" : "all-nodes-distance-k-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[3,8]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[7,4,1]",
      "input" : "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2",
      "slug" : "all-nodes-distance-k-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[3,14.5,2]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[3,10,2.33333]",
      "input" : "root = [3,9,20,1,null,2,3]",
      "slug" : "average-of-levels-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[3,14.5,2]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[3,14.5,2.0]",
      "input" : "root = [3,9,20,1,null,2,3]",
      "slug" : "average-of-levels-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[]]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[]",
      "input" : "root = []",
      "slug" : "binary-tree-level-order-traversal-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "[1,null,1,null,1]",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "[1,null,1,null,null,null,1]",
      "input" : "root = [1,0,1,0,0,0,1]",
      "slug" : "binary-tree-pruning",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,null,1,null,1]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1,null,1,null,null,null,1]",
      "input" : "root = [1,0,1,0,0,0,1]",
      "slug" : "binary-tree-pruning",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "15",
      "input" : "root = [4,2,9,3,5]",
      "slug" : "binary-tree-tilt",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "15",
      "input" : "root = [4,2,9,3,5]",
      "slug" : "binary-tree-tilt",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:216:34: error: cannot find type 'TreeNode' in scope\n214 | }\n215 | \n216 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n217 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n218 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:234:30: error: cannot find type 'TreeNode' in scope\n232 | }\n233 | \n234 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n235 |     guard let root else { return [] }\n236 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:218:17: error: cannot find type 'TreeNode' in scope\n216 | func toTreeNode(_ value: Any) -> TreeNode? {\n217 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n218 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n219 |         if item is NSNull { return nil }\n220 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:237:17: error: cannot find type 'TreeNode' in scope\n235 |     guard let root else { return [] }\n236 |     var result: [Any] = []\n237 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n238 |     while !queue.isEmpty {\n239 |         let node = queue.removeFirst()\n",
      "expected" : "true",
      "input" : "root = [1,2,3,4,5,6]",
      "slug" : "check-completeness-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:216:34: error: cannot find type 'TreeNode' in scope\n214 | }\n215 | \n216 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n217 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n218 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:234:30: error: cannot find type 'TreeNode' in scope\n232 | }\n233 | \n234 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n235 |     guard let root else { return [] }\n236 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:218:17: error: cannot find type 'TreeNode' in scope\n216 | func toTreeNode(_ value: Any) -> TreeNode? {\n217 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n218 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n219 |         if item is NSNull { return nil }\n220 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_1\/solution.swift:237:17: error: cannot find type 'TreeNode' in scope\n235 |     guard let root else { return [] }\n236 |     var result: [Any] = []\n237 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n238 |     while !queue.isEmpty {\n239 |         let node = queue.removeFirst()\n",
      "expected" : "false",
      "input" : "root = [1,2,3,4,5,null,7]",
      "slug" : "check-completeness-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:18:19: warning: value 'right' was defined but never used; consider replacing with boolean test [#no-usage]\n 16 |         queue.append(left)\n 17 |         nullEncountered = true\n 18 |     } else if let right = node.right {\n    |                   `- warning: value 'right' was defined but never used; consider replacing with boolean test [#no-usage]\n 19 |         return false\n 20 |     } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "true",
      "input" : "root = [1,2,3,4,5,6]",
      "slug" : "check-completeness-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:18:19: warning: value 'right' was defined but never used; consider replacing with boolean test [#no-usage]\n 16 |         queue.append(left)\n 17 |         nullEncountered = true\n 18 |     } else if let right = node.right {\n    |                   `- warning: value 'right' was defined but never used; consider replacing with boolean test [#no-usage]\n 19 |         return false\n 20 |     } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/check-completeness-of-a-binary-tree_2\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "false",
      "input" : "root = [1,2,3,4,5,null,7]",
      "slug" : "check-completeness-of-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:5:15: error: cannot find type 'TreeNode' in scope\n  3 | class Solution {\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n    |               `- error: cannot find type 'TreeNode' in scope\n  6 |     init(_ root: TreeNode?) { \n  7 |         self.root = root \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:6:18: error: cannot find type 'TreeNode' in scope\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n  6 |     init(_ root: TreeNode?) { \n    |                  `- error: cannot find type 'TreeNode' in scope\n  7 |         self.root = root \n  8 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:26:24: error: cannot find type 'TreeNode' in scope\n 24 |         return -1 \n 25 |     } \n 26 |     func get_root() -> TreeNode? { \n    |                        `- error: cannot find type 'TreeNode' in scope\n 27 |         return root \n 28 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:253:23: error: value of type 'Solution' has no member 'insert'\n251 | \n252 | let arg0 = toInt(valueAt(args, 0))\n253 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n254 | let output: Any = result\n255 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:10:21: error: cannot find type 'TreeNode' in scope\n  8 |     } \n  9 |     func insert(_ v: Int) -> Int { \n 10 |         var queue: [TreeNode] = [root!] \n    |                     `- error: cannot find type 'TreeNode' in scope\n 11 |         while !queue.isEmpty { \n 12 |             let node = queue.removeFirst() \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:14:29: error: cannot find 'TreeNode' in scope\n 12 |             let node = queue.removeFirst() \n 13 |             if node.left == nil { \n 14 |                 node.left = TreeNode(v) \n    |                             `- error: cannot find 'TreeNode' in scope\n 15 |                 return node.val \n 16 |             } else if node.right == nil { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:17:30: error: cannot find 'TreeNode' in scope\n 15 |                 return node.val \n 16 |             } else if node.right == nil { \n 17 |                 node.right = TreeNode(v) \n    |                              `- error: cannot find 'TreeNode' in scope\n 18 |                 return node.val \n 19 |             } else { \n",
      "expected" : "2",
      "input" : "root = [1,2], v = 3",
      "slug" : "complete-binary-tree-inserter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:5:15: error: cannot find type 'TreeNode' in scope\n  3 | class Solution {\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n    |               `- error: cannot find type 'TreeNode' in scope\n  6 |     init(_ root: TreeNode?) { \n  7 |         self.root = root \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:6:18: error: cannot find type 'TreeNode' in scope\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n  6 |     init(_ root: TreeNode?) { \n    |                  `- error: cannot find type 'TreeNode' in scope\n  7 |         self.root = root \n  8 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:26:24: error: cannot find type 'TreeNode' in scope\n 24 |         return -1 \n 25 |     } \n 26 |     func get_root() -> TreeNode? { \n    |                        `- error: cannot find type 'TreeNode' in scope\n 27 |         return root \n 28 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:253:23: error: value of type 'Solution' has no member 'insert'\n251 | \n252 | let arg0 = toInt(valueAt(args, 0))\n253 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n254 | let output: Any = result\n255 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:10:21: error: cannot find type 'TreeNode' in scope\n  8 |     } \n  9 |     func insert(_ v: Int) -> Int { \n 10 |         var queue: [TreeNode] = [root!] \n    |                     `- error: cannot find type 'TreeNode' in scope\n 11 |         while !queue.isEmpty { \n 12 |             let node = queue.removeFirst() \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:14:29: error: cannot find 'TreeNode' in scope\n 12 |             let node = queue.removeFirst() \n 13 |             if node.left == nil { \n 14 |                 node.left = TreeNode(v) \n    |                             `- error: cannot find 'TreeNode' in scope\n 15 |                 return node.val \n 16 |             } else if node.right == nil { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_1\/solution.swift:17:30: error: cannot find 'TreeNode' in scope\n 15 |                 return node.val \n 16 |             } else if node.right == nil { \n 17 |                 node.right = TreeNode(v) \n    |                              `- error: cannot find 'TreeNode' in scope\n 18 |                 return node.val \n 19 |             } else { \n",
      "expected" : "4",
      "input" : "root = [1,2,3,4,5,6], v = 7",
      "slug" : "complete-binary-tree-inserter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:5:15: error: cannot find type 'TreeNode' in scope\n  3 | class Solution {\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n    |               `- error: cannot find type 'TreeNode' in scope\n  6 |     var queue: [TreeNode] \n  7 |     init(_ root: TreeNode?) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:6:17: error: cannot find type 'TreeNode' in scope\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n  6 |     var queue: [TreeNode] \n    |                 `- error: cannot find type 'TreeNode' in scope\n  7 |     init(_ root: TreeNode?) { \n  8 |         self.root = root \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:7:18: error: cannot find type 'TreeNode' in scope\n  5 |     var root: TreeNode? \n  6 |     var queue: [TreeNode] \n  7 |     init(_ root: TreeNode?) { \n    |                  `- error: cannot find type 'TreeNode' in scope\n  8 |         self.root = root \n  9 |         self.queue = [] \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:34:24: error: cannot find type 'TreeNode' in scope\n 32 |         return node.val \n 33 |     } \n 34 |     func get_root() -> TreeNode? { \n    |                        `- error: cannot find type 'TreeNode' in scope\n 35 |         return root \n 36 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:261:23: error: value of type 'Solution' has no member 'insert'\n259 | \n260 | let arg0 = toInt(valueAt(args, 0))\n261 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n262 | let output: Any = result\n263 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:10:17: error: cannot find type 'TreeNode' in scope\n  8 |         self.root = root \n  9 |         self.queue = [] \n 10 |         var q: [TreeNode] = [root!] \n    |                 `- error: cannot find type 'TreeNode' in scope\n 11 |         while !q.isEmpty { \n 12 |             let node = q.removeFirst() \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:27:25: error: cannot find 'TreeNode' in scope\n 25 |         let node = queue.removeFirst() \n 26 |         if node.left == nil { \n 27 |             node.left = TreeNode(v) \n    |                         `- error: cannot find 'TreeNode' in scope\n 28 |         } else { \n 29 |             node.right = TreeNode(v) \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:29:26: error: cannot find 'TreeNode' in scope\n 27 |             node.left = TreeNode(v) \n 28 |         } else { \n 29 |             node.right = TreeNode(v) \n    |                          `- error: cannot find 'TreeNode' in scope\n 30 |         } \n 31 |         queue.append(node) \n",
      "expected" : "2",
      "input" : "root = [1,2], v = 3",
      "slug" : "complete-binary-tree-inserter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:5:15: error: cannot find type 'TreeNode' in scope\n  3 | class Solution {\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n    |               `- error: cannot find type 'TreeNode' in scope\n  6 |     var queue: [TreeNode] \n  7 |     init(_ root: TreeNode?) { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:6:17: error: cannot find type 'TreeNode' in scope\n  4 | class CBTInserter { \n  5 |     var root: TreeNode? \n  6 |     var queue: [TreeNode] \n    |                 `- error: cannot find type 'TreeNode' in scope\n  7 |     init(_ root: TreeNode?) { \n  8 |         self.root = root \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:7:18: error: cannot find type 'TreeNode' in scope\n  5 |     var root: TreeNode? \n  6 |     var queue: [TreeNode] \n  7 |     init(_ root: TreeNode?) { \n    |                  `- error: cannot find type 'TreeNode' in scope\n  8 |         self.root = root \n  9 |         self.queue = [] \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:34:24: error: cannot find type 'TreeNode' in scope\n 32 |         return node.val \n 33 |     } \n 34 |     func get_root() -> TreeNode? { \n    |                        `- error: cannot find type 'TreeNode' in scope\n 35 |         return root \n 36 |     } \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:261:23: error: value of type 'Solution' has no member 'insert'\n259 | \n260 | let arg0 = toInt(valueAt(args, 0))\n261 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n262 | let output: Any = result\n263 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:10:17: error: cannot find type 'TreeNode' in scope\n  8 |         self.root = root \n  9 |         self.queue = [] \n 10 |         var q: [TreeNode] = [root!] \n    |                 `- error: cannot find type 'TreeNode' in scope\n 11 |         while !q.isEmpty { \n 12 |             let node = q.removeFirst() \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:27:25: error: cannot find 'TreeNode' in scope\n 25 |         let node = queue.removeFirst() \n 26 |         if node.left == nil { \n 27 |             node.left = TreeNode(v) \n    |                         `- error: cannot find 'TreeNode' in scope\n 28 |         } else { \n 29 |             node.right = TreeNode(v) \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/complete-binary-tree-inserter_2\/solution.swift:29:26: error: cannot find 'TreeNode' in scope\n 27 |             node.left = TreeNode(v) \n 28 |         } else { \n 29 |             node.right = TreeNode(v) \n    |                          `- error: cannot find 'TreeNode' in scope\n 30 |         } \n 31 |         queue.append(node) \n",
      "expected" : "4",
      "input" : "root = [1,2,3,4,5,6], v = 7",
      "slug" : "complete-binary-tree-inserter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "Tree with inorder traversal: 4,2,5,1,3 and postorder traversal: 4,5,2,3,1",
      "input" : "inorder = [4,2,5,1,3], postorder = [4,5,2,3,1]",
      "slug" : "construct-binary-tree-from-inorder-and-postorder-traversal",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "Tree with inorder traversal: 2,1,3 and postorder traversal: 2,3,1",
      "input" : "inorder = [2,1,3], postorder = [2,3,1]",
      "slug" : "construct-binary-tree-from-inorder-and-postorder-traversal",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "Tree with inorder traversal: 4,2,5,1,3 and postorder traversal: 4,5,2,3,1",
      "input" : "inorder = [4,2,5,1,3], postorder = [4,5,2,3,1]",
      "slug" : "construct-binary-tree-from-inorder-and-postorder-traversal",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "Tree with inorder traversal: 2,1,3 and postorder traversal: 2,3,1",
      "input" : "inorder = [2,1,3], postorder = [2,3,1]",
      "slug" : "construct-binary-tree-from-inorder-and-postorder-traversal",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[1,2,3,4,5,6,7]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "The tree with the given preorder and postorder traversal sequences.",
      "input" : "preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]",
      "slug" : "construct-binary-tree-from-preorder-and-postorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "A tree with a single node having value 1.",
      "input" : "preorder = [1], postorder = [1]",
      "slug" : "construct-binary-tree-from-preorder-and-postorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,2,null,4,null,5,null,3,null,6,null,7]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "The tree with the given preorder and postorder traversal sequences.",
      "input" : "preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]",
      "slug" : "construct-binary-tree-from-preorder-and-postorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "A tree with a single node having value 1.",
      "input" : "preorder = [1], postorder = [1]",
      "slug" : "construct-binary-tree-from-preorder-and-postorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "solution.Node",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "Node(val: true, isLeaf: false, topLeft: Node(val: false, isLeaf: true), topRight: Node(val: true, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
      "input" : "grid = [[0,1],[1,0]]",
      "slug" : "construct-quad-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "solution.Node",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "Node(val: true, isLeaf: false, topLeft: Node(val: true, isLeaf: true), topRight: Node(val: false, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
      "input" : "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
      "slug" : "construct-quad-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "solution.Node",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "Node(val: true, isLeaf: false, topLeft: Node(val: false, isLeaf: true), topRight: Node(val: true, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
      "input" : "grid = [[0,1],[1,0]]",
      "slug" : "construct-quad-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "solution.Node",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "Node(val: true, isLeaf: false, topLeft: Node(val: true, isLeaf: true), topRight: Node(val: false, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
      "input" : "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
      "slug" : "construct-quad-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:223:34: error: cannot find type 'TreeNode' in scope\n221 | }\n222 | \n223 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n224 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n225 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:241:30: error: cannot find type 'TreeNode' in scope\n239 | }\n240 | \n241 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n242 |     guard let root else { return [] }\n243 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:225:17: error: cannot find type 'TreeNode' in scope\n223 | func toTreeNode(_ value: Any) -> TreeNode? {\n224 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n225 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n226 |         if item is NSNull { return nil }\n227 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:244:17: error: cannot find type 'TreeNode' in scope\n242 |     guard let root else { return [] }\n243 |     var result: [Any] = []\n244 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n245 |     while !queue.isEmpty {\n246 |         let node = queue.removeFirst()\n",
      "expected" : "1(2(4))(3)",
      "input" : "t = [1,2,3,4]",
      "slug" : "construct-string-from-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:223:34: error: cannot find type 'TreeNode' in scope\n221 | }\n222 | \n223 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n224 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n225 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:241:30: error: cannot find type 'TreeNode' in scope\n239 | }\n240 | \n241 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n242 |     guard let root else { return [] }\n243 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:225:17: error: cannot find type 'TreeNode' in scope\n223 | func toTreeNode(_ value: Any) -> TreeNode? {\n224 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n225 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n226 |         if item is NSNull { return nil }\n227 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/construct-string-from-binary-tree_1\/solution.swift:244:17: error: cannot find type 'TreeNode' in scope\n242 |     guard let root else { return [] }\n243 |     var result: [Any] = []\n244 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n245 |     while !queue.isEmpty {\n246 |         let node = queue.removeFirst()\n",
      "expected" : "1(2()(4))(3)",
      "input" : "t = [1,2,3,null,4]",
      "slug" : "construct-string-from-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"1(2(4))(3)\"",
      "approachName" : "Iterative",
      "approachOrder" : 2,
      "expected" : "1(2(4))(3)",
      "input" : "t = [1,2,3,4]",
      "slug" : "construct-string-from-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"1(2(4))(3)\"",
      "approachName" : "Iterative",
      "approachOrder" : 2,
      "expected" : "1(2()(4))(3)",
      "input" : "t = [1,2,3,null,4]",
      "slug" : "construct-string-from-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:10:41: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    |                                         `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 11 |                        if let node = node {\n 12 |                            sum += node.val\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:14:62: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    :\n 12 |                            sum += node.val\n 13 |                            node.val = sum\n 14 |                            if let right = node.right { queue.append(right) }\n    |                                                              `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 15 |                            if let left = node.left { queue.append(left) }\n 16 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:15:60: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    :\n 13 |                            node.val = sum\n 14 |                            if let right = node.right { queue.append(right) }\n 15 |                            if let left = node.left { queue.append(left) }\n    |                                                            `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 16 |                        }\n 17 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:227:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 |         if item is NSNull { return nil }\n229 |         return TreeNode(toInt(item))\n",
      "expected" : "[30,36,21,36,35,26,15,null,null,null,16,null,null,8]",
      "input" : "root = [4,1,6,0,2,5,7,null,null,null,3,null,null,8]",
      "slug" : "convert-bst-to-greater-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:10:41: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    |                                         `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 11 |                        if let node = node {\n 12 |                            sum += node.val\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:14:62: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    :\n 12 |                            sum += node.val\n 13 |                            node.val = sum\n 14 |                            if let right = node.right { queue.append(right) }\n    |                                                              `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 15 |                            if let left = node.left { queue.append(left) }\n 16 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:15:60: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 |                    guard let root = root else { return nil }\n  7 |                    var sum = 0\n  8 |                    let queue = [TreeNode?](arrayLiteral: root)\n    |                    `- note: change 'let' to 'var' to make it mutable\n  9 |                    while !queue.isEmpty {\n 10 |                        let node = queue.removeFirst()\n    :\n 13 |                            node.val = sum\n 14 |                            if let right = node.right { queue.append(right) }\n 15 |                            if let left = node.left { queue.append(left) }\n    |                                                            `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 16 |                        }\n 17 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-bst-to-greater-tree_1\/solution.swift:227:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 |         if item is NSNull { return nil }\n229 |         return TreeNode(toInt(item))\n",
      "expected" : "[1,null,1]",
      "input" : "root = [0,null,1]",
      "slug" : "convert-bst-to-greater-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[30,36,21,36,35,26,7,null,null,null,33,null,null,15]",
      "approachName" : "Optimized Reverse In-Order Traversal Approach",
      "approachOrder" : 2,
      "expected" : "[30,36,21,36,35,26,15,null,null,null,16,null,null,8]",
      "input" : "root = [4,1,6,0,2,5,7,null,null,null,3,null,null,8]",
      "slug" : "convert-bst-to-greater-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[-10,null,-3,null,0,null,5,null,9]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "a balanced BST",
      "input" : "nums = [-10,-3,0,5,9]",
      "slug" : "convert-sorted-array-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1,null,2,null,3,null,4,null,5]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "a BST where 3 is the root",
      "input" : "nums = [1,2,3,4,5]",
      "slug" : "convert-sorted-array-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[3,1,4,null,2,null,5]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "a balanced BST with 3 as root",
      "input" : "nums = [1,2,3,4,5]",
      "slug" : "convert-sorted-array-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[4,2,6,1,3,5,7]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "a balanced BST with 4 as root",
      "input" : "nums = [1,2,3,4,5,6,7]",
      "slug" : "convert-sorted-array-to-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/cousins-in-binary-tree_1\/solution.swift:302:25: error: missing argument label 'val:' in call\n300 |     var nodes: [TreeNode?] = array.map { item in\n301 |         if item is NSNull { return nil }\n302 |         return TreeNode(toInt(item))\n    |                         `- error: missing argument label 'val:' in call\n303 |     }\n304 |     var index = 0\n",
      "expected" : "false",
      "input" : "root = [1,2,3,4], x = 4, y = 3",
      "slug" : "cousins-in-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/cousins-in-binary-tree_1\/solution.swift:302:25: error: missing argument label 'val:' in call\n300 |     var nodes: [TreeNode?] = array.map { item in\n301 |         if item is NSNull { return nil }\n302 |         return TreeNode(toInt(item))\n    |                         `- error: missing argument label 'val:' in call\n303 |     }\n304 |     var index = 0\n",
      "expected" : "true",
      "input" : "root = [1,2,3,null,4,null,5], x = 5, y = 4",
      "slug" : "cousins-in-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/cousins-in-binary-tree_2\/solution.swift:241:25: error: missing argument label 'val:' in call\n239 |     var nodes: [TreeNode?] = array.map { item in\n240 |         if item is NSNull { return nil }\n241 |         return TreeNode(toInt(item))\n    |                         `- error: missing argument label 'val:' in call\n242 |     }\n243 |     var index = 0\n",
      "expected" : "false",
      "input" : "root = [1,2,3,4], x = 4, y = 3",
      "slug" : "cousins-in-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/cousins-in-binary-tree_2\/solution.swift:241:25: error: missing argument label 'val:' in call\n239 |     var nodes: [TreeNode?] = array.map { item in\n240 |         if item is NSNull { return nil }\n241 |         return TreeNode(toInt(item))\n    |                         `- error: missing argument label 'val:' in call\n242 |     }\n243 |     var index = 0\n",
      "expected" : "true",
      "input" : "root = [1,2,3,null,4,null,5], x = 5, y = 4",
      "slug" : "cousins-in-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[5,4,6,2,null,null,7]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[5,2,6,2,4,null,7]",
      "input" : "root = [5,3,6,2,4,null,7], key = 3",
      "slug" : "delete-node-in-a-bst",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[5,4,6,2,null,null,7]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[5,2,6,null,null,4,7]",
      "input" : "root = [5,3,6,2,4,null,7], key = 3",
      "slug" : "delete-node-in-a-bst",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "TreeNode(3), TreeNode(0), TreeNode(0)",
      "slug" : "distribute-coins-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "TreeNode(0), TreeNode(3), TreeNode(0)",
      "slug" : "distribute-coins-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "TreeNode(3), TreeNode(0), TreeNode(0)",
      "slug" : "distribute-coins-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "TreeNode(0), TreeNode(3), TreeNode(0)",
      "slug" : "distribute-coins-in-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/employee-importance_1\/solution.swift:260:37: error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n258 | let arg0 = toArray(valueAt(args, 0)) { $0 }\n259 | let arg1 = toInt(valueAt(args, 1))\n260 | let result = solution.getImportance(arg0, arg1)\n    |                                     |- error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n    |                                     `- note: arguments to generic parameter 'Element' ('Any' and 'Solution.Employee') are expected to be equal\n261 | let output: Any = result\n262 | print(jsonString(from: output))\n",
      "expected" : "11",
      "input" : "employees = [Employee(1, 5, [2,3]), Employee(2, 3, []), Employee(3, 3, [])], id = 1",
      "slug" : "employee-importance",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/employee-importance_1\/solution.swift:260:37: error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n258 | let arg0 = toArray(valueAt(args, 0)) { $0 }\n259 | let arg1 = toInt(valueAt(args, 1))\n260 | let result = solution.getImportance(arg0, arg1)\n    |                                     |- error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n    |                                     `- note: arguments to generic parameter 'Element' ('Any' and 'Solution.Employee') are expected to be equal\n261 | let output: Any = result\n262 | print(jsonString(from: output))\n",
      "expected" : "7",
      "input" : "employees = [Employee(2, 3, []), Employee(3, 4, [2])], id = 3",
      "slug" : "employee-importance",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/employee-importance_2\/solution.swift:265:37: error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n263 | let arg0 = toArray(valueAt(args, 0)) { $0 }\n264 | let arg1 = toInt(valueAt(args, 1))\n265 | let result = solution.getImportance(arg0, arg1)\n    |                                     |- error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n    |                                     `- note: arguments to generic parameter 'Element' ('Any' and 'Solution.Employee') are expected to be equal\n266 | let output: Any = result\n267 | print(jsonString(from: output))\n",
      "expected" : "11",
      "input" : "employees = [Employee(1, 5, [2,3]), Employee(2, 3, []), Employee(3, 3, [])], id = 1",
      "slug" : "employee-importance",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/employee-importance_2\/solution.swift:265:37: error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n263 | let arg0 = toArray(valueAt(args, 0)) { $0 }\n264 | let arg1 = toInt(valueAt(args, 1))\n265 | let result = solution.getImportance(arg0, arg1)\n    |                                     |- error: cannot convert value of type '[Any]' to expected argument type '[Solution.Employee]'\n    |                                     `- note: arguments to generic parameter 'Element' ('Any' and 'Solution.Employee') are expected to be equal\n266 | let output: Any = result\n267 | print(jsonString(from: output))\n",
      "expected" : "7",
      "input" : "employees = [Employee(2, 3, []), Employee(3, 4, [2])], id = 3",
      "slug" : "employee-importance",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "4",
      "approachName" : "Brute-Force BFS",
      "approachOrder" : 1,
      "expected" : "7",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "find-bottom-left-tree-value",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "4",
      "approachName" : "Depth-First Search",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "find-bottom-left-tree-value",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[1,2]",
      "input" : "root = [1,2,3,1,null,2]",
      "slug" : "find-duplicate-subtrees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[1]",
      "input" : "root = [2,1,1]",
      "slug" : "find-duplicate-subtrees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:16:167: error: type 'TreeNode' does not conform to protocol 'Hashable'\n 14 |                }\n 15 | \n 16 |                func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?], _ idxMap: inout [Int: Int], _ idx: inout Int, _ ids: inout [TreeNode?: Int]) -> Int {\n    |                                                                                                                                                                       `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n 17 |                    if root == nil {\n 18 |                        return 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:16:167: error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n 14 |                }\n 15 | \n 16 |                func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?], _ idxMap: inout [Int: Int], _ idx: inout Int, _ ids: inout [TreeNode?: Int]) -> Int {\n    |                                                                                                                                                                       |- error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n    |                                                                                                                                                                       |- note: requirement specified as 'TreeNode' : 'Hashable'\n    |                                                                                                                                                                       `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n 17 |                    if root == nil {\n 18 |                        return 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:10:29: error: type 'TreeNode' does not conform to protocol 'Hashable'\n  8 |                    var idxMap: [Int: Int] = [:]\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n    |                             `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:10:29: error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  8 |                    var idxMap: [Int: Int] = [:]\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n    |                             |- error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n    |                             |- note: requirement specified as 'TreeNode' : 'Hashable'\n    |                             `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:11:23: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n 11 |                    ids[root] = 0\n    |                       `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n 13 |                    return result\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:12:20: warning: result of call to 'traverse' is unused [#no-usage]\n 10 |                    var ids: [TreeNode?: Int] = [:]\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n    |                    `- warning: result of call to 'traverse' is unused [#no-usage]\n 13 |                    return result\n 14 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:22:44: error: type annotation missing in pattern\n 20 |                    let left = traverse(root?.left, &count, &result, &idxMap, &idx, &ids)\n 21 |                    let right = traverse(root?.right, &count, &result, &idxMap, &idx, &ids)\n 22 |                    let hash = (root!.val),(left),(right)\n    |                                            `- error: type annotation missing in pattern\n 23 |                    if idxMap[hash] == nil {\n 24 |                        idxMap[hash] = idx\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:22:51: error: type annotation missing in pattern\n 20 |                    let left = traverse(root?.left, &count, &result, &idxMap, &idx, &ids)\n 21 |                    let right = traverse(root?.right, &count, &result, &idxMap, &idx, &ids)\n 22 |                    let hash = (root!.val),(left),(right)\n    |                                                   `- error: type annotation missing in pattern\n 23 |                    if idxMap[hash] == nil {\n 24 |                        idxMap[hash] = idx\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:28:26: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 26 |                    }\n 27 |                    let id = idxMap[hash]!\n 28 |                    if ids[root] == nil {\n    |                          `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 29 |                        ids[root] = id\n 30 |                    }\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:29:27: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 27 |                    let id = idxMap[hash]!\n 28 |                    if ids[root] == nil {\n 29 |                        ids[root] = id\n    |                           `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 30 |                    }\n 31 |                    if count[hash] == 1 {\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:31:29: error: cannot convert value of type 'Int' to expected argument type 'String'\n 29 |                        ids[root] = id\n 30 |                    }\n 31 |                    if count[hash] == 1 {\n    |                             `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 32 |                        result.append(root)\n 33 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:34:29: error: cannot convert value of type 'Int' to expected argument type 'String'\n 32 |                        result.append(root)\n 33 |                    }\n 34 |                    if count[hash] != nil {\n    |                             `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 35 |                        count[hash]! += 1\n 36 |                    } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:35:30: error: cannot convert value of type 'Int' to expected argument type 'String'\n 33 |                    }\n 34 |                    if count[hash] != nil {\n 35 |                        count[hash]! += 1\n    |                              `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 36 |                    } else {\n 37 |                        count[hash] = 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:37:30: error: cannot convert value of type 'Int' to expected argument type 'String'\n 35 |                        count[hash]! += 1\n 36 |                    } else {\n 37 |                        count[hash] = 1\n    |                              `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 38 |                    }\n 39 |                    return id\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:248:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n246 | func toTreeNode(_ value: Any) -> TreeNode? {\n247 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n248 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n249 |         if item is NSNull { return nil }\n250 |         return TreeNode(toInt(item))\n",
      "expected" : "[1,2]",
      "input" : "root = [1,2,3,1,null,2]",
      "slug" : "find-duplicate-subtrees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:16:167: error: type 'TreeNode' does not conform to protocol 'Hashable'\n 14 |                }\n 15 | \n 16 |                func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?], _ idxMap: inout [Int: Int], _ idx: inout Int, _ ids: inout [TreeNode?: Int]) -> Int {\n    |                                                                                                                                                                       `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n 17 |                    if root == nil {\n 18 |                        return 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:16:167: error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n 14 |                }\n 15 | \n 16 |                func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?], _ idxMap: inout [Int: Int], _ idx: inout Int, _ ids: inout [TreeNode?: Int]) -> Int {\n    |                                                                                                                                                                       |- error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n    |                                                                                                                                                                       |- note: requirement specified as 'TreeNode' : 'Hashable'\n    |                                                                                                                                                                       `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n 17 |                    if root == nil {\n 18 |                        return 0\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:10:29: error: type 'TreeNode' does not conform to protocol 'Hashable'\n  8 |                    var idxMap: [Int: Int] = [:]\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n    |                             `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:10:29: error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  8 |                    var idxMap: [Int: Int] = [:]\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n    |                             |- error: 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n    |                             |- note: requirement specified as 'TreeNode' : 'Hashable'\n    |                             `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:11:23: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n  9 |                    var idx = 1\n 10 |                    var ids: [TreeNode?: Int] = [:]\n 11 |                    ids[root] = 0\n    |                       `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n 13 |                    return result\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:12:20: warning: result of call to 'traverse' is unused [#no-usage]\n 10 |                    var ids: [TreeNode?: Int] = [:]\n 11 |                    ids[root] = 0\n 12 |                    traverse(root, &count, &result, &idxMap, &idx, &ids)\n    |                    `- warning: result of call to 'traverse' is unused [#no-usage]\n 13 |                    return result\n 14 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:22:44: error: type annotation missing in pattern\n 20 |                    let left = traverse(root?.left, &count, &result, &idxMap, &idx, &ids)\n 21 |                    let right = traverse(root?.right, &count, &result, &idxMap, &idx, &ids)\n 22 |                    let hash = (root!.val),(left),(right)\n    |                                            `- error: type annotation missing in pattern\n 23 |                    if idxMap[hash] == nil {\n 24 |                        idxMap[hash] = idx\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:22:51: error: type annotation missing in pattern\n 20 |                    let left = traverse(root?.left, &count, &result, &idxMap, &idx, &ids)\n 21 |                    let right = traverse(root?.right, &count, &result, &idxMap, &idx, &ids)\n 22 |                    let hash = (root!.val),(left),(right)\n    |                                                   `- error: type annotation missing in pattern\n 23 |                    if idxMap[hash] == nil {\n 24 |                        idxMap[hash] = idx\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:28:26: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 26 |                    }\n 27 |                    let id = idxMap[hash]!\n 28 |                    if ids[root] == nil {\n    |                          `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 29 |                        ids[root] = id\n 30 |                    }\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:29:27: error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 27 |                    let id = idxMap[hash]!\n 28 |                    if ids[root] == nil {\n 29 |                        ids[root] = id\n    |                           `- error: referencing subscript 'subscript(_:)' on 'Optional' requires that 'TreeNode' conform to 'Hashable'\n 30 |                    }\n 31 |                    if count[hash] == 1 {\n\nSwift.Optional:1:11: note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n1 | extension Optional : Hashable where Wrapped : Hashable {\n  |           `- note: requirement from conditional conformance of 'TreeNode?' to 'Hashable'\n2 |     @inlinable public func hash(into hasher: inout Hasher)\n3 |     public var hashValue: Int { get }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:31:29: error: cannot convert value of type 'Int' to expected argument type 'String'\n 29 |                        ids[root] = id\n 30 |                    }\n 31 |                    if count[hash] == 1 {\n    |                             `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 32 |                        result.append(root)\n 33 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:34:29: error: cannot convert value of type 'Int' to expected argument type 'String'\n 32 |                        result.append(root)\n 33 |                    }\n 34 |                    if count[hash] != nil {\n    |                             `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 35 |                        count[hash]! += 1\n 36 |                    } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:35:30: error: cannot convert value of type 'Int' to expected argument type 'String'\n 33 |                    }\n 34 |                    if count[hash] != nil {\n 35 |                        count[hash]! += 1\n    |                              `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 36 |                    } else {\n 37 |                        count[hash] = 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:37:30: error: cannot convert value of type 'Int' to expected argument type 'String'\n 35 |                        count[hash]! += 1\n 36 |                    } else {\n 37 |                        count[hash] = 1\n    |                              `- error: cannot convert value of type 'Int' to expected argument type 'String'\n 38 |                    }\n 39 |                    return id\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-duplicate-subtrees_2\/solution.swift:248:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n246 | func toTreeNode(_ value: Any) -> TreeNode? {\n247 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n248 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n249 |         if item is NSNull { return nil }\n250 |         return TreeNode(toInt(item))\n",
      "expected" : "[1]",
      "input" : "root = [2,1,1]",
      "slug" : "find-duplicate-subtrees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[0,0,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1,3,9]",
      "input" : "TreeNode(1) \n      \/   \\\n     3     2 \n    \/ \\   \\\n   5   3   9",
      "slug" : "find-largest-value-in-each-tree-row",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1]",
      "input" : "TreeNode(1)",
      "slug" : "find-largest-value-in-each-tree-row",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[0,0,0]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1,3,9]",
      "input" : "TreeNode(1) \n      \/   \\\n     3     2 \n    \/ \\   \\\n   5   3   9",
      "slug" : "find-largest-value-in-each-tree-row",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1]",
      "input" : "TreeNode(1)",
      "slug" : "find-largest-value-in-each-tree-row",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force: In-Order Traversal and Hash Map",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:1: error: expected 'func' keyword in instance method declaration\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:7: error: expected parameter name followed by ':'\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:32: error: expected '}' in class\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    |                `- note: to match this opening '{'\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n  6 |     func inOrder(_ node: TreeNode?) {\n    :\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:3:37: error: value type 'TreeNode' cannot have a stored property that recursively contains it\n  1 | import Foundation\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n    |                                     |- error: value type 'TreeNode' cannot have a stored property that recursively contains it\n    |                                     `- note: cycle beginning here: TreeNode? -> (some(_:): TreeNode)\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:261:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n259 | }\n260 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n261 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n262 | let args = parseArgs(from: input, expectedCount: 1)\n263 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:262:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n260 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n261 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n262 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n263 | let hasInput = !args.isEmpty\n264 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:266:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n264 | let solution = Solution()\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:266:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n264 | let solution = Solution()\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:267:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n267 | let result = solution.findMode(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:221:48: error: cannot assign to property: 'node' is a 'let' constant\n219 |     while childIndex < nodes.count {\n220 |         if let node = nodes[index] {\n221 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n222 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n223 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:222:48: error: cannot assign to property: 'node' is a 'let' constant\n220 |         if let node = nodes[index] {\n221 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n222 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n223 |         }\n224 |         index += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:1: error: expected '{' in body of function declaration\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[2]",
      "input" : "root = [1,null,2,2]",
      "slug" : "find-mode-in-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force: In-Order Traversal and Hash Map",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:1: error: expected 'func' keyword in instance method declaration\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:7: error: expected parameter name followed by ':'\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:32: error: expected '}' in class\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    |                `- note: to match this opening '{'\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n  6 |     func inOrder(_ node: TreeNode?) {\n    :\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:3:37: error: value type 'TreeNode' cannot have a stored property that recursively contains it\n  1 | import Foundation\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n    |                                     |- error: value type 'TreeNode' cannot have a stored property that recursively contains it\n    |                                     `- note: cycle beginning here: TreeNode? -> (some(_:): TreeNode)\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:261:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n259 | }\n260 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n261 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n262 | let args = parseArgs(from: input, expectedCount: 1)\n263 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:262:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n260 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n261 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n262 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n263 | let hasInput = !args.isEmpty\n264 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:266:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n264 | let solution = Solution()\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:266:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n264 | let solution = Solution()\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:267:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n265 | \n266 | let arg0 = toTreeNode(valueAt(args, 0))\n267 | let result = solution.findMode(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:221:48: error: cannot assign to property: 'node' is a 'let' constant\n219 |     while childIndex < nodes.count {\n220 |         if let node = nodes[index] {\n221 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n222 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n223 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:222:48: error: cannot assign to property: 'node' is a 'let' constant\n220 |         if let node = nodes[index] {\n221 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n222 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n223 |         }\n224 |         index += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_1\/solution.swift:269:1: error: expected '{' in body of function declaration\n267 | let result = solution.findMode(arg0)\n268 | let output: Any = result\n269 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[0]",
      "input" : "root = [0]",
      "slug" : "find-mode-in-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized: Morris Traversal and Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:1: error: expected 'func' keyword in instance method declaration\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:7: error: expected parameter name followed by ':'\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:32: error: expected '}' in class\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    |                `- note: to match this opening '{'\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n  6 |     var current: TreeNode? = root;\n    :\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:3:37: error: value type 'TreeNode' cannot have a stored property that recursively contains it\n  1 | import Foundation\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n    |                                     |- error: value type 'TreeNode' cannot have a stored property that recursively contains it\n    |                                     `- note: cycle beginning here: TreeNode? -> (some(_:): TreeNode)\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:274:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n272 | }\n273 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n274 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n275 | let args = parseArgs(from: input, expectedCount: 1)\n276 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:275:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n273 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n274 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n275 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n276 | let hasInput = !args.isEmpty\n277 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:279:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n277 | let solution = Solution()\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:279:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n277 | let solution = Solution()\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:280:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n280 | let result = solution.findMode(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:13:77: error: argument type 'TreeNode' expected to be an instance of a class or class-constrained type\n 11 |         } else {\n 12 |             var predecessor: TreeNode? = node.left;\n 13 |             while let pred = predecessor, pred.right != nil, pred.right !== node {\n    |                                                                             `- error: argument type 'TreeNode' expected to be an instance of a class or class-constrained type\n 14 |                 predecessor = pred.right;\n 15 |             }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:234:48: error: cannot assign to property: 'node' is a 'let' constant\n232 |     while childIndex < nodes.count {\n233 |         if let node = nodes[index] {\n234 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n235 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n236 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:235:48: error: cannot assign to property: 'node' is a 'let' constant\n233 |         if let node = nodes[index] {\n234 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n235 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n236 |         }\n237 |         index += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:1: error: expected '{' in body of function declaration\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[2]",
      "input" : "root = [1,null,2,2]",
      "slug" : "find-mode-in-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized: Morris Traversal and Hash Map",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:1: error: expected 'func' keyword in instance method declaration\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:7: error: expected parameter name followed by ':'\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:32: error: expected '}' in class\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    |                `- note: to match this opening '{'\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n  6 |     var current: TreeNode? = root;\n    :\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:3:37: error: value type 'TreeNode' cannot have a stored property that recursively contains it\n  1 | import Foundation\n  2 | \n  3 | struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\n    |                                     |- error: value type 'TreeNode' cannot have a stored property that recursively contains it\n    |                                     `- note: cycle beginning here: TreeNode? -> (some(_:): TreeNode)\n  4 | class Solution { func findMode(_ root: TreeNode?) -> [Int] {\n  5 |     var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:274:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n272 | }\n273 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n274 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n275 | let args = parseArgs(from: input, expectedCount: 1)\n276 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:275:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n273 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n274 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n275 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n276 | let hasInput = !args.isEmpty\n277 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:279:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n277 | let solution = Solution()\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:279:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n277 | let solution = Solution()\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:280:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n278 | \n279 | let arg0 = toTreeNode(valueAt(args, 0))\n280 | let result = solution.findMode(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:13:77: error: argument type 'TreeNode' expected to be an instance of a class or class-constrained type\n 11 |         } else {\n 12 |             var predecessor: TreeNode? = node.left;\n 13 |             while let pred = predecessor, pred.right != nil, pred.right !== node {\n    |                                                                             `- error: argument type 'TreeNode' expected to be an instance of a class or class-constrained type\n 14 |                 predecessor = pred.right;\n 15 |             }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:234:48: error: cannot assign to property: 'node' is a 'let' constant\n232 |     while childIndex < nodes.count {\n233 |         if let node = nodes[index] {\n234 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n235 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n236 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:235:48: error: cannot assign to property: 'node' is a 'let' constant\n233 |         if let node = nodes[index] {\n234 |             if childIndex < nodes.count { node.left = nodes[childIndex]; childIndex += 1 }\n235 |             if childIndex < nodes.count { node.right = nodes[childIndex]; childIndex += 1 }\n    |                                                `- error: cannot assign to property: 'node' is a 'let' constant\n236 |         }\n237 |         index += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-mode-in-binary-search-tree_2\/solution.swift:282:1: error: expected '{' in body of function declaration\n280 | let result = solution.findMode(arg0)\n281 | let output: Any = result\n282 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[0]",
      "input" : "root = [0]",
      "slug" : "find-mode-in-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "root1 = [1,2,3,4,5,6,7], root2 = [1,3,2,6,4,5,7]",
      "slug" : "flip-binary-tree-to-match-preorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "root1 = [1,2,3,4,5,6,7], root2 = [1,3,2,6,4,5,7]",
      "slug" : "flip-binary-tree-to-match-preorder-traversal",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:3:170: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { guard let root1 = root1, let root2 = root2 else { return root1 == nil && root2 == nil } if root1.val != root2.val { return false } return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)) } }\n    |                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:3:213: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { guard let root1 = root1, let root2 = root2 else { return root1 == nil && root2 == nil } if root1.val != root2.val { return false } return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)) } }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "true",
      "input" : "root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,null,6,4,null,null,8,7]",
      "slug" : "flip-equivalent-binary-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:3:170: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { guard let root1 = root1, let root2 = root2 else { return root1 == nil && root2 == nil } if root1.val != root2.val { return false } return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)) } }\n    |                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:3:213: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { guard let root1 = root1, let root2 = root2 else { return root1 == nil && root2 == nil } if root1.val != root2.val { return false } return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)) } }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "false",
      "input" : "root1 = [1,2,3], root2 = [1,3,2]",
      "slug" : "flip-equivalent-binary-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Depth-First Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:109: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                             `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:256: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:299: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:373: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:448: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "true",
      "input" : "root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,null,6,4,null,null,8,7]",
      "slug" : "flip-equivalent-binary-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Depth-First Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:109: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                             `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:256: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:299: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:373: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:3:448: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/flip-equivalent-binary-trees_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "false",
      "input" : "root1 = [1,2,3], root2 = [1,3,2]",
      "slug" : "flip-equivalent-binary-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[40,20,60,10,30,50,70,null,null,25]",
      "approachName" : "Recursive Approach",
      "approachOrder" : 1,
      "expected" : "[40,20,60,10,30,50,70,25]",
      "input" : "root = [40,20,60,10,30,50,70], val = 25",
      "slug" : "insert-into-a-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:3:262: error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { guard let root = root else { return TreeNode(val) }; var node = root; while true { if val < node.val { if node.left == nil { node.left = TreeNode(val); break } else { node = node.left } } else { if node.right == nil { node.right = TreeNode(val); break } else { node = node.right } } }; return root } }\n    |                                                                                                                                                                                                                                                                      |- error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n    |                                                                                                                                                                                                                                                                      |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                      `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:3:356: error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { guard let root = root else { return TreeNode(val) }; var node = root; while true { if val < node.val { if node.left == nil { node.left = TreeNode(val); break } else { node = node.left } } else { if node.right == nil { node.right = TreeNode(val); break } else { node = node.right } } }; return root } }\n    |                                                                                                                                                                                                                                                                                                                                                                    |- error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                                                                                                    |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                                                                                    `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[4,2,7,1,3,5]",
      "input" : "root = [4,2,7,1,3], val = 5",
      "slug" : "insert-into-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Iterative Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:3:262: error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { guard let root = root else { return TreeNode(val) }; var node = root; while true { if val < node.val { if node.left == nil { node.left = TreeNode(val); break } else { node = node.left } } else { if node.right == nil { node.right = TreeNode(val); break } else { node = node.right } } }; return root } }\n    |                                                                                                                                                                                                                                                                      |- error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n    |                                                                                                                                                                                                                                                                      |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                      `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:3:356: error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { guard let root = root else { return TreeNode(val) }; var node = root; while true { if val < node.val { if node.left == nil { node.left = TreeNode(val); break } else { node = node.left } } else { if node.right == nil { node.right = TreeNode(val); break } else { node = node.right } } }; return root } }\n    |                                                                                                                                                                                                                                                                                                                                                                    |- error: value of optional type 'TreeNode?' must be unwrapped to a value of type 'TreeNode'\n    |                                                                                                                                                                                                                                                                                                                                                                    |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                                                                                                                                                                                                                                                    `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-into-a-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[40,20,60,10,30,50,70,25]",
      "input" : "root = [40,20,60,10,30,50,70], val = 25",
      "slug" : "insert-into-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "true",
      "input" : "tree1: [3,5,1,6,2,9,8,7,4], tree2: [3,5,1,6,2,9,8,7,4]",
      "slug" : "leaf-similar-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_1\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "false",
      "input" : "tree1: [1,2,3], tree2: [1,3,2]",
      "slug" : "leaf-similar-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:240:34: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:258:30: error: cannot find type 'TreeNode' in scope\n256 | }\n257 | \n258 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n259 |     guard let root else { return [] }\n260 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:242:17: error: cannot find type 'TreeNode' in scope\n240 | func toTreeNode(_ value: Any) -> TreeNode? {\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n243 |         if item is NSNull { return nil }\n244 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:261:17: error: cannot find type 'TreeNode' in scope\n259 |     guard let root else { return [] }\n260 |     var result: [Any] = []\n261 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n262 |     while !queue.isEmpty {\n263 |         let node = queue.removeFirst()\n",
      "expected" : "true",
      "input" : "tree1: [3,5,1,6,2,9,8,7,4], tree2: [3,5,1,6,2,9,8,7,4]",
      "slug" : "leaf-similar-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:240:34: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:258:30: error: cannot find type 'TreeNode' in scope\n256 | }\n257 | \n258 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n259 |     guard let root else { return [] }\n260 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:242:17: error: cannot find type 'TreeNode' in scope\n240 | func toTreeNode(_ value: Any) -> TreeNode? {\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n243 |         if item is NSNull { return nil }\n244 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/leaf-similar-trees_2\/solution.swift:261:17: error: cannot find type 'TreeNode' in scope\n259 |     guard let root else { return [] }\n260 |     var result: [Any] = []\n261 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n262 |     while !queue.isEmpty {\n263 |         let node = queue.removeFirst()\n",
      "expected" : "true",
      "input" : "tree1: [1], tree2: [1]",
      "slug" : "leaf-similar-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:68: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                                    `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:38: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                      `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:58: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                          `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n",
      "expected" : "[0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1]",
      "input" : "quadTree1 = [0,1,1,1,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,1,0,1], quadTree2 = [0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1]",
      "slug" : "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:68: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                                    `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:38: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                      `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_1\/solution.swift:5:58: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                          `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n",
      "expected" : "[1]",
      "input" : "quadTree1 = [1,1,1,1,1,1,1,1], quadTree2 = [1,1,1,1,1,1,1,1]",
      "slug" : "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:68: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                                    `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:38: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                      `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:58: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                          `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n",
      "expected" : "[0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1]",
      "input" : "quadTree1 = [0,1,1,1,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,1,0,1], quadTree2 = [0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1]",
      "slug" : "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:68: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                                    `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:38: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                      `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/logical-or-of-two-binary-grids-represented-as-quad-trees_2\/solution.swift:5:58: error: cannot find type 'Node' in scope\n  3 | \n  4 |        class Solution {\n  5 |          func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    |                                                          `- error: cannot find type 'Node' in scope\n  6 |            guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n  7 |            if quadTree1.val == 1 { return quadTree1 }\n",
      "expected" : "[1]",
      "input" : "quadTree1 = [1,1,1,1,1,1,1,1], quadTree2 = [1,1,1,1,1,1,1,1]",
      "slug" : "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "root = [5,4,5,1,1,5]",
      "slug" : "longest-univalue-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "root = [1,4,5,4,4,5]",
      "slug" : "longest-univalue-path",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Iterative BST Walk",
      "approachOrder" : 1,
      "expected" : "6",
      "input" : "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
      "slug" : "lowest-common-ancestor-of-a-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Iterative BST Walk",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
      "slug" : "lowest-common-ancestor-of-a-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Recursive BST",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "root = [2,1], p = 2, q = 1",
      "slug" : "lowest-common-ancestor-of-a-binary-search-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Recursive",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "root=[3,5,1,6,2,0,8], p=5, q=1",
      "slug" : "lowest-common-ancestor-of-a-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "Maximum Binary Tree: 6\n    \/   \\\n   3     5\n  \/ \\   \n 2   0\n\/ \n1  nil",
      "input" : "nums = [3,2,1,6,0,5]",
      "slug" : "maximum-binary-tree-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_1\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "Maximum Binary Tree: 3\n    \/   \\\n   2     nil\n  \/ \n 1  nil",
      "input" : "nums = [3,2,1]",
      "slug" : "maximum-binary-tree-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:225:34: error: cannot find type 'TreeNode' in scope\n223 | }\n224 | \n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:243:30: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n244 |     guard let root else { return [] }\n245 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:227:17: error: cannot find type 'TreeNode' in scope\n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n228 |         if item is NSNull { return nil }\n229 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:246:17: error: cannot find type 'TreeNode' in scope\n244 |     guard let root else { return [] }\n245 |     var result: [Any] = []\n246 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n247 |     while !queue.isEmpty {\n248 |         let node = queue.removeFirst()\n",
      "expected" : "Maximum Binary Tree: 6\n    \/   \\\n   3     5\n  \/ \\   \n 2   0\n\/ \n1  nil",
      "input" : "nums = [3,2,1,6,0,5]",
      "slug" : "maximum-binary-tree-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:225:34: error: cannot find type 'TreeNode' in scope\n223 | }\n224 | \n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:243:30: error: cannot find type 'TreeNode' in scope\n241 | }\n242 | \n243 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n244 |     guard let root else { return [] }\n245 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:227:17: error: cannot find type 'TreeNode' in scope\n225 | func toTreeNode(_ value: Any) -> TreeNode? {\n226 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n227 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n228 |         if item is NSNull { return nil }\n229 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-binary-tree-ii_2\/solution.swift:246:17: error: cannot find type 'TreeNode' in scope\n244 |     guard let root else { return [] }\n245 |     var result: [Any] = []\n246 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n247 |     while !queue.isEmpty {\n248 |         let node = queue.removeFirst()\n",
      "expected" : "Maximum Binary Tree: 3\n    \/   \\\n   2     nil\n  \/ \n 1  nil",
      "input" : "nums = [3,2,1]",
      "slug" : "maximum-binary-tree-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_1\/solution.swift:249:32: error: cannot convert value of type 'Any' to expected argument type 'Node'\n247 | \n248 | let arg0 = valueAt(args, 0)\n249 | let result = solution.maxDepth(arg0)\n    |                                `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n250 | let output: Any = result\n251 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "root = [1,null,3,2,4,null,5,6]",
      "slug" : "maximum-depth-of-n-ary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_1\/solution.swift:249:32: error: cannot convert value of type 'Any' to expected argument type 'Node'\n247 | \n248 | let arg0 = valueAt(args, 0)\n249 | let result = solution.maxDepth(arg0)\n    |                                `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n250 | let output: Any = result\n251 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "root = [1,null,2,3,4,5,null,null,6,7,null,8]",
      "slug" : "maximum-depth-of-n-ary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_2\/solution.swift:258:32: error: cannot convert value of type 'Any' to expected argument type 'Node'\n256 | \n257 | let arg0 = valueAt(args, 0)\n258 | let result = solution.maxDepth(arg0)\n    |                                `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n259 | let output: Any = result\n260 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_2\/solution.swift:26:27: error: initializer for conditional binding must have Optional type, not '[Node?]'\n 24 |                    for _ in 1...levelSize {\n 25 |                        let node = queue.removeFirst()\n 26 |                        if let children = node.children {\n    |                           `- error: initializer for conditional binding must have Optional type, not '[Node?]'\n 27 |                            queue.append(contentsOf: children.compactMap { $0 })\n 28 |                        }\n",
      "expected" : "3",
      "input" : "root = [1,null,3,2,4,null,5,6]",
      "slug" : "maximum-depth-of-n-ary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_2\/solution.swift:258:32: error: cannot convert value of type 'Any' to expected argument type 'Node'\n256 | \n257 | let arg0 = valueAt(args, 0)\n258 | let result = solution.maxDepth(arg0)\n    |                                `- error: cannot convert value of type 'Any' to expected argument type 'Node'\n259 | let output: Any = result\n260 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-depth-of-n-ary-tree_2\/solution.swift:26:27: error: initializer for conditional binding must have Optional type, not '[Node?]'\n 24 |                    for _ in 1...levelSize {\n 25 |                        let node = queue.removeFirst()\n 26 |                        if let children = node.children {\n    |                           `- error: initializer for conditional binding must have Optional type, not '[Node?]'\n 27 |                            queue.append(contentsOf: children.compactMap { $0 })\n 28 |                        }\n",
      "expected" : "3",
      "input" : "root = [1,null,2,3,4,5,null,null,6,7,null,8]",
      "slug" : "maximum-depth-of-n-ary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:163: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:327: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:195: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                   `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:247: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                       `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:262: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                      `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:295: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                       `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:310: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "7",
      "input" : "root = [8,3,10,1,6,14,4,7,13]",
      "slug" : "maximum-difference-between-node-and-ancestor",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:163: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:327: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:195: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                   `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:247: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                       `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:262: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                      `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:295: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                       `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:3:310: error: cannot call value of non-function type 'Int'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) { if node == nil { return } let val = node!.val; maxDiff = max(maxDiff, max - val, val - min); dfs(node!.left, min(min, val), max(max, val)); dfs(node!.right, min(min, val), max(max, val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: cannot call value of non-function type 'Int'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "1",
      "input" : "root = [3,1,2]",
      "slug" : "maximum-difference-between-node-and-ancestor",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized DFS",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:3:173: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ minA: Int, _ maxA: Int) -> Void { if node == nil { return } maxDiff = max(maxDiff, maxA - node!.val, node!.val - minA); dfs(node!.left, min(minA, node!.val), max(maxA, node!.val)); dfs(node!.right, min(minA, node!.val), max(maxA, node!.val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:3:358: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ minA: Int, _ maxA: Int) -> Void { if node == nil { return } maxDiff = max(maxDiff, maxA - node!.val, node!.val - minA); dfs(node!.left, min(minA, node!.val), max(maxA, node!.val)); dfs(node!.right, min(minA, node!.val), max(maxA, node!.val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "7",
      "input" : "root = [8,3,10,1,6,14,4,7,13]",
      "slug" : "maximum-difference-between-node-and-ancestor",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized DFS",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:3:173: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ minA: Int, _ maxA: Int) -> Void { if node == nil { return } maxDiff = max(maxDiff, maxA - node!.val, node!.val - minA); dfs(node!.left, min(minA, node!.val), max(maxA, node!.val)); dfs(node!.right, min(minA, node!.val), max(maxA, node!.val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:3:358: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ minA: Int, _ maxA: Int) -> Void { if node == nil { return } maxDiff = max(maxDiff, maxA - node!.val, node!.val - minA); dfs(node!.left, min(minA, node!.val), max(maxA, node!.val)); dfs(node!.right, min(minA, node!.val), max(maxA, node!.val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }\n    |                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-difference-between-node-and-ancestor_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "1",
      "input" : "root = [3,1,2]",
      "slug" : "maximum-difference-between-node-and-ancestor",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "root = [1,3,2,5]",
      "slug" : "maximum-width-of-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "root = [1,3,2,5]",
      "slug" : "maximum-width-of-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "[2,null,2]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[2,1,2]",
      "input" : "t1 = [1], t2 = [1,null,2]",
      "slug" : "merge-two-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[2,null,2]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[2,1,2]",
      "input" : "t1 = [1], t2 = [1,null,2]",
      "slug" : "merge-two-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "-22",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "0",
      "input" : "root = [1,0,48,1,null,42,49,null,null,null,null,33,null,null,30,44,48,null,null,8,52,null,null,null,null,45]",
      "slug" : "minimum-absolute-difference-in-bst",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "-22",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "root = [1,0,48,1,null,42,49,null,null,null,null,33,null,null,30,44,48,null,null,8,52,null,null,null,null,45]",
      "slug" : "minimum-absolute-difference-in-bst",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "1",
      "input" : "root = [4,2,6,1,3]",
      "slug" : "minimum-distance-between-bst-nodes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_1\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "2147483647",
      "input" : "root = [90]",
      "slug" : "minimum-distance-between-bst-nodes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "1",
      "input" : "root = [4,2,6,1,3]",
      "slug" : "minimum-distance-between-bst-nodes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-distance-between-bst-nodes_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "2147483647",
      "input" : "root = [90]",
      "slug" : "minimum-distance-between-bst-nodes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:1: error: expected 'func' keyword in instance method declaration\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:7: error: expected parameter name followed by ':'\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:32: error: expected '}' in class\n 16 | }\n 17 | \n 18 | class Solution {\n    |                `- note: to match this opening '{'\n 19 |     var sumToCount: [Int: Int] = [:]\n 20 |     \n    :\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:295:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n293 | }\n294 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n295 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n296 | let args = parseArgs(from: input, expectedCount: 1)\n297 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:296:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n294 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n295 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n296 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n297 | let hasInput = !args.isEmpty\n298 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:300:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n298 | let solution = Solution()\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:300:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n298 | let solution = Solution()\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:301:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n301 | let result = solution.findFrequentTreeSum(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:247:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n245 | func toTreeNode(_ value: Any) -> TreeNode? {\n246 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n247 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n248 |         if item is NSNull { return nil }\n249 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:1: error: expected '{' in body of function declaration\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[2,-3,4]",
      "input" : "root = [5,2,-5]",
      "slug" : "most-frequent-subtree-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:1: error: expected 'func' keyword in instance method declaration\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:7: error: expected parameter name followed by ':'\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:32: error: expected '}' in class\n 16 | }\n 17 | \n 18 | class Solution {\n    |                `- note: to match this opening '{'\n 19 |     var sumToCount: [Int: Int] = [:]\n 20 |     \n    :\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:295:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n293 | }\n294 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n295 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n296 | let args = parseArgs(from: input, expectedCount: 1)\n297 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:296:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n294 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n295 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n296 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n297 | let hasInput = !args.isEmpty\n298 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:300:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n298 | let solution = Solution()\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:300:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n298 | let solution = Solution()\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:301:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n299 | \n300 | let arg0 = toTreeNode(valueAt(args, 0))\n301 | let result = solution.findFrequentTreeSum(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:247:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n245 | func toTreeNode(_ value: Any) -> TreeNode? {\n246 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n247 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n248 |         if item is NSNull { return nil }\n249 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_1\/solution.swift:303:1: error: expected '{' in body of function declaration\n301 | let result = solution.findFrequentTreeSum(arg0)\n302 | let output: Any = result\n303 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[3,-2]",
      "input" : "root = [3,0,5,0,3,-2,1,2]",
      "slug" : "most-frequent-subtree-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:1: error: expected 'func' keyword in instance method declaration\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:7: error: expected parameter name followed by ':'\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:32: error: expected '}' in class\n 16 | }\n 17 | \n 18 | class Solution {\n    |                `- note: to match this opening '{'\n 19 |     var sumToCount: [Int: Int] = [:]\n 20 |     var maxCount = 0\n    :\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:297:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n295 | }\n296 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n297 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n298 | let args = parseArgs(from: input, expectedCount: 1)\n299 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:298:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n296 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n297 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n298 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n299 | let hasInput = !args.isEmpty\n300 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:302:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n300 | let solution = Solution()\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:302:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n300 | let solution = Solution()\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:303:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n303 | let result = solution.findFrequentTreeSum(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:23:9: warning: result of call to 'postOrderDfs' is unused [#no-usage]\n 21 |     \n 22 |     func findFrequentTreeSum(_ root: TreeNode?) -> [Int] {\n 23 |         postOrderDfs(root)\n    |         `- warning: result of call to 'postOrderDfs' is unused [#no-usage]\n 24 |         \n 25 |         var result: [Int] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:249:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n247 | func toTreeNode(_ value: Any) -> TreeNode? {\n248 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n249 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n250 |         if item is NSNull { return nil }\n251 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:1: error: expected '{' in body of function declaration\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[2,-3,4]",
      "input" : "root = [5,2,-5]",
      "slug" : "most-frequent-subtree-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:1: error: expected 'func' keyword in instance method declaration\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:7: error: expected parameter name followed by ':'\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:32: error: expected '}' in class\n 16 | }\n 17 | \n 18 | class Solution {\n    |                `- note: to match this opening '{'\n 19 |     var sumToCount: [Int: Int] = [:]\n 20 |     var maxCount = 0\n    :\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:297:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n295 | }\n296 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n297 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n298 | let args = parseArgs(from: input, expectedCount: 1)\n299 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:298:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n296 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n297 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n298 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n299 | let hasInput = !args.isEmpty\n300 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:302:12: error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n300 | let solution = Solution()\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toTreeNode' within property initializer; property initializers run before 'self' is available\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:302:23: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n300 | let solution = Solution()\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n    |                       `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:303:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n301 | \n302 | let arg0 = toTreeNode(valueAt(args, 0))\n303 | let result = solution.findFrequentTreeSum(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:23:9: warning: result of call to 'postOrderDfs' is unused [#no-usage]\n 21 |     \n 22 |     func findFrequentTreeSum(_ root: TreeNode?) -> [Int] {\n 23 |         postOrderDfs(root)\n    |         `- warning: result of call to 'postOrderDfs' is unused [#no-usage]\n 24 |         \n 25 |         var result: [Int] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:249:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n247 | func toTreeNode(_ value: Any) -> TreeNode? {\n248 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n249 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n250 |         if item is NSNull { return nil }\n251 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/most-frequent-subtree-sum_2\/solution.swift:305:1: error: expected '{' in body of function declaration\n303 | let result = solution.findFrequentTreeSum(arg0)\n304 | let output: Any = result\n305 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "[3,-2]",
      "input" : "root = [3,0,5,0,3,-2,1,2]",
      "slug" : "most-frequent-subtree-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_1\/solution.swift:5:40: error: cannot find type 'Node' in scope\n  3 | \n  4 |            class Solution {\n  5 |                func levelOrder(_ root: Node?) -> [[Int]] {\n    |                                        `- error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_1\/solution.swift:8:32: error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n  8 |                    var queue: [Node] = [root]\n    |                                `- error: cannot find type 'Node' in scope\n  9 |                    while !queue.isEmpty {\n 10 |                        var level: [Int] = []\n",
      "expected" : "[[1], [3, 2, 4], [5, 6]]",
      "input" : "let node1 = Node(1); let node3 = Node(3); let node2 = Node(2); let node4 = Node(4); let node5 = Node(5); let node6 = Node(6); node1.children = [node3, node2, node4]; node3.children = [node5, node6]; Solution().levelOrder(node1)",
      "slug" : "n-ary-tree-level-order-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_1\/solution.swift:5:40: error: cannot find type 'Node' in scope\n  3 | \n  4 |            class Solution {\n  5 |                func levelOrder(_ root: Node?) -> [[Int]] {\n    |                                        `- error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_1\/solution.swift:8:32: error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n  8 |                    var queue: [Node] = [root]\n    |                                `- error: cannot find type 'Node' in scope\n  9 |                    while !queue.isEmpty {\n 10 |                        var level: [Int] = []\n",
      "expected" : "[[1], [2, 3, 4], [5]]",
      "input" : "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); let node4 = Node(4); let node5 = Node(5); node1.children = [node2, node3, node4]; node3.children = [node5]; Solution().levelOrder(node1)",
      "slug" : "n-ary-tree-level-order-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_2\/solution.swift:5:40: error: cannot find type 'Node' in scope\n  3 | \n  4 |            class Solution {\n  5 |                func levelOrder(_ root: Node?) -> [[Int]] {\n    |                                        `- error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_2\/solution.swift:8:32: error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n  8 |                    var queue: [Node] = [root]\n    |                                `- error: cannot find type 'Node' in scope\n  9 |                    while !queue.isEmpty {\n 10 |                        var level: [Int] = []\n",
      "expected" : "[[1], [2, 3]]",
      "input" : "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); node1.children = [node2, node3]; Solution().levelOrder(node1)",
      "slug" : "n-ary-tree-level-order-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_2\/solution.swift:5:40: error: cannot find type 'Node' in scope\n  3 | \n  4 |            class Solution {\n  5 |                func levelOrder(_ root: Node?) -> [[Int]] {\n    |                                        `- error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/n-ary-tree-level-order-traversal_2\/solution.swift:8:32: error: cannot find type 'Node' in scope\n  6 |                    guard let root = root else { return [] }\n  7 |                    var result: [[Int]] = []\n  8 |                    var queue: [Node] = [root]\n    |                                `- error: cannot find type 'Node' in scope\n  9 |                    while !queue.isEmpty {\n 10 |                        var level: [Int] = []\n",
      "expected" : "[[1], [2, 3], [4, 5]]",
      "input" : "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); let node4 = Node(4); let node5 = Node(5); node1.children = [node2, node3]; node2.children = [node4, node5]; Solution().levelOrder(node1)",
      "slug" : "n-ary-tree-level-order-traversal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8",
      "slug" : "path-sum-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
      "slug" : "path-sum-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:208:34: error: cannot find type 'TreeNode' in scope\n206 | }\n207 | \n208 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n209 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n210 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:226:30: error: cannot find type 'TreeNode' in scope\n224 | }\n225 | \n226 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n227 |     guard let root else { return [] }\n228 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:210:17: error: cannot find type 'TreeNode' in scope\n208 | func toTreeNode(_ value: Any) -> TreeNode? {\n209 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n210 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n211 |         if item is NSNull { return nil }\n212 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:229:17: error: cannot find type 'TreeNode' in scope\n227 |     guard let root else { return [] }\n228 |     var result: [Any] = []\n229 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n230 |     while !queue.isEmpty {\n231 |         let node = queue.removeFirst()\n",
      "expected" : "1, 2, 4, 5, 3, 6, 7",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "print-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:208:34: error: cannot find type 'TreeNode' in scope\n206 | }\n207 | \n208 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n209 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n210 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:226:30: error: cannot find type 'TreeNode' in scope\n224 | }\n225 | \n226 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n227 |     guard let root else { return [] }\n228 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:210:17: error: cannot find type 'TreeNode' in scope\n208 | func toTreeNode(_ value: Any) -> TreeNode? {\n209 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n210 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n211 |         if item is NSNull { return nil }\n212 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_1\/solution.swift:229:17: error: cannot find type 'TreeNode' in scope\n227 |     guard let root else { return [] }\n228 |     var result: [Any] = []\n229 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n230 |     while !queue.isEmpty {\n231 |         let node = queue.removeFirst()\n",
      "expected" : "1, 2, 3, 4, 5",
      "input" : "root = [1,2,3,null,null,4,5]",
      "slug" : "print-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:211:34: error: cannot find type 'TreeNode' in scope\n209 | }\n210 | \n211 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n212 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n213 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:229:30: error: cannot find type 'TreeNode' in scope\n227 | }\n228 | \n229 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n230 |     guard let root else { return [] }\n231 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:213:17: error: cannot find type 'TreeNode' in scope\n211 | func toTreeNode(_ value: Any) -> TreeNode? {\n212 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n213 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n214 |         if item is NSNull { return nil }\n215 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:232:17: error: cannot find type 'TreeNode' in scope\n230 |     guard let root else { return [] }\n231 |     var result: [Any] = []\n232 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n233 |     while !queue.isEmpty {\n234 |         let node = queue.removeFirst()\n",
      "expected" : "1, 2, 3, 4, 5, 6, 7",
      "input" : "root = [1,2,3,4,5,6,7]",
      "slug" : "print-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:211:34: error: cannot find type 'TreeNode' in scope\n209 | }\n210 | \n211 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n212 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n213 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:229:30: error: cannot find type 'TreeNode' in scope\n227 | }\n228 | \n229 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n230 |     guard let root else { return [] }\n231 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:213:17: error: cannot find type 'TreeNode' in scope\n211 | func toTreeNode(_ value: Any) -> TreeNode? {\n212 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n213 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n214 |         if item is NSNull { return nil }\n215 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/print-binary-tree_2\/solution.swift:232:17: error: cannot find type 'TreeNode' in scope\n230 |     guard let root else { return [] }\n231 |     var result: [Any] = []\n232 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n233 |     while !queue.isEmpty {\n234 |         let node = queue.removeFirst()\n",
      "expected" : "1, 2, 3, 4, 5",
      "input" : "root = [1,2,3,null,null,4,5]",
      "slug" : "print-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:222: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:261: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                     `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:459: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:474: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:602: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:748: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:809: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:339: error: cannot provide default value to inout parameter 'nodes'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                   `- error: cannot provide default value to inout parameter 'nodes'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:263:5: warning: constant 'result' inferred to have type 'Void', which may be unexpected\n261 | \n262 | let arg0 = toTreeNode(valueAt(args, 0))\n263 | let result = solution.recoverTree(arg0)\n    |     |- warning: constant 'result' inferred to have type 'Void', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:380: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                            `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:415: error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:429: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                             `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "root = [3,1,null,null,2]",
      "input" : "root = [1,3,null,null,2]",
      "slug" : "recover-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:222: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:261: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                     `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:459: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:474: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:602: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:748: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:809: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:339: error: cannot provide default value to inout parameter 'nodes'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                   `- error: cannot provide default value to inout parameter 'nodes'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:263:5: warning: constant 'result' inferred to have type 'Void', which may be unexpected\n261 | \n262 | let arg0 = toTreeNode(valueAt(args, 0))\n263 | let result = solution.recoverTree(arg0)\n    |     |- warning: constant 'result' inferred to have type 'Void', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:380: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                            `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:415: error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:3:429: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); for i in 0..<nodes.count-1 { for j in i+1..<nodes.count { swapTwoNodes(nodes[i], nodes[j]); if isValidBST(root) { return } swapTwoNodes(nodes[j], nodes[i]) } } } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool { guard let node = node else { return true } if node.val <= minVal || node.val >= maxVal { return false } return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal) } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                             `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "root = [2,1,4,null,null,3]",
      "input" : "root = [3,1,4,null,null,2]",
      "slug" : "recover-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:176: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:374: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:389: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:612: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:636: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:663: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:254: error: cannot provide default value to inout parameter 'nodes'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                              `- error: cannot provide default value to inout parameter 'nodes'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:263:5: warning: constant 'result' inferred to have type 'Void', which may be unexpected\n261 | \n262 | let arg0 = toTreeNode(valueAt(args, 0))\n263 | let result = solution.recoverTree(arg0)\n    |     |- warning: constant 'result' inferred to have type 'Void', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:295: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                       `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:330: error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                          `- error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:344: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "root = [3,1,null,null,2]",
      "input" : "root = [1,3,null,null,2]",
      "slug" : "recover-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:176: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:374: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:389: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:612: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:636: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:663: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:254: error: cannot provide default value to inout parameter 'nodes'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                              `- error: cannot provide default value to inout parameter 'nodes'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:263:5: warning: constant 'result' inferred to have type 'Void', which may be unexpected\n261 | \n262 | let arg0 = toTreeNode(valueAt(args, 0))\n263 | let result = solution.recoverTree(arg0)\n    |     |- warning: constant 'result' inferred to have type 'Void', which may be unexpected\n    |     `- note: add an explicit type annotation to silence this warning\n264 | let output: Any = NSNull()\n265 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:295: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                       `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:330: error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                          `- error: cannot use mutating member on immutable value: 'nodes' is a 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:3:344: warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func recoverTree(_ root: TreeNode?) -> Void { let nodes = inOrderTraversal(root); let (first, second) = findSwappedNodes(nodes); swapTwoNodes(first, second) } private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] { if let node = node { inOrderTraversal(node.left); nodes.append(node); inOrderTraversal(node.right) } return nodes } private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) { var first: TreeNode?; var second: TreeNode?; for i in 0..<nodes.count-1 { if nodes[i].val > nodes[i+1].val { if first == nil { first = nodes[i] } second = nodes[i+1] } } return (first!, second!) } private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) { let tmp = node1.val; node1.val = node2.val; node2.val = tmp } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- warning: result of call to 'inOrderTraversal' is unused [#no-usage]\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/recover-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "root = [2,1,4,null,null,3]",
      "input" : "root = [3,1,4,null,null,2]",
      "slug" : "recover-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:108: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:144: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:182: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:213: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[2,1,3]",
      "input" : "root = [4,2,7,1,3], val = 2",
      "slug" : "search-in-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:108: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:144: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:182: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:3:213: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "null",
      "input" : "root = [4,2,7,1,3], val = 5",
      "slug" : "search-in-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:3:94: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { var node = root while node != nil { if node?.val == val { return node } else if node?.val ?? 0 > val { node = node?.left } else { node = node?.right } } return nil } }\n    |                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:3:231: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { var node = root while node != nil { if node?.val == val { return node } else if node?.val ?? 0 > val { node = node?.left } else { node = node?.right } } return nil } }\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "[2,1,3]",
      "input" : "root = [4,2,7,1,3], val = 2",
      "slug" : "search-in-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:3:94: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { var node = root while node != nil { if node?.val == val { return node } else if node?.val ?? 0 > val { node = node?.left } else { node = node?.right } } return nil } }\n    |                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:3:231: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { var node = root while node != nil { if node?.val == val { return node } else if node?.val ?? 0 > val { node = node?.left } else { node = node?.right } } return nil } }\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/search-in-a-binary-search-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "null",
      "input" : "root = [4,2,7,1,3], val = 5",
      "slug" : "search-in-a-binary-search-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:95: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:169: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:184: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:204: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:214: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:259: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:310: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "5",
      "input" : "root = [2,2,2,5,null,null,5,7]",
      "slug" : "second-minimum-node-in-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:95: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:169: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:184: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:204: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:214: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:259: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:3:310: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }\n    |                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_1\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "-1",
      "input" : "root = [2,2,2]",
      "slug" : "second-minimum-node-in-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:96: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:123: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:324: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:339: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:359: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:369: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:410: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:78: warning: variable 'minVal' was never mutated; consider changing to 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                              `- warning: variable 'minVal' was never mutated; consider changing to 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "5",
      "input" : "root = [2,2,2,5,null,null,5,7]",
      "slug" : "second-minimum-node-in-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:96: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:123: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:324: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:339: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:359: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:369: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:410: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:3:78: warning: variable 'minVal' was never mutated; consider changing to 'let' constant\n  1 | import Foundation\n  2 | \n  3 | class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }\n    |                                                                              `- warning: variable 'minVal' was never mutated; consider changing to 'let' constant\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/second-minimum-node-in-a-binary-tree_2\/solution.swift:209:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n207 | func toTreeNode(_ value: Any) -> TreeNode? {\n208 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n209 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n210 |         if item is NSNull { return nil }\n211 |         return TreeNode(toInt(item))\n",
      "expected" : "-1",
      "input" : "root = [2,2,2]",
      "slug" : "second-minimum-node-in-a-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:277:34: error: cannot find type 'TreeNode' in scope\n275 | }\n276 | \n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:295:30: error: cannot find type 'TreeNode' in scope\n293 | }\n294 | \n295 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:333:23: error: value of type 'Solution' has no member 'serialize'\n331 | \n332 | let arg0 = toTreeNode(valueAt(args, 0))\n333 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n334 | let output: Any = result\n335 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:26:47: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 24 |                    while !stack.isEmpty {\n 25 |                        let node = stack.removeLast()\n 26 |                        if let nodeValue = node?.val {\n    |                                               `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 27 |                            res += String(nodeValue) + \",\"\n 28 |                        } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:31:43: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 29 |                            res += \"null,\"\n 30 |                        }\n 31 |                        if let right = node?.right {\n    |                                           `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:34:42: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n 34 |                        if let left = node?.left {\n    |                                          `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 35 |                            stack.append(left)\n 36 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:279:17: error: cannot find type 'TreeNode' in scope\n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n280 |         if item is NSNull { return nil }\n281 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:298:17: error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n298 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n299 |     while !queue.isEmpty {\n300 |         let node = queue.removeFirst()\n",
      "expected" : "[2,1,null,null,3,null,null]",
      "input" : "TreeNode { val: 2, left: TreeNode { val: 1, left: nil, right: nil }, right: TreeNode { val: 3, left: nil, right: nil } }",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:277:34: error: cannot find type 'TreeNode' in scope\n275 | }\n276 | \n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:295:30: error: cannot find type 'TreeNode' in scope\n293 | }\n294 | \n295 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:333:23: error: value of type 'Solution' has no member 'serialize'\n331 | \n332 | let arg0 = toTreeNode(valueAt(args, 0))\n333 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n334 | let output: Any = result\n335 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:26:47: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 24 |                    while !stack.isEmpty {\n 25 |                        let node = stack.removeLast()\n 26 |                        if let nodeValue = node?.val {\n    |                                               `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 27 |                            res += String(nodeValue) + \",\"\n 28 |                        } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:31:43: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 29 |                            res += \"null,\"\n 30 |                        }\n 31 |                        if let right = node?.right {\n    |                                           `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:34:42: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n 34 |                        if let left = node?.left {\n    |                                          `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 35 |                            stack.append(left)\n 36 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:279:17: error: cannot find type 'TreeNode' in scope\n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n280 |         if item is NSNull { return nil }\n281 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:298:17: error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n298 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n299 |     while !queue.isEmpty {\n300 |         let node = queue.removeFirst()\n",
      "expected" : "[2,null,null]",
      "input" : "TreeNode { val: 2, left: nil, right: nil }",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:277:34: error: cannot find type 'TreeNode' in scope\n275 | }\n276 | \n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:295:30: error: cannot find type 'TreeNode' in scope\n293 | }\n294 | \n295 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:333:23: error: value of type 'Solution' has no member 'serialize'\n331 | \n332 | let arg0 = toTreeNode(valueAt(args, 0))\n333 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n334 | let output: Any = result\n335 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:26:47: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 24 |                    while !stack.isEmpty {\n 25 |                        let node = stack.removeLast()\n 26 |                        if let nodeValue = node?.val {\n    |                                               `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 27 |                            res += String(nodeValue) + \",\"\n 28 |                        } else {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:31:43: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 29 |                            res += \"null,\"\n 30 |                        }\n 31 |                        if let right = node?.right {\n    |                                           `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:34:42: error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 32 |                            stack.append(right)\n 33 |                        }\n 34 |                        if let left = node?.left {\n    |                                          `- error: cannot use optional chaining on non-optional value of type 'Solution.TreeNode'\n 35 |                            stack.append(left)\n 36 |                        }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:279:17: error: cannot find type 'TreeNode' in scope\n277 | func toTreeNode(_ value: Any) -> TreeNode? {\n278 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n279 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n280 |         if item is NSNull { return nil }\n281 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_1\/solution.swift:298:17: error: cannot find type 'TreeNode' in scope\n296 |     guard let root else { return [] }\n297 |     var result: [Any] = []\n298 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n299 |     while !queue.isEmpty {\n300 |         let node = queue.removeFirst()\n",
      "expected" : "[null]",
      "input" : "nil",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:250:34: error: cannot find type 'TreeNode' in scope\n248 | }\n249 | \n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:268:30: error: cannot find type 'TreeNode' in scope\n266 | }\n267 | \n268 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:306:23: error: value of type 'Solution' has no member 'serialize'\n304 | \n305 | let arg0 = toTreeNode(valueAt(args, 0))\n306 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n307 | let output: Any = result\n308 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |         if item is NSNull { return nil }\n254 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:271:17: error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n271 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n272 |     while !queue.isEmpty {\n273 |         let node = queue.removeFirst()\n",
      "expected" : "2,1,null,null,3,null,null",
      "input" : "TreeNode { val: 2, left: TreeNode { val: 1, left: nil, right: nil }, right: TreeNode { val: 3, left: nil, right: nil } }",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:250:34: error: cannot find type 'TreeNode' in scope\n248 | }\n249 | \n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:268:30: error: cannot find type 'TreeNode' in scope\n266 | }\n267 | \n268 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:306:23: error: value of type 'Solution' has no member 'serialize'\n304 | \n305 | let arg0 = toTreeNode(valueAt(args, 0))\n306 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n307 | let output: Any = result\n308 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |         if item is NSNull { return nil }\n254 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:271:17: error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n271 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n272 |     while !queue.isEmpty {\n273 |         let node = queue.removeFirst()\n",
      "expected" : "1,null,2,null,null",
      "input" : "TreeNode { val: 1, left: nil, right: TreeNode { val: 2, left: nil, right: nil } }",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:250:34: error: cannot find type 'TreeNode' in scope\n248 | }\n249 | \n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:268:30: error: cannot find type 'TreeNode' in scope\n266 | }\n267 | \n268 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:306:23: error: value of type 'Solution' has no member 'serialize'\n304 | \n305 | let arg0 = toTreeNode(valueAt(args, 0))\n306 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n307 | let output: Any = result\n308 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 | func toTreeNode(_ value: Any) -> TreeNode? {\n251 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n252 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |         if item is NSNull { return nil }\n254 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-bst_2\/solution.swift:271:17: error: cannot find type 'TreeNode' in scope\n269 |     guard let root else { return [] }\n270 |     var result: [Any] = []\n271 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n272 |     while !queue.isEmpty {\n273 |         let node = queue.removeFirst()\n",
      "expected" : "",
      "input" : "nil",
      "slug" : "serialize-and-deserialize-bst",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "[7]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "Node 2",
      "input" : "root = [3,5,1,6,2,0,8,null,null,7,4]",
      "slug" : "smallest-subtree-with-all-the-deepest-nodes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "Node 1",
      "input" : "root = [1]",
      "slug" : "smallest-subtree-with-all-the-deepest-nodes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,0,8]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "Node 2",
      "input" : "root = [3,5,1,6,2,0,8,null,null,7,4]",
      "slug" : "smallest-subtree-with-all-the-deepest-nodes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "Node 1",
      "input" : "root = [1]",
      "slug" : "smallest-subtree-with-all-the-deepest-nodes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:228:34: error: cannot find type 'TreeNode' in scope\n226 | }\n227 | \n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:246:30: error: cannot find type 'TreeNode' in scope\n244 | }\n245 | \n246 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n247 |     guard let root else { return [] }\n248 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:230:17: error: cannot find type 'TreeNode' in scope\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:249:17: error: cannot find type 'TreeNode' in scope\n247 |     guard let root else { return [] }\n248 |     var result: [Any] = []\n249 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n250 |     while !queue.isEmpty {\n251 |         let node = queue.removeFirst()\n",
      "expected" : "22",
      "input" : "root = [1,0,1,0,1,0,1]",
      "slug" : "sum-of-root-to-leaf-binary-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:228:34: error: cannot find type 'TreeNode' in scope\n226 | }\n227 | \n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:246:30: error: cannot find type 'TreeNode' in scope\n244 | }\n245 | \n246 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n247 |     guard let root else { return [] }\n248 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:230:17: error: cannot find type 'TreeNode' in scope\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_1\/solution.swift:249:17: error: cannot find type 'TreeNode' in scope\n247 |     guard let root else { return [] }\n248 |     var result: [Any] = []\n249 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n250 |     while !queue.isEmpty {\n251 |         let node = queue.removeFirst()\n",
      "expected" : "0",
      "input" : "root = [0]",
      "slug" : "sum-of-root-to-leaf-binary-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "22",
      "input" : "root = [1,0,1,0,1,0,1]",
      "slug" : "sum-of-root-to-leaf-binary-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:231:34: error: cannot find type 'TreeNode' in scope\n229 | }\n230 | \n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:249:30: error: cannot find type 'TreeNode' in scope\n247 | }\n248 | \n249 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:233:17: error: cannot find type 'TreeNode' in scope\n231 | func toTreeNode(_ value: Any) -> TreeNode? {\n232 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n233 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n234 |         if item is NSNull { return nil }\n235 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sum-of-root-to-leaf-binary-numbers_2\/solution.swift:252:17: error: cannot find type 'TreeNode' in scope\n250 |     guard let root else { return [] }\n251 |     var result: [Any] = []\n252 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n253 |     while !queue.isEmpty {\n254 |         let node = queue.removeFirst()\n",
      "expected" : "0",
      "input" : "root = [0]",
      "slug" : "sum-of-root-to-leaf-binary-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "root = [1,1,1,1,1,null,1]",
      "slug" : "univalued-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Optimized Iterative Approach",
      "approachOrder" : 2,
      "expected" : "false",
      "input" : "root = [1,1,1,1,1,null,1]",
      "slug" : "univalued-binary-tree",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Hash Maps + Heap Merge",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-twitter_1\/solution.swift:270:23: error: value of type 'Solution' has no member 'postTweet'\n268 | let arg0 = toInt(valueAt(args, 0))\n269 | let arg1 = toInt(valueAt(args, 1))\n270 | let result = solution.postTweet(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'postTweet'\n271 | let output: Any = NSNull()\n272 | print(jsonString(from: output))\n",
      "expected" : "[5], [6,5], [5]",
      "input" : "postTweet(1,5), getNewsFeed(1), follow(1,2), postTweet(2,6), getNewsFeed(1), unfollow(1,2), getNewsFeed(1)",
      "slug" : "design-twitter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized with Min-Heap (k-way merge)",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/design-twitter_2\/solution.swift:286:23: error: value of type 'Solution' has no member 'postTweet'\n284 | let arg0 = toInt(valueAt(args, 0))\n285 | let arg1 = toInt(valueAt(args, 1))\n286 | let result = solution.postTweet(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'postTweet'\n287 | let output: Any = NSNull()\n288 | print(jsonString(from: output))\n",
      "expected" : "Correctly merged feed by timestamp",
      "input" : "Multiple users posting and following",
      "slug" : "design-twitter",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:95: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                               `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:181: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:325: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:432: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:453: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:502: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:539: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:9:18: error: empty collection literal requires an explicit type\n  7 | \n  8 | \/\/ FocusApp LeetCode Runner\n  9 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 10 |     func parseQuotedString(_ input: String) -> String? {\n 11 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'seat'\n226 | \n227 | \n228 | let result = solution.seat()\n    |                       `- error: value of type 'Solution' has no member 'seat'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:78:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 76 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 77 |         guard !trimmed.isEmpty else { return [] }\n 78 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 79 |         if !keyValues.isEmpty {\n 80 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0, 9, 0",
      "input" : "ExamRoom(10); seat(); leave(0); seat()",
      "slug" : "exam-room",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:95: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                               `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:181: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:325: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:432: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:453: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:502: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:4:539: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: [Int]; init(_ n: Int) { self.n = n; occupied = [] } func seat() -> Int { var maxDist = -1; var seat = -1; for i in 0...n-1 { var dist = 1 if i == 0 { dist = occupied.first ?? n } else if i == n-1 { dist = n - (occupied.last ?? -1) - 1 } else if occupied.count > 0 { var minDist = n for pos in occupied { let currDist = min(i - pos, pos - i); if currDist < minDist { minDist = currDist } } dist = minDist \/ 2 } if dist > maxDist { maxDist = dist; seat = i } } occupied.append(seat); return seat } func leave(_ p: Int) { if let index = occupied.firstIndex(of: p) { occupied.remove(at: index) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:9:18: error: empty collection literal requires an explicit type\n  7 | \n  8 | \/\/ FocusApp LeetCode Runner\n  9 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 10 |     func parseQuotedString(_ input: String) -> String? {\n 11 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'seat'\n226 | \n227 | \n228 | let result = solution.seat()\n    |                       `- error: value of type 'Solution' has no member 'seat'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_1\/solution.swift:78:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 76 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 77 |         guard !trimmed.isEmpty else { return [] }\n 78 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 79 |         if !keyValues.isEmpty {\n 80 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0, 2, 4, 1",
      "input" : "ExamRoom(5); seat(); seat(); seat(); leave(1); seat()",
      "slug" : "exam-room",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:147: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                   `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:221: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:353: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:390: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:460: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:9:18: error: empty collection literal requires an explicit type\n  7 | \n  8 | \/\/ FocusApp LeetCode Runner\n  9 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 10 |     func parseQuotedString(_ input: String) -> String? {\n 11 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'seat'\n226 | \n227 | \n228 | let result = solution.seat()\n    |                       `- error: value of type 'Solution' has no member 'seat'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:78:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 76 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 77 |         guard !trimmed.isEmpty else { return [] }\n 78 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 79 |         if !keyValues.isEmpty {\n 80 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0, 9, 0",
      "input" : "ExamRoom(10); seat(); leave(0); seat()",
      "slug" : "exam-room",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:147: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                   `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:221: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:353: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:390: error: consecutive declarations on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive declarations on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:460: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class ExamRoom { let n: Int; var occupied: Set<Int>; var pq: [(Int, Int)] = []; let INF = Int.max; init(_ n: Int) { self.n = n; occupied = Set() } func seat() -> Int { if occupied.isEmpty { occupied.insert(0); return 0 } var maxDist = -1; var seat = -1; for i in occupied { let dist = max(i, n - 1 - i); if dist > maxDist { maxDist = dist; seat = i } } occupied.insert(seat); return seat } func leave(_ p: Int) { if occupied.contains(p) { occupied.remove(p) } var index = 0 while index < pq.count { if pq[index].1 == p { pq.remove(at: index); break } index += 1 } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:9:18: error: empty collection literal requires an explicit type\n  7 | \n  8 | \/\/ FocusApp LeetCode Runner\n  9 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 10 |     func parseQuotedString(_ input: String) -> String? {\n 11 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'seat'\n226 | \n227 | \n228 | let result = solution.seat()\n    |                       `- error: value of type 'Solution' has no member 'seat'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/exam-room_2\/solution.swift:78:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 76 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 77 |         guard !trimmed.isEmpty else { return [] }\n 78 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 79 |         if !keyValues.isEmpty {\n 80 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0, 2, 4, 1",
      "input" : "ExamRoom(5); seat(); seat(); seat(); leave(1); seat()",
      "slug" : "exam-room",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n",
      "expected" : "[[1,2],[1,4],[1,6]]",
      "input" : "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
      "slug" : "find-k-pairs-with-smallest-sums",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func kSmallestPairs(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [[Int]] {\n",
      "expected" : "[[1,1],[1,1]]",
      "input" : "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
      "slug" : "find-k-pairs-with-smallest-sums",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach using Priority Queue",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        struct Pair: Comparable {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:7:15: error: type 'Solution.Pair' does not conform to protocol 'Equatable'\n  5 |        import Foundation\n  6 | \n  7 |        struct Pair: Comparable {\n    |               |- error: type 'Solution.Pair' does not conform to protocol 'Equatable'\n    |               `- note: add stubs for conformance\n  8 |            let sum: Int\n  9 |            let indices: (Int, Int)\n    |                `- note: stored property type '(Int, Int)' does not conform to protocol 'Equatable', preventing synthesized conformance of 'Solution.Pair' to 'Equatable'\n 10 | \n 11 |            static func < (lhs: Pair, rhs: Pair) -> Bool {\n\nSwift.==:1:24: note: candidate would match if 'Solution.Pair' conformed to 'RawRepresentable'\n1 | @inlinable public func == <T>(lhs: T, rhs: T) -> Bool where T : RawRepresentable, T.RawValue : Equatable\n  |                        `- note: candidate would match if 'Solution.Pair' conformed to 'RawRepresentable'\n\nSwift.FloatingPoint.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'FloatingPoint'\n1 | protocol FloatingPoint {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'FloatingPoint'\n3 | \n\nSwift.BinaryInteger.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'BinaryInteger'\n1 | protocol BinaryInteger {\n2 | public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'BinaryInteger'\n3 | \n\nSwift._Pointer.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n1 | protocol _Pointer {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n3 | \n\nSwift._Pointer.==:2:31: note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n1 | protocol _Pointer {\n2 | @inlinable public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : _Pointer}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n3 | \n\nSwift.Strideable.==:2:31: note: candidate would match if 'Solution.Pair' conformed to 'Strideable'\n1 | protocol Strideable {\n2 | @inlinable public static func == (x: Self, y: Self) -> Bool}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to 'Strideable'\n3 | \n\nSwift.StringProtocol.==:2:31: note: candidate would match if 'Solution.Pair' conformed to 'StringProtocol'\n1 | protocol StringProtocol {\n2 | @inlinable public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to 'StringProtocol'\n3 | \n\nSwift.SIMD.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'SIMD'\n1 | protocol SIMD {\n2 | public static func == (a: Self, b: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'SIMD'\n3 | \n\nFoundation.AttributedStringProtocol.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'AttributedStringProtocol'\n1 | protocol AttributedStringProtocol {\n2 | public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : AttributedStringProtocol}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'AttributedStringProtocol'\n3 | \n\nFoundation._BridgedStoredNSError.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_BridgedStoredNSError'\n1 | protocol _BridgedStoredNSError {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_BridgedStoredNSError'\n3 | \n\nCoreFoundation._CFObject.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_CFObject'\n1 | protocol _CFObject {\n2 | public static func == (left: Self, right: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_CFObject'\n3 | \n\nSwift.Equatable.==:2:13: note: protocol requires function '==' with type '(Solution.Pair, Solution.Pair) -> Bool'\n1 | protocol Equatable {\n2 | static func == (lhs: Self, rhs: Self) -> Bool}\n  |             `- note: protocol requires function '==' with type '(Solution.Pair, Solution.Pair) -> Bool'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:28:25: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 26 |            }\n 27 | \n 28 |            var heapSet: Set<(Int, Int)> = Set(heap)\n    |                         `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 29 | \n 30 |            let heap1 = heap.sorted { (nums1[$0.0] + nums2[$0.1]) < (nums1[$1.0] + nums2[$1.1]) }\n",
      "expected" : "[[1,2],[1,4],[1,6]]",
      "input" : "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
      "slug" : "find-k-pairs-with-smallest-sums",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach using Priority Queue",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        struct Pair: Comparable {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:7:15: error: type 'Solution.Pair' does not conform to protocol 'Equatable'\n  5 |        import Foundation\n  6 | \n  7 |        struct Pair: Comparable {\n    |               |- error: type 'Solution.Pair' does not conform to protocol 'Equatable'\n    |               `- note: add stubs for conformance\n  8 |            let sum: Int\n  9 |            let indices: (Int, Int)\n    |                `- note: stored property type '(Int, Int)' does not conform to protocol 'Equatable', preventing synthesized conformance of 'Solution.Pair' to 'Equatable'\n 10 | \n 11 |            static func < (lhs: Pair, rhs: Pair) -> Bool {\n\nSwift.==:1:24: note: candidate would match if 'Solution.Pair' conformed to 'RawRepresentable'\n1 | @inlinable public func == <T>(lhs: T, rhs: T) -> Bool where T : RawRepresentable, T.RawValue : Equatable\n  |                        `- note: candidate would match if 'Solution.Pair' conformed to 'RawRepresentable'\n\nSwift.FloatingPoint.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'FloatingPoint'\n1 | protocol FloatingPoint {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'FloatingPoint'\n3 | \n\nSwift.BinaryInteger.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'BinaryInteger'\n1 | protocol BinaryInteger {\n2 | public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'BinaryInteger'\n3 | \n\nSwift._Pointer.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n1 | protocol _Pointer {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n3 | \n\nSwift._Pointer.==:2:31: note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n1 | protocol _Pointer {\n2 | @inlinable public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : _Pointer}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to '_Pointer'\n3 | \n\nSwift.Strideable.==:2:31: note: candidate would match if 'Solution.Pair' conformed to 'Strideable'\n1 | protocol Strideable {\n2 | @inlinable public static func == (x: Self, y: Self) -> Bool}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to 'Strideable'\n3 | \n\nSwift.StringProtocol.==:2:31: note: candidate would match if 'Solution.Pair' conformed to 'StringProtocol'\n1 | protocol StringProtocol {\n2 | @inlinable public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol}\n  |                               `- note: candidate would match if 'Solution.Pair' conformed to 'StringProtocol'\n3 | \n\nSwift.SIMD.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'SIMD'\n1 | protocol SIMD {\n2 | public static func == (a: Self, b: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'SIMD'\n3 | \n\nFoundation.AttributedStringProtocol.==:2:20: note: candidate would match if 'Solution.Pair' conformed to 'AttributedStringProtocol'\n1 | protocol AttributedStringProtocol {\n2 | public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : AttributedStringProtocol}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to 'AttributedStringProtocol'\n3 | \n\nFoundation._BridgedStoredNSError.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_BridgedStoredNSError'\n1 | protocol _BridgedStoredNSError {\n2 | public static func == (lhs: Self, rhs: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_BridgedStoredNSError'\n3 | \n\nCoreFoundation._CFObject.==:2:20: note: candidate would match if 'Solution.Pair' conformed to '_CFObject'\n1 | protocol _CFObject {\n2 | public static func == (left: Self, right: Self) -> Bool}\n  |                    `- note: candidate would match if 'Solution.Pair' conformed to '_CFObject'\n3 | \n\nSwift.Equatable.==:2:13: note: protocol requires function '==' with type '(Solution.Pair, Solution.Pair) -> Bool'\n1 | protocol Equatable {\n2 | static func == (lhs: Self, rhs: Self) -> Bool}\n  |             `- note: protocol requires function '==' with type '(Solution.Pair, Solution.Pair) -> Bool'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-k-pairs-with-smallest-sums_2\/solution.swift:28:25: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 26 |            }\n 27 | \n 28 |            var heapSet: Set<(Int, Int)> = Set(heap)\n    |                         `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 29 | \n 30 |            let heap1 = heap.sorted { (nums1[$0.0] + nums2[$0.1]) < (nums1[$1.0] + nums2[$1.1]) }\n",
      "expected" : "[[1,1],[1,1]]",
      "input" : "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
      "slug" : "find-k-pairs-with-smallest-sums",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Heaps",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-median-from-data-stream_1\/solution.swift:254:23: error: value of type 'Solution' has no member 'addNum'\n252 | \n253 | let arg0 = toInt(valueAt(args, 0))\n254 | let result = solution.addNum(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addNum'\n255 | let output: Any = NSNull()\n256 | print(jsonString(from: output))\n",
      "expected" : "1.5, 2.0",
      "input" : "addNum(1), addNum(2), findMedian(), addNum(3), findMedian()",
      "slug" : "find-median-from-data-stream",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[[1,3]]",
      "approachName" : "Max Heap",
      "approachOrder" : 1,
      "expected" : "[[-2,2]]",
      "input" : "points = [[1,3],[-2,2]], k = 1",
      "slug" : "k-closest-points-to-origin",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Min Heap of Size K",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-largest-element-in-a-stream_1\/solution.swift:243:23: error: value of type 'Solution' has no member 'add'\n241 | \n242 | let arg0 = toInt(valueAt(args, 0))\n243 | let result = solution.add(arg0)\n    |                       `- error: value of type 'Solution' has no member 'add'\n244 | let output: Any = result\n245 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/kth-largest-element-in-a-stream_1\/solution.swift:10:27: warning: result of call to 'add' is unused [#no-usage]\n  8 |     init(_ k: Int, _ nums: [Int]) {\n  9 |         self.k = k\n 10 |         for num in nums { add(num) }\n    |                           `- warning: result of call to 'add' is unused [#no-usage]\n 11 |     }\n 12 |     \n",
      "expected" : "4, 5, 5",
      "input" : "KthLargest(3, [4,5,8,2]), add(3), add(5), add(10)",
      "slug" : "kth-largest-element-in-a-stream",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/relative-ranks_1\/solution.swift:4:392: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRelativeRanks(_ scores: [Int]) -> [String] { let sortedScores = scores.sorted(by: >); var result = [String](); for score in scores { if let index = sortedScores.firstIndex(of: score) { if index == 0 { result.append(\"Gold Medal\") } else if index == 1 { result.append(\"Silver Medal\") } else if index == 2 { result.append(\"Bronze Medal\") } else { result.append(String(index + 1)) } } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]",
      "input" : "nums = [10, 3, 8, 9, 4]",
      "slug" : "relative-ranks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/relative-ranks_1\/solution.swift:4:392: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRelativeRanks(_ scores: [Int]) -> [String] { let sortedScores = scores.sorted(by: >); var result = [String](); for score in scores { if let index = sortedScores.firstIndex(of: score) { if index == 0 { result.append(\"Gold Medal\") } else if index == 1 { result.append(\"Silver Medal\") } else if index == 2 { result.append(\"Bronze Medal\") } else { result.append(String(index + 1)) } } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]",
      "input" : "nums = [5, 4, 3, 2, 1]",
      "slug" : "relative-ranks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/relative-ranks_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRelativeRanks(_ scores: [Int]) -> [String] { let tuples = scores.enumerated().map { ($0, $1) }; let sortedTuples = tuples.sorted(by: { $0.1 > $1.1 }); var result = Array(repeating: \"\", count: scores.count); for (index, score) in sortedTuples.enumerated() { if index == 0 { result[score.0] = \"Gold Medal\" } else if index == 1 { result[score.0] = \"Silver Medal\" } else if index == 2 { result[score.0] = \"Bronze Medal\" } else { result[score.0] = String(index + 1) } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]",
      "input" : "nums = [10, 3, 8, 9, 4]",
      "slug" : "relative-ranks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/relative-ranks_2\/solution.swift:4:474: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findRelativeRanks(_ scores: [Int]) -> [String] { let tuples = scores.enumerated().map { ($0, $1) }; let sortedTuples = tuples.sorted(by: { $0.1 > $1.1 }); var result = Array(repeating: \"\", count: scores.count); for (index, score) in sortedTuples.enumerated() { if index == 0 { result[score.0] = \"Gold Medal\" } else if index == 1 { result[score.0] = \"Silver Medal\" } else if index == 2 { result[score.0] = \"Bronze Medal\" } else { result[score.0] = String(index + 1) } } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]",
      "input" : "nums = [5, 4, 3, 2, 1]",
      "slug" : "relative-ranks",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-characters-by-frequency_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func frequencySort(_ s: String) -> String {\n",
      "expected" : "eert",
      "input" : "tree",
      "slug" : "sort-characters-by-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-characters-by-frequency_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func frequencySort(_ s: String) -> String {\n",
      "expected" : "aaaccc",
      "input" : "cccaaa",
      "slug" : "sort-characters-by-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach with Priority Queue",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-characters-by-frequency_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        struct Element: Comparable {\n",
      "expected" : "bbaA",
      "input" : "Aabb",
      "slug" : "sort-characters-by-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach with Priority Queue",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sort-characters-by-frequency_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        struct Element: Comparable {\n",
      "expected" : "llheo",
      "input" : "hello",
      "slug" : "sort-characters-by-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:255: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:280: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:290: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:478: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "112358",
      "slug" : "additive-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:255: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:280: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:290: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_1\/solution.swift:4:478: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { var ans = false; func backtrack(_ idx: Int, _ path: [Int]) { if idx == num.count { if path.count >= 3 { var add = true; for i in 2..<path.count { if path[i] != path[i-1] + path[i-2] { add = false; break; } } if add { ans = true; } } return; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if cur.count > 1 && cur.first == \"0\" { continue; } if let n = Int(cur) { backtrack(i+1, path + [n]); } } }; backtrack(0, []); return ans; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "199100199",
      "slug" : "additive-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Backtracking",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:398: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:541: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "112358",
      "slug" : "additive-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Backtracking",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:230: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:398: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/additive-number_2\/solution.swift:4:541: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func isAdditiveNumber(_ num: String) -> Bool { func isValid(_ num: String) -> Bool { return num.count == 1 || num.first != \"0\" }; func backtrack(_ idx: Int, _ path: [Int]) -> Bool { if idx == num.count { return path.count >= 3; } for i in idx...num.count-1 { let cur = String(num[num.index(num.startIndex, offsetBy: idx)...num.index(num.startIndex, offsetBy: i+1)]); if !isValid(cur) { continue; } if let n = Int(cur) { if path.count < 2 || n == path[path.count-1] + path[path.count-2] { if backtrack(i+1, path + [n]) { return true; } } } } return false; }; return backtrack(0, []); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "199100199",
      "slug" : "additive-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4]]",
      "input" : "graph = [[4,3,1],[3,2,4],[3],[4],[]]",
      "slug" : "all-paths-from-source-to-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[0,4],[0,3,4],[0,3,4],[0,3,4],[0,1,4]]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4]]",
      "input" : "graph = [[4,3,1],[3,2,4],[3],[4],[]]",
      "slug" : "all-paths-from-source-to-target",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_1\/solution.swift:8:20: error: cannot find 'numsprefix' in scope\n  6 |     let nums = Array(s.dropFirst().dropLast())\n  7 |     for i in 1...nums.count-1 {\n  8 |         let left = numsprefix(i)\n    |                    `- error: cannot find 'numsprefix' in scope\n  9 |         let right = nums.suffix(nums.count-i)\n 10 |         for l in possibleInterpretations(left) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_1\/solution.swift:11:46: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let right = nums.suffix(nums.count-i)\n 10 |         for l in possibleInterpretations(left) {\n 11 |             for r in possibleInterpretations(right) {\n    |                                              `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |                 res.append(\"((l), (r))\")\n 13 |             }\n",
      "expected" : "[\"(1, 23)\", \"(12, 3)\", \"(1.2, 3)\", \"(1, 2.3)\"]",
      "input" : "s = \"123\"",
      "slug" : "ambiguous-coordinates",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_1\/solution.swift:8:20: error: cannot find 'numsprefix' in scope\n  6 |     let nums = Array(s.dropFirst().dropLast())\n  7 |     for i in 1...nums.count-1 {\n  8 |         let left = numsprefix(i)\n    |                    `- error: cannot find 'numsprefix' in scope\n  9 |         let right = nums.suffix(nums.count-i)\n 10 |         for l in possibleInterpretations(left) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_1\/solution.swift:11:46: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let right = nums.suffix(nums.count-i)\n 10 |         for l in possibleInterpretations(left) {\n 11 |             for r in possibleInterpretations(right) {\n    |                                              `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |                 res.append(\"((l), (r))\")\n 13 |             }\n",
      "expected" : "[\"(0, 004)\", \"(0, 0.04)\", \"(0.0, 04)\", \"(00, 04)\", \"(0, 0.4)\", \"(0.0, 4)\", \"(00, 0.4)\", \"(0, 04)\", \"(0.00, 4)\"]",
      "input" : "s = \"0004\"",
      "slug" : "ambiguous-coordinates",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:11:29: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let left = nums.prefix(i)\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n    |                             `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n 13 |         for l in lOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:11:62: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let left = nums.prefix(i)\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n    |                                                              `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n 13 |         for l in lOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:12:29: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n    |                             `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 13 |         for l in lOptions {\n 14 |             for r in rOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:12:63: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n    |                                                               `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 13 |         for l in lOptions {\n 14 |             for r in rOptions {\n",
      "expected" : "[\"(1, 23)\", \"(12, 3)\", \"(1.2, 3)\", \"(1, 2.3)\"]",
      "input" : "s = \"123\"",
      "slug" : "ambiguous-coordinates",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:11:29: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let left = nums.prefix(i)\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n    |                             `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n 13 |         for l in lOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:11:62: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n  9 |         let left = nums.prefix(i)\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n    |                                                              `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n 13 |         for l in lOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:12:29: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n    |                             `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 13 |         for l in lOptions {\n 14 |             for r in rOptions {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ambiguous-coordinates_2\/solution.swift:12:63: error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 10 |         let right = nums.suffix(nums.count-i)\n 11 |         let lOptions = memo[left] ?? possibleInterpretations(left)\n 12 |         let rOptions = memo[right] ?? possibleInterpretations(right)\n    |                                                               `- error: cannot convert value of type 'Array<Substring.Element>.SubSequence' (aka 'ArraySlice<Character>') to expected argument type 'Substring'\n 13 |         for l in lOptions {\n 14 |             for r in rOptions {\n",
      "expected" : "[\"(0, 004)\", \"(0, 0.04)\", \"(0.0, 04)\", \"(00, 04)\", \"(0, 0.4)\", \"(0.0, 4)\", \"(00, 0.4)\", \"(0, 04)\", \"(0.00, 4)\"]",
      "input" : "s = \"0004\"",
      "slug" : "ambiguous-coordinates",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[\"1->3\",\"1->2->5\"]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[\"1->2->5\",\"1->3\"]",
      "input" : "root = [1,2,3,null,5]",
      "slug" : "binary-tree-paths",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"1->3\",\"1->2\"]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[\"1->2\",\"1->3\"]",
      "input" : "root = [1,2,3]",
      "slug" : "binary-tree-paths",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[\"00:01\",\"00:02\",\"00:04\",\"00:08\",\"00:16\",\"00:32\",\"01:00\",\"02:00\",\"04:00\",\"08:00\"]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]",
      "input" : "turnedOn = 1",
      "slug" : "binary-watch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"00:03\",\"00:05\",\"00:06\",\"00:09\",\"00:10\",\"00:12\",\"00:17\",\"00:18\",\"00:20\",\"00:24\",\"00:33\",\"00:34\",\"00:36\",\"00:40\",\"00:48\",\"01:01\",\"01:02\",\"01:04\",\"01:08\",\"01:16\",\"01:32\",\"02:01\",\"02:02\",\"02:04\",\"02:08\",\"02:16\",\"02:32\",\"03:00\",\"04:01\",\"04:02\",\"04:04\",\"04:08\",\"04:16\",\"04:32\",\"05:00\",\"06:00\",\"08:01\",\"08:02\",\"08:04\",\"08:08\",\"08:16\",\"08:32\",\"09:00\",\"10:00\"]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[\"0:11\",\"0:12\",\"0:13\",\"0:14\",\"0:15\",\"0:16\",\"0:17\",\"0:18\",\"0:19\",\"0:21\",\"0:22\",\"0:23\",\"0:24\",\"0:25\",\"0:26\",\"0:27\",\"0:28\",\"0:29\",\"0:31\",\"0:32\",\"0:33\",\"0:34\",\"0:35\",\"0:36\",\"0:37\",\"0:38\",\"0:39\",\"0:41\",\"0:42\",\"0:43\",\"0:44\",\"0:45\",\"0:46\",\"0:47\",\"0:48\",\"0:49\",\"0:51\",\"0:52\",\"0:53\",\"0:54\",\"0:55\",\"0:56\",\"0:57\",\"0:58\",\"0:59\",\"1:00\",\"2:00\",\"3:00\",\"4:00\",\"5:00\",\"6:00\",\"7:00\",\"8:00\",\"9:00\"]",
      "input" : "turnedOn = 2",
      "slug" : "binary-watch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]",
      "input" : "turnedOn = 1",
      "slug" : "binary-watch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"01:01\",\"01:02\",\"01:04\",\"01:08\",\"02:01\",\"02:02\",\"02:04\",\"02:08\",\"04:01\",\"04:02\",\"04:04\",\"04:08\",\"08:01\",\"08:02\",\"08:04\",\"08:08\"]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[\"0:11\",\"0:12\",\"0:13\",\"0:14\",\"0:15\",\"0:16\",\"0:17\",\"0:18\",\"0:19\",\"0:21\",\"0:22\",\"0:23\",\"0:24\",\"0:25\",\"0:26\",\"0:27\",\"0:28\",\"0:29\",\"0:31\",\"0:32\",\"0:33\",\"0:34\",\"0:35\",\"0:36\",\"0:37\",\"0:38\",\"0:39\",\"0:41\",\"0:42\",\"0:43\",\"0:44\",\"0:45\",\"0:46\",\"0:47\",\"0:48\",\"0:49\",\"0:51\",\"0:52\",\"0:53\",\"0:54\",\"0:55\",\"0:56\",\"0:57\",\"0:58\",\"0:59\",\"1:00\",\"2:00\",\"3:00\",\"4:00\",\"5:00\",\"6:00\",\"7:00\",\"8:00\",\"9:00\"]",
      "input" : "turnedOn = 2",
      "slug" : "binary-watch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[[1,2,6],[1,3,5],[2,3,4]]",
      "input" : "k = 3, n = 9",
      "slug" : "combination-sum-iii",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[[1,2,7],[1,3,6],[1,4,5],[2,3,5]]",
      "input" : "k = 3, n = 10",
      "slug" : "combination-sum-iii",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Backtracking",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[1,2,6],[1,3,5],[2,3,4]]",
      "input" : "k = 3, n = 9",
      "slug" : "combination-sum-iii",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Backtracking",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[[1,2,7],[1,3,6],[1,4,5],[2,3,5]]",
      "input" : "k = 3, n = 10",
      "slug" : "combination-sum-iii",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Backtracking",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
      "input" : "n=4, k=2",
      "slug" : "combinations",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-time-for-given-digits_1\/solution.swift:19:18: error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 17 |     } else {\n 18 |         for i in start..<A.count {\n 19 |             swap(&A, start, i)\n    |                  `- error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 20 |             permute(A, start + 1, &time, &maxTime)\n 21 |             swap(&A, start, i)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-time-for-given-digits_1\/solution.swift:21:18: error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 19 |             swap(&A, start, i)\n 20 |             permute(A, start + 1, &time, &maxTime)\n 21 |             swap(&A, start, i)\n    |                  `- error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 22 |         }\n 23 |     }\n",
      "expected" : "23:41",
      "input" : "A = [1,2,3,4]",
      "slug" : "largest-time-for-given-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-time-for-given-digits_1\/solution.swift:19:18: error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 17 |     } else {\n 18 |         for i in start..<A.count {\n 19 |             swap(&A, start, i)\n    |                  `- error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 20 |             permute(A, start + 1, &time, &maxTime)\n 21 |             swap(&A, start, i)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-time-for-given-digits_1\/solution.swift:21:18: error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 19 |             swap(&A, start, i)\n 20 |             permute(A, start + 1, &time, &maxTime)\n 21 |             swap(&A, start, i)\n    |                  `- error: cannot pass immutable value as inout argument: 'A' is a 'let' constant\n 22 |         }\n 23 |     }\n",
      "expected" : "",
      "input" : "A = [5,5,5,5]",
      "slug" : "largest-time-for-given-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"23:41\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "23:41",
      "input" : "A = [1,2,3,4]",
      "slug" : "largest-time-for-given-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "",
      "input" : "A = [5,5,5,5]",
      "slug" : "largest-time-for-given-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n",
      "expected" : "[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]",
      "input" : "a1b2",
      "slug" : "letter-case-permutation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n",
      "expected" : "[\"3z4\", \"3Z4\"]",
      "input" : "3z4",
      "slug" : "letter-case-permutation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_2\/solution.swift:8:9: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n  8 |     let n = s.count\n    |         `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  9 |     let numBits = s.reduce(0) { $0 + ($1.isLetter ? 1 : 0) }\n 10 |     var result: [String] = []\n",
      "expected" : "[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]",
      "input" : "a1b2",
      "slug" : "letter-case-permutation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/letter-case-permutation_2\/solution.swift:8:9: warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  6 | \n  7 | func letterCasePermutation(_ s: String) -> [String] {\n  8 |     let n = s.count\n    |         `- warning: initialization of immutable value 'n' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  9 |     let numBits = s.reduce(0) { $0 + ($1.isLetter ? 1 : 0) }\n 10 |     var result: [String] = []\n",
      "expected" : "[\"3z4\", \"3Z4\"]",
      "input" : "3z4",
      "slug" : "letter-case-permutation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-subsequences_1\/solution.swift:18:115: error: cannot force unwrap value of non-optional type '[String]'\n 16 |         } \n 17 |     } \n 18 |     return Array(Set(result.map { String($0.map { String($0) }.joined()) })).map { $0.components(separatedBy: \".\")!.map { Int($0)! } } \n    |                                                                                                                   `- error: cannot force unwrap value of non-optional type '[String]'\n 19 | } \n 20 |  \n",
      "expected" : "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
      "input" : "nums = [4,6,7,7]",
      "slug" : "non-decreasing-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/non-decreasing-subsequences_1\/solution.swift:18:115: error: cannot force unwrap value of non-optional type '[String]'\n 16 |         } \n 17 |     } \n 18 |     return Array(Set(result.map { String($0.map { String($0) }.joined()) })).map { $0.components(separatedBy: \".\")!.map { Int($0)! } } \n    |                                                                                                                   `- error: cannot force unwrap value of non-optional type '[String]'\n 19 | } \n 20 |  \n",
      "expected" : "[[1,2],[1,2,3],[1,3],[2,3]]",
      "input" : "nums = [1,2,3]",
      "slug" : "non-decreasing-subsequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[4,6,7,7],[4,6,7],[4,6,7],[4,6],[4,7,7],[4,7],[4,7],[6,7,7],[6,7],[6,7],[7,7]]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
      "input" : "nums = [4,6,7,7]",
      "slug" : "non-decreasing-subsequences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[1,2,3],[1,2],[1,3],[2,3]]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[[1,2],[1,2,3],[1,3],[2,3]]",
      "input" : "nums = [1,2,3]",
      "slug" : "non-decreasing-subsequences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[181,292,707,818,929]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[181,292,383,484,585,686,787,878,979]",
      "input" : "n = 3, k = 7",
      "slug" : "numbers-with-same-consecutive-differences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[12,10,23,21,34,32,45,43,56,54,67,65,78,76,89,87,98]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]",
      "input" : "n = 2, k = 1",
      "slug" : "numbers-with-same-consecutive-differences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[181,292,707,818,929]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[181,292,383,484,585,686,787,878,979]",
      "input" : "n = 3, k = 7",
      "slug" : "numbers-with-same-consecutive-differences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[12,10,23,21,34,32,45,43,56,54,67,65,78,76,89,87,98]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]",
      "input" : "n = 2, k = 1",
      "slug" : "numbers-with-same-consecutive-differences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[[5,4,11,2],[5,8,4,5]]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[[5,4,11,2], [5,8,4,5]]",
      "input" : "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
      "slug" : "path-sum-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[[5,4,11,2],[5,8,4,5]]",
      "approachName" : "Optimized Depth-First Search",
      "approachOrder" : 2,
      "expected" : "[[5,4,11,2], [5,8,4,5]]",
      "input" : "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
      "slug" : "path-sum-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:119: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:169: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:272: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:281: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:457: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:492: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:515: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:310: warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                      `- warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  4 | \n  5 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "[\"ABC\"]",
      "input" : "bottom = \"ABC\", allowed = [\"ABC\"]",
      "slug" : "pyramid-transition-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:119: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:169: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:272: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:281: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:457: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:492: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:515: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_1\/solution.swift:3:310: warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } for str in allowed { if str.substring(to: str.index(str.startIndex, offsetBy: 1)) == String(chars[index]) + String(chars[index + 1]) { let newStr = current + String(str.last!) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                      `- warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  4 | \n  5 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "[\"ABCD\"]",
      "input" : "bottom = \"ABCD\", allowed = [\"ABCD\"]",
      "slug" : "pyramid-transition-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:138: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:227: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:280: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:306: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:356: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:459: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:468: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:636: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:671: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:694: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:174: warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                              `- warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  4 | \n  5 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "[\"ABC\"]",
      "input" : "bottom = \"ABC\", allowed = [\"ABC\"]",
      "slug" : "pyramid-transition-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:138: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:227: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:280: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:306: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:356: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:459: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:468: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:636: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:671: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:694: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/pyramid-transition-matrix_2\/solution.swift:3:174: warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  1 | import Foundation\n  2 | \n  3 | class Solution { func pyramidTransition(_ bottom: String, _ allowed: [String]) -> [String] { var transitions: [String: [Character]] = [:] for str in allowed { let key = str.substring(to: str.index(str.startIndex, offsetBy: 2)) transitions[key] = Array<Character>(str.suffix(1)) } var result: [String] = [] let chars: [Character] = Array<Character>(bottom) func backtrack(_ index: Int, _ current: String) { if index == chars.count - 1 { result.append(current) return } if let validTransitions = transitions[String(chars[index]) + String(chars[index + 1])] { for transition in validTransitions { let newStr = current + String(transition) backtrack(index + 1, newStr) } } } backtrack(0, String()) return result } }\n    |                                                                                                                                                                              `- warning: 'substring(to:)' is deprecated: Please use String slicing subscript with a 'partial range upto' operator. [#DeprecatedDeclaration]\n  4 | \n  5 | \n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "[\"XYA\", \"XYB\", \"XYC\"]",
      "input" : "bottom = \"XYZ\", allowed = [\"XYA\", \"XYB\", \"XYC\"]",
      "slug" : "pyramid-transition-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:256: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:265: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:547: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:583: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: expected 'func' keyword in instance method declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:589: error: expected parameter name followed by ':'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: expected parameter name followed by ':'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:317: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                             |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:465: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:583: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: expected '{' in body of function declaration\n  5 | }\n  6 | \n",
      "expected" : "[\"255.255.11.135\",\"255.255.111.35\"]",
      "input" : "s = \"25525511135\"",
      "slug" : "restore-ip-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:256: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:265: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:547: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:583: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: expected 'func' keyword in instance method declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:589: error: expected parameter name followed by ':'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: expected parameter name followed by ':'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:317: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                             |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                             `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:465: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_1\/solution.swift:4:583: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func backtrack(_ s: String, _ path: [String], _ start: Int) { if path.count == 4 { if start == n { res.append(path.joined(separator: \".\")) } return } for i in 1...3 { if start + i <= n { let segment = String(s.startIndex..., offsetBy: start + i - start); if Int(segment) ?? 0 <= 255 && (segment.first == \"0\" ? segment.count == 1 : true) { backtrack(String(s.startIndex..., offsetBy: start + i), path + [segment], start + i) } } } } backtrack(s, [], 0); return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: expected '{' in body of function declaration\n  5 | }\n  6 | \n",
      "expected" : "[\"0.0.0.0\"]",
      "input" : "s = \"0000\"",
      "slug" : "restore-ip-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:219: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:573: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:671: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:686: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected 'func' keyword in instance method declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:692: error: expected parameter name followed by ':'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: expected parameter name followed by ':'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:338: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                  |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:384: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:456: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:528: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:686: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected '{' in body of function declaration\n  5 | }\n  6 | \n",
      "expected" : "[\"255.255.11.135\",\"255.255.111.35\"]",
      "input" : "s = \"25525511135\"",
      "slug" : "restore-ip-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:219: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:573: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:671: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:686: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected 'func' keyword in instance method declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:692: error: expected parameter name followed by ':'\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: expected parameter name followed by ':'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:338: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                  |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                  `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:384: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:456: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (repeating: String, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (repeating: Character, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |- note: candidate has partially matching parameter list (utf16CodeUnits: UnsafePointer<unichar>, count: Int)\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- note: candidate has partially matching parameter list (repeating: String.Element, count: Int)\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\nSwift.String.init:2:8: note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: candidate '(_) -> String' has 2 parameters, but context '(PartialRangeFrom<String.Index>) -> String' has 1\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:528: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/restore-ip-addresses_2\/solution.swift:4:686: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | let s = \"25525511135\"; func restoreIpAddresses(_ s: String) -> [String] { let n = s.count; var res: [String] = []; func isValid(_ segment: String) -> Bool { if segment.first == \"0\" && segment.count > 1 { return false } return Int(segment) ?? 0 <= 255 }; for i in 1...3 { for j in i+1...i+3 { for k in j+1...j+3 { if k <= n - 1 { let a = String(s.startIndex..., offsetBy: i); let b = String(s.index(s.startIndex, offsetBy: i)..., offsetBy: j - i); let c = String(s.index(s.startIndex, offsetBy: j)..., offsetBy: k - j); let d = String(s.index(s.startIndex, offsetBy: k)...) if isValid(a) && isValid(b) && isValid(c) && isValid(d) { res.append(\"(a).(b).(c).(d)\") } } } } } return res }; print(restoreIpAddresses(s))\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: expected '{' in body of function declaration\n  5 | }\n  6 | \n",
      "expected" : "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
      "input" : "s = \"101023\"",
      "slug" : "restore-ip-addresses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-string-starting-from-leaf_1\/solution.swift:243:36: error: 'nil' is not compatible with closure result type 'TreeNode'\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n243 |         if item is NSNull { return nil }\n    |                                    `- error: 'nil' is not compatible with closure result type 'TreeNode'\n244 |         return TreeNode(toInt(item), nil, nil)\n245 |     }\n",
      "expected" : "dba",
      "input" : "root = [0,1,2,3,4,3,4]\nroot's children are labeled as [3,4,3,4]",
      "slug" : "smallest-string-starting-from-leaf",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-string-starting-from-leaf_1\/solution.swift:243:36: error: 'nil' is not compatible with closure result type 'TreeNode'\n241 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n242 |     var nodes: [TreeNode?] = array.map { item in\n243 |         if item is NSNull { return nil }\n    |                                    `- error: 'nil' is not compatible with closure result type 'TreeNode'\n244 |         return TreeNode(toInt(item), nil, nil)\n245 |     }\n",
      "expected" : "adz",
      "input" : "root = [25,1,3,1,3,0,2]",
      "slug" : "smallest-string-starting-from-leaf",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-string-starting-from-leaf_2\/solution.swift:254:36: error: 'nil' is not compatible with closure result type 'TreeNode'\n252 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n253 |     var nodes: [TreeNode?] = array.map { item in\n254 |         if item is NSNull { return nil }\n    |                                    `- error: 'nil' is not compatible with closure result type 'TreeNode'\n255 |         return TreeNode(toInt(item), nil, nil)\n256 |     }\n",
      "expected" : "dba",
      "input" : "root = [0,1,2,3,4,3,4]\nroot's children are labeled as [3,4,3,4]",
      "slug" : "smallest-string-starting-from-leaf",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-string-starting-from-leaf_2\/solution.swift:254:36: error: 'nil' is not compatible with closure result type 'TreeNode'\n252 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n253 |     var nodes: [TreeNode?] = array.map { item in\n254 |         if item is NSNull { return nil }\n    |                                    `- error: 'nil' is not compatible with closure result type 'TreeNode'\n255 |         return TreeNode(toInt(item), nil, nil)\n256 |     }\n",
      "expected" : "adz",
      "input" : "root = [25,1,3,1,3,0,2]",
      "slug" : "smallest-string-starting-from-leaf",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_1\/solution.swift:19:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 17 |                                result.append(contentsOf: backtrack(path + [num], i + len))\n 18 |                            } else if path[path.count - 1] + path[path.count - 2] == num {\n 19 |                                if let res = backtrack(path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 20 |                                    return res\n 21 |                                }\n",
      "expected" : "[1,2,3]",
      "input" : "123",
      "slug" : "split-array-into-fibonacci-sequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_1\/solution.swift:19:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 17 |                                result.append(contentsOf: backtrack(path + [num], i + len))\n 18 |                            } else if path[path.count - 1] + path[path.count - 2] == num {\n 19 |                                if let res = backtrack(path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 20 |                                    return res\n 21 |                                }\n",
      "expected" : "[1,2,3,5,8,13,21,34,55]",
      "input" : "123456789",
      "slug" : "split-array-into-fibonacci-sequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:39:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 37 |                        if let child = node.children[String(num)] {\n 38 |                            if path.count < 2 {\n 39 |                                if let res = dfs(child, path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 40 |                                    return res\n 41 |                                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:43:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 41 |                                }\n 42 |                            } else if path[path.count - 1] + path[path.count - 2] == num {\n 43 |                                if let res = dfs(child, path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 44 |                                    return res\n 45 |                                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:14:24: warning: variable 'root' was never mutated; consider changing to 'let' constant\n 12 | \n 13 |                func buildTrie(_ seq: [Int]) {\n 14 |                    var root = TrieNode()\n    |                        `- warning: variable 'root' was never mutated; consider changing to 'let' constant\n 15 |                    var node = root\n 16 |                    for num in seq {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:31:24: warning: variable 'result' was never used; consider replacing with '_' or removing it [#no-usage]\n 29 |                    }\n 30 | \n 31 |                    var result: [[Int]] = []\n    |                        `- warning: variable 'result' was never used; consider replacing with '_' or removing it [#no-usage]\n 32 |                    for len in 1...10 {\n 33 |                        if i + len > S.count { break }\n",
      "expected" : "[1,2,3]",
      "input" : "123",
      "slug" : "split-array-into-fibonacci-sequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:39:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 37 |                        if let child = node.children[String(num)] {\n 38 |                            if path.count < 2 {\n 39 |                                if let res = dfs(child, path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 40 |                                    return res\n 41 |                                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:43:35: error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 41 |                                }\n 42 |                            } else if path[path.count - 1] + path[path.count - 2] == num {\n 43 |                                if let res = dfs(child, path + [num], i + len) {\n    |                                   `- error: initializer for conditional binding must have Optional type, not '[[Int]]'\n 44 |                                    return res\n 45 |                                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:14:24: warning: variable 'root' was never mutated; consider changing to 'let' constant\n 12 | \n 13 |                func buildTrie(_ seq: [Int]) {\n 14 |                    var root = TrieNode()\n    |                        `- warning: variable 'root' was never mutated; consider changing to 'let' constant\n 15 |                    var node = root\n 16 |                    for num in seq {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/split-array-into-fibonacci-sequence_2\/solution.swift:31:24: warning: variable 'result' was never used; consider replacing with '_' or removing it [#no-usage]\n 29 |                    }\n 30 | \n 31 |                    var result: [[Int]] = []\n    |                        `- warning: variable 'result' was never used; consider replacing with '_' or removing it [#no-usage]\n 32 |                    for len in 1...10 {\n 33 |                        if i + len > S.count { break }\n",
      "expected" : "[1,2,3,5,8,13,21,34,55]",
      "input" : "123456789",
      "slug" : "split-array-into-fibonacci-sequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]",
      "approachName" : "Backtracking",
      "approachOrder" : 1,
      "expected" : "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
      "input" : "[1,2,3]",
      "slug" : "subsets",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Union Find",
      "approachOrder" : 1,
      "expected" : "Merged accounts",
      "input" : "accounts with overlapping emails",
      "slug" : "accounts-merge",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "DFS with Hash Map",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:4:35: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func cloneGraph(_ node: Node?) -> Node? {\n    |                                   `- error: cannot find type 'Node' in scope\n  5 |     guard let node = node else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:4:25: error: cannot find type 'Node' in scope\n  2 | \n  3 | class Solution {\n  4 | func cloneGraph(_ node: Node?) -> Node? {\n    |                         `- error: cannot find type 'Node' in scope\n  5 |     guard let node = node else { return nil }\n  6 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:7:23: error: cannot find type 'Node' in scope\n  5 |     guard let node = node else { return nil }\n  6 |     \n  7 |     var cloned: [Int: Node] = [:]\n    |                       `- error: cannot find type 'Node' in scope\n  8 |     \n  9 |     func dfs(_ node: Node) -> Node {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:9:31: error: cannot find type 'Node' in scope\n  7 |     var cloned: [Int: Node] = [:]\n  8 |     \n  9 |     func dfs(_ node: Node) -> Node {\n    |                               `- error: cannot find type 'Node' in scope\n 10 |         if let clone = cloned[node.val] { return clone }\n 11 |         \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:9:22: error: cannot find type 'Node' in scope\n  7 |     var cloned: [Int: Node] = [:]\n  8 |     \n  9 |     func dfs(_ node: Node) -> Node {\n    |                      `- error: cannot find type 'Node' in scope\n 10 |         if let clone = cloned[node.val] { return clone }\n 11 |         \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clone-graph_1\/solution.swift:12:21: error: cannot find 'Node' in scope\n 10 |         if let clone = cloned[node.val] { return clone }\n 11 |         \n 12 |         let clone = Node(node.val)\n    |                     `- error: cannot find 'Node' in scope\n 13 |         cloned[node.val] = clone\n 14 |         \n",
      "expected" : "[[2,4],[1,3],[2,4],[1,3]]",
      "input" : "[[2,4],[1,3],[2,4],[1,3]]",
      "slug" : "clone-graph",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[0,1,2,3]",
      "approachName" : "Kahn's Algorithm (BFS)",
      "approachOrder" : 1,
      "expected" : "[0,1,2,3] or [0,2,1,3]",
      "input" : "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
      "slug" : "course-schedule-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[6]",
      "approachName" : "Graph DFS",
      "approachOrder" : 1,
      "expected" : "[6.0]",
      "input" : "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"]]",
      "slug" : "evaluate-division",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,1,2,3,4,5,6,7]",
      "approachName" : "DFS",
      "approachOrder" : 1,
      "expected" : "[5,5,2,5,4,5,6,7]",
      "input" : "richer = [[1,0],[2,1],[3,1],[3,7],...], quiet = [3,2,5,4,6,1,7,0]",
      "slug" : "loud-and-rich",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "DFS Flood Fill",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "3",
      "input" : "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
      "slug" : "number-of-islands",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[[3,0],[3,1],[2,2],[0,4],[4,0],[1,3],[1,4]]",
      "approachName" : "Reverse BFS from Oceans",
      "approachOrder" : 1,
      "expected" : "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
      "input" : "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
      "slug" : "pacific-atlantic-water-flow",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:32:51: error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n 30 |                 if p1 == current && !visited.contains(p2) {\n 31 |                     queue.append(p2)\n 32 |                     bipartition[p2] = !bipartition[p1]\n    |                                                   |- error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n    |                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 33 |                 }\n 34 |                 if p2 == current && !visited.contains(p1) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:36:51: error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n 34 |                 if p2 == current && !visited.contains(p1) {\n 35 |                     queue.append(p1)\n 36 |                     bipartition[p1] = !bipartition[p2]\n    |                                                   |- error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n    |                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 37 |                 }\n 38 |             }\n",
      "expected" : "false",
      "input" : "N = 4, dislikes = [[1,2],[1,3],[2,4]]",
      "slug" : "possible-bipartition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:32:51: error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n 30 |                 if p1 == current && !visited.contains(p2) {\n 31 |                     queue.append(p2)\n 32 |                     bipartition[p2] = !bipartition[p1]\n    |                                                   |- error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n    |                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 33 |                 }\n 34 |                 if p2 == current && !visited.contains(p1) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_1\/solution.swift:36:51: error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n 34 |                 if p2 == current && !visited.contains(p1) {\n 35 |                     queue.append(p1)\n 36 |                     bipartition[p1] = !bipartition[p2]\n    |                                                   |- error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n    |                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 37 |                 }\n 38 |             }\n",
      "expected" : "false",
      "input" : "N = 3, dislikes = [[1,2],[1,3],[2,3]]",
      "slug" : "possible-bipartition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\n",
      "expected" : "false",
      "input" : "N = 4, dislikes = [[1,2],[1,3],[2,4]]",
      "slug" : "possible-bipartition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/possible-bipartition_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\n",
      "expected" : "false",
      "input" : "N = 3, dislikes = [[1,2],[1,3],[2,3]]",
      "slug" : "possible-bipartition",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "-1",
      "approachName" : "BFS",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "board with snakes\/ladders",
      "slug" : "snakes-and-ladders",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "DFS from Border",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/surrounded-regions_1\/solution.swift:253:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n250 | let solution = Solution()\n251 | \n252 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toCharacter($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n253 | let result = solution.solve(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n254 | let output: Any = NSNull()\n255 | print(jsonString(from: output))\n",
      "expected" : "[[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]",
      "input" : "[[\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\"]]",
      "slug" : "surrounded-regions",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode)]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "all possible full binary trees with 7 nodes",
      "input" : "n = 7",
      "slug" : "all-possible-full-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "all possible full binary trees with 3 nodes",
      "input" : "n = 3",
      "slug" : "all-possible-full-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode)]",
      "approachName" : "Optimized Memoization",
      "approachOrder" : 2,
      "expected" : "all possible full binary trees with 7 nodes",
      "input" : "n = 7",
      "slug" : "all-possible-full-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Optimized Memoization",
      "approachOrder" : 2,
      "expected" : "all possible full binary trees with 3 nodes",
      "input" : "n = 3",
      "slug" : "all-possible-full-binary-trees",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_1\/solution.swift:4:297: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; for i in 0..<nums.count { for j in i + 2..<nums.count { let slice = Array(nums[i...j]); var diff = slice[1] - slice[0]; var valid = true; for k in 2..<slice.count { if slice[k] - slice[k - 1] != diff { valid = false; break; } } if valid { count += 1 } } }; return count }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_1\/solution.swift:4:162: warning: variable 'diff' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; for i in 0..<nums.count { for j in i + 2..<nums.count { let slice = Array(nums[i...j]); var diff = slice[1] - slice[0]; var valid = true; for k in 2..<slice.count { if slice[k] - slice[k - 1] != diff { valid = false; break; } } if valid { count += 1 } } }; return count }\n    |                                                                                                                                                                  `- warning: variable 'diff' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1, 2, 3, 4]",
      "slug" : "arithmetic-slices",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_1\/solution.swift:4:297: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; for i in 0..<nums.count { for j in i + 2..<nums.count { let slice = Array(nums[i...j]); var diff = slice[1] - slice[0]; var valid = true; for k in 2..<slice.count { if slice[k] - slice[k - 1] != diff { valid = false; break; } } if valid { count += 1 } } }; return count }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_1\/solution.swift:4:162: warning: variable 'diff' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; for i in 0..<nums.count { for j in i + 2..<nums.count { let slice = Array(nums[i...j]); var diff = slice[1] - slice[0]; var valid = true; for k in 2..<slice.count { if slice[k] - slice[k - 1] != diff { valid = false; break; } } if valid { count += 1 } } }; return count }\n    |                                                                                                                                                                  `- warning: variable 'diff' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "nums = [1, 2, 4, 5, 7, 10]",
      "slug" : "arithmetic-slices",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_2\/solution.swift:4:321: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; var dp = [Int: Int](); for i in 2..<nums.count { let diff = nums[i] - nums[i - 1]; for j in (0...i - 2) { let prevDiff = nums[j + 1] - nums[j]; if prevDiff == diff { if let currCount = dp[j] { count += currCount; dp[i] = (dp[i] ?? 0) + currCount } } } dp[i] = (dp[i] ?? 0) + 1 }; return count }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1, 2, 3, 4]",
      "slug" : "arithmetic-slices",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/arithmetic-slices_2\/solution.swift:4:321: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func numberOfArithmeticSlices(_ nums: [Int]) -> Int { var count = 0; var dp = [Int: Int](); for i in 2..<nums.count { let diff = nums[i] - nums[i - 1]; for j in (0...i - 2) { let prevDiff = nums[j + 1] - nums[j]; if prevDiff == diff { if let currCount = dp[j] { count += currCount; dp[i] = (dp[i] ?? 0) + currCount } } } dp[i] = (dp[i] ?? 0) + 1 }; return count }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "nums = [1, 2, 4, 5, 7, 10]",
      "slug" : "arithmetic-slices",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/best-time-to-buy-and-sell-stock-with-transaction-fee_1\/solution.swift:4:213: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProfit(prices: [Int], fee: Int) -> Int { var max = 0; for i in 0..<prices.count { for j in i+1..<prices.count { if prices[j] - prices[i] - fee > 0 { max = Swift.max(max, prices[j] - prices[i] - fee) } } } return max }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "prices = [1,3,2,8,4,9], fee = 2",
      "slug" : "best-time-to-buy-and-sell-stock-with-transaction-fee",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/best-time-to-buy-and-sell-stock-with-transaction-fee_1\/solution.swift:4:213: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProfit(prices: [Int], fee: Int) -> Int { var max = 0; for i in 0..<prices.count { for j in i+1..<prices.count { if prices[j] - prices[i] - fee > 0 { max = Swift.max(max, prices[j] - prices[i] - fee) } } } return max }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "prices = [1,3,7,5,10,3], fee = 3",
      "slug" : "best-time-to-buy-and-sell-stock-with-transaction-fee",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-trees-with-factors_1\/solution.swift:22:26: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n 20 |         for i in 0..<arr.count {\n 21 |             let candidate = arr[i]\n 22 |             if candidate > sqrt(Double(num)) {\n    |                          |- error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n    |                          `- note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)\n 23 |                 break\n 24 |             }\n",
      "expected" : "3",
      "input" : "[2, 4]",
      "slug" : "binary-trees-with-factors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-trees-with-factors_1\/solution.swift:22:26: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n 20 |         for i in 0..<arr.count {\n 21 |             let candidate = arr[i]\n 22 |             if candidate > sqrt(Double(num)) {\n    |                          |- error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n    |                          `- note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)\n 23 |                 break\n 24 |             }\n",
      "expected" : "7",
      "input" : "[2, 4, 5, 10]",
      "slug" : "binary-trees-with-factors",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "9",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "[2, 4, 5, 10]",
      "slug" : "binary-trees-with-factors",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[1,2,3,4,5,6,7]",
      "input" : "nums = [1,2,4]",
      "slug" : "bitwise-ors-of-subarrays",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[0]",
      "input" : "nums = [0,0,0]",
      "slug" : "bitwise-ors-of-subarrays",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[1,3]",
      "input" : "nums = [1,1,2]",
      "slug" : "bitwise-ors-of-subarrays",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[0,1,2,3,4,5,6,7]",
      "input" : "nums = [0,1,2,4]",
      "slug" : "bitwise-ors-of-subarrays",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:329: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0.0",
      "input" : "poured = 1, query_row = 1, query_glass = 1",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:329: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0.5",
      "input" : "poured = 2, query_row = 1, query_glass = 1",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:329: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_1\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var prevRow = [Double](repeating: 0, count: 1); prevRow[0] = Double(poured); for row in 1...query_row { var curRow = [Double](repeating: 0, count: row + 1); for i in 0..<row { curRow[i] += prevRow[i] \/ 2.0; curRow[i + 1] += prevRow[i] \/ 2.0; } prevRow = curRow; } return min(1, prevRow[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1.0",
      "input" : "poured = 100000009, query_row = 33, query_glass = 17",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:400: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:429: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0.0",
      "input" : "poured = 1, query_row = 1, query_glass = 1",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:400: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:429: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0.5",
      "input" : "poured = 2, query_row = 1, query_glass = 1",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:349: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:400: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/champagne-tower_2\/solution.swift:4:429: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func champagneTower(_ poured: Int, _ query_row: Int, _ query_glass: Int) -> Double { var champagne = [Double](repeating: 0, count: query_row + 1); champagne[0] = Double(poured); for row in 1...query_row { var nextChampagne = [Double](repeating: 0, count: row + 1); for i in 0..<row { if champagne[i] > 1 { nextChampagne[i] += (champagne[i] - 1) \/ 2 nextChampagne[i + 1] += (champagne[i] - 1) \/ 2 } } champagne = nextChampagne; } return min(1, champagne[query_glass]); }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1.0",
      "input" : "poured = 100000009, query_row = 33, query_glass = 17",
      "slug" : "champagne-tower",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "",
      "approachName" : "DP with Brian Kernighan",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[0]",
      "input" : "n = 0",
      "slug" : "counting-bits",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "12",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "15",
      "input" : "nums = [3,4,8]",
      "slug" : "delete-and-earn",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "12",
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "15",
      "input" : "nums = [3,4,8]",
      "slug" : "delete-and-earn",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "26",
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "18",
      "input" : "nums = [2,7,9,4,4]",
      "slug" : "delete-and-earn",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:6:20: warning: variable 'm' was never mutated; consider changing to 'let' constant\n  4 | \n  5 |            func minDistance(_ word1: String, _ word2: String) -> Int {\n  6 |                var m = word1.count\n    |                    `- warning: variable 'm' was never mutated; consider changing to 'let' constant\n  7 |                var n = word2.count\n  8 |                return m + n - 2 * lcs(word1, word2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:7:20: warning: variable 'n' was never mutated; consider changing to 'let' constant\n  5 |            func minDistance(_ word1: String, _ word2: String) -> Int {\n  6 |                var m = word1.count\n  7 |                var n = word2.count\n    |                    `- warning: variable 'n' was never mutated; consider changing to 'let' constant\n  8 |                return m + n - 2 * lcs(word1, word2)\n  9 |            }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:18:27: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                for i in 1...m {\n 17 |                    for j in 1...n {\n 18 |                        if word1[i - 1] == word2[j - 1] {\n    |                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 19 |                            dp[i][j] = dp[i - 1][j - 1] + 1\n 20 |                        } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:18:43: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                for i in 1...m {\n 17 |                    for j in 1...n {\n 18 |                        if word1[i - 1] == word2[j - 1] {\n    |                                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 19 |                            dp[i][j] = dp[i - 1][j - 1] + 1\n 20 |                        } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "3",
      "input" : "word1 = \"sea\", word2 = \"eat\"",
      "slug" : "delete-operation-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:6:20: warning: variable 'm' was never mutated; consider changing to 'let' constant\n  4 | \n  5 |            func minDistance(_ word1: String, _ word2: String) -> Int {\n  6 |                var m = word1.count\n    |                    `- warning: variable 'm' was never mutated; consider changing to 'let' constant\n  7 |                var n = word2.count\n  8 |                return m + n - 2 * lcs(word1, word2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:7:20: warning: variable 'n' was never mutated; consider changing to 'let' constant\n  5 |            func minDistance(_ word1: String, _ word2: String) -> Int {\n  6 |                var m = word1.count\n  7 |                var n = word2.count\n    |                    `- warning: variable 'n' was never mutated; consider changing to 'let' constant\n  8 |                return m + n - 2 * lcs(word1, word2)\n  9 |            }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:18:27: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                for i in 1...m {\n 17 |                    for j in 1...n {\n 18 |                        if word1[i - 1] == word2[j - 1] {\n    |                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 19 |                            dp[i][j] = dp[i - 1][j - 1] + 1\n 20 |                        } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_1\/solution.swift:18:43: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                for i in 1...m {\n 17 |                    for j in 1...n {\n 18 |                        if word1[i - 1] == word2[j - 1] {\n    |                                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 19 |                            dp[i][j] = dp[i - 1][j - 1] + 1\n 20 |                        } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "4",
      "input" : "word1 = \"delete\", word2 = \"leet\"",
      "slug" : "delete-operation-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_2\/solution.swift:19:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                    }\n 18 | \n 19 |                    if word1[i - 1] == word2[j - 1] {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                        memo[i][j] = 1 + lcs(i - 1, j - 1)\n 21 |                    } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_2\/solution.swift:19:39: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                    }\n 18 | \n 19 |                    if word1[i - 1] == word2[j - 1] {\n    |                                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                        memo[i][j] = 1 + lcs(i - 1, j - 1)\n 21 |                    } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "3",
      "input" : "word1 = \"kitten\", word2 = \"sitting\"",
      "slug" : "delete-operation-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_2\/solution.swift:19:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                    }\n 18 | \n 19 |                    if word1[i - 1] == word2[j - 1] {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                        memo[i][j] = 1 + lcs(i - 1, j - 1)\n 21 |                    } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/delete-operation-for-two-strings_2\/solution.swift:19:39: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                    }\n 18 | \n 19 |                    if word1[i - 1] == word2[j - 1] {\n    |                                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                        memo[i][j] = 1 + lcs(i - 1, j - 1)\n 21 |                    } else {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "4",
      "input" : "word1 = \"hello\", word2 = \"world\"",
      "slug" : "delete-operation-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "5",
      "input" : "n = 3",
      "slug" : "domino-and-tromino-tiling",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "11",
      "input" : "n = 4",
      "slug" : "domino-and-tromino-tiling",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "5",
      "input" : "n = 3",
      "slug" : "domino-and-tromino-tiling",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Optimized Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "11",
      "input" : "n = 4",
      "slug" : "domino-and-tromino-tiling",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "9223372036854775807",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "s = \"00110\"",
      "slug" : "flip-string-to-monotone-increasing",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "9223372036854775807",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "s = \"010110\"",
      "slug" : "flip-string-to-monotone-increasing",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "9223372036854775807",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "0",
      "input" : "s = \"000111\"",
      "slug" : "flip-string-to-monotone-increasing",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "0",
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "s = \"00110\"",
      "slug" : "flip-string-to-monotone-increasing",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "s = \"010110\"",
      "slug" : "flip-string-to-monotone-increasing",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "7",
      "input" : " TreeNode(3), TreeNode(2), TreeNode(3) None None, TreeNode(3) None None",
      "slug" : "house-robber-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "TreeNode(3) None None",
      "slug" : "house-robber-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:6:31: error: type 'TreeNode' does not conform to protocol 'Hashable'\n  4 |            class Solution {\n  5 |                func rob(_ root: TreeNode?) -> Int {\n  6 |                    var memo = [TreeNode: (Int, Int)]()\n    |                               `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n  7 |                    func dfs(_ node: TreeNode?) -> (Int, Int) {\n  8 |                        if node == nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:6:31: error: generic struct 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  4 |            class Solution {\n  5 |                func rob(_ root: TreeNode?) -> Int {\n  6 |                    var memo = [TreeNode: (Int, Int)]()\n    |                               `- error: generic struct 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  7 |                    func dfs(_ node: TreeNode?) -> (Int, Int) {\n  8 |                        if node == nil {\n\nSwift.Dictionary:1:23: note: where 'Key' = 'TreeNode'\n1 | @frozen public struct Dictionary<Key, Value> where Key : Hashable {\n  |                       `- note: where 'Key' = 'TreeNode'\n2 |     public typealias Element = (key: Key, value: Value)\n3 |     @inlinable public init(_immutableCocoaDictionary: __owned AnyObject)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:230:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n",
      "expected" : "3",
      "input" : "TreeNode(3) None None",
      "slug" : "house-robber-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:6:31: error: type 'TreeNode' does not conform to protocol 'Hashable'\n  4 |            class Solution {\n  5 |                func rob(_ root: TreeNode?) -> Int {\n  6 |                    var memo = [TreeNode: (Int, Int)]()\n    |                               `- error: type 'TreeNode' does not conform to protocol 'Hashable'\n  7 |                    func dfs(_ node: TreeNode?) -> (Int, Int) {\n  8 |                        if node == nil {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:6:31: error: generic struct 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  4 |            class Solution {\n  5 |                func rob(_ root: TreeNode?) -> Int {\n  6 |                    var memo = [TreeNode: (Int, Int)]()\n    |                               `- error: generic struct 'Dictionary' requires that 'TreeNode' conform to 'Hashable'\n  7 |                    func dfs(_ node: TreeNode?) -> (Int, Int) {\n  8 |                        if node == nil {\n\nSwift.Dictionary:1:23: note: where 'Key' = 'TreeNode'\n1 | @frozen public struct Dictionary<Key, Value> where Key : Hashable {\n  |                       `- note: where 'Key' = 'TreeNode'\n2 |     public typealias Element = (key: Key, value: Value)\n3 |     @inlinable public init(_immutableCocoaDictionary: __owned AnyObject)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/house-robber-iii_2\/solution.swift:230:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n228 | func toTreeNode(_ value: Any) -> TreeNode? {\n229 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n230 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n231 |         if item is NSNull { return nil }\n232 |         return TreeNode(toInt(item))\n",
      "expected" : "4",
      "input" : "TreeNode(2), TreeNode(2) None None",
      "slug" : "house-robber-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "n = 7",
      "slug" : "integer-replacement",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:247: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:256: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:267: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:300: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:309: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:320: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:347: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
      "slug" : "interleaving-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:247: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:256: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:267: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:300: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:309: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:320: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:347: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
      "slug" : "interleaving-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:247: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:256: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:267: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:300: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:309: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:320: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/interleaving-string_1\/solution.swift:4:347: error: missing argument labels 'i:j:k:' in call\n  2 | \n  3 | class Solution {\n  4 | func isInterleave(_ s1: String, _ s2: String, _ s3: String) -> Bool { let n = s1.count, m = s2.count; if n + m != s3.count { return false }; var res = false; func dfs(i: Int, j: Int, k: Int) { if k == s3.count { res = true; return }; if i < n && s1[i] == s3[k] { dfs(i + 1, j, k + 1) }; if j < m && s2[j] == s3[k] { dfs(i, j + 1, k + 1) }; }; dfs(0, 0, 0); return res; }\n    |                                                                                                                                                                                                                                                                                                                                                           `- error: missing argument labels 'i:j:k:' in call\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s1 = \"a\", s2 = \"b\", s3 = \"ab\"",
      "slug" : "interleaving-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "",
      "approachName" : "DP (for comparison)",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "2",
      "input" : "nums = [2,3,1,1,4]",
      "slug" : "jump-game-ii",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "22",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "20",
      "input" : "N = 2",
      "slug" : "knight-dialer",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0.25",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "0.0",
      "input" : "n = 3, k = 1, row = 0, column = 0",
      "slug" : "knight-probability-in-chessboard",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0.03125",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "0.0625",
      "input" : "n = 3, k = 2, row = 0, column = 0",
      "slug" : "knight-probability-in-chessboard",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "1.0",
      "input" : "n = 1, k = 0, row = 0, column = 0",
      "slug" : "knight-probability-in-chessboard",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:4:409: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: expected declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:5:1: error: extraneous '}' at top level\n  3 | class Solution {\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n  5 | }\n    | `- error: extraneous '}' at top level\n  6 | \n  7 | \n",
      "expected" : "2",
      "input" : "n = 5, mines = [4]",
      "slug" : "largest-plus-sign",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:4:409: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: expected declaration\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-plus-sign_1\/solution.swift:5:1: error: extraneous '}' at top level\n  3 | class Solution {\n  4 | func orderOfLargestPlusSign(_ n: Int, _ mines: [Int]) -> Int { let set = Set(mines); var res = 0; for i in 0..<n { for j in 0..<n { var count = 0; if !set.contains(i*n+j) { while i+count < n && j+count < n && i-count >= 0 && j-count >= 0 && !set.contains((i+count)*n+j) && !set.contains((i-count)*n+j) && !set.contains(i*n+j+count) && !set.contains(i*n+j-count) { count += 1 } } res = max(res, count) } } }; return res }\n  5 | }\n    | `- error: extraneous '}' at top level\n  6 | \n  7 | \n",
      "expected" : "1",
      "input" : "n = 1, mines = []",
      "slug" : "largest-plus-sign",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "n = 5, mines = [4]",
      "slug" : "largest-plus-sign",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:262: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:283: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:414: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:344: error: cannot convert value of type '(Double) -> Double' to expected argument type '(Double, Int) throws -> Double'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: cannot convert value of type '(Double) -> Double' to expected argument type '(Double, Int) throws -> Double'\n  4 | \n  5 | \n",
      "expected" : "20.0",
      "input" : "nums = [9,1,2,3,9], k = 3",
      "slug" : "largest-sum-of-averages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:262: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:283: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:414: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_1\/solution.swift:3:344: error: cannot convert value of type '(Double) -> Double' to expected argument type '(Double, Int) throws -> Double'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var maxSum = Double(Int.min); func backtrack(_ start: Int, _ k: Int, _ currentSum: Double) { if start == n && k == 0 { maxSum = max(maxSum, currentSum); return } if k == 0 { return } for i in start...n-1 { let sum = (nums[start...i].reduce(0, +)) \/ Double(i - start + 1); backtrack(i+1, k-1, currentSum + sum) } } backtrack(0, k, 0); return maxSum } }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: cannot convert value of type '(Double) -> Double' to expected argument type '(Double, Int) throws -> Double'\n  4 | \n  5 | \n",
      "expected" : "18.0",
      "input" : "nums = [1,2,3,4,5,6,7], k = 4",
      "slug" : "largest-sum-of-averages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:221: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:479: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:501: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "20.0",
      "input" : "nums = [9,1,2,3,9], k = 3",
      "slug" : "largest-sum-of-averages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:221: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:479: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-sum-of-averages_2\/solution.swift:3:501: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func largestSumOfAverages(_ nums: [Int], _ k: Int) -> Double { let n = nums.count; var prefixSum = [Double](repeating: 0, count: n+1); for i in 0...n-1 { prefixSum[i+1] = prefixSum[i] + Double(nums[i]) } var dp = [[Double]](repeating: [Double](repeating: 0, count: k+1), count: n+1); for i in 1...n { for j in 1...min(i, k) { var maxVal = Double(Int.min); for x in (j-1)...(i-1) { maxVal = max(maxVal, dp[x][j-1] + (prefixSum[i] - prefixSum[x]) \/ Double(i-x)) } dp[i][j] = maxVal } } return dp[n][k] } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "18.166666666666668",
      "input" : "nums = [1,2,3,4,5,6,7], k = 4",
      "slug" : "largest-sum-of-averages",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:270: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:310: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:194: warning: value 'index' was defined but never used; consider replacing with boolean test [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                  `- warning: value 'index' was defined but never used; consider replacing with boolean test [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "nums = [1,2,3,5,8,13]",
      "slug" : "length-of-longest-fibonacci-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:270: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:310: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_1\/solution.swift:4:194: warning: value 'index' was defined but never used; consider replacing with boolean test [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let n = A.count; var maxLength = 0; for i in 0..<n { for j in i+1..<n { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; if let index = A.firstIndex(of: z) { x = y; y = z; length += 1; } else { break; } } maxLength = max(maxLength, length); } } return maxLength > 2 ? maxLength : 0; }\n    |                                                                                                                                                                                                  `- warning: value 'index' was defined but never used; consider replacing with boolean test [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1,3,7,11,12,14,18]",
      "slug" : "length-of-longest-fibonacci-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:237: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:324: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "nums = [1,2,3,5,8,13]",
      "slug" : "length-of-longest-fibonacci-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:237: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-longest-fibonacci-subsequence_2\/solution.swift:4:324: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lenLongestFibSubseq(_ A: [Int]) -> Int { let set = Set(A); var maxLength = 0; for i in 0..<A.count { for j in i+1..<A.count { var x = A[i], y = A[j]; var length = 2; while true { let z = x + y; guard set.contains(z) else { break; } x = y; y = z; length += 1; } if length > 2 { maxLength = max(maxLength, length); } } } return maxLength; }\n    |                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "nums = [1,3,7,11,12,14,18]",
      "slug" : "length-of-longest-fibonacci-subsequence",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "s = \"bbbab\"",
      "slug" : "longest-palindromic-subsequence",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "5",
      "input" : "arr = [9,4,2,10,7,8,8,1,9]",
      "slug" : "longest-turbulent-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "arr = [4,8,12,16]",
      "slug" : "longest-turbulent-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "arr = [4,8,12,16]",
      "slug" : "longest-turbulent-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "true",
      "input" : "matchsticks = [1,1,1,1,1,1,1,1,1,1]",
      "slug" : "matchsticks-to-square",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "matchsticks = [1,1,1,1,1,1,1,1,1,1]",
      "slug" : "matchsticks-to-square",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "4",
      "input" : "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
      "slug" : "maximal-square",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:267: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:304: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:228: error: no exact matches in call to subscript \n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                    `- error: no exact matches in call to subscript \n  5 | }\n  6 | \n\nSwift.Array.subscript:2:19: note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n1 | generic struct Array {\n2 | @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }}\n  |                   `- note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n3 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:243: error: no exact matches in call to subscript \n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                   `- error: no exact matches in call to subscript \n  5 | }\n  6 | \n\nSwift.Array.subscript:2:19: note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n1 | generic struct Array {\n2 | @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }}\n  |                   `- note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n3 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:417: error: no exact matches in call to instance method 'append'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: no exact matches in call to instance method 'append'\n  5 | }\n  6 | \n\nSwift.Array.append:2:33: note: found candidate with type '[[Int]]'\n1 | generic struct Array {\n2 | @inlinable public mutating func append(_ newElement: __owned Element)}\n  |                                 `- note: found candidate with type '[[Int]]'\n3 | \n\nSwift.RangeReplaceableCollection.append:2:33: note: found candidate with type '[[Int]]'\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public mutating func append(_ newElement: __owned Self.Element)}\n  |                                 `- note: found candidate with type '[[Int]]'\n3 | \n\nSwift.Array.append:2:33: note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n1 | generic struct Array {\n2 | @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Sequence}\n  |                                 `- note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n3 | \n\nSwift.RangeReplaceableCollection.append:2:33: note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where S : Sequence, Self.Element == S.Element}\n  |                                 `- note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:461: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:471: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:519: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:529: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "pairs = [[1,2],[2,3],[3,4]]",
      "slug" : "maximum-length-of-pair-chain",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:267: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:304: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:228: error: no exact matches in call to subscript \n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                    `- error: no exact matches in call to subscript \n  5 | }\n  6 | \n\nSwift.Array.subscript:2:19: note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n1 | generic struct Array {\n2 | @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }}\n  |                   `- note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n3 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:243: error: no exact matches in call to subscript \n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                   `- error: no exact matches in call to subscript \n  5 | }\n  6 | \n\nSwift.Array.subscript:2:19: note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n1 | generic struct Array {\n2 | @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }}\n  |                   `- note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n3 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\nSwift.MutableCollection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol MutableCollection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:417: error: no exact matches in call to instance method 'append'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: no exact matches in call to instance method 'append'\n  5 | }\n  6 | \n\nSwift.Array.append:2:33: note: found candidate with type '[[Int]]'\n1 | generic struct Array {\n2 | @inlinable public mutating func append(_ newElement: __owned Element)}\n  |                                 `- note: found candidate with type '[[Int]]'\n3 | \n\nSwift.RangeReplaceableCollection.append:2:33: note: found candidate with type '[[Int]]'\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public mutating func append(_ newElement: __owned Self.Element)}\n  |                                 `- note: found candidate with type '[[Int]]'\n3 | \n\nSwift.Array.append:2:33: note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n1 | generic struct Array {\n2 | @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Sequence}\n  |                                 `- note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n3 | \n\nSwift.RangeReplaceableCollection.append:2:33: note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public mutating func append<S>(contentsOf newElements: __owned S) where S : Sequence, Self.Element == S.Element}\n  |                                 `- note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:461: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:471: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:519: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_1\/solution.swift:4:529: error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(pairs: [[Int]]) -> Int { let n = pairs.count; var permutations: [[Int]] = []; permute(pairs, 0, n - 1, &permutations); var maxLength = 0; for p in permutations { var length = 1; for i in 1..<p.count { if p[i - 1][1] <= p[i][0] { length += 1 } } maxLength = max(maxLength, length) } return maxLength }; func permute(_ nums: [[Int]], _ l: Int, _ r: Int, _ list: inout [[Int]]) { if l == r { list.append(nums) } else { for i in l...r { swap(&nums[l], &nums[i]); permute(nums, l + 1, r, &list); swap(&nums[l], &nums[i]) } } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot pass immutable value as inout argument: 'nums' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "pairs = [[1,2],[7,8],[4,5]]",
      "slug" : "maximum-length-of-pair-chain",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_2\/solution.swift:4:257: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(_ pairs: [[Int]]) -> Int { let sortedPairs = pairs.sorted { $0[1] < $1[1] }; var count = 1; var lastEnd = sortedPairs[0][1]; for i in 1..<sortedPairs.count { if sortedPairs[i][0] > lastEnd { count += 1; lastEnd = sortedPairs[i][1] } } return count }\n    |                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "pairs = [[1,2],[2,3],[3,4]]",
      "slug" : "maximum-length-of-pair-chain",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-length-of-pair-chain_2\/solution.swift:4:257: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findLongestChain(_ pairs: [[Int]]) -> Int { let sortedPairs = pairs.sorted { $0[1] < $1[1] }; var count = 1; var lastEnd = sortedPairs[0][1]; for i in 1..<sortedPairs.count { if sortedPairs[i][0] > lastEnd { count += 1; lastEnd = sortedPairs[i][1] } } return count }\n    |                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "pairs = [[1,2],[7,8],[4,5]]",
      "slug" : "maximum-length-of-pair-chain",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "7",
      "approachName" : "Kadane's Algorithm Approach",
      "approachOrder" : 2,
      "expected" : "10",
      "input" : "nums = [5,-3,5]",
      "slug" : "maximum-sum-circular-subarray",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:308: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:371: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:563: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:64: warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                `- warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "231",
      "input" : "s1 = \"sea\", s2 = \"eat\"",
      "slug" : "minimum-ascii-delete-sum-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:308: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:371: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:563: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_1\/solution.swift:4:64: warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { var result = 0; let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                `- warning: initialization of variable 'result' was never used; consider replacing with assignment to '_' or removing it [#no-usage]\n  5 | }\n  6 | \n",
      "expected" : "403",
      "input" : "s1 = \"delete\", s2 = \"leet\"",
      "slug" : "minimum-ascii-delete-sum-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:292: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:355: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:547: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "231",
      "input" : "s1 = \"sea\", s2 = \"eat\"",
      "slug" : "minimum-ascii-delete-sum-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:292: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:355: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-ascii-delete-sum-for-two-strings_2\/solution.swift:4:547: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minimumDeleteSum(_ s1: String, _ s2: String) -> Int { let arr1 = Array(s1.utf8); let arr2 = Array(s2.utf8); let m = arr1.count; let n = arr2.count; var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1); for i in 1...m { dp[i][0] = dp[i - 1][0] + Int(arr1[i - 1]); } for j in 1...n { dp[0][j] = dp[0][j - 1] + Int(arr2[j - 1]); } for i in 1...m { for j in 1...n { if arr1[i - 1] == arr2[j - 1] { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + Int(arr1[i - 1]), dp[i][j - 1] + Int(arr2[j - 1])); } } } return dp[m][n]; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "403",
      "input" : "s1 = \"delete\", s2 = \"leet\"",
      "slug" : "minimum-ascii-delete-sum-for-two-strings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_1\/solution.swift:4:344: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; var dp = Array(repeating: 0, count: n + 1); for i in 1...n { let oneDay = dp[i - 1] + costs[0]; let sevenDays = (i - 7 >= 0 ? dp[i - 7] : 0) + costs[1]; let thirtyDays = (i - 30 >= 0 ? dp[i - 30] : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n]; }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "11",
      "input" : "days = [1,4,6,7,8,20], costs = [2,7,15]",
      "slug" : "minimum-cost-for-tickets",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_1\/solution.swift:4:344: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; var dp = Array(repeating: 0, count: n + 1); for i in 1...n { let oneDay = dp[i - 1] + costs[0]; let sevenDays = (i - 7 >= 0 ? dp[i - 7] : 0) + costs[1]; let thirtyDays = (i - 30 >= 0 ? dp[i - 30] : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n]; }\n    |                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "17",
      "input" : "days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,15,40]",
      "slug" : "minimum-cost-for-tickets",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:638: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:277: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                     `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:354: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                  `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:464: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:542: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n",
      "expected" : "11",
      "input" : "days = [1,4,6,7,8,20], costs = [2,7,15]",
      "slug" : "minimum-cost-for-tickets",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:638: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:277: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                     `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:354: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                  `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:464: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-cost-for-tickets_2\/solution.swift:4:542: error: incorrect argument label in call (have 'from:', expected 'to:')\n  2 | \n  3 | class Solution {\n  4 | func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int { let n = days.count; let set = Set(days); var dp = [Int: Int](); dp[0] = 0; for i in 1...n { let iDay = days[i-1]; let oneDay = (dp[i-1] ?? 0) + costs[0]; let sevenDays = ((set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 7 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[1]; let thirtyDays = ((set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1 < i ? dp[(set.filter { $0 <= iDay - 30 }.last?.distance(from: iDay) ?? 0) + 1] ?? 0 : 0) + costs[2]; dp[i] = min(oneDay, min(sevenDays, thirtyDays)); } return dp[n] ?? 0; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: incorrect argument label in call (have 'from:', expected 'to:')\n  5 | }\n  6 | \n",
      "expected" : "17",
      "input" : "days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,15,40]",
      "slug" : "minimum-cost-for-tickets",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:20:12: error: cannot assign value of type '[Int]' to type '[[Int]]'\n 18 |         }\n 19 |         \n 20 |         dp = nextRow\n    |            |- error: cannot assign value of type '[Int]' to type '[[Int]]'\n    |            `- note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected to be equal\n 21 |     }\n 22 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:23:15: error: referencing instance method 'min()' on 'Sequence' requires that '[Int]' conform to 'Comparable'\n 21 |     }\n 22 |     \n 23 |     return dp.min() ?? 0\n    |               `- error: referencing instance method 'min()' on 'Sequence' requires that '[Int]' conform to 'Comparable'\n 24 | }\n 25 | \n\nSwift.Sequence:1:11: note: where 'Self.Element' = '[Int]'\n1 | extension Sequence where Self.Element : Comparable {\n  |           `- note: where 'Self.Element' = '[Int]'\n2 |     @warn_unqualified_access\n3 |     @inlinable public func min() -> Self.Element?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:23:15: error: cannot convert value of type '[Int]?' to expected argument type 'Int?'\n 21 |     }\n 22 |     \n 23 |     return dp.min() ?? 0\n    |               `- error: cannot convert value of type '[Int]?' to expected argument type 'Int?'\n 24 | }\n 25 | \n",
      "expected" : "13",
      "input" : "arr = [[2,1,3],[6,5,4],[7,8,9]]",
      "slug" : "minimum-falling-path-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:20:12: error: cannot assign value of type '[Int]' to type '[[Int]]'\n 18 |         }\n 19 |         \n 20 |         dp = nextRow\n    |            |- error: cannot assign value of type '[Int]' to type '[[Int]]'\n    |            `- note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected to be equal\n 21 |     }\n 22 |     \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:23:15: error: referencing instance method 'min()' on 'Sequence' requires that '[Int]' conform to 'Comparable'\n 21 |     }\n 22 |     \n 23 |     return dp.min() ?? 0\n    |               `- error: referencing instance method 'min()' on 'Sequence' requires that '[Int]' conform to 'Comparable'\n 24 | }\n 25 | \n\nSwift.Sequence:1:11: note: where 'Self.Element' = '[Int]'\n1 | extension Sequence where Self.Element : Comparable {\n  |           `- note: where 'Self.Element' = '[Int]'\n2 |     @warn_unqualified_access\n3 |     @inlinable public func min() -> Self.Element?\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-falling-path-sum_2\/solution.swift:23:15: error: cannot convert value of type '[Int]?' to expected argument type 'Int?'\n 21 |     }\n 22 |     \n 23 |     return dp.min() ?? 0\n    |               `- error: cannot convert value of type '[Int]?' to expected argument type 'Int?'\n 24 | }\n 25 | \n",
      "expected" : "-36",
      "input" : "arr = [[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]",
      "slug" : "minimum-falling-path-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ones-and-zeroes_1\/solution.swift:46:11: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 44 |     while n > 0 { \n 45 |         count += n & 1 \n 46 |         n >>= 1 \n    |           `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 47 |     } \n 48 |     return count \n",
      "expected" : "2",
      "input" : "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
      "slug" : "ones-and-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ones-and-zeroes_1\/solution.swift:46:11: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 44 |     while n > 0 { \n 45 |         count += n & 1 \n 46 |         n >>= 1 \n    |           `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 47 |     } \n 48 |     return count \n",
      "expected" : "4",
      "input" : "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
      "slug" : "ones-and-zeroes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "3",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "4",
      "input" : "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
      "slug" : "ones-and-zeroes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "6",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "m = 2, n = 2, N = 2, i = 0, j = 0",
      "slug" : "out-of-boundary-paths",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "6",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "m = 2, n = 2, N = 2, i = 0, j = 0",
      "slug" : "out-of-boundary-paths",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "2D Prefix Sum",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-2d-immutable_1\/solution.swift:247:23: error: value of type 'Solution' has no member 'sumRegion'\n245 | let arg2 = toInt(valueAt(args, 2))\n246 | let arg3 = toInt(valueAt(args, 3))\n247 | let result = solution.sumRegion(arg0, arg1, arg2, arg3)\n    |                       `- error: value of type 'Solution' has no member 'sumRegion'\n248 | let output: Any = result\n249 | print(jsonString(from: output))\n",
      "expected" : "10",
      "input" : "NumMatrix([[3,0,1],[5,6,3]]), sumRegion(0,1,1,2)",
      "slug" : "range-sum-query-2d-immutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Prefix Sum",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-sum-query-immutable_1\/solution.swift:242:23: error: value of type 'Solution' has no member 'sumRange'\n240 | let arg0 = toInt(valueAt(args, 0))\n241 | let arg1 = toInt(valueAt(args, 1))\n242 | let result = solution.sumRange(arg0, arg1)\n    |                       `- error: value of type 'Solution' has no member 'sumRange'\n243 | let output: Any = result\n244 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "NumArray([-2,0,3,-5,2,-1]), sumRange(0,2)",
      "slug" : "range-sum-query-immutable",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode)]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
      "input" : "n = 3",
      "slug" : "unique-binary-search-trees-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "[[1]]",
      "input" : "n = 1",
      "slug" : "unique-binary-search-trees-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode), Optional(solution.TreeNode)]",
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
      "input" : "n = 3",
      "slug" : "unique-binary-search-trees-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[Optional(solution.TreeNode)]",
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "[[1]]",
      "input" : "n = 1",
      "slug" : "unique-binary-search-trees-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "True",
      "input" : "s = \"(*)\"",
      "slug" : "valid-parenthesis-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "False",
      "input" : "s = \"(*)*)\"",
      "slug" : "valid-parenthesis-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Two Pointer Approach",
      "approachOrder" : 2,
      "expected" : "True",
      "input" : "s = \"(**())\"",
      "slug" : "valid-parenthesis-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Two Pointer Approach",
      "approachOrder" : 2,
      "expected" : "True",
      "input" : "s = \"(***)\"",
      "slug" : "valid-parenthesis-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:213: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:375: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "clips = [[0,2],[4,6],[8,10],[1,9]], T = 9",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:213: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:375: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "clips = [[0,4],[2,8]], T = 5",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:213: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_1\/solution.swift:4:375: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { let n = clips.count; var result = Int.max; func backtrack(_ index: Int, _ count: Int, _ current: Int) { if current >= T { result = min(result, count); return } if index == n { return } backtrack(index + 1, count, current); if clips[index][0] <= current { backtrack(index + 1, count + 1, max(current, clips[index][1])) } } backtrack(0, 0, 0); return result == Int.max ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "-1",
      "input" : "clips = [[1,2]], T = 3",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:357: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:386: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:412: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:276: error: assigning a variable to itself\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                    `- error: assigning a variable to itself\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "clips = [[0,2],[4,6],[8,10],[1,9]], T = 9",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:357: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:386: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:412: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:276: error: assigning a variable to itself\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                    `- error: assigning a variable to itself\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "clips = [[0,4],[2,8]], T = 5",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:203: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:357: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:386: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:412: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/video-stitching_2\/solution.swift:4:276: error: assigning a variable to itself\n  2 | \n  3 | class Solution {\n  4 | func videoStitching(clips: [[Int]], T: Int) -> Int { var result = 0; var last = 0; var far = 0; var i = 0; let n = clips.count; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far; while i < n { far = far; while i < n && clips[i][0] <= last { far = max(far, clips[i][1]); i += 1 } if last == far { return -1 } result += 1; last = far } return last < T ? -1 : result }\n    |                                                                                                                                                                                                                                                                                    `- error: assigning a variable to itself\n  5 | }\n  6 | \n",
      "expected" : "-1",
      "input" : "clips = [[1,2]], T = 3",
      "slug" : "video-stitching",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "10",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "7",
      "input" : "nums = [1,17,5,10,13,15,10,5,16,8]",
      "slug" : "wiggle-subsequence",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "9",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "nums = [1,2,3,4,5,6,7,8,9]",
      "slug" : "wiggle-subsequence",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "nums = [1,1,1,1,1,1,1,1,1]",
      "slug" : "wiggle-subsequence",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "3",
      "input" : "n = 3",
      "slug" : "2-keys-keyboard",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "5",
      "input" : "n = 6",
      "slug" : "2-keys-keyboard",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:210: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 2, 0, 3, 4]",
      "input" : "num = [1, 2, 0, 0], k = 34",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:210: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[4, 5, 5]",
      "input" : "num = [2, 7, 4], k = 181",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:210: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_1\/solution.swift:4:258: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var result = [Int](); var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { let sum = num[i] + k; k = sum \/ 10; result.append(sum % 10); } while k > 0 { result.append(k % 10); k \/= 10; } return result.reversed(); }\n    |                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 0, 2, 1]",
      "input" : "num = [2, 1, 5], k = 806",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:186: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 2, 0, 3, 4]",
      "input" : "num = [1, 2, 0, 0], k = 34",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:186: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[4, 5, 5]",
      "input" : "num = [2, 7, 4], k = 181",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:186: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/add-to-array-form-of-integer_2\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] { var num = num; var k = k; for i in stride(from: num.count - 1, through: 0, by: -1) { num[i] += k; k = num[i] \/ 10; num[i] %= 10; } while k > 0 { num.insert(k % 10, at: 0); k \/= 10; } return num; }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 0, 2, 1]",
      "input" : "num = [2, 1, 5], k = 806",
      "slug" : "add-to-array-form-of-integer",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "\"202\"",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "202",
      "input" : "num = 100",
      "slug" : "base-7",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"-10\"",
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "expected" : "-10",
      "input" : "num = -7",
      "slug" : "base-7",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"202\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "202",
      "input" : "num = 100",
      "slug" : "base-7",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"-10\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "-10",
      "input" : "num = -7",
      "slug" : "base-7",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"0\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "num = 0",
      "slug" : "base-7",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-arrangement-ii_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func constructArray(n: Int) -> [Int] {\n",
      "expected" : "[1, 3, 2]",
      "input" : "n = 3",
      "slug" : "beautiful-arrangement-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-arrangement-ii_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func constructArray(n: Int) -> [Int] {\n",
      "expected" : "[2, 1, 4, 3]",
      "input" : "n = 4",
      "slug" : "beautiful-arrangement-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-arrangement-ii_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func constructArray(n: Int) -> [Int] {\n",
      "expected" : "[1, 2]",
      "input" : "n = 2",
      "slug" : "beautiful-arrangement-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-arrangement-ii_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func constructArray(n: Int) -> [Int] {\n",
      "expected" : "[2, 1, 5, 4, 3]",
      "input" : "n = 5",
      "slug" : "beautiful-arrangement-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-array_1\/solution.swift:4:183: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func beautifulArray(_ n: Int) -> [Int] { let arr = Array(1...n); var result: [Int] = []; for i in arr { if result.count % 2 == 0 || (i - result.last!) % 4 != 0 { result.append(i) } } return result }\n    |                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 3, 2, 4]",
      "input" : "n = 4",
      "slug" : "beautiful-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-array_1\/solution.swift:4:183: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func beautifulArray(_ n: Int) -> [Int] { let arr = Array(1...n); var result: [Int] = []; for i in arr { if result.count % 2 == 0 || (i - result.last!) % 4 != 0 { result.append(i) } } return result }\n    |                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 3, 5, 2, 4]",
      "input" : "n = 5",
      "slug" : "beautiful-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Divide and Conquer",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-array_2\/solution.swift:4:66: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func beautifulArray(_ n: Int) -> [Int] { if n == 1 { return [1] } let odds = beautifulArray(n \/ 2); let evens = beautifulArray((n + 1) \/ 2); return odds + evens.map { $0 * 2 } }\n    |                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 3, 2]",
      "input" : "n = 3",
      "slug" : "beautiful-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Divide and Conquer",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/beautiful-array_2\/solution.swift:4:66: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func beautifulArray(_ n: Int) -> [Int] { if n == 1 { return [1] } let odds = beautifulArray(n \/ 2); let evens = beautifulArray((n + 1) \/ 2); return odds + evens.map { $0 * 2 } }\n    |                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[1, 3, 5, 2, 4, 6]",
      "input" : "n = 6",
      "slug" : "beautiful-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func brokenCalc(_ X: Int, _ Y: Int) -> Int {\n",
      "expected" : "2",
      "input" : "X = 2, Y = 3",
      "slug" : "broken-calculator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func brokenCalc(_ X: Int, _ Y: Int) -> Int {\n",
      "expected" : "2",
      "input" : "X = 5, Y = 8",
      "slug" : "broken-calculator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func brokenCalc(_ X: Int, _ Y: Int) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:15:22: error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 13 |            while Y > X {\n 14 |                if Y % 2 == 0 {\n 15 |                    Y \/= 2\n    |                      `- error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 16 |                } else {\n 17 |                    Y += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:17:22: error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 15 |                    Y \/= 2\n 16 |                } else {\n 17 |                    Y += 1\n    |                      `- error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 18 |                }\n 19 |                count += 1\n",
      "expected" : "2",
      "input" : "X = 2, Y = 3",
      "slug" : "broken-calculator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Greedy Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func brokenCalc(_ X: Int, _ Y: Int) -> Int {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:15:22: error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 13 |            while Y > X {\n 14 |                if Y % 2 == 0 {\n 15 |                    Y \/= 2\n    |                      `- error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 16 |                } else {\n 17 |                    Y += 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/broken-calculator_2\/solution.swift:17:22: error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 15 |                    Y \/= 2\n 16 |                } else {\n 17 |                    Y += 1\n    |                      `- error: left side of mutating operator isn't mutable: 'Y' is a 'let' constant\n 18 |                }\n 19 |                count += 1\n",
      "expected" : "1023",
      "input" : "X = 1024, Y = 1",
      "slug" : "broken-calculator",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulb-switcher_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func bulbSwitch(_ n: Int) -> Int {\n",
      "expected" : "2",
      "input" : "n = 4",
      "slug" : "bulb-switcher",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bulb-switcher_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func bulbSwitch(_ n: Int) -> Int {\n",
      "expected" : "10",
      "input" : "n = 100",
      "slug" : "bulb-switcher",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "4",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "n = 1, presses = 1",
      "slug" : "bulb-switcher-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "n = 2, presses = 1",
      "slug" : "bulb-switcher-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Optimized Bit Manipulation",
      "approachOrder" : 2,
      "expected" : "4",
      "input" : "n = 3, presses = 1",
      "slug" : "bulb-switcher-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Optimized Bit Manipulation",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "n = 4, presses = 2",
      "slug" : "bulb-switcher-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "maxChoosableInteger = 10, desiredTotal = 0",
      "slug" : "can-i-win",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "false",
      "input" : "maxChoosableInteger = 10, desiredTotal = 40",
      "slug" : "can-i-win",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Memoization and Bitmasking",
      "approachOrder" : 2,
      "expected" : "false",
      "input" : "maxChoosableInteger = 10, desiredTotal = 40",
      "slug" : "can-i-win",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clumsy-factorial_1\/solution.swift:7:22: error: cannot convert value of type 'Int' to specified type 'Int64'\n  5 |     var res: Int64 = Int64(N)\n  6 |     var idx: Int = 0\n  7 |     var num: Int64 = N\n    |                      `- error: cannot convert value of type 'Int' to specified type 'Int64'\n  8 |     var operators: [String] = [\"]\", \"+\", \"-\", \"*\"]\n  9 |     while num > 1 {\n",
      "expected" : "7",
      "input" : "N = 4",
      "slug" : "clumsy-factorial",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/clumsy-factorial_1\/solution.swift:7:22: error: cannot convert value of type 'Int' to specified type 'Int64'\n  5 |     var res: Int64 = Int64(N)\n  6 |     var idx: Int = 0\n  7 |     var num: Int64 = N\n    |                      `- error: cannot convert value of type 'Int' to specified type 'Int64'\n  8 |     var operators: [String] = [\"]\", \"+\", \"-\", \"*\"]\n  9 |     while num > 1 {\n",
      "expected" : "12",
      "input" : "N = 10",
      "slug" : "clumsy-factorial",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Stack",
      "approachOrder" : 2,
      "expected" : "7",
      "input" : "N = 4",
      "slug" : "clumsy-factorial",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "-26",
      "approachName" : "Stack",
      "approachOrder" : 2,
      "expected" : "12",
      "input" : "N = 10",
      "slug" : "clumsy-factorial",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"(real)+(imag)i\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "0+2i",
      "input" : "num1 = \"1+1i\", num2 = \"1+1i\"",
      "slug" : "complex-number-multiplication",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "11-2i",
      "input" : "num1 = \"1+2i\", num2 = \"3-4i\"",
      "slug" : "complex-number-multiplication",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"(real)+(imag)i\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "-10+11i",
      "input" : "num1 = \"2+3i\", num2 = \"1+4i\"",
      "slug" : "complex-number-multiplication",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "2+0i",
      "input" : "num1 = \"1-1i\", num2 = \"1+1i\"",
      "slug" : "complex-number-multiplication",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[1,37]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[37,1]",
      "input" : "area = 37",
      "slug" : "construct-the-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_1\/solution.swift:4:188: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; for i in 0..<n { var sum = 0; for j in i..<n { sum += nums[j]; if sum % k == 0 && sum != 0 { return true } } } return false }\n    |                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [23,2,4,6,7], k = 6",
      "slug" : "continuous-subarray-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_1\/solution.swift:4:188: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; for i in 0..<n { var sum = 0; for j in i..<n { sum += nums[j]; if sum % k == 0 && sum != 0 { return true } } } return false }\n    |                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [23,2,6,4,7], k = 6",
      "slug" : "continuous-subarray-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Prefix Sum with Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_2\/solution.swift:4:256: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; var prefixSum = 0; var hashTable: [Int: Int] = [0: -1]; for i in 0..<n { prefixSum += nums[i]; if k != 0 && hashTable.contains(where: { $0.key == prefixSum % k }) { return true } if hashTable[prefixSum % k] == nil { hashTable[prefixSum % k] = i } } return false }\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_2\/solution.swift:4:326: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; var prefixSum = 0; var hashTable: [Int: Int] = [0: -1]; for i in 0..<n { prefixSum += nums[i]; if k != 0 && hashTable.contains(where: { $0.key == prefixSum % k }) { return true } if hashTable[prefixSum % k] == nil { hashTable[prefixSum % k] = i } } return false }\n    |                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "nums = [23,2,4,6,7], k = 13",
      "slug" : "continuous-subarray-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Prefix Sum with Hash Table",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_2\/solution.swift:4:256: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; var prefixSum = 0; var hashTable: [Int: Int] = [0: -1]; for i in 0..<n { prefixSum += nums[i]; if k != 0 && hashTable.contains(where: { $0.key == prefixSum % k }) { return true } if hashTable[prefixSum % k] == nil { hashTable[prefixSum % k] = i } } return false }\n    |                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/continuous-subarray-sum_2\/solution.swift:4:326: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; var prefixSum = 0; var hashTable: [Int: Int] = [0: -1]; for i in 0..<n { prefixSum += nums[i]; if k != 0 && hashTable.contains(where: { $0.key == prefixSum % k }) { return true } if hashTable[prefixSum % k] == nil { hashTable[prefixSum % k] = i } } return false }\n    |                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "nums = [23,2,6,4,7], k = 6",
      "slug" : "continuous-subarray-sum",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:60: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:82: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:129: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:188: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:198: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:235: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:139: error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                           `- error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: where 'T' = 'Character'\n1 | struct String {\n2 | public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger}\n  |        `- note: where 'T' = 'Character'\n3 | \n",
      "expected" : "a",
      "input" : "num = 10",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:60: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:82: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:129: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:188: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:198: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:235: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:139: error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                           `- error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: where 'T' = 'Character'\n1 | struct String {\n2 | public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger}\n  |        `- note: where 'T' = 'Character'\n3 | \n",
      "expected" : "f",
      "input" : "num = 15",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:60: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:82: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:99: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:129: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:188: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:198: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:235: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_1\/solution.swift:4:139: error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n \/= 16 } if num < 0 { result = \"-\" + result } return result }\n    |                                                                                                                                           `- error: initializer 'init(_:radix:uppercase:)' requires that 'Character' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: where 'T' = 'Character'\n1 | struct String {\n2 | public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger}\n  |        `- note: where 'T' = 'Character'\n3 | \n",
      "expected" : "17",
      "input" : "num = 23",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:50: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:75: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:109: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "a",
      "input" : "num = 10",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:50: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:75: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:109: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "f",
      "input" : "num = 15",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:50: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:75: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-a-number-to-hexadecimal_2\/solution.swift:4:109: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }\n    |                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "17",
      "input" : "num = 23",
      "slug" : "convert-a-number-to-hexadecimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_1\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n \/= -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "10",
      "input" : "N = 2",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_1\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n \/= -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "11",
      "input" : "N = 3",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_1\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n \/= -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "100",
      "input" : "N = 4",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_2\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n = (n - remainder) \/ -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "101",
      "input" : "N = 5",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_2\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n = (n - remainder) \/ -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "110",
      "input" : "N = 6",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/convert-to-base-2_2\/solution.swift:11:7: error: cannot assign to value: 'remainder' is a 'let' constant\n  6 |   var res = \"\" \n  7 |   while n != 0 { \n  8 |     let remainder = n % -2 \n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     n = (n - remainder) \/ -2 \n 10 |     if remainder < 0 { \n 11 |       remainder = 1 \n    |       `- error: cannot assign to value: 'remainder' is a 'let' constant\n 12 |       n += 1 \n 13 |     } \n",
      "expected" : "111",
      "input" : "N = 7",
      "slug" : "convert-to-base-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:233: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 2",
      "slug" : "count-numbers-with-unique-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:233: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:266: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_1\/solution.swift:4:294: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { var count = 0; for i in 0...n { var num = i; var unique = true; var seen: [Int: Bool] = [:]; while num > 0 { let digit = num % 10; if seen[digit] != nil { unique = false; break; } seen[digit] = true; num \/= 10; } if unique { count += 1; } } return count }\n    |                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "n = 3",
      "slug" : "count-numbers-with-unique-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Mathematical Optimization",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:156: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:277: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 2",
      "slug" : "count-numbers-with-unique-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Mathematical Optimization",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:156: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-numbers-with-unique-digits_2\/solution.swift:4:277: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countNumbersWithUniqueDigits(_ n: Int) -> Int { let length = String(n).count; var count = 0; for i in 0...length { if i == 0 { count += 1; continue; } let available = 9; let choose = i - 1; var temp = 1; for j in 0...choose-1 { temp *= (available - j); } count += temp; } return count }\n    |                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "10",
      "input" : "n = 10",
      "slug" : "count-numbers-with-unique-digits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:36: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:60: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:11:42: error: missing argument label 'expression:' in call\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n    |                                          `- error: missing argument label 'expression:' in call\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n 13 |             for num1 in left {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:12:43: error: missing argument label 'expression:' in call\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n    |                                           `- error: missing argument label 'expression:' in call\n 13 |             for num1 in left {\n 14 |                 for num2 in right {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:15:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |             for num1 in left {\n 14 |                 for num2 in right {\n 15 |                     if expression[i] == \"+\" {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:16:44: error: cannot convert value of type 'String' to expected argument type 'Int'\n 14 |                 for num2 in right {\n 15 |                     if expression[i] == \"+\" {\n 16 |                         result.append(num1 + num2)\n    |                                            `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:17:31: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                     if expression[i] == \"+\" {\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n    |                               `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:18:44: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n    |                                            `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 19 |                     } else if expression[i] == \"*\" {\n 20 |                         result.append(num1 * num2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:19:31: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n    |                               `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                         result.append(num1 * num2)\n 21 |                     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:20:44: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n 20 |                         result.append(num1 * num2)\n    |                                            `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 21 |                     }\n 22 |                 }\n",
      "expected" : "[2,0]",
      "input" : "2-1-1",
      "slug" : "different-ways-to-add-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:36: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                    `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:10:60: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |     var result: [Int] = []\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:11:42: error: missing argument label 'expression:' in call\n  9 |     for i in 0..<expression.count {\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n    |                                          `- error: missing argument label 'expression:' in call\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n 13 |             for num1 in left {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:12:43: error: missing argument label 'expression:' in call\n 10 |         if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n 11 |             let left = diffWaysToCompute(String(expression.prefix(i)))\n 12 |             let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n    |                                           `- error: missing argument label 'expression:' in call\n 13 |             for num1 in left {\n 14 |                 for num2 in right {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:15:24: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |             for num1 in left {\n 14 |                 for num2 in right {\n 15 |                     if expression[i] == \"+\" {\n    |                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:16:44: error: cannot convert value of type 'String' to expected argument type 'Int'\n 14 |                 for num2 in right {\n 15 |                     if expression[i] == \"+\" {\n 16 |                         result.append(num1 + num2)\n    |                                            `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:17:31: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                     if expression[i] == \"+\" {\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n    |                               `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:18:44: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 16 |                         result.append(num1 + num2)\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n    |                                            `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 19 |                     } else if expression[i] == \"*\" {\n 20 |                         result.append(num1 * num2)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:19:31: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 17 |                     } else if expression[i] == \"-\" {\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n    |                               `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                         result.append(num1 * num2)\n 21 |                     }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_1\/solution.swift:20:44: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 18 |                         result.append(num1 - num2)\n 19 |                     } else if expression[i] == \"*\" {\n 20 |                         result.append(num1 * num2)\n    |                                            `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 21 |                     }\n 22 |                 }\n",
      "expected" : "[-34,-10,-14,-10,10]",
      "input" : "2*3-4*5",
      "slug" : "different-ways-to-add-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:40: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:64: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:20:28: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                 for num1 in left {\n 19 |                     for num2 in right {\n 20 |                         if expression[i] == \"+\" {\n    |                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                             result.append(num1 + num2)\n 22 |                         } else if expression[i] == \"-\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:22:35: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                         if expression[i] == \"+\" {\n 21 |                             result.append(num1 + num2)\n 22 |                         } else if expression[i] == \"-\" {\n    |                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                             result.append(num1 - num2)\n 24 |                         } else if expression[i] == \"*\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:24:35: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 |                         } else if expression[i] == \"-\" {\n 23 |                             result.append(num1 - num2)\n 24 |                         } else if expression[i] == \"*\" {\n    |                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                             result.append(num1 * num2)\n 26 |                         }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "[2,0]",
      "input" : "2-1-1",
      "slug" : "different-ways-to-add-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:40: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:15:64: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |         var result: [Int] = []\n 14 |         for i in 0..<expression.count {\n 15 |             if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n    |                                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 16 |                 let left = dp(String(expression.prefix(i)))\n 17 |                 let right = dp(String(expression.suffix(expression.count - i - 1)))\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:20:28: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                 for num1 in left {\n 19 |                     for num2 in right {\n 20 |                         if expression[i] == \"+\" {\n    |                            `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                             result.append(num1 + num2)\n 22 |                         } else if expression[i] == \"-\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:22:35: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 20 |                         if expression[i] == \"+\" {\n 21 |                             result.append(num1 + num2)\n 22 |                         } else if expression[i] == \"-\" {\n    |                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 23 |                             result.append(num1 - num2)\n 24 |                         } else if expression[i] == \"*\" {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/different-ways-to-add-parentheses_2\/solution.swift:24:35: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 22 |                         } else if expression[i] == \"-\" {\n 23 |                             result.append(num1 - num2)\n 24 |                         } else if expression[i] == \"*\" {\n    |                                   `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 25 |                             result.append(num1 * num2)\n 26 |                         }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "[-34,-10,-14,-10,10]",
      "input" : "2*3-4*5",
      "slug" : "different-ways-to-add-parentheses",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:84: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:104: warning: variable 'isNegative' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                                        `- warning: variable 'isNegative' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:187: warning: variable 'absDivisor' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                                                                                                                           `- warning: variable 'absDivisor' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "dividend = 10, divisor = 3",
      "slug" : "divide-two-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:84: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:104: warning: variable 'isNegative' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                                        `- warning: variable 'isNegative' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/divide-two-integers_1\/solution.swift:4:187: warning: variable 'absDivisor' was never mutated; consider changing to 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func divide(_ dividend: Int, _ divisor: Int) -> Int { if dividend == 0 { return 0 } var count = 0; var isNegative = (dividend < 0) == (divisor < 0); var absDividend = abs(dividend); var absDivisor = abs(divisor); while absDividend >= absDivisor { absDividend -= absDivisor; count += 1; }; if !isNegative && count > Int32.max { return Int(Int32.max) }; if isNegative && count > Int32.max { return Int(Int32.min) }; return isNegative ? -count : count; }\n    |                                                                                                                                                                                           `- warning: variable 'absDivisor' was never mutated; consider changing to 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "-2",
      "input" : "dividend = -7, divisor = 3",
      "slug" : "divide-two-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "True",
      "input" : "N = 2",
      "slug" : "divisor-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "False",
      "input" : "N = 3",
      "slug" : "divisor-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "True",
      "input" : "N = 2",
      "slug" : "divisor-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "False",
      "input" : "N = 3",
      "slug" : "divisor-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_1\/solution.swift:4:179: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_1\/solution.swift:4:227: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 5",
      "slug" : "elimination-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_1\/solution.swift:4:179: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_1\/solution.swift:4:227: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "6",
      "input" : "n = 9",
      "slug" : "elimination-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Mathematical Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_2\/solution.swift:4:179: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_2\/solution.swift:4:227: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "n = 3",
      "slug" : "elimination-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Mathematical Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_2\/solution.swift:4:179: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/elimination-game_2\/solution.swift:4:227: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func lastRemaining(n: Int) -> Int { var head = 1; var remaining = n; var isForward = true; var step = 1; while remaining > 1 { if isForward || remaining % 2 == 1 { head += step } step *= 2; remaining \/= 2; isForward.toggle() } return head }\n    |                                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "n = 10",
      "slug" : "elimination-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/escape-the-ghosts_1\/solution.swift:3:223: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1]; for ghost in ghosts { if abs(ghost[0] - tx) + abs(ghost[1] - ty) <= abs(tx) + abs(ty) { return false; } } return true; } }\n    |                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "True",
      "input" : "ghosts = [[1,0],[0,3]], target = [0,1]",
      "slug" : "escape-the-ghosts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/escape-the-ghosts_1\/solution.swift:3:223: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1]; for ghost in ghosts { if abs(ghost[0] - tx) + abs(ghost[1] - ty) <= abs(tx) + abs(ty) { return false; } } return true; } }\n    |                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "False",
      "input" : "ghosts = [[1,0]], target = [2,0]",
      "slug" : "escape-the-ghosts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/escape-the-ghosts_2\/solution.swift:3:321: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1], px = 0, py = 0; let playerDistance = abs(tx - px) + abs(ty - py); for ghost in ghosts { let ghostDistance = abs(ghost[0] - tx) + abs(ghost[1] - ty); if ghostDistance <= playerDistance { return false; } } return true; } }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "True",
      "input" : "ghosts = [[-1,0],[0,1],[1,0],[0,-1]], target = [0,0]",
      "slug" : "escape-the-ghosts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/escape-the-ghosts_2\/solution.swift:3:321: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1], px = 0, py = 0; let playerDistance = abs(tx - px) + abs(ty - py); for ghost in ghosts { let ghostDistance = abs(ghost[0] - tx) + abs(ghost[1] - ty); if ghostDistance <= playerDistance { return false; } } return true; } }\n    |                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n",
      "expected" : "True",
      "input" : "ghosts = [[1,0],[0,3]], target = [0,1]",
      "slug" : "escape-the-ghosts",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-number_2\/solution.swift:9:31: error: cannot convert value of type 'Double' to expected argument type 'Int'\n  7 |     for (index, char) in sArray.enumerated() {\n  8 |         let charValue = Int(String(char).unicodeScalars.first!.value) - 64\n  9 |         result += charValue * pow(26, Double(s.count - index - 1))\n    |                               `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |     }\n 11 |     return Int(result)\n",
      "expected" : "27",
      "input" : "s = \"AA\"",
      "slug" : "excel-sheet-column-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-number_2\/solution.swift:9:31: error: cannot convert value of type 'Double' to expected argument type 'Int'\n  7 |     for (index, char) in sArray.enumerated() {\n  8 |         let charValue = Int(String(char).unicodeScalars.first!.value) - 64\n  9 |         result += charValue * pow(26, Double(s.count - index - 1))\n    |                               `- error: cannot convert value of type 'Double' to expected argument type 'Int'\n 10 |     }\n 11 |     return Int(result)\n",
      "expected" : "52",
      "input" : "s = \"AZ\"",
      "slug" : "excel-sheet-column-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:56: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                        `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:131: error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                                                                                                   |- error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n    |                                                                                                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  5 | }\n  6 | \n",
      "expected" : "A",
      "input" : "n = 1",
      "slug" : "excel-sheet-column-title",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:56: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                        `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_1\/solution.swift:4:131: error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) \/ 26; } return result }\n    |                                                                                                                                   |- error: value of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n    |                                                                                                                                   |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                                                                                                   `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n  5 | }\n  6 | \n",
      "expected" : "AB",
      "input" : "n = 28",
      "slug" : "excel-sheet-column-title",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:69: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                     `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:114: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                  `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:269: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:220: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                                                                                                                            `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:19: note: found candidate with type 'Unicode.Scalar?'\n1 | struct String {\n2 | @inlinable public init(_ scalar: Unicode.Scalar)}\n  |                   `- note: found candidate with type 'Unicode.Scalar?'\n3 | \n\nSwift.String.init:2:19: note: found candidate with type 'Unicode.Scalar?'\n1 | struct String {\n2 | @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible}\n  |                   `- note: found candidate with type 'Unicode.Scalar?'\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "AZ",
      "input" : "n = 52",
      "slug" : "excel-sheet-column-title",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:69: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                     `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:114: error: single-quoted string literal found, use '\"'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                  `- error: single-quoted string literal found, use '\"'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:269: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/excel-sheet-column-title_2\/solution.swift:4:220: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func convertToTitle(_ n: Int) -> String { guard n > 0 else { return '' }; let base = 26; var n = n; var result = ''; while n > 0 { let remainder = (n - 1) % base; let character = UnicodeScalar(65 + remainder); result = String(character) + result; n = (n - 1) \/ base; } return result }\n    |                                                                                                                                                                                                                            `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:19: note: found candidate with type 'Unicode.Scalar?'\n1 | struct String {\n2 | @inlinable public init(_ scalar: Unicode.Scalar)}\n  |                   `- note: found candidate with type 'Unicode.Scalar?'\n3 | \n\nSwift.String.init:2:19: note: found candidate with type 'Unicode.Scalar?'\n1 | struct String {\n2 | @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible}\n  |                   `- note: found candidate with type 'Unicode.Scalar?'\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "ZY",
      "input" : "n = 701",
      "slug" : "excel-sheet-column-title",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "1",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "0",
      "input" : "3",
      "slug" : "factorial-trailing-zeroes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "2",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "5",
      "slug" : "factorial-trailing-zeroes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\"]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[\"1\", \"2\", \"Fizz\"]",
      "input" : "n = 3",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "input" : "n = 5",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
      "input" : "n = 15",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\"]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[\"1\", \"2\", \"Fizz\"]",
      "input" : "n = 3",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
      "input" : "n = 5",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
      "input" : "n = 15",
      "slug" : "fizz-buzz",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:10:40: error: single-quoted string literal found, use '\"'\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                                        `- error: single-quoted string literal found, use '\"'\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:12:47: error: single-quoted string literal found, use '\"'\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                                               `- error: single-quoted string literal found, use '\"'\n 13 |                        i -= 1\n 14 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:34:35: error: single-quoted string literal found, use '\"'\n 32 |                    B \/= g\n 33 |                }\n 34 |                return String(A) + '\/' + String(B)\n    |                                   `- error: single-quoted string literal found, use '\"'\n 35 |            }\n 36 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:12:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        i -= 1\n 14 |                    }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:17:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                    i += 1\n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n 19 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:18:67: error: no exact matches in call to subscript \n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n    |                                                                   `- error: no exact matches in call to subscript \n 19 |                        i += 1\n 20 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:23:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                    i += 1\n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n 25 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:24:71: error: no exact matches in call to subscript \n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n    |                                                                       `- error: no exact matches in call to subscript \n 25 |                        i += 1\n 26 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n",
      "expected" : "8\/3",
      "input" : "1\/2+1\/2+1\/3",
      "slug" : "fraction-addition-and-subtraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:10:40: error: single-quoted string literal found, use '\"'\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                                        `- error: single-quoted string literal found, use '\"'\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:12:47: error: single-quoted string literal found, use '\"'\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                                               `- error: single-quoted string literal found, use '\"'\n 13 |                        i -= 1\n 14 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:34:35: error: single-quoted string literal found, use '\"'\n 32 |                    B \/= g\n 33 |                }\n 34 |                return String(A) + '\/' + String(B)\n    |                                   `- error: single-quoted string literal found, use '\"'\n 35 |            }\n 36 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:12:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        i -= 1\n 14 |                    }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:17:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                    i += 1\n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n 19 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:18:67: error: no exact matches in call to subscript \n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n    |                                                                   `- error: no exact matches in call to subscript \n 19 |                        i += 1\n 20 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:23:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                    i += 1\n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n 25 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_1\/solution.swift:24:71: error: no exact matches in call to subscript \n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n    |                                                                       `- error: no exact matches in call to subscript \n 25 |                        i += 1\n 26 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n",
      "expected" : "1\/3",
      "input" : "-1\/2+1\/2+1\/3",
      "slug" : "fraction-addition-and-subtraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:40: error: single-quoted string literal found, use '\"'\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                                        `- error: single-quoted string literal found, use '\"'\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:47: error: single-quoted string literal found, use '\"'\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                                               `- error: single-quoted string literal found, use '\"'\n 13 |                        i -= 1\n 14 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:34:35: error: single-quoted string literal found, use '\"'\n 32 |                    B \/= g\n 33 |                }\n 34 |                return String(A) + '\/' + String(B)\n    |                                   `- error: single-quoted string literal found, use '\"'\n 35 |            }\n 36 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        i -= 1\n 14 |                    }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:17:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                    i += 1\n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n 19 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:18:67: error: no exact matches in call to subscript \n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n    |                                                                   `- error: no exact matches in call to subscript \n 19 |                        i += 1\n 20 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:23:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                    i += 1\n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n 25 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:24:71: error: no exact matches in call to subscript \n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n    |                                                                       `- error: no exact matches in call to subscript \n 25 |                        i += 1\n 26 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n",
      "expected" : "8\/3",
      "input" : "1\/2+1\/2+1\/3",
      "slug" : "fraction-addition-and-subtraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:40: error: single-quoted string literal found, use '\"'\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                                        `- error: single-quoted string literal found, use '\"'\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:47: error: single-quoted string literal found, use '\"'\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                                               `- error: single-quoted string literal found, use '\"'\n 13 |                        i -= 1\n 14 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:34:35: error: single-quoted string literal found, use '\"'\n 32 |                    B \/= g\n 33 |                }\n 34 |                return String(A) + '\/' + String(B)\n    |                                   `- error: single-quoted string literal found, use '\"'\n 35 |            }\n 36 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        i -= 1\n 14 |                    }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:17:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                    i += 1\n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n 19 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:18:67: error: no exact matches in call to subscript \n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n    |                                                                   `- error: no exact matches in call to subscript \n 19 |                        i += 1\n 20 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:23:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                    i += 1\n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n 25 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:24:71: error: no exact matches in call to subscript \n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n    |                                                                       `- error: no exact matches in call to subscript \n 25 |                        i += 1\n 26 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n",
      "expected" : "1\/3",
      "input" : "-1\/2+1\/2+1\/3",
      "slug" : "fraction-addition-and-subtraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:40: error: single-quoted string literal found, use '\"'\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                                        `- error: single-quoted string literal found, use '\"'\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:47: error: single-quoted string literal found, use '\"'\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                                               `- error: single-quoted string literal found, use '\"'\n 13 |                        i -= 1\n 14 |                    }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:34:35: error: single-quoted string literal found, use '\"'\n 32 |                    B \/= g\n 33 |                }\n 34 |                return String(A) + '\/' + String(B)\n    |                                   `- error: single-quoted string literal found, use '\"'\n 35 |            }\n 36 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:10:23: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |                while i < expression.count {\n  9 |                    var sign = 1\n 10 |                    if expression[i] == '-' {\n    |                       `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:12:30: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 10 |                    if expression[i] == '-' {\n 11 |                        sign = -1\n 12 |                    } else if expression[i] != '+' {\n    |                              `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 13 |                        i -= 1\n 14 |                    }\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:17:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 15 |                    i += 1\n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n 19 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:18:67: error: no exact matches in call to subscript \n 16 |                    var numerator = 0\n 17 |                    while i < expression.count, expression[i].isNumber {\n 18 |                        numerator = numerator * 10 + Int(expression[i])!\n    |                                                                   `- error: no exact matches in call to subscript \n 19 |                        i += 1\n 20 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:23:48: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 21 |                    i += 1\n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n    |                                                `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n 25 |                        i += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-addition-and-subtraction_2\/solution.swift:24:71: error: no exact matches in call to subscript \n 22 |                    var denominator = 0\n 23 |                    while i < expression.count, expression[i].isNumber {\n 24 |                        denominator = denominator * 10 + Int(expression[i])!\n    |                                                                       `- error: no exact matches in call to subscript \n 25 |                        i += 1\n 26 |                    }\n\nSwift.String.subscript:3:10: note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n1 | struct String {\n2 | @available(swift 4)\n3 |   public subscript(r: Range<String.Index>) -> Substring { get }}\n  |          `- note: candidate expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n4 | \n\nSwift.Collection.subscript:2:19: note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n1 | protocol Collection {\n2 | @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }}\n  |                   `- note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n3 | \n",
      "expected" : "-1\/6",
      "input" : "1\/3-1\/2",
      "slug" : "fraction-addition-and-subtraction",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:490: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:530: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:538: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:568: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:598: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:631: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:665: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:696: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:726: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:753: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:727: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.5",
      "input" : "numerator = 1, denominator = 2",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:490: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:530: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:538: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:568: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:598: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:631: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:665: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:696: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:726: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:753: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:727: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.(6)",
      "input" : "numerator = 2, denominator = 3",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:490: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:530: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:538: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:568: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:598: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:631: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:665: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:696: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:726: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:753: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:727: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.(4)",
      "input" : "numerator = 4, denominator = 9",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:490: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:530: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:538: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:568: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:598: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:631: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:665: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:696: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:726: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:753: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_1\/solution.swift:4:727: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.1(6)",
      "input" : "numerator = 1, denominator = 6",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 3
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:497: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:528: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:582: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:612: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:646: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:680: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:711: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:738: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:780: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:712: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.5",
      "input" : "numerator = 1, denominator = 2",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:497: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:528: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:582: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:612: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:646: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:680: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:711: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:738: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:780: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:712: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.(6)",
      "input" : "numerator = 2, denominator = 3",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:497: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:528: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:582: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:612: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:646: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:680: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:711: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:738: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:780: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:712: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.(4)",
      "input" : "numerator = 4, denominator = 9",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:106: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:122: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:180: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:205: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:232: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:260: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:286: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:322: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:362: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:497: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:528: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:543: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:551: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:582: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:612: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:646: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:680: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:711: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:738: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:780: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/fraction-to-recurring-decimal_2\/solution.swift:4:712: error: cannot assign to value: 'remainder' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num \/ den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple \/ den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }\n    |                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `- error: cannot assign to value: 'remainder' is a 'let' constant\n    |                                                                                                                                                                                                                                                                     `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n",
      "expected" : "0.1(6)",
      "input" : "numerator = 1, denominator = 6",
      "slug" : "fraction-to-recurring-decimal",
      "status" : "COMPILE_ERROR",
      "testIndex" : 3
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:30:18: error: empty collection literal requires an explicit type\n 28 | \n 29 | \/\/ FocusApp LeetCode Runner\n 30 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 31 |     func parseQuotedString(_ input: String) -> String? {\n 32 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:246:24: error: missing arguments for parameters #1, #2, #3 in call\n  9 |     let y_center: Double\n 10 | \n 11 |     init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n    |     `- note: 'init(_:_:_:)' declared here\n 12 |         self.radius = radius\n 13 |         self.x_center = x_center\n    :\n244 | let args = parseArgs(from: input, expectedCount: 0)\n245 | let hasInput = !args.isEmpty\n246 | let solution = Solution()\n    |                        `- error: missing arguments for parameters #1, #2, #3 in call\n247 | \n248 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:99:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 97 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 98 |         guard !trimmed.isEmpty else { return [] }\n 99 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n100 |         if !keyValues.isEmpty {\n101 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0.5, 0.3]",
      "input" : "Solution(1.0, 0.0, 0.0)",
      "slug" : "generate-random-point-in-a-circle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:30:18: error: empty collection literal requires an explicit type\n 28 | \n 29 | \/\/ FocusApp LeetCode Runner\n 30 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 31 |     func parseQuotedString(_ input: String) -> String? {\n 32 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:246:24: error: missing arguments for parameters #1, #2, #3 in call\n  9 |     let y_center: Double\n 10 | \n 11 |     init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n    |     `- note: 'init(_:_:_:)' declared here\n 12 |         self.radius = radius\n 13 |         self.x_center = x_center\n    :\n244 | let args = parseArgs(from: input, expectedCount: 0)\n245 | let hasInput = !args.isEmpty\n246 | let solution = Solution()\n    |                        `- error: missing arguments for parameters #1, #2, #3 in call\n247 | \n248 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_1\/solution.swift:99:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 97 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 98 |         guard !trimmed.isEmpty else { return [] }\n 99 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n100 |         if !keyValues.isEmpty {\n101 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[9.7, 19.3]",
      "input" : "Solution(5.0, 10.0, 20.0)",
      "slug" : "generate-random-point-in-a-circle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:28:18: error: empty collection literal requires an explicit type\n 26 | \n 27 | \/\/ FocusApp LeetCode Runner\n 28 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 29 |     func parseQuotedString(_ input: String) -> String? {\n 30 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:244:24: error: missing arguments for parameters #1, #2, #3 in call\n  9 |     let y_center: Double\n 10 | \n 11 |     init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n    |     `- note: 'init(_:_:_:)' declared here\n 12 |         self.radius = radius\n 13 |         self.x_center = x_center\n    :\n242 | let args = parseArgs(from: input, expectedCount: 0)\n243 | let hasInput = !args.isEmpty\n244 | let solution = Solution()\n    |                        `- error: missing arguments for parameters #1, #2, #3 in call\n245 | \n246 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:97:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 95 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 96 |         guard !trimmed.isEmpty else { return [] }\n 97 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 98 |         if !keyValues.isEmpty {\n 99 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0.2, 0.8]",
      "input" : "Solution(1.0, 0.0, 0.0)",
      "slug" : "generate-random-point-in-a-circle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:28:18: error: empty collection literal requires an explicit type\n 26 | \n 27 | \/\/ FocusApp LeetCode Runner\n 28 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 29 |     func parseQuotedString(_ input: String) -> String? {\n 30 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:244:24: error: missing arguments for parameters #1, #2, #3 in call\n  9 |     let y_center: Double\n 10 | \n 11 |     init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n    |     `- note: 'init(_:_:_:)' declared here\n 12 |         self.radius = radius\n 13 |         self.x_center = x_center\n    :\n242 | let args = parseArgs(from: input, expectedCount: 0)\n243 | let hasInput = !args.isEmpty\n244 | let solution = Solution()\n    |                        `- error: missing arguments for parameters #1, #2, #3 in call\n245 | \n246 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/generate-random-point-in-a-circle_2\/solution.swift:97:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 95 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 96 |         guard !trimmed.isEmpty else { return [] }\n 97 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 98 |         if !keyValues.isEmpty {\n 99 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[18.4, 28.7]",
      "input" : "Solution(10.0, 20.0, 30.0)",
      "slug" : "generate-random-point-in-a-circle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:1: error: expected 'func' keyword in instance method declaration\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    | `- error: expected 'func' keyword in instance method declaration\n 14 | }\n 15 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:7: error: expected parameter name followed by ':'\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    |       `- error: expected parameter name followed by ':'\n 14 | }\n 15 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:1: error: expected '{' in body of function declaration\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    | `- error: expected '{' in body of function declaration\n 14 | }\n 15 | \n",
      "expected" : "true",
      "input" : "nums = [1,0,2]",
      "slug" : "global-and-local-inversions",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:1: error: expected 'func' keyword in instance method declaration\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    | `- error: expected 'func' keyword in instance method declaration\n 14 | }\n 15 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:7: error: expected parameter name followed by ':'\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    |       `- error: expected parameter name followed by ':'\n 14 | }\n 15 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/global-and-local-inversions_1\/solution.swift:13:1: error: expected '{' in body of function declaration\n 11 |     return true\n 12 | }\n 13 | print(isIdealPermutation(A))\n    | `- error: expected '{' in body of function declaration\n 14 | }\n 15 | \n",
      "expected" : "false",
      "input" : "nums = [1,2,0]",
      "slug" : "global-and-local-inversions",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "true",
      "input" : "nums = [1,0,2]",
      "slug" : "global-and-local-inversions",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "false",
      "input" : "nums = [1,2,0]",
      "slug" : "global-and-local-inversions",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:1: error: expected 'func' keyword in instance method declaration\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    | `- error: expected 'func' keyword in instance method declaration\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:18: error: unnamed parameters must be written with the empty name '_'\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    |                  `- error: unnamed parameters must be written with the empty name '_'\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:18: error: cannot find type 'n' in scope\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    |                  `- error: cannot find type 'n' in scope\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n",
      "expected" : "[0, 1, 3, 2]",
      "input" : "n = 2",
      "slug" : "gray-code",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:1: error: expected 'func' keyword in instance method declaration\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    | `- error: expected 'func' keyword in instance method declaration\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:18: error: unnamed parameters must be written with the empty name '_'\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    |                  `- error: unnamed parameters must be written with the empty name '_'\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/gray-code_1\/solution.swift:5:18: error: cannot find type 'n' in scope\n  3 | class Solution {\n  4 | let n = 3\n  5 | generateGrayCode(n)\n    |                  `- error: cannot find type 'n' in scope\n  6 | func generateGrayCode(_ n: Int) -> [Int] {\n  7 |     if n == 1 {\n",
      "expected" : "[0, 1, 3, 2, 6, 7, 5, 4]",
      "input" : "n = 3",
      "slug" : "gray-code",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[0,1,3,2]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[0, 1, 3, 2]",
      "input" : "n = 2",
      "slug" : "gray-code",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,1,3,2,6,7,5,4]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[0, 1, 3, 2, 6, 7, 5, 4]",
      "input" : "n = 3",
      "slug" : "gray-code",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "[0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]",
      "input" : "n = 4",
      "slug" : "gray-code",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force\/Baseline Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower-ii_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func getMoneyAmount(_ n: Int) -> Int {\n  6 |     var memo = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n",
      "expected" : "1",
      "input" : "n = 2",
      "slug" : "guess-number-higher-or-lower-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force\/Baseline Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower-ii_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func getMoneyAmount(_ n: Int) -> Int {\n  6 |     var memo = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n",
      "expected" : "6",
      "input" : "n = 5",
      "slug" : "guess-number-higher-or-lower-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower-ii_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func getMoneyAmount(_ n: Int) -> Int {\n  6 |     var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n",
      "expected" : "0",
      "input" : "n = 1",
      "slug" : "guess-number-higher-or-lower-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/guess-number-higher-or-lower-ii_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func getMoneyAmount(_ n: Int) -> Int {\n  6 |     var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n",
      "expected" : "12",
      "input" : "n = 10",
      "slug" : "guess-number-higher-or-lower-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:3:123: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func rand10() -> Int { var x = 50; while (x > 47) { x = 7 * (rand7() - 1) + rand7() }; return x \/ 5 + 1 } func rand7() -> Int { return Int.random(in: 1...7) } }\n    |                                                                                                                           `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "Random number between 1 and 10",
      "input" : "First Test Case",
      "slug" : "implement-rand10-using-rand7",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:3:123: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func rand10() -> Int { var x = 50; while (x > 47) { x = 7 * (rand7() - 1) + rand7() }; return x \/ 5 + 1 } func rand7() -> Int { return Int.random(in: 1...7) } }\n    |                                                                                                                           `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_1\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "Another random number between 1 and 10",
      "input" : "Second Test Case",
      "slug" : "implement-rand10-using-rand7",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Rejection Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:3:132: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func rand10() -> Int { while true { let x = 7 * (rand7() - 1) + rand7(); if x <= 40 { return (x - 1) \/ 4 + 1 } } } func rand7() -> Int { return Int.random(in: 1...7) } }\n    |                                                                                                                                    `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "Random number between 1 and 10",
      "input" : "First Test Case",
      "slug" : "implement-rand10-using-rand7",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Rejection Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:3:132: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { func rand10() -> Int { while true { let x = 7 * (rand7() - 1) + rand7(); if x <= 40 { return (x - 1) \/ 4 + 1 } } } func rand7() -> Int { return Int.random(in: 1...7) } }\n    |                                                                                                                                    `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/implement-rand10-using-rand7_2\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "Another random number between 1 and 10",
      "input" : "Second Test Case",
      "slug" : "implement-rand10-using-rand7",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:4:125: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RandomizedSet { var elements: [Int] = []; func insert(_ val: Int) -> Bool { if elements.contains(val) { return false } elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = elements.firstIndex(of: val) { elements.remove(at: index); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:4:284: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RandomizedSet { var elements: [Int] = []; func insert(_ val: Int) -> Bool { if elements.contains(val) { return false } elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = elements.firstIndex(of: val) { elements.remove(at: index); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'insert'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "2, true, true, false",
      "input" : "insert(1), insert(2), remove(1), insert(2), remove(2), getRandom()",
      "slug" : "insert-delete-getrandom-o1",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:4:125: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RandomizedSet { var elements: [Int] = []; func insert(_ val: Int) -> Bool { if elements.contains(val) { return false } elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = elements.firstIndex(of: val) { elements.remove(at: index); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:4:284: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | class RandomizedSet { var elements: [Int] = []; func insert(_ val: Int) -> Bool { if elements.contains(val) { return false } elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = elements.firstIndex(of: val) { elements.remove(at: index); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_1\/solution.swift:228:23: error: value of type 'Solution' has no member 'insert'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "true, true, true, true, false",
      "input" : "insert(0), insert(1), remove(0), insert(2), remove(1), getRandom()",
      "slug" : "insert-delete-getrandom-o1",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:173: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:438: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'insert'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "true, true, true, false, true, nil",
      "input" : "insert(1), insert(2), remove(1), insert(2), remove(2), getRandom()",
      "slug" : "insert-delete-getrandom-o1",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:173: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:4:438: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | import Foundation; class RandomizedSet { var dict: [Int: Int] = [:]; var elements: [Int] = []; func insert(_ val: Int) -> Bool { if dict.keys.contains(val) { return false } dict[val] = elements.count; elements.append(val); return true }; func remove(_ val: Int) -> Bool { if let index = dict[val] { let last = elements.last!; elements[index] = last; dict[last] = index; elements.removeLast(); dict.removeValue(forKey: val); return true } return false }; func getRandom() -> Int { return elements.randomElement()! }; }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/insert-delete-getrandom-o1_2\/solution.swift:228:23: error: value of type 'Solution' has no member 'insert'\n226 | \n227 | let arg0 = toInt(valueAt(args, 0))\n228 | let result = solution.insert(arg0)\n    |                       `- error: value of type 'Solution' has no member 'insert'\n229 | let output: Any = result\n230 | print(jsonString(from: output))\n",
      "expected" : "true, true, true, true, true, 2",
      "input" : "insert(0), insert(1), remove(0), insert(2), remove(1), getRandom()",
      "slug" : "insert-delete-getrandom-o1",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:146: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                         `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:261: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                     `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                      |- error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n    |                                                                                                                                                                                                                                                                                      |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                                                                                                                                                                                                                                      `- note: required by instance method 'append(contentsOf:)' where 'S' = '(Duration, Duration)'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:285: error: missing argument label 'contentsOf:' in call\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                             `- error: missing argument label 'contentsOf:' in call\n  5 | }\n  6 | \n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "1",
      "input" : "n = 2",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:146: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                         `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:261: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                     `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                      |- error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n    |                                                                                                                                                                                                                                                                                      |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                                                                                                                                                                                                                                      `- note: required by instance method 'append(contentsOf:)' where 'S' = '(Duration, Duration)'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:285: error: missing argument label 'contentsOf:' in call\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                             `- error: missing argument label 'contentsOf:' in call\n  5 | }\n  6 | \n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "36",
      "input" : "n = 10",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:146: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                         `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:261: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                     `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                        |                                                                                                                                                                                                                             `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n    |                                                        `- note: change 'let' to 'var' to make it mutable\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:278: error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                      |- error: type '(Duration, Duration)' cannot conform to 'Sequence' [#ProtocolTypeNonConformance]\n    |                                                                                                                                                                                                                                                                                      |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                                                                                                                                                                                                                                                                                      `- note: required by instance method 'append(contentsOf:)' where 'S' = '(Duration, Duration)'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_1\/solution.swift:4:285: error: missing argument label 'contentsOf:' in call\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { var maxProduct = 0; let queue: [(Int, Int)] = [(n, 1)]; while !queue.isEmpty { let (current, product) = queue.removeFirst(); if current == 1 { maxProduct = max(maxProduct, product); } else { for i in 1...current { if current - i >= 0 { queue.append((current - i, product * i)); } } } }; return maxProduct; }\n    |                                                                                                                                                                                                                                                                                             `- error: missing argument label 'contentsOf:' in call\n  5 | }\n  6 | \n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "18",
      "input" : "n = 8",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:59: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:138: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:131: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                   `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "n = 2",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:59: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:138: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:131: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                   `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "36",
      "input" : "n = 10",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:59: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:83: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:138: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/integer-break_2\/solution.swift:4:131: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func integerBreak(n: Int) -> Int { if n == 2 { return 1; } if n == 3 { return 2; } var product = 1; while n > 4 { product *= 3; n -= 3; } product *= n; return product; }\n    |                                                                                                                                   `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "18",
      "input" : "n = 8",
      "slug" : "integer-break",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "\"III\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "III",
      "input" : "num = 3",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"IV\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "IV",
      "input" : "num = 4",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"IX\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "IX",
      "input" : "num = 9",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "\"III\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "III",
      "input" : "num = 3",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"LVIII\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "LVIII",
      "input" : "num = 58",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"MCMXCIV\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "MCMXCIV",
      "input" : "num = 1994",
      "slug" : "integer-to-roman",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Baseline Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-symbol-in-grammar_1\/solution.swift:4:85: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func kthGrammar(_ n: Int, _ k: Int) -> Int { let row = getRow(n); return Int(String(row[k-1]))! }; func getRow(_ n: Int) -> String { if n == 1 { return \"0\" } else { let prevRow = getRow(n-1); return String(prevRow.map { $0 == \"0\" ? \"01\" : \"10\" }) } }\n    |                                                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-symbol-in-grammar_1\/solution.swift:4:200: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func kthGrammar(_ n: Int, _ k: Int) -> Int { let row = getRow(n); return Int(String(row[k-1]))! }; func getRow(_ n: Int) -> String { if n == 1 { return \"0\" } else { let prevRow = getRow(n-1); return String(prevRow.map { $0 == \"0\" ? \"01\" : \"10\" }) } }\n    |                                                                                                                                                                                                        |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                        `- note: found candidate with type '([Character]) -> String'\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "0",
      "input" : "n = 1, k = 1",
      "slug" : "k-th-symbol-in-grammar",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Recursive Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-symbol-in-grammar_1\/solution.swift:4:85: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  2 | \n  3 | class Solution {\n  4 | func kthGrammar(_ n: Int, _ k: Int) -> Int { let row = getRow(n); return Int(String(row[k-1]))! }; func getRow(_ n: Int) -> String { if n == 1 { return \"0\" } else { let prevRow = getRow(n-1); return String(prevRow.map { $0 == \"0\" ? \"01\" : \"10\" }) } }\n    |                                                                                     `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 | }\n  6 | \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/k-th-symbol-in-grammar_1\/solution.swift:4:200: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func kthGrammar(_ n: Int, _ k: Int) -> Int { let row = getRow(n); return Int(String(row[k-1]))! }; func getRow(_ n: Int) -> String { if n == 1 { return \"0\" } else { let prevRow = getRow(n-1); return String(prevRow.map { $0 == \"0\" ? \"01\" : \"10\" }) } }\n    |                                                                                                                                                                                                        |- error: no exact matches in call to initializer \n    |                                                                                                                                                                                                        `- note: found candidate with type '([Character]) -> String'\n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n",
      "expected" : "1",
      "input" : "n = 2, k = 2",
      "slug" : "k-th-symbol-in-grammar",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "8",
      "approachName" : "Optimized Bit Manipulation Approach",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "n = 3, k = 1",
      "slug" : "k-th-symbol-in-grammar",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "20",
      "approachName" : "Optimized Bit Manipulation Approach",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "n = 4, k = 5",
      "slug" : "k-th-symbol-in-grammar",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:33:27: error: value of optional type '[Int]?' must be unwrapped to a value of type '[Int]'\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n 33 |                    return maxSubset\n    |                           |- error: value of optional type '[Int]?' must be unwrapped to a value of type '[Int]'\n    |                           |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                           `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 34 |                }\n 35 |                return []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:32:71: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 30 |                    }\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n    |                                                                       `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 33 |                    return maxSubset\n 34 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:32:50: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 30 |                    }\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n    |                                                  `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 33 |                    return maxSubset\n 34 |                }\n",
      "expected" : "[1,2] or [1,3]",
      "input" : "nums = [1,2,3]",
      "slug" : "largest-divisible-subset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:33:27: error: value of optional type '[Int]?' must be unwrapped to a value of type '[Int]'\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n 33 |                    return maxSubset\n    |                           |- error: value of optional type '[Int]?' must be unwrapped to a value of type '[Int]'\n    |                           |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                           `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 34 |                }\n 35 |                return []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:32:71: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 30 |                    }\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n    |                                                                       `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 33 |                    return maxSubset\n 34 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_1\/solution.swift:32:50: warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 30 |                    }\n 31 |                }\n 32 |                if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n    |                                                  `- warning: trailing closure in this context is confusable with the body of the statement; pass as a parenthesized argument to silence this warning\n 33 |                    return maxSubset\n 34 |                }\n",
      "expected" : "[1,2,4,8]",
      "input" : "nums = [1,2,4,8]",
      "slug" : "largest-divisible-subset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:27:26: warning: comparing non-optional value of type 'Int' to 'nil' always returns true\n 25 |                var subset: [Int] = []\n 26 |                var idx = maxIndex\n 27 |                while idx != nil {\n    |                          `- warning: comparing non-optional value of type 'Int' to 'nil' always returns true\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:28:42: error: cannot force unwrap value of non-optional type 'Int'\n 26 |                var idx = maxIndex\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n    |                                          `- error: cannot force unwrap value of non-optional type 'Int'\n 29 |                    idx = prev[idx!]\n 30 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:29:30: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n    |                              |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                              |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                              `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 30 |                }\n 31 |                return subset.reversed()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:29:34: error: cannot force unwrap value of non-optional type 'Int'\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n    |                                  `- error: cannot force unwrap value of non-optional type 'Int'\n 30 |                }\n 31 |                return subset.reversed()\n",
      "expected" : "[1,2] or [1,3]",
      "input" : "nums = [1,2,3]",
      "slug" : "largest-divisible-subset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:27:26: warning: comparing non-optional value of type 'Int' to 'nil' always returns true\n 25 |                var subset: [Int] = []\n 26 |                var idx = maxIndex\n 27 |                while idx != nil {\n    |                          `- warning: comparing non-optional value of type 'Int' to 'nil' always returns true\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:28:42: error: cannot force unwrap value of non-optional type 'Int'\n 26 |                var idx = maxIndex\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n    |                                          `- error: cannot force unwrap value of non-optional type 'Int'\n 29 |                    idx = prev[idx!]\n 30 |                }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:29:30: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n    |                              |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                              |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                              `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 30 |                }\n 31 |                return subset.reversed()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-divisible-subset_2\/solution.swift:29:34: error: cannot force unwrap value of non-optional type 'Int'\n 27 |                while idx != nil {\n 28 |                    subset.append(nums[idx!])\n 29 |                    idx = prev[idx!]\n    |                                  `- error: cannot force unwrap value of non-optional type 'Int'\n 30 |                }\n 31 |                return subset.reversed()\n",
      "expected" : "[1,2,4,8]",
      "input" : "nums = [1,2,4,8]",
      "slug" : "largest-divisible-subset",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-perimeter-triangle_1\/solution.swift:4:279: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var maxPerimeter = 0; for i in 0..<n { for j in i+1..<n { for k in j+1..<n { let a = nums[i], b = nums[j], c = nums[k]; if a + b > c && a + c > b && b + c > a { maxPerimeter = max(maxPerimeter, a + b + c) } } } } return maxPerimeter }\n    |                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "5",
      "input" : "nums = [2,1,2]",
      "slug" : "largest-perimeter-triangle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-perimeter-triangle_1\/solution.swift:4:279: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var maxPerimeter = 0; for i in 0..<n { for j in i+1..<n { for k in j+1..<n { let a = nums[i], b = nums[j], c = nums[k]; if a + b > c && a + c > b && b + c > a { maxPerimeter = max(maxPerimeter, a + b + c) } } } } return maxPerimeter }\n    |                                                                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "nums = [1,2,1]",
      "slug" : "largest-perimeter-triangle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-perimeter-triangle_2\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var numsSorted = nums; numsSorted.sort { $0 > $1 }; for i in 0..<n-2 { let a = numsSorted[i], b = numsSorted[i+1], c = numsSorted[i+2]; if a < b + c { return a + b + c } } return 0 }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "nums = [3,6,2,3]",
      "slug" : "largest-perimeter-triangle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-perimeter-triangle_2\/solution.swift:4:238: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var numsSorted = nums; numsSorted.sort { $0 > $1 }; for i in 0..<n-2 { let a = numsSorted[i], b = numsSorted[i+1], c = numsSorted[i+2]; if a < b + c { return a + b + c } } return 0 }\n    |                                                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "10",
      "input" : "nums = [3,2,3,4]",
      "slug" : "largest-perimeter-triangle",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-triangle-area_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func largestTriangleArea(_ points: [[Int]]) -> Double {\n",
      "expected" : "0.5",
      "input" : "points = [[0,0],[0,1],[1,0],[1,1]]",
      "slug" : "largest-triangle-area",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-triangle-area_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func largestTriangleArea(_ points: [[Int]]) -> Double {\n",
      "expected" : "0.5",
      "input" : "points = [[0,0],[1,0],[1,1]]",
      "slug" : "largest-triangle-area",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-triangle-area_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func largestTriangleArea(_ points: [[Int]]) -> Double {\n",
      "expected" : "0.5",
      "input" : "points = [[0,0],[0,1],[1,0],[1,1]]",
      "slug" : "largest-triangle-area",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-triangle-area_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func largestTriangleArea(_ points: [[Int]]) -> Double {\n",
      "expected" : "0.5",
      "input" : "points = [[0,0],[1,0],[1,1]]",
      "slug" : "largest-triangle-area",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/largest-triangle-area_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func largestTriangleArea(_ points: [[Int]]) -> Double {\n",
      "expected" : "2500",
      "input" : "points = [[-50,-50],[50,-50],[50,50],[-50,50]]",
      "slug" : "largest-triangle-area",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "[[1,1],[1,3],[3,1],[3,3],[2,2]]",
      "slug" : "minimum-area-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "2",
      "input" : "[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]",
      "slug" : "minimum-area-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "[[1,1],[1,3],[3,1],[3,3],[2,2]]",
      "slug" : "minimum-area-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "2",
      "input" : "[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]",
      "slug" : "minimum-area-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:287: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:493: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:655: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:616: error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.BinaryInteger.<:2:20: note: where 'Other' = 'CGFloat'\n1 | protocol BinaryInteger {\n2 | public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: where 'Other' = 'CGFloat'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:638: error: cannot assign value of type 'Int' to type 'CGFloat'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: cannot assign value of type 'Int' to type 'CGFloat'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "points = [[1,2],[2,1],[1,0],[0,1]]",
      "slug" : "minimum-area-rectangle-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:287: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:493: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:655: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:616: error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.BinaryInteger.<:2:20: note: where 'Other' = 'CGFloat'\n1 | protocol BinaryInteger {\n2 | public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: where 'Other' = 'CGFloat'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_1\/solution.swift:4:638: error: cannot assign value of type 'Int' to type 'CGFloat'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; for k in 0..<n { for l in 0..<n { if k == i || k == j || l == i || l == j { continue } let point3 = points[k]; let point4 = points[l]; if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1])); if area2 < minArea { minArea = area2 } } } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              `- error: cannot assign value of type 'Int' to type 'CGFloat'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "points = [[0,1],[2,1],[1,1],[1,0],[2,0]]",
      "slug" : "minimum-area-rectangle-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:613: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:579: error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.BinaryInteger.<:2:20: note: where 'Other' = 'CGFloat'\n1 | protocol BinaryInteger {\n2 | public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: where 'Other' = 'CGFloat'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:601: error: cannot assign value of type 'Int' to type 'CGFloat'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: cannot assign value of type 'Int' to type 'CGFloat'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "points = [[1,2],[2,1],[1,0],[0,1]]",
      "slug" : "minimum-area-rectangle-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:613: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:579: error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   `- error: operator function '<' requires that 'CGFloat' conform to 'BinaryInteger'\n  5 | }\n  6 | \n\nSwift.BinaryInteger.<:2:20: note: where 'Other' = 'CGFloat'\n1 | protocol BinaryInteger {\n2 | public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger}\n  |                    `- note: where 'Other' = 'CGFloat'\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-area-rectangle-ii_2\/solution.swift:4:601: error: cannot assign value of type 'Int' to type 'CGFloat'\n  2 | \n  3 | class Solution {\n  4 | func minAreaFreeRect(_ points: [[Int]]) -> CGFloat { let n = points.count; var pointsSet: Set<[Int]> = []; for point in points { pointsSet.insert(point) }; var minArea: CGFloat = CGFloat.infinity; for i in 0..<n { for j in i+1..<n { let point1 = points[i]; let point2 = points[j]; let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]; let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]; if pointsSet.contains(point3) && pointsSet.contains(point4) { let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])); if area < minArea { minArea = area } } } } return sqrt(minArea) }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: cannot assign value of type 'Int' to type 'CGFloat'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "points = [[0,1],[2,1],[1,1],[1,0],[2,0]]",
      "slug" : "minimum-area-rectangle-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-moves-to-equal-array-elements-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n",
      "expected" : "2",
      "input" : "nums = [1,2,3]",
      "slug" : "minimum-moves-to-equal-array-elements-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-moves-to-equal-array-elements-ii_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n",
      "expected" : "16",
      "input" : "nums = [1,10,2,9]",
      "slug" : "minimum-moves-to-equal-array-elements-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-moves-to-equal-array-elements-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n",
      "expected" : "2",
      "input" : "nums = [1,2,3]",
      "slug" : "minimum-moves-to-equal-array-elements-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-moves-to-equal-array-elements-ii_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n",
      "expected" : "16",
      "input" : "nums = [1,10,2,9]",
      "slug" : "minimum-moves-to-equal-array-elements-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-time-difference_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func findMinDifference(_ timePoints: [String]) -> Int {\n",
      "expected" : "1",
      "input" : "timePoints = [\"23:59\",\"00:00\"]",
      "slug" : "minimum-time-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-time-difference_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func findMinDifference(_ timePoints: [String]) -> Int {\n",
      "expected" : "43",
      "input" : "timePoints = [\"12:01\",\"12:44\" ]",
      "slug" : "minimum-time-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-time-difference_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func findMinDifference(_ timePoints: [String]) -> Int {\n",
      "expected" : "1",
      "input" : "timePoints = [\"23:59\",\"00:00\"]",
      "slug" : "minimum-time-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/minimum-time-difference_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func findMinDifference(_ timePoints: [String]) -> Int {\n",
      "expected" : "43",
      "input" : "timePoints = [\"12:01\",\"12:44\" ]",
      "slug" : "minimum-time-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflection(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "1",
      "input" : "p = 2, q = 2",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflection(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "0",
      "input" : "p = 2, q = 3",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflection(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "2",
      "input" : "p = 2, q = 4",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflectionOptimized(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "1",
      "input" : "p = 2, q = 2",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflectionOptimized(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "0",
      "input" : "p = 2, q = 3",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/mirror-reflection_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func mirrorReflectionOptimized(_ p: Int, _ q: Int) -> Int {\n",
      "expected" : "2",
      "input" : "p = 2, q = 4",
      "slug" : "mirror-reflection",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "332",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "299",
      "input" : "N = 332",
      "slug" : "monotone-increasing-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "100",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "99",
      "input" : "N = 100",
      "slug" : "monotone-increasing-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0.28928846103977207",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "0.6",
      "input" : "n = 10, k = 2, maxPts = 6",
      "slug" : "new-21-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0.161051",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "0.6",
      "input" : "n = 6, k = 1, maxPts = 10",
      "slug" : "new-21-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "-0.019290123456790115",
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "0.6",
      "input" : "n = 10, k = 2, maxPts = 6",
      "slug" : "new-21-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "-0.008000000000000002",
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "expected" : "0.6",
      "input" : "n = 6, k = 1, maxPts = 10",
      "slug" : "new-21-game",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-iii_1\/solution.swift:4:284: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func nextGreaterElement(_ n: Int) -> Int { let str = String(n); var res: Int = -1; let chars = str.map { String($0) }; func backtrack(_ current: String, _ index: Int) { if current.count == str.count { if Int(current)! > n && (res == -1 || Int(current)! < res) { res = Int(current)! } return }; for i in index..<chars.count { if index > 0 && chars[i] <= chars[index - 1] { continue }; let newCurrent = current + chars[i]; var visited: [String] = []; for j in 0..<chars.count { if j != i && visited.contains(chars[j]) { continue }; visited.append(chars[j]); backtrack(newCurrent, i + 1); visited.removeLast(); } } }; backtrack(\"\", 0); return res };\n    |                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "21",
      "input" : "n = 12",
      "slug" : "next-greater-element-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-iii_1\/solution.swift:4:284: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func nextGreaterElement(_ n: Int) -> Int { let str = String(n); var res: Int = -1; let chars = str.map { String($0) }; func backtrack(_ current: String, _ index: Int) { if current.count == str.count { if Int(current)! > n && (res == -1 || Int(current)! < res) { res = Int(current)! } return }; for i in index..<chars.count { if index > 0 && chars[i] <= chars[index - 1] { continue }; let newCurrent = current + chars[i]; var visited: [String] = []; for j in 0..<chars.count { if j != i && visited.contains(chars[j]) { continue }; visited.append(chars[j]); backtrack(newCurrent, i + 1); visited.removeLast(); } } }; backtrack(\"\", 0); return res };\n    |                                                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "-1",
      "input" : "n = 21",
      "slug" : "next-greater-element-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Find First Increasing Digit Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-iii_2\/solution.swift:4:410: error: cannot convert value of type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func nextGreaterElement(_ n: Int) -> Int { let str = String(n); var chars = Array(str); var i = chars.count - 2; while i >= 0 && chars[i] >= chars[i + 1] { i -= 1 }; if i < 0 { return -1 }; var j = chars.count - 1; while j > i && chars[j] <= chars[i] { j -= 1 }; let temp = chars[j]; chars[j] = chars[i]; chars[i] = temp; let left = chars[0...i]; let mid = chars[i + 1...j].reversed(); let right = chars[j + 1...]; let res = String(left + mid + right); return Int(res) ?? -1 };\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot convert value of type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "21",
      "input" : "n = 12",
      "slug" : "next-greater-element-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Find First Increasing Digit Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/next-greater-element-iii_2\/solution.swift:4:410: error: cannot convert value of type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func nextGreaterElement(_ n: Int) -> Int { let str = String(n); var chars = Array(str); var i = chars.count - 2; while i >= 0 && chars[i] >= chars[i + 1] { i -= 1 }; if i < 0 { return -1 }; var j = chars.count - 1; while j > i && chars[j] <= chars[i] { j -= 1 }; let temp = chars[j]; chars[j] = chars[i]; chars[i] = temp; let left = chars[0...i]; let mid = chars[i + 1...j].reversed(); let right = chars[j + 1...]; let res = String(left + mid + right); return Int(res) ?? -1 };\n    |                                                                                                                                                                                                                                                                                                                                                                                                                          `- error: cannot convert value of type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "-1",
      "input" : "n = 21",
      "slug" : "next-greater-element-iii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/nth-digit_2\/solution.swift:4:113: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findNthDigit(_ n: Int) -> Int { var length = 1; var count = 9; var start = 1; while n > length * count { n -= length * count; length += 1; count *= 10; start *= 10 }; start += (n - 1) \/ length; return Int(String(start)[ (n - 1) % length ]) ?? 0 }\n    |                                                                                                                 `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/nth-digit_2\/solution.swift:4:234: error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n  2 | \n  3 | class Solution {\n  4 | func findNthDigit(_ n: Int) -> Int { var length = 1; var count = 9; var start = 1; while n > length * count { n -= length * count; length += 1; count *= 10; start *= 10 }; start += (n - 1) \/ length; return Int(String(start)[ (n - 1) % length ]) ?? 0 }\n    |                                                                                                                                                                                                                                          `- error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n  5 | }\n  6 | \n",
      "expected" : "3",
      "input" : "n = 3",
      "slug" : "nth-digit",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/nth-digit_2\/solution.swift:4:113: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func findNthDigit(_ n: Int) -> Int { var length = 1; var count = 9; var start = 1; while n > length * count { n -= length * count; length += 1; count *= 10; start *= 10 }; start += (n - 1) \/ length; return Int(String(start)[ (n - 1) % length ]) ?? 0 }\n    |                                                                                                                 `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/nth-digit_2\/solution.swift:4:234: error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n  2 | \n  3 | class Solution {\n  4 | func findNthDigit(_ n: Int) -> Int { var length = 1; var count = 9; var start = 1; while n > length * count { n -= length * count; length += 1; count *= 10; start *= 10 }; start += (n - 1) \/ length; return Int(String(start)[ (n - 1) % length ]) ?? 0 }\n    |                                                                                                                                                                                                                                          `- error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "n = 11",
      "slug" : "nth-digit",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-boomerangs_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n  6 |     var count = 0\n",
      "expected" : "2",
      "input" : "points = [[0,0],[1,0],[2,0]]",
      "slug" : "number-of-boomerangs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-boomerangs_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n  6 |     var count = 0\n",
      "expected" : "0",
      "input" : "points = [[1,1]]",
      "slug" : "number-of-boomerangs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-boomerangs_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n  6 |     var count = 0\n",
      "expected" : "2",
      "input" : "points = [[0,0],[1,0],[2,0]]",
      "slug" : "number-of-boomerangs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-boomerangs_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n  6 |     var count = 0\n",
      "expected" : "0",
      "input" : "points = [[1,1]]",
      "slug" : "number-of-boomerangs",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:192: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:231: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:306: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:352: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "1000\/(100\/10\/2)",
      "input" : "nums = [1000,100,10,2]",
      "slug" : "optimal-division",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:192: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:231: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:306: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_1\/solution.swift:4:352: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    var result = String(nums[0]) + \"\/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}\n    |                                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4\/(3\/2)",
      "input" : "nums = [4,3,2]",
      "slug" : "optimal-division",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:192: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:252: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:228: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                    `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate requires that the types 'DropFirstSequence<[Int]>.Element' (aka 'Int') and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'DropFirstSequence<[Int]>.Element' (aka 'Int') and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'Int' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'Int' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:252: error: cannot find 'joined' in scope\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                                            `- error: cannot find 'joined' in scope\n  5 | }\n  6 | \n",
      "expected" : "1000\/(100\/10\/2)",
      "input" : "nums = [1000,100,10,2]",
      "slug" : "optimal-division",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:192: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:252: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:228: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                    `- error: no exact matches in call to initializer \n  5 | }\n  6 | \n\nSwift.String.init:2:8: note: candidate requires that the types 'DropFirstSequence<[Int]>.Element' (aka 'Int') and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n1 | struct String {\n2 | public init<S>(_ characters: S) where S : Sequence, S.Element == Character}\n  |        `- note: candidate requires that the types 'DropFirstSequence<[Int]>.Element' (aka 'Int') and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n3 | \n\nSwift.RangeReplaceableCollection.init:2:19: note: candidate requires that the types 'String.Element' (aka 'Character') and 'Int' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n1 | protocol RangeReplaceableCollection {\n2 | @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element}\n  |                   `- note: candidate requires that the types 'String.Element' (aka 'Character') and 'Int' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | public init<Subject>(describing instance: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:19: note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n1 | struct String {\n2 | @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible}\n  |                   `- note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n3 | \n\nSwift.String.init:2:8: note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n1 | struct String {\n2 | public init<Subject>(reflecting subject: Subject)}\n  |        `- note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/optimal-division_2\/solution.swift:4:252: error: cannot find 'joined' in scope\n  2 | \n  3 | class Solution {\n  4 | func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"\/\" + String(nums[1])    }    return String(nums[0]) + \"\/(\" + String(nums.dropFirst())joined(separator: \"\/\") + \")\"}\n    |                                                                                                                                                                                                                                                            `- error: cannot find 'joined' in scope\n  5 | }\n  6 | \n",
      "expected" : "4\/(3\/2)",
      "input" : "nums = [4,3,2]",
      "slug" : "optimal-division",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/power-of-three_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Darwin; func isPowerOfThree(_ n: Int) -> Bool { let logValue = log(Double(n)) \/ log(3); return fmod(logValue, 1) == 0 && n > 0; }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "n = 27",
      "slug" : "power-of-three",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/power-of-three_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Darwin; func isPowerOfThree(_ n: Int) -> Bool { let logValue = log(Double(n)) \/ log(3); return fmod(logValue, 1) == 0 && n > 0; }\n    | `- error: declaration is only valid at file scope\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "n = 0",
      "slug" : "power-of-three",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:24:1: error: declaration is only valid at file scope\n 22 | }\n 23 | \n 24 | extension Int {\n    | `- error: declaration is only valid at file scope\n 25 |     func pow(_ n: Int) -> Int {\n 26 |         return Int(pow(Double(self), Double(n)))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:7:13: error: value of type 'Int' has no member 'pow'\n  5 |     var result: Set<Int> = []\n  6 |     var i = 0\n  7 |     while x.pow(i) <= bound {\n    |             `- error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:9:17: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                 `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:9:28: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                            `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:10:29: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                             `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:10:40: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                                        `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n",
      "expected" : "[2, 3, 4, 5, 7, 9, 10, 13, 14, 15, 19]",
      "input" : "x = 2, y = 3, bound = 20",
      "slug" : "powerful-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:24:1: error: declaration is only valid at file scope\n 22 | }\n 23 | \n 24 | extension Int {\n    | `- error: declaration is only valid at file scope\n 25 |     func pow(_ n: Int) -> Int {\n 26 |         return Int(pow(Double(self), Double(n)))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:7:13: error: value of type 'Int' has no member 'pow'\n  5 |     var result: Set<Int> = []\n  6 |     var i = 0\n  7 |     while x.pow(i) <= bound {\n    |             `- error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:9:17: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                 `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:9:28: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                            `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:10:29: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                             `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_1\/solution.swift:10:40: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                                        `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n",
      "expected" : "[2, 4, 6, 8, 10, 14]",
      "input" : "x = 3, y = 5, bound = 15",
      "slug" : "powerful-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:24:1: error: declaration is only valid at file scope\n 22 | }\n 23 | \n 24 | extension Int {\n    | `- error: declaration is only valid at file scope\n 25 |     func pow(_ n: Int) -> Int {\n 26 |         return Int(pow(Double(self), Double(n)))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:7:13: error: value of type 'Int' has no member 'pow'\n  5 |     var result: Set<Int> = []\n  6 |     var i = 0\n  7 |     while x.pow(i) <= bound {\n    |             `- error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:9:17: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                 `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:9:28: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                            `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:10:29: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                             `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:10:40: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                                        `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n",
      "expected" : "[2, 3, 4, 5, 7, 9, 10, 13, 14, 15, 19]",
      "input" : "x = 2, y = 3, bound = 20",
      "slug" : "powerful-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:24:1: error: declaration is only valid at file scope\n 22 | }\n 23 | \n 24 | extension Int {\n    | `- error: declaration is only valid at file scope\n 25 |     func pow(_ n: Int) -> Int {\n 26 |         return Int(pow(Double(self), Double(n)))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:7:13: error: value of type 'Int' has no member 'pow'\n  5 |     var result: Set<Int> = []\n  6 |     var i = 0\n  7 |     while x.pow(i) <= bound {\n    |             `- error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:9:17: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                 `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:9:28: error: value of type 'Int' has no member 'pow'\n  7 |     while x.pow(i) <= bound {\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n    |                            `- error: value of type 'Int' has no member 'pow'\n 10 |             result.insert(x.pow(i) + y.pow(j))\n 11 |             if y == 1 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:10:29: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                             `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/powerful-integers_2\/solution.swift:10:40: error: value of type 'Int' has no member 'pow'\n  8 |         var j = 0\n  9 |         while x.pow(i) + y.pow(j) <= bound {\n 10 |             result.insert(x.pow(i) + y.pow(j))\n    |                                        `- error: value of type 'Int' has no member 'pow'\n 11 |             if y == 1 {\n 12 |                 break\n",
      "expected" : "[2, 4, 6, 8, 10, 14]",
      "input" : "x = 3, y = 5, bound = 15",
      "slug" : "powerful-integers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:114: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:183: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:333: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "L = 6, R = 10",
      "slug" : "prime-number-of-set-bits-in-binary-representation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:114: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                  `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:183: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                       `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_1\/solution.swift:4:333: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                                                                                                                                                                             `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "L = 10, R = 15",
      "slug" : "prime-number-of-set-bits-in-binary-representation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_2\/solution.swift:4:257: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let primes: [Int] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if primes.contains(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "L = 6, R = 10",
      "slug" : "prime-number-of-set-bits-in-binary-representation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prime-number-of-set-bits-in-binary-representation_2\/solution.swift:4:257: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let primes: [Int] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if primes.contains(setBits) { count += 1 } } return count }\n    |                                                                                                                                                                                                                                                                 `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "L = 10, R = 15",
      "slug" : "prime-number-of-set-bits-in-binary-representation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "1021",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "1009",
      "input" : "n = 1000",
      "slug" : "prime-palindrome",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "1409",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "1331",
      "input" : "n = 1234",
      "slug" : "prime-palindrome",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prison-cells-after-n-days_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n",
      "expected" : "[0,0,1,1,0,0,0,0]",
      "input" : "cells = [0,1,0,1,1,0,0,1], n = 7",
      "slug" : "prison-cells-after-n-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prison-cells-after-n-days_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n",
      "expected" : "[0,0,1,1,1,1,1,0]",
      "input" : "cells = [1,0,0,1,0,0,1,0], n = 1000000000",
      "slug" : "prison-cells-after-n-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prison-cells-after-n-days_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n",
      "expected" : "[0,0,1,1,0,0,0,0]",
      "input" : "cells = [0,1,0,1,1,0,0,1], n = 7",
      "slug" : "prison-cells-after-n-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/prison-cells-after-n-days_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n",
      "expected" : "[0,0,1,1,1,1,1,0]",
      "input" : "cells = [1,0,0,1,0,0,1,0], n = 1000000000",
      "slug" : "prison-cells-after-n-days",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:163: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:312: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:330: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:300: error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "15",
      "input" : "grid = [[1,2],[3,4]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:163: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:312: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:330: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:300: error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "grid = [[1,0],[0,2]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:163: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:191: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:208: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:312: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:330: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                          `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_1\/solution.swift:4:300: error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                            `- error: cannot convert value of type '[Int]' to expected argument type 'Int'\n  5 | }\n  6 | \n",
      "expected" : "21",
      "input" : "grid = [[1,1,1],[1,1,1],[1,1,1]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:297: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:409: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:440: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "15",
      "input" : "grid = [[1,2],[3,4]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:297: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:409: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:440: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "grid = [[1,0],[0,2]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:297: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:336: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:379: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:409: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/projection-area-of-3d-shapes_2\/solution.swift:4:440: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "21",
      "input" : "grid = [[1,1,1],[1,1,1],[1,1,1]]",
      "slug" : "projection-area-of-3d-shapes",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:36:18: error: empty collection literal requires an explicit type\n 34 | \n 35 | \/\/ FocusApp LeetCode Runner\n 36 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 37 |     func parseQuotedString(_ input: String) -> String? {\n 38 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:255:23: error: value of type 'Solution' has no member 'flip'\n253 | \n254 | \n255 | let result = solution.flip()\n    |                       `- error: value of type 'Solution' has no member 'flip'\n256 | let output: Any = result\n257 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:105:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n103 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n104 |         guard !trimmed.isEmpty else { return [] }\n105 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n106 |         if !keyValues.isEmpty {\n107 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0, 0]",
      "input" : "n = 1",
      "slug" : "random-flip-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:36:18: error: empty collection literal requires an explicit type\n 34 | \n 35 | \/\/ FocusApp LeetCode Runner\n 36 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 37 |     func parseQuotedString(_ input: String) -> String? {\n 38 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:255:23: error: value of type 'Solution' has no member 'flip'\n253 | \n254 | \n255 | let result = solution.flip()\n    |                       `- error: value of type 'Solution' has no member 'flip'\n256 | let output: Any = result\n257 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_1\/solution.swift:105:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n103 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n104 |         guard !trimmed.isEmpty else { return [] }\n105 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n106 |         if !keyValues.isEmpty {\n107 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0, 0], [0, 1], [1, 0], [1, 1]",
      "input" : "n = 2",
      "slug" : "random-flip-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:26:39: error: consecutive statements on a line must be separated by ';'\n 24 | \n 25 |     func unflip(_ row: Int, _ col: Int) {\n 26 |         available.insert(\"(row)(col)\"))\n    |                                       `- error: consecutive statements on a line must be separated by ';'\n 27 |     }\n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:26:39: error: expected expression\n 24 | \n 25 |     func unflip(_ row: Int, _ col: Int) {\n 26 |         available.insert(\"(row)(col)\"))\n    |                                       `- error: expected expression\n 27 |     }\n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:33:18: error: empty collection literal requires an explicit type\n 31 | \n 32 | \/\/ FocusApp LeetCode Runner\n 33 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 34 |     func parseQuotedString(_ input: String) -> String? {\n 35 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:252:23: error: value of type 'Solution' has no member 'flip'\n250 | \n251 | \n252 | let result = solution.flip()\n    |                       `- error: value of type 'Solution' has no member 'flip'\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:12:13: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 10 |         self.n = n\n 11 |         available = Set()\n 12 |         for i in 0..<n {\n    |             `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 13 |             for j in 0..<n {\n 14 |                 available.insert(\"(i)(j)\")\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:13:17: warning: immutable value 'j' was never used; consider replacing with '_' or removing it [#no-usage]\n 11 |         available = Set()\n 12 |         for i in 0..<n {\n 13 |             for j in 0..<n {\n    |                 `- warning: immutable value 'j' was never used; consider replacing with '_' or removing it [#no-usage]\n 14 |                 available.insert(\"(i)(j)\")\n 15 |             }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:22:17: error: cannot convert value of type 'Int?' to expected element type 'Int'\n 20 |         let cell = Array(available)[Int.random(in: 0..<available.count)]\n 21 |         available.remove(cell)\n 22 |         return [Int(String(cell.prefix(1)) ?? \"0\"), Int(String(cell.suffix(1)) ?? \"0\")]\n    |                 `- error: cannot convert value of type 'Int?' to expected element type 'Int'\n 23 |     }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:22:53: error: cannot convert value of type 'Int?' to expected element type 'Int'\n 20 |         let cell = Array(available)[Int.random(in: 0..<available.count)]\n 21 |         available.remove(cell)\n 22 |         return [Int(String(cell.prefix(1)) ?? \"0\"), Int(String(cell.suffix(1)) ?? \"0\")]\n    |                                                     `- error: cannot convert value of type 'Int?' to expected element type 'Int'\n 23 |     }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:102:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n100 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n101 |         guard !trimmed.isEmpty else { return [] }\n102 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n103 |         if !keyValues.isEmpty {\n104 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0, 0]",
      "input" : "n = 1",
      "slug" : "random-flip-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:26:39: error: consecutive statements on a line must be separated by ';'\n 24 | \n 25 |     func unflip(_ row: Int, _ col: Int) {\n 26 |         available.insert(\"(row)(col)\"))\n    |                                       `- error: consecutive statements on a line must be separated by ';'\n 27 |     }\n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:26:39: error: expected expression\n 24 | \n 25 |     func unflip(_ row: Int, _ col: Int) {\n 26 |         available.insert(\"(row)(col)\"))\n    |                                       `- error: expected expression\n 27 |     }\n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:33:18: error: empty collection literal requires an explicit type\n 31 | \n 32 | \/\/ FocusApp LeetCode Runner\n 33 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 34 |     func parseQuotedString(_ input: String) -> String? {\n 35 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:252:23: error: value of type 'Solution' has no member 'flip'\n250 | \n251 | \n252 | let result = solution.flip()\n    |                       `- error: value of type 'Solution' has no member 'flip'\n253 | let output: Any = result\n254 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:12:13: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 10 |         self.n = n\n 11 |         available = Set()\n 12 |         for i in 0..<n {\n    |             `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 13 |             for j in 0..<n {\n 14 |                 available.insert(\"(i)(j)\")\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:13:17: warning: immutable value 'j' was never used; consider replacing with '_' or removing it [#no-usage]\n 11 |         available = Set()\n 12 |         for i in 0..<n {\n 13 |             for j in 0..<n {\n    |                 `- warning: immutable value 'j' was never used; consider replacing with '_' or removing it [#no-usage]\n 14 |                 available.insert(\"(i)(j)\")\n 15 |             }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:22:17: error: cannot convert value of type 'Int?' to expected element type 'Int'\n 20 |         let cell = Array(available)[Int.random(in: 0..<available.count)]\n 21 |         available.remove(cell)\n 22 |         return [Int(String(cell.prefix(1)) ?? \"0\"), Int(String(cell.suffix(1)) ?? \"0\")]\n    |                 `- error: cannot convert value of type 'Int?' to expected element type 'Int'\n 23 |     }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:22:53: error: cannot convert value of type 'Int?' to expected element type 'Int'\n 20 |         let cell = Array(available)[Int.random(in: 0..<available.count)]\n 21 |         available.remove(cell)\n 22 |         return [Int(String(cell.prefix(1)) ?? \"0\"), Int(String(cell.suffix(1)) ?? \"0\")]\n    |                                                     `- error: cannot convert value of type 'Int?' to expected element type 'Int'\n 23 |     }\n 24 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-flip-matrix_2\/solution.swift:102:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n100 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n101 |         guard !trimmed.isEmpty else { return [] }\n102 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n103 |         if !keyValues.isEmpty {\n104 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[0, 0], [0, 1], [1, 0], [1, 1]",
      "input" : "n = 2",
      "slug" : "random-flip-matrix",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-index_1\/solution.swift:240:25: error: missing argument for parameter #1 in call\n  4 |            class Solution {\n  5 |                var nums: [Int]\n  6 |                init(_ nums: [Int]) {\n    |                `- note: 'init(_:)' declared here\n  7 |                    self.nums = nums\n  8 |                }\n    :\n238 | let args = parseArgs(from: input, expectedCount: 1)\n239 | let hasInput = !args.isEmpty\n240 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n241 | \n242 | let arg0 = toInt(valueAt(args, 0))\n",
      "expected" : "2",
      "input" : "nums = [1,2,3,3,3], target = 3",
      "slug" : "random-pick-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-index_1\/solution.swift:240:25: error: missing argument for parameter #1 in call\n  4 |            class Solution {\n  5 |                var nums: [Int]\n  6 |                init(_ nums: [Int]) {\n    |                `- note: 'init(_:)' declared here\n  7 |                    self.nums = nums\n  8 |                }\n    :\n238 | let args = parseArgs(from: input, expectedCount: 1)\n239 | let hasInput = !args.isEmpty\n240 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n241 | \n242 | let arg0 = toInt(valueAt(args, 0))\n",
      "expected" : "0",
      "input" : "nums = [1,2,3,3,3], target = 1",
      "slug" : "random-pick-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Reservoir Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-index_2\/solution.swift:243:25: error: missing argument for parameter #1 in call\n  4 |            class Solution {\n  5 |                var nums: [Int]\n  6 |                init(_ nums: [Int]) {\n    |                `- note: 'init(_:)' declared here\n  7 |                    self.nums = nums\n  8 |                }\n    :\n241 | let args = parseArgs(from: input, expectedCount: 1)\n242 | let hasInput = !args.isEmpty\n243 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n244 | \n245 | let arg0 = toInt(valueAt(args, 0))\n",
      "expected" : "2",
      "input" : "nums = [1,2,3,3,3], target = 3",
      "slug" : "random-pick-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Reservoir Sampling",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-index_2\/solution.swift:243:25: error: missing argument for parameter #1 in call\n  4 |            class Solution {\n  5 |                var nums: [Int]\n  6 |                init(_ nums: [Int]) {\n    |                `- note: 'init(_:)' declared here\n  7 |                    self.nums = nums\n  8 |                }\n    :\n241 | let args = parseArgs(from: input, expectedCount: 1)\n242 | let hasInput = !args.isEmpty\n243 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n244 | \n245 | let arg0 = toInt(valueAt(args, 0))\n",
      "expected" : "0",
      "input" : "nums = [1,2,3,3,3], target = 1",
      "slug" : "random-pick-index",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:3:231: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:3:390: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:223:25: error: missing argument for parameter #1 in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                      `- note: 'init(_:)' declared here\n  4 | \n  5 | \n    :\n221 | let args = parseArgs(from: input, expectedCount: 0)\n222 | let hasInput = !args.isEmpty\n223 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n224 | \n225 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0 (with probability 1\/4) or 1 (with probability 3\/4)",
      "input" : "weights = [1, 3], pickIndex()",
      "slug" : "random-pick-with-weight",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:3:231: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:3:390: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:223:25: error: missing argument for parameter #1 in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); for i in 0..<cumulativeSum.count { if cumulativeSum[i] > random { return i } } return 0 } }\n    |                                                                      `- note: 'init(_:)' declared here\n  4 | \n  5 | \n    :\n221 | let args = parseArgs(from: input, expectedCount: 0)\n222 | let hasInput = !args.isEmpty\n223 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n224 | \n225 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_1\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0",
      "input" : "weights = [1], pickIndex()",
      "slug" : "random-pick-with-weight",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:3:231: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:3:486: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:223:25: error: missing argument for parameter #1 in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                      `- note: 'init(_:)' declared here\n  4 | \n  5 | \n    :\n221 | let args = parseArgs(from: input, expectedCount: 0)\n222 | let hasInput = !args.isEmpty\n223 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n224 | \n225 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0 (with probability 1\/4) or 1 (with probability 3\/4)",
      "input" : "weights = [1, 3], pickIndex()",
      "slug" : "random-pick-with-weight",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:3:231: error: consecutive declarations on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                                                                                                                                                                                       `- error: consecutive declarations on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:3:486: error: consecutive statements on a line must be separated by ';'\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `- error: consecutive statements on a line must be separated by ';'\n  4 | \n  5 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:7:18: error: empty collection literal requires an explicit type\n  5 | \n  6 | \/\/ FocusApp LeetCode Runner\n  7 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n  8 |     func parseQuotedString(_ input: String) -> String? {\n  9 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:223:25: error: missing argument for parameter #1 in call\n  1 | import Foundation\n  2 | \n  3 | class Solution { var weights = [Int](); var cumulativeSum = [Int](); init(_ w: [Int]) { weights = w; cumulativeSum = Array(repeating: 0, count: w.count); var sum = 0; for i in 0..<w.count { sum += w[i]; cumulativeSum[i] = sum; } } func pickIndex() -> Int { let random = Int.random(in: 0..<cumulativeSum.last!); var left = 0; var right = cumulativeSum.count - 1; while left < right { let mid = (left + right) \/ 2; if cumulativeSum[mid] < random { left = mid + 1 } else { right = mid } } return left } }\n    |                                                                      `- note: 'init(_:)' declared here\n  4 | \n  5 | \n    :\n221 | let args = parseArgs(from: input, expectedCount: 0)\n222 | let hasInput = !args.isEmpty\n223 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n224 | \n225 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-pick-with-weight_2\/solution.swift:76:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n 74 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n 75 |         guard !trimmed.isEmpty else { return [] }\n 76 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n 77 |         if !keyValues.isEmpty {\n 78 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "0 (with probability 1\/10), 1 (with probability 2\/10), 2 (with probability 3\/10), or 3 (with probability 4\/10)",
      "input" : "weights = [1, 2, 3, 4], pickIndex()",
      "slug" : "random-pick-with-weight",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:42:18: error: empty collection literal requires an explicit type\n 40 | \n 41 | \/\/ FocusApp LeetCode Runner\n 42 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 43 |     func parseQuotedString(_ input: String) -> String? {\n 44 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:258:25: error: missing argument for parameter 'rectangles' in call\n  4 |        import Foundation\n  5 | \n  6 |        struct Solution {\n    |               `- note: 'init(rectangles:)' declared here\n  7 |            let rectangles: [[Int]]\n  8 | \n    :\n256 | let args = parseArgs(from: input, expectedCount: 0)\n257 | let hasInput = !args.isEmpty\n258 | let solution = Solution()\n    |                         `- error: missing argument for parameter 'rectangles' in call\n259 | \n260 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:111:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n109 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n110 |         guard !trimmed.isEmpty else { return [] }\n111 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n112 |         if !keyValues.isEmpty {\n113 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[3, 3]",
      "input" : "rectangles = [[1,1,5,5],[6,3,10,7],[1,8,9,10]]",
      "slug" : "random-point-in-non-overlapping-rectangles",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:42:18: error: empty collection literal requires an explicit type\n 40 | \n 41 | \/\/ FocusApp LeetCode Runner\n 42 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 43 |     func parseQuotedString(_ input: String) -> String? {\n 44 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:258:25: error: missing argument for parameter 'rectangles' in call\n  4 |        import Foundation\n  5 | \n  6 |        struct Solution {\n    |               `- note: 'init(rectangles:)' declared here\n  7 |            let rectangles: [[Int]]\n  8 | \n    :\n256 | let args = parseArgs(from: input, expectedCount: 0)\n257 | let hasInput = !args.isEmpty\n258 | let solution = Solution()\n    |                         `- error: missing argument for parameter 'rectangles' in call\n259 | \n260 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_1\/solution.swift:111:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n109 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n110 |         guard !trimmed.isEmpty else { return [] }\n111 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n112 |         if !keyValues.isEmpty {\n113 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[1, 1]",
      "input" : "rectangles = [[0,0,4,3]]",
      "slug" : "random-point-in-non-overlapping-rectangles",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:52:18: error: empty collection literal requires an explicit type\n 50 | \n 51 | \/\/ FocusApp LeetCode Runner\n 52 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 53 |     func parseQuotedString(_ input: String) -> String? {\n 54 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:268:25: error: missing argument for parameter #1 in call\n  9 |            let prefixSums: [Int]\n 10 | \n 11 |            init(_ rectangles: [[Int]]) {\n    |            `- note: 'init(_:)' declared here\n 12 |                self.rectangles = rectangles\n 13 |                var areas: [Int] = []\n    :\n266 | let args = parseArgs(from: input, expectedCount: 0)\n267 | let hasInput = !args.isEmpty\n268 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n269 | \n270 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:121:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n119 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n120 |         guard !trimmed.isEmpty else { return [] }\n121 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n122 |         if !keyValues.isEmpty {\n123 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[3, 3]",
      "input" : "rectangles = [[1,1,5,5],[6,3,10,7],[1,8,9,10]]",
      "slug" : "random-point-in-non-overlapping-rectangles",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:52:18: error: empty collection literal requires an explicit type\n 50 | \n 51 | \/\/ FocusApp LeetCode Runner\n 52 | let paramNames = []\n    |                  `- error: empty collection literal requires an explicit type\n 53 |     func parseQuotedString(_ input: String) -> String? {\n 54 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:268:25: error: missing argument for parameter #1 in call\n  9 |            let prefixSums: [Int]\n 10 | \n 11 |            init(_ rectangles: [[Int]]) {\n    |            `- note: 'init(_:)' declared here\n 12 |                self.rectangles = rectangles\n 13 |                var areas: [Int] = []\n    :\n266 | let args = parseArgs(from: input, expectedCount: 0)\n267 | let hasInput = !args.isEmpty\n268 | let solution = Solution()\n    |                         `- error: missing argument for parameter #1 in call\n269 | \n270 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/random-point-in-non-overlapping-rectangles_2\/solution.swift:121:65: error: cannot convert value of type '[Any]' to expected argument type '[String]'\n119 |         let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)\n120 |         guard !trimmed.isEmpty else { return [] }\n121 |         let keyValues = parseKeyValueInput(trimmed, paramNames: paramNames)\n    |                                                                 |- error: cannot convert value of type '[Any]' to expected argument type '[String]'\n    |                                                                 `- note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n122 |         if !keyValues.isEmpty {\n123 |             let ordered = paramNames.compactMap { keyValues[$0] }\n",
      "expected" : "[1, 1]",
      "input" : "rectangles = [[0,0,4,3]]",
      "slug" : "random-point-in-non-overlapping-rectangles",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-addition-ii_1\/solution.swift:4:345: error: contextual closure type '(Range<Int>.Element) -> Bool' (aka '(Int) -> Bool') expects 1 argument, but 2 were used in closure body\n  2 | \n  3 | class Solution {\n  4 | func maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int { var grid = Array(repeating: Array(repeating: false, count: n), count: m); for op in ops { for i in op[0]...m-1 { for j in op[1]...n-1 { grid[i][j] = true } } }; let rows = grid.map { $0.filter { $0 }.count }; let min_rows = rows.min() ?? 0; let cols = (0..<n).map { col in (0..<m).map { grid[$0][$1] }.filter { $0 }.count }; let min_cols = cols.min() ?? 0; return min_rows * min_cols; }\n    |                                                                                                                                                                                                                                                                                                                                                         `- error: contextual closure type '(Range<Int>.Element) -> Bool' (aka '(Int) -> Bool') expects 1 argument, but 2 were used in closure body\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "m = 3, n = 3, ops = [[2,2],[3,3]]",
      "slug" : "range-addition-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/range-addition-ii_1\/solution.swift:4:345: error: contextual closure type '(Range<Int>.Element) -> Bool' (aka '(Int) -> Bool') expects 1 argument, but 2 were used in closure body\n  2 | \n  3 | class Solution {\n  4 | func maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int { var grid = Array(repeating: Array(repeating: false, count: n), count: m); for op in ops { for i in op[0]...m-1 { for j in op[1]...n-1 { grid[i][j] = true } } }; let rows = grid.map { $0.filter { $0 }.count }; let min_rows = rows.min() ?? 0; let cols = (0..<n).map { col in (0..<m).map { grid[$0][$1] }.filter { $0 }.count }; let min_cols = cols.min() ?? 0; return min_rows * min_cols; }\n    |                                                                                                                                                                                                                                                                                                                                                         `- error: contextual closure type '(Range<Int>.Element) -> Bool' (aka '(Int) -> Bool') expects 1 argument, but 2 were used in closure body\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "m = 3, n = 3, ops = [[2,2],[3,3],[4,4],[5,5]]",
      "slug" : "range-addition-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"1459\"",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"45\"\n",
      "input" : "s = \"fviefuro\"\n",
      "slug" : "reconstruct-original-digits-from-english",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"02\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"012\"\n",
      "input" : "s = \"owoztneoer\"\n",
      "slug" : "reconstruct-original-digits-from-english",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"4559\"",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"45\"\n",
      "input" : "s = \"fviefuro\"\n",
      "slug" : "reconstruct-original-digits-from-english",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "16",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "24",
      "input" : "A = -2, B = -2, C = 2, D = 2, E = -1, F = -1, G = 1, H = 1",
      "slug" : "rectangle-area",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "True",
      "input" : "N = 46",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "True",
      "input" : "N = 1",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "False",
      "input" : "N = 10",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "True",
      "input" : "N = 46",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "True",
      "input" : "N = 1",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "False",
      "input" : "N = 10",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/reordered-power-of-2_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 |        func reorderedPowerOf2(_ N: Int) -> Bool {\n  7 |            let numStr = String(N)\n",
      "expected" : "True",
      "input" : "N = 16",
      "slug" : "reordered-power-of-2",
      "status" : "COMPILE_ERROR",
      "testIndex" : 3
    },
    {
      "actual" : "223",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "136",
      "input" : "nums = [4,8,3,1,2,5,6,0,7,9]",
      "slug" : "rotate-function",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "40",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "20",
      "input" : "nums = [1,2,3,4,5]",
      "slug" : "rotate-function",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "X = 10, Y = 20",
      "slug" : "rotated-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "41",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "40",
      "input" : "X = 100, Y = 200",
      "slug" : "rotated-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "4",
      "input" : "X = 10, Y = 20",
      "slug" : "rotated-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "41",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "40",
      "input" : "X = 100, Y = 200",
      "slug" : "rotated-digits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
      "input" : "left = 1, right = 22",
      "slug" : "self-dividing-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[48,55,66,77]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[48, 55, 66, 77]",
      "input" : "left = 47, right = 85",
      "slug" : "self-dividing-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
      "input" : "left = 1, right = 22",
      "slug" : "self-dividing-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[48,55,66,77]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[48, 55, 66, 77]",
      "input" : "left = 47, right = 85",
      "slug" : "self-dividing-numbers",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:30: error: expected ',' separator\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                              `- error: expected ',' separator\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:8:27: error: use of local variable 'perms' before its declaration\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |             `- note: 'perms' declared here\n  8 |         permute(nums, 0, &perms)\n    |                           `- error: use of local variable 'perms' before its declaration\n  9 |         let idx = Int.random(in: 0..<perms.count)\n 10 |         return perms[idx]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:26: error: binary operator '>>' cannot be applied to operands of type 'Int.Type' and '()'\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                          `- error: binary operator '>>' cannot be applied to operands of type 'Int.Type' and '()'\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\nSwift.BinaryInteger.>>:2:13: note: candidate requires that '()' conform to 'BinaryInteger' (requirement specified as 'RHS' : 'BinaryInteger')\n1 | protocol BinaryInteger {\n2 | static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger}\n  |             `- note: candidate requires that '()' conform to 'BinaryInteger' (requirement specified as 'RHS' : 'BinaryInteger')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:26: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                          |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                          |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                          `- note: required by referencing operator function '>>' on 'BinaryInteger' where 'Self' = 'Int.Type'\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "[3,1,2]",
      "input" : "nums = [1,2,3]",
      "slug" : "shuffle-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:30: error: expected ',' separator\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                              `- error: expected ',' separator\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:8:27: error: use of local variable 'perms' before its declaration\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |             `- note: 'perms' declared here\n  8 |         permute(nums, 0, &perms)\n    |                           `- error: use of local variable 'perms' before its declaration\n  9 |         let idx = Int.random(in: 0..<perms.count)\n 10 |         return perms[idx]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:26: error: binary operator '>>' cannot be applied to operands of type 'Int.Type' and '()'\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                          `- error: binary operator '>>' cannot be applied to operands of type 'Int.Type' and '()'\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\nSwift.BinaryInteger.>>:2:13: note: candidate requires that '()' conform to 'BinaryInteger' (requirement specified as 'RHS' : 'BinaryInteger')\n1 | protocol BinaryInteger {\n2 | static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger}\n  |             `- note: candidate requires that '()' conform to 'BinaryInteger' (requirement specified as 'RHS' : 'BinaryInteger')\n3 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/shuffle-an-array_1\/solution.swift:7:26: error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n  5 | class Solution {\n  6 |     func shuffle(_ nums: [Int]) -> [Int] {\n  7 |         var perms = [[Int>>()\n    |                          |- error: type 'Int.Type' cannot conform to 'BinaryInteger' [#ProtocolTypeNonConformance]\n    |                          |- note: only concrete types such as structs, enums and classes can conform to protocols\n    |                          `- note: required by referencing operator function '>>' on 'BinaryInteger' where 'Self' = 'Int.Type'\n  8 |         permute(nums, 0, &perms)\n  9 |         let idx = Int.random(in: 0..<perms.count)\n\n[#ProtocolTypeNonConformance]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/protocol-type-non-conformance>\n",
      "expected" : "[2,1,1]",
      "input" : "nums = [1,1,2]",
      "slug" : "shuffle-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[1,3,2]",
      "approachName" : "Fisher-Yates Shuffle",
      "approachOrder" : 2,
      "expected" : "[2,3,1]",
      "input" : "nums = [1,2,3]",
      "slug" : "shuffle-an-array",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1,1,2]",
      "approachName" : "Fisher-Yates Shuffle",
      "approachOrder" : 2,
      "expected" : "[2,1,1]",
      "input" : "nums = [1,1,2]",
      "slug" : "shuffle-an-array",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-integer-divisible-by-k_1\/solution.swift:238:19: warning: expression implicitly coerced from 'Int?' to 'Any'\n236 | let arg0 = toInt(valueAt(args, 0))\n237 | let result = solution.smallestRepunitDivisibleByK(k: arg0)\n238 | let output: Any = result\n    |                   |- warning: expression implicitly coerced from 'Int?' to 'Any'\n    |                   |- note: provide a default value to avoid this warning\n    |                   |- note: force-unwrap the value to avoid this warning\n    |                   `- note: explicitly cast to 'Any' with 'as Any' to silence this warning\n239 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-integer-divisible-by-k_1\/solution.swift:7:5: error: cannot assign to value: 'remainder' is a 'let' constant\n  3 | class Solution {\n  4 | func smallestRepunitDivisibleByK(k: Int) -> Int? { \n  5 | let remainder = 0\n    | `- note: change 'let' to 'var' to make it mutable\n  6 | for n in 1...k * 10 {\n  7 |     remainder = (remainder * 10 + 1) % k\n    |     `- error: cannot assign to value: 'remainder' is a 'let' constant\n  8 |     if remainder == 0 {\n  9 |         return n\n",
      "expected" : "1",
      "input" : "k = 1",
      "slug" : "smallest-integer-divisible-by-k",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-integer-divisible-by-k_1\/solution.swift:238:19: warning: expression implicitly coerced from 'Int?' to 'Any'\n236 | let arg0 = toInt(valueAt(args, 0))\n237 | let result = solution.smallestRepunitDivisibleByK(k: arg0)\n238 | let output: Any = result\n    |                   |- warning: expression implicitly coerced from 'Int?' to 'Any'\n    |                   |- note: provide a default value to avoid this warning\n    |                   |- note: force-unwrap the value to avoid this warning\n    |                   `- note: explicitly cast to 'Any' with 'as Any' to silence this warning\n239 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-integer-divisible-by-k_1\/solution.swift:7:5: error: cannot assign to value: 'remainder' is a 'let' constant\n  3 | class Solution {\n  4 | func smallestRepunitDivisibleByK(k: Int) -> Int? { \n  5 | let remainder = 0\n    | `- note: change 'let' to 'var' to make it mutable\n  6 | for n in 1...k * 10 {\n  7 |     remainder = (remainder * 10 + 1) % k\n    |     `- error: cannot assign to value: 'remainder' is a 'let' constant\n  8 |     if remainder == 0 {\n  9 |         return n\n",
      "expected" : "11",
      "input" : "k = 2",
      "slug" : "smallest-integer-divisible-by-k",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Math",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "k = 2",
      "slug" : "smallest-integer-divisible-by-k",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:66: error: binary operator '??' cannot be applied to operands of type 'ClosedRange<Int>' and 'Int'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                                                  `- error: binary operator '??' cannot be applied to operands of type 'ClosedRange<Int>' and 'Int'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:45: error: binary operator '??' cannot be applied to operands of type 'Int?' and 'ClosedRange<Int>'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                             `- error: binary operator '??' cannot be applied to operands of type 'Int?' and 'ClosedRange<Int>'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:45: error: no '??' overloads produce result type that conforms to 'Sequence'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                             `- error: no '??' overloads produce result type that conforms to 'Sequence'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\nSwift.??:1:13: note: result type 'Int' of '??' does not conform to 'Sequence'\n1 | public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T) rethrows -> T where T : ~Copyable\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'ClosedRange<Int>?' of '??' does not conform to 'Sequence'\n  |             `- note: result type 'Int' of '??' does not conform to 'Sequence'\n\nSwift.??:1:13: note: result type 'Int?' of '??' does not conform to 'Sequence'\n1 | public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? where T : ~Copyable\n  |             |- note: result type 'Int?' of '??' does not conform to 'Sequence'\n  |             `- note: result type 'ClosedRange<Int>?' of '??' does not conform to 'Sequence'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:60: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                                            |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                            |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                            `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:11:50: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n    |                                                  |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                  |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                  `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:11:59: error: cannot convert value of type 'Int' to expected argument type 'ClosedRange<Int>'\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n    |                                                           `- error: cannot convert value of type 'Int' to expected argument type 'ClosedRange<Int>'\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:12:36: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n    |                                    `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 13 |                                if high - low < minRange[1] - minRange[0] {\n 14 |                                    minRange = [low, high]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:13:46: error: binary operator '<' cannot be applied to operands of type 'Duration' and 'Int'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n    |                                              |- error: binary operator '<' cannot be applied to operands of type 'Duration' and 'Int'\n    |                                              `- note: overloads for '<' exist with these partially matching parameter lists: (Duration, Duration), (Int, Int)\n 14 |                                    minRange = [low, high]\n 15 |                                }\n",
      "expected" : "[1,1]",
      "input" : "nums = [[1,2,3],[1,2,3],[1,2,3]], k = 0",
      "slug" : "smallest-range-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:66: error: binary operator '??' cannot be applied to operands of type 'ClosedRange<Int>' and 'Int'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                                                  `- error: binary operator '??' cannot be applied to operands of type 'ClosedRange<Int>' and 'Int'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:45: error: binary operator '??' cannot be applied to operands of type 'Int?' and 'ClosedRange<Int>'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                             `- error: binary operator '??' cannot be applied to operands of type 'Int?' and 'ClosedRange<Int>'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:45: error: no '??' overloads produce result type that conforms to 'Sequence'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                             `- error: no '??' overloads produce result type that conforms to 'Sequence'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\nSwift.??:1:13: note: result type 'Int' of '??' does not conform to 'Sequence'\n1 | public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T) rethrows -> T where T : ~Copyable\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'Int' of '??' does not conform to 'Sequence'\n  |             |- note: result type 'ClosedRange<Int>?' of '??' does not conform to 'Sequence'\n  |             `- note: result type 'Int' of '??' does not conform to 'Sequence'\n\nSwift.??:1:13: note: result type 'Int?' of '??' does not conform to 'Sequence'\n1 | public func ?? <T>(optional: consuming T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? where T : ~Copyable\n  |             |- note: result type 'Int?' of '??' does not conform to 'Sequence'\n  |             `- note: result type 'ClosedRange<Int>?' of '??' does not conform to 'Sequence'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:10:60: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  8 |            for i in 0..<n {\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n    |                                                            |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                            |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                            `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:11:50: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n    |                                                  |- error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    |                                                  |- note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    |                                                  `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:11:59: error: cannot convert value of type 'Int' to expected argument type 'ClosedRange<Int>'\n  9 |                for j in i..<n {\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n    |                                                           `- error: cannot convert value of type 'Int' to expected argument type 'ClosedRange<Int>'\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:12:36: error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 10 |                    for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n    |                                    `- error: cannot convert value of type 'Duration' to expected argument type 'Int'\n 13 |                                if high - low < minRange[1] - minRange[0] {\n 14 |                                    minRange = [low, high]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_1\/solution.swift:13:46: error: binary operator '<' cannot be applied to operands of type 'Duration' and 'Int'\n 11 |                        for high in low...nums[j].max() ?? 0 {\n 12 |                            if high - low <= k {\n 13 |                                if high - low < minRange[1] - minRange[0] {\n    |                                              |- error: binary operator '<' cannot be applied to operands of type 'Duration' and 'Int'\n    |                                              `- note: overloads for '<' exist with these partially matching parameter lists: (Duration, Duration), (Int, Int)\n 14 |                                    minRange = [low, high]\n 15 |                                }\n",
      "expected" : "[3,5]",
      "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]], k = 2",
      "slug" : "smallest-range-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func smallestRange(_ nums: [[Int]], _ k: Int) -> [Int] {\n",
      "expected" : "[1,1]",
      "input" : "nums = [[1,2,3],[1,2,3],[1,2,3]], k = 0",
      "slug" : "smallest-range-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-i_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func smallestRange(_ nums: [[Int]], _ k: Int) -> [Int] {\n",
      "expected" : "[3,5]",
      "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]], k = 2",
      "slug" : "smallest-range-i",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected 'func' keyword in instance method declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:6: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    |      `- error: expected '(' in argument list of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:1: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected '{' in body of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n",
      "expected" : "3",
      "input" : "nums = [1,3,6], k = 3",
      "slug" : "smallest-range-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected 'func' keyword in instance method declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:6: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    |      `- error: expected '(' in argument list of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_1\/solution.swift:4:1: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected '{' in body of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let n = nums.count\n",
      "expected" : "4",
      "input" : "nums = [7,8,8,8], k = 5",
      "slug" : "smallest-range-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected 'func' keyword in instance method declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:6: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    |      `- error: expected '(' in argument list of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:1: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected '{' in body of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n",
      "expected" : "3",
      "input" : "nums = [1,3,6], k = 3",
      "slug" : "smallest-range-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:1: error: expected 'func' keyword in instance method declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected 'func' keyword in instance method declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:6: error: expected '(' in argument list of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    |      `- error: expected '(' in argument list of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/smallest-range-ii_2\/solution.swift:4:1: error: expected '{' in body of function declaration\n  2 | \n  3 | class Solution {\n  4 | Swift\n    | `- error: expected '{' in body of function declaration\n  5 | func smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n  6 |     let nums = nums.sorted()\n",
      "expected" : "0",
      "input" : "nums = [7,8,8,8], k = 5",
      "slug" : "smallest-range-ii",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force\/Baseline",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "x=2",
      "input" : "equation = \"x+5-3+x=6+x-2\"",
      "slug" : "solve-the-equation",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "",
      "approachName" : "Brute-Force\/Baseline",
      "approachOrder" : 1,
      "error" : "",
      "expected" : "Infinite solutions",
      "input" : "equation = \"x=x\"",
      "slug" : "solve-the-equation",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"x=(x)\"",
      "approachName" : "Brute-Force\/Baseline",
      "approachOrder" : 1,
      "expected" : "x=0",
      "input" : "equation = \"2x=x\"",
      "slug" : "solve-the-equation",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:8:48: error: invalid escape sequence in literal\n  6 |            class Solution {\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n    |                                                `- error: invalid escape sequence in literal\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:9:86: error: incorrect argument label in call (have 'for:', expected 'of:')\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n    |                                                                                      `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n 11 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:10:87: error: incorrect argument label in call (have 'for:', expected 'of:')\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n    |                                                                                       `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 11 | \n 12 |                    var xLeft = 0\n",
      "expected" : "x=2",
      "input" : "equation = \"x+5-3+x=6+x-2\"",
      "slug" : "solve-the-equation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:8:48: error: invalid escape sequence in literal\n  6 |            class Solution {\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n    |                                                `- error: invalid escape sequence in literal\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:9:86: error: incorrect argument label in call (have 'for:', expected 'of:')\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n    |                                                                                      `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n 11 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:10:87: error: incorrect argument label in call (have 'for:', expected 'of:')\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n    |                                                                                       `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 11 | \n 12 |                    var xLeft = 0\n",
      "expected" : "Infinite solutions",
      "input" : "equation = \"x=x\"",
      "slug" : "solve-the-equation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:8:48: error: invalid escape sequence in literal\n  6 |            class Solution {\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n    |                                                `- error: invalid escape sequence in literal\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:9:86: error: incorrect argument label in call (have 'for:', expected 'of:')\n  7 |                func solveEquation(_ equation: String) -> String {\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n    |                                                                                      `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n 11 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/solve-the-equation_2\/solution.swift:10:87: error: incorrect argument label in call (have 'for:', expected 'of:')\n  8 |                    let regex = \"([+-]?d*x|[+-]\\d+)\"\n  9 |                    let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n 10 |                    let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n    |                                                                                       `- error: incorrect argument label in call (have 'for:', expected 'of:')\n 11 | \n 12 |                    var xLeft = 0\n",
      "expected" : "x=0",
      "input" : "equation = \"2x=x\"",
      "slug" : "solve-the-equation",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "1.0",
      "input" : "n = 50",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "0.25",
      "input" : "n = 4",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "0.5",
      "input" : "n = 8",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "1.0",
      "input" : "n = 50",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "0.25",
      "input" : "n = 4",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/soup-servings_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func soupServings(_ n: Int) -> Double {\n",
      "expected" : "0.5",
      "input" : "n = 8",
      "slug" : "soup-servings",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    var i = 0 \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:236:23: error: value of type 'Solution' has no member 'mySqrt'\n234 | \n235 | let arg0 = toInt(valueAt(args, 0))\n236 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n237 | let output: Any = result\n238 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "x = 4",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    var i = 0 \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:236:23: error: value of type 'Solution' has no member 'mySqrt'\n234 | \n235 | let arg0 = toInt(valueAt(args, 0))\n236 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n237 | let output: Any = result\n238 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "x = 8",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    var i = 0 \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_1\/solution.swift:236:23: error: value of type 'Solution' has no member 'mySqrt'\n234 | \n235 | let arg0 = toInt(valueAt(args, 0))\n236 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n237 | let output: Any = result\n238 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "x = 9",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    if x == 0 || x == 1 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'mySqrt'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n249 | let output: Any = result\n250 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "x = 4",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    if x == 0 || x == 1 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'mySqrt'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n249 | let output: Any = result\n250 | print(jsonString(from: output))\n",
      "expected" : "2",
      "input" : "x = 8",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    if x == 0 || x == 1 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'mySqrt'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n249 | let output: Any = result\n250 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "x = 9",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Binary Search",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:4:1: error: expected declaration\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |       `- note: in declaration of 'Solution'\n  4 | ( \n    | `- error: expected declaration\n  5 |                func mySqrt(_ x: Int) -> Int { \n  6 |                    if x == 0 || x == 1 { \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/sqrtx_2\/solution.swift:248:23: error: value of type 'Solution' has no member 'mySqrt'\n246 | \n247 | let arg0 = toInt(valueAt(args, 0))\n248 | let result = solution.mySqrt(arg0)\n    |                       `- error: value of type 'Solution' has no member 'mySqrt'\n249 | let output: Any = result\n250 | print(jsonString(from: output))\n",
      "expected" : "4",
      "input" : "x = 16",
      "slug" : "sqrtx",
      "status" : "COMPILE_ERROR",
      "testIndex" : 3
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/stone-game_1\/solution.swift:22:20: error: cannot assign through subscript: 'memo' is a 'let' constant\n  7 |     func stoneGame(_ piles: [Int]) -> Bool {\n  8 |         let n = piles.count\n  9 |         let memo: [[Int?]] = Array(repeating: Array(repeating: nil, count: n), count: n)\n    |         `- note: change 'let' to 'var' to make it mutable\n 10 |         \n 11 |         func dp(_ i: Int, _ j: Int) -> Int {\n    :\n 20 |             let pickFirst = dp(i + 1, j) + piles[i]\n 21 |             let pickLast = dp(i, j - 1) + piles[j]\n 22 |             memo[i][j] = max(pickFirst, pickLast)\n    |                    `- error: cannot assign through subscript: 'memo' is a 'let' constant\n 23 |             return memo[i][j]!\n 24 |         }\n",
      "expected" : "true",
      "input" : "piles = [5,3,4,5]",
      "slug" : "stone-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/stone-game_1\/solution.swift:22:20: error: cannot assign through subscript: 'memo' is a 'let' constant\n  7 |     func stoneGame(_ piles: [Int]) -> Bool {\n  8 |         let n = piles.count\n  9 |         let memo: [[Int?]] = Array(repeating: Array(repeating: nil, count: n), count: n)\n    |         `- note: change 'let' to 'var' to make it mutable\n 10 |         \n 11 |         func dp(_ i: Int, _ j: Int) -> Int {\n    :\n 20 |             let pickFirst = dp(i + 1, j) + piles[i]\n 21 |             let pickLast = dp(i, j - 1) + piles[j]\n 22 |             memo[i][j] = max(pickFirst, pickLast)\n    |                    `- error: cannot assign through subscript: 'memo' is a 'let' constant\n 23 |             return memo[i][j]!\n 24 |         }\n",
      "expected" : "true",
      "input" : "piles = [3,7,2,3]",
      "slug" : "stone-game",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:74: error: expected ',' separator\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                          `- error: expected ',' separator\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:120: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:120: error: expected expression\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                                        `- error: expected expression\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:78: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                              |- error: no exact matches in call to initializer \n    |                                                                              `- note: found candidate with type '(Int.ParseInput, Int) throws -> Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:63: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                               |- error: no exact matches in call to global function 'pow'\n    |                                                               |- note: candidate has partially matching parameter list (Decimal, Int)\n    |                                                               `- note: candidate has partially matching parameter list (Float, Float)\n  5 | }\n  6 | \n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate has partially matching parameter list (Double, Double)\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate has partially matching parameter list (Double, Double)\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:100: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                    `- error: no exact matches in call to global function 'pow'\n  5 | }\n  6 | \n\n_DarwinFoundation1.pow:2:13: note: candidate expects value of type 'Float' for parameter #1 (got 'Int')\n1 | @available(macOS 10.9, iOS 7.0, watchOS 2.0, tvOS 9.0, visionOS 1.0, *)\n2 | public func pow(_ lhs: Float, _ rhs: Float) -> Float\n  |             `- note: candidate expects value of type 'Float' for parameter #1 (got 'Int')\n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate expects value of type 'Double' for parameter #1 (got 'Int')\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate expects value of type 'Double' for parameter #1 (got 'Int')\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:74: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                          |- error: no exact matches in call to global function 'pow'\n    |                                                                          |- note: candidate has partially matching parameter list (Decimal, Int)\n    |                                                                          `- note: candidate has partially matching parameter list (Float, Float)\n  5 | }\n  6 | \n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate has partially matching parameter list (Double, Double)\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate has partially matching parameter list (Double, Double)\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:63: error: no 'pow' candidates produce the expected contextual result type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                               `- error: no 'pow' candidates produce the expected contextual result type 'Int'\n  5 | }\n  6 | \n\nFoundation.pow:2:13: note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n1 | @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)\n2 | public func pow(_ x: Decimal, _ y: Int) -> Decimal\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             `- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n\n_DarwinFoundation1.pow:2:13: note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n1 | @available(macOS 10.9, iOS 7.0, watchOS 2.0, tvOS 9.0, visionOS 1.0, *)\n2 | public func pow(_ lhs: Float, _ rhs: Float) -> Float\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             `- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               `- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:94: error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments, but 3 were used in closure body\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                              `- error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments, but 3 were used in closure body\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "a = 2, b = [3], c = 3",
      "slug" : "super-pow",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:74: error: expected ',' separator\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                          `- error: expected ',' separator\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:120: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:120: error: expected expression\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                                        `- error: expected expression\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:78: error: no exact matches in call to initializer \n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                              |- error: no exact matches in call to initializer \n    |                                                                              `- note: found candidate with type '(Int.ParseInput, Int) throws -> Int'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:63: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                               |- error: no exact matches in call to global function 'pow'\n    |                                                               |- note: candidate has partially matching parameter list (Decimal, Int)\n    |                                                               `- note: candidate has partially matching parameter list (Float, Float)\n  5 | }\n  6 | \n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate has partially matching parameter list (Double, Double)\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate has partially matching parameter list (Double, Double)\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:100: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                                    `- error: no exact matches in call to global function 'pow'\n  5 | }\n  6 | \n\n_DarwinFoundation1.pow:2:13: note: candidate expects value of type 'Float' for parameter #1 (got 'Int')\n1 | @available(macOS 10.9, iOS 7.0, watchOS 2.0, tvOS 9.0, visionOS 1.0, *)\n2 | public func pow(_ lhs: Float, _ rhs: Float) -> Float\n  |             `- note: candidate expects value of type 'Float' for parameter #1 (got 'Int')\n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate expects value of type 'Double' for parameter #1 (got 'Int')\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate expects value of type 'Double' for parameter #1 (got 'Int')\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:74: error: no exact matches in call to global function 'pow'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                          |- error: no exact matches in call to global function 'pow'\n    |                                                                          |- note: candidate has partially matching parameter list (Decimal, Int)\n    |                                                                          `- note: candidate has partially matching parameter list (Float, Float)\n  5 | }\n  6 | \n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: candidate has partially matching parameter list (Double, Double)\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               `- note: candidate has partially matching parameter list (Double, Double)\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:63: error: no 'pow' candidates produce the expected contextual result type 'Int'\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                               `- error: no 'pow' candidates produce the expected contextual result type 'Int'\n  5 | }\n  6 | \n\nFoundation.pow:2:13: note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n1 | @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)\n2 | public func pow(_ x: Decimal, _ y: Int) -> Decimal\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n  |             `- note: 'pow' produces 'Decimal', not the expected contextual result type 'Int'\n\n_DarwinFoundation1.pow:2:13: note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n1 | @available(macOS 10.9, iOS 7.0, watchOS 2.0, tvOS 9.0, visionOS 1.0, *)\n2 | public func pow(_ lhs: Float, _ rhs: Float) -> Float\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             |- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n  |             `- note: 'pow' produces 'Float', not the expected contextual result type 'Int'\n\n\/Applications\/Xcode_26.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX26.0.sdk\/usr\/include\/math.h:453:15: note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n451 | \n452 | extern float powf(float, float);\n453 | extern double pow(double, double);\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               |- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n    |               `- note: 'pow' produces 'Double', not the expected contextual result type 'Int'\n454 | extern long double powl(long double, long double);\n455 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/super-pow_1\/solution.swift:4:94: error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments, but 3 were used in closure body\n  2 | \n  3 | class Solution {\n  4 | func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }\n    |                                                                                              `- error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments, but 3 were used in closure body\n  5 | }\n  6 | \n",
      "expected" : "1024",
      "input" : "a = 2, b = [1, 0], c = 3",
      "slug" : "super-pow",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "8",
      "input" : "a = 2, b = [3], c = 3",
      "slug" : "super-pow",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1024",
      "input" : "a = 2, b = [1, 0], c = 3",
      "slug" : "super-pow",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "18",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "34",
      "input" : "grid = [[1,2],[3,4]]",
      "slug" : "surface-area-of-3d-shapes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "16",
      "input" : "grid = [[1,0],[0,1]]",
      "slug" : "surface-area-of-3d-shapes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "-6",
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "expected" : "26",
      "input" : "grid = [[1,1,1],[1,1,1],[1,1,1]]",
      "slug" : "surface-area-of-3d-shapes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "12",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "16",
      "input" : "grid = [[1,0],[0,1]]",
      "slug" : "surface-area-of-3d-shapes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "30",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "26",
      "input" : "grid = [[1,1,1],[1,1,1],[1,1,1]]",
      "slug" : "surface-area-of-3d-shapes",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "11",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "10",
      "input" : "nums = [1,2,3,4]",
      "slug" : "total-hamming-distance",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "11",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "10",
      "input" : "nums = [1,2,3,4]",
      "slug" : "total-hamming-distance",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ugly-number_1\/solution.swift:10:24: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |                for prime in primes {\n  9 |                   while n % prime == 0 {\n 10 |                      n \/= prime\n    |                        `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 11 |                   }\n 12 |                }\n",
      "expected" : "true",
      "input" : "n = 6",
      "slug" : "ugly-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ugly-number_1\/solution.swift:10:24: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |                for prime in primes {\n  9 |                   while n % prime == 0 {\n 10 |                      n \/= prime\n    |                        `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 11 |                   }\n 12 |                }\n",
      "expected" : "true",
      "input" : "n = 8",
      "slug" : "ugly-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/ugly-number_1\/solution.swift:10:24: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |                for prime in primes {\n  9 |                   while n % prime == 0 {\n 10 |                      n \/= prime\n    |                        `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 11 |                   }\n 12 |                }\n",
      "expected" : "false",
      "input" : "n = 14",
      "slug" : "ugly-number",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-binary-search-trees_1\/solution.swift:24:9: error: cannot assign through subscript: 'memo' is a 'let' constant\n  3 | class Solution {\n  4 | \n  5 | let memo = [Int: Int]()\n    | `- note: change 'let' to 'var' to make it mutable\n  6 | func numTrees(_ n: Int) -> Int {\n  7 |     if n == 0 {\n    :\n 22 |     }\n 23 |     \n 24 |     memo[n] = res\n    |         `- error: cannot assign through subscript: 'memo' is a 'let' constant\n 25 |     return res\n 26 | }\n",
      "expected" : "5",
      "input" : "n = 3",
      "slug" : "unique-binary-search-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/unique-binary-search-trees_1\/solution.swift:24:9: error: cannot assign through subscript: 'memo' is a 'let' constant\n  3 | class Solution {\n  4 | \n  5 | let memo = [Int: Int]()\n    | `- note: change 'let' to 'var' to make it mutable\n  6 | func numTrees(_ n: Int) -> Int {\n  7 |     if n == 0 {\n    :\n 22 |     }\n 23 |     \n 24 |     memo[n] = res\n    |         `- error: cannot assign through subscript: 'memo' is a 'let' constant\n 25 |     return res\n 26 | }\n",
      "expected" : "1",
      "input" : "n = 1",
      "slug" : "unique-binary-search-trees",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-square_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "p1 = [1,1], p2 = [1, 0], p3 = [0,1], p4 = [0,0]",
      "slug" : "valid-square",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-square_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "p1 = [0,1], p2 = [2,1], p3 = [1,2], p4 = [1,0]",
      "slug" : "valid-square",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-square_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "p1 = [1,1], p2 = [1, 0], p3 = [0,1], p4 = [0,0]",
      "slug" : "valid-square",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-square_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n",
      "expected" : "true",
      "input" : "p1 = [0,1], p2 = [2,1], p3 = [1,2], p4 = [1,0]",
      "slug" : "valid-square",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:9:18: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n    |                  `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 10 | \n 11 |     while !queue.isEmpty {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:12:34: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n 10 | \n 11 |     while !queue.isEmpty {\n 12 |         let (jug1, jug2) = queue.removeFirst()\n    |                                  `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 13 | \n 14 |         if jug1 == targetCapacity || jug2 == targetCapacity || jug1 + jug2 == targetCapacity {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:23:75: error: cannot convert value of type 'String' to expected argument type 'Int'\n 21 |             (0, jug2),\n 22 |             (jug1, 0),\n 23 |             (max(0, jug1 - (jug2Capacity - jug2)), min(jug2Capacity, jug2 + jug1)),\n    |                                                                           `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 24 |             (min(jug1Capacity, jug1 + jug2), max(0, jug2 - (jug1Capacity - jug1)))\n 25 |         ]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:24:37: error: cannot convert value of type 'String' to expected argument type 'Int'\n 22 |             (jug1, 0),\n 23 |             (max(0, jug1 - (jug2Capacity - jug2)), min(jug2Capacity, jug2 + jug1)),\n 24 |             (min(jug1Capacity, jug1 + jug2), max(0, jug2 - (jug1Capacity - jug1)))\n    |                                     `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 25 |         ]\n 26 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:29:23: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n 10 | \n    :\n 27 |         for state in states {\n 28 |             if !visited.contains(state) {\n 29 |                 queue.append(state)\n    |                       `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 30 |                 visited.insert(state)\n 31 |             }\n",
      "expected" : "True",
      "input" : "jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4",
      "slug" : "water-and-jug-problem",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:9:18: error: type '(Int, Int)' does not conform to protocol 'Hashable'\n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n    |                  `- error: type '(Int, Int)' does not conform to protocol 'Hashable'\n 10 | \n 11 |     while !queue.isEmpty {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:12:34: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n 10 | \n 11 |     while !queue.isEmpty {\n 12 |         let (jug1, jug2) = queue.removeFirst()\n    |                                  `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 13 | \n 14 |         if jug1 == targetCapacity || jug2 == targetCapacity || jug1 + jug2 == targetCapacity {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:23:75: error: cannot convert value of type 'String' to expected argument type 'Int'\n 21 |             (0, jug2),\n 22 |             (jug1, 0),\n 23 |             (max(0, jug1 - (jug2Capacity - jug2)), min(jug2Capacity, jug2 + jug1)),\n    |                                                                           `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 24 |             (min(jug1Capacity, jug1 + jug2), max(0, jug2 - (jug1Capacity - jug1)))\n 25 |         ]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:24:37: error: cannot convert value of type 'String' to expected argument type 'Int'\n 22 |             (jug1, 0),\n 23 |             (max(0, jug1 - (jug2Capacity - jug2)), min(jug2Capacity, jug2 + jug1)),\n 24 |             (min(jug1Capacity, jug1 + jug2), max(0, jug2 - (jug1Capacity - jug1)))\n    |                                     `- error: cannot convert value of type 'String' to expected argument type 'Int'\n 25 |         ]\n 26 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/water-and-jug-problem_1\/solution.swift:29:23: error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n  6 | \n  7 | func canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n  8 |     let queue: [(Int, Int)] = [(0, 0)]\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     var visited: Set<(Int, Int)> = [(0, 0)]\n 10 | \n    :\n 27 |         for state in states {\n 28 |             if !visited.contains(state) {\n 29 |                 queue.append(state)\n    |                       `- error: cannot use mutating member on immutable value: 'queue' is a 'let' constant\n 30 |                 visited.insert(state)\n 31 |             }\n",
      "expected" : "False",
      "input" : "jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5",
      "slug" : "water-and-jug-problem",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Math-Based Approach",
      "approachOrder" : 2,
      "expected" : "True",
      "input" : "jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4",
      "slug" : "water-and-jug-problem",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Math-Based Approach",
      "approachOrder" : 2,
      "expected" : "False",
      "input" : "jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5",
      "slug" : "water-and-jug-problem",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:1: error: expected 'func' keyword in instance method declaration\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    | `- error: expected 'func' keyword in instance method declaration\n 27 | \n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:7: error: expected parameter name followed by ':'\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    |       `- error: expected parameter name followed by ':'\n 27 | \n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:10:20: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  6 | let handSize = 3\n  7 | func isNStraightHand(deck: [Int], handSize: Int) -> Bool {\n  8 |     let count = Array(repeating: 0, count: 1001)\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     for num in deck {\n 10 |         count[num] += 1\n    |                    `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n 11 |     }\n 12 |     for num in 1...1000 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:1: error: expected '{' in body of function declaration\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    | `- error: expected '{' in body of function declaration\n 27 | \n 28 | }\n",
      "expected" : "true",
      "input" : "deck = [1,1,1,2,2,2,3,3,3,4,4,4,4], handSize = 3",
      "slug" : "x-of-a-kind-in-a-deck-of-cards",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:1: error: expected 'func' keyword in instance method declaration\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    | `- error: expected 'func' keyword in instance method declaration\n 27 | \n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:7: error: expected parameter name followed by ':'\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    |       `- error: expected parameter name followed by ':'\n 27 | \n 28 | }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:10:20: error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n  6 | let handSize = 3\n  7 | func isNStraightHand(deck: [Int], handSize: Int) -> Bool {\n  8 |     let count = Array(repeating: 0, count: 1001)\n    |     `- note: change 'let' to 'var' to make it mutable\n  9 |     for num in deck {\n 10 |         count[num] += 1\n    |                    `- error: left side of mutating operator isn't mutable: 'count' is a 'let' constant\n 11 |     }\n 12 |     for num in 1...1000 {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/x-of-a-kind-in-a-deck-of-cards_1\/solution.swift:26:1: error: expected '{' in body of function declaration\n 24 |     return true\n 25 | }\n 26 | print(isNStraightHand(deck: deck, handSize: handSize))\n    | `- error: expected '{' in body of function declaration\n 27 | \n 28 | }\n",
      "expected" : "true",
      "input" : "deck = [1,1,1,1,1], handSize = 3",
      "slug" : "x-of-a-kind-in-a-deck-of-cards",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "deck = [1,1,1,2,2,2,3,3,3,4,4,4,4], handSize = 3",
      "slug" : "x-of-a-kind-in-a-deck-of-cards",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "false",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "deck = [1,1,1,1,1], handSize = 3",
      "slug" : "x-of-a-kind-in-a-deck-of-cards",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_1\/solution.swift:4:206: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { let binary = String(N, radix: 2); var maxGap = 0; var prevOne = -1; for (i, c) in binary.enumerated() { if c == \"1\" { if prevOne != -1 { maxGap = max(maxGap, i - prevOne); } prevOne = i; } } return maxGap; }\n    |                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_1\/solution.swift:4:223: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { let binary = String(N, radix: 2); var maxGap = 0; var prevOne = -1; for (i, c) in binary.enumerated() { if c == \"1\" { if prevOne != -1 { maxGap = max(maxGap, i - prevOne); } prevOne = i; } } return maxGap; }\n    |                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "22",
      "slug" : "binary-gap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_1\/solution.swift:4:206: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { let binary = String(N, radix: 2); var maxGap = 0; var prevOne = -1; for (i, c) in binary.enumerated() { if c == \"1\" { if prevOne != -1 { maxGap = max(maxGap, i - prevOne); } prevOne = i; } } return maxGap; }\n    |                                                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_1\/solution.swift:4:223: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { let binary = String(N, radix: 2); var maxGap = 0; var prevOne = -1; for (i, c) in binary.enumerated() { if c == \"1\" { if prevOne != -1 { maxGap = max(maxGap, i - prevOne); } prevOne = i; } } return maxGap; }\n    |                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "2",
      "input" : "5",
      "slug" : "binary-gap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:174: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:201: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:211: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:150: error: value of type 'Int' has no member 'bitPosition'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                      `- error: value of type 'Int' has no member 'bitPosition'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:187: error: value of type 'Int' has no member 'bitPosition'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                           `- error: value of type 'Int' has no member 'bitPosition'\n  5 | }\n  6 | \n",
      "expected" : "1",
      "input" : "6",
      "slug" : "binary-gap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:174: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                              `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:201: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                                         `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:211: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                                                   `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:150: error: value of type 'Int' has no member 'bitPosition'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                      `- error: value of type 'Int' has no member 'bitPosition'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-gap_2\/solution.swift:4:187: error: value of type 'Int' has no member 'bitPosition'\n  2 | \n  3 | class Solution {\n  4 | func binaryGap(N: Int) -> Int { var n = N; var maxGap = 0; var prevOne = -1; while n > 0 { if n % 2 == 1 { if prevOne != -1 { maxGap = max(maxGap, n.bitPosition - prevOne) } prevOne = n.bitPosition; } n \/= 2; } return maxGap; }\n    |                                                                                                                                                                                           `- error: value of type 'Int' has no member 'bitPosition'\n  5 | }\n  6 | \n",
      "expected" : "0",
      "input" : "8",
      "slug" : "binary-gap",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:7:7: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | func hasAlternatingBits(_ n: Int) -> Bool {\n  6 |     var previousBit = n & 1\n  7 |     n >>= 1\n    |       `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |     while n > 0 {\n  9 |         let currentBit = n & 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:14:11: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 12 |         }\n 13 |         previousBit = currentBit\n 14 |         n >>= 1\n    |           `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 15 |     }\n 16 |     return true\n",
      "expected" : "true",
      "input" : "n = 5",
      "slug" : "binary-number-with-alternating-bits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:7:7: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | func hasAlternatingBits(_ n: Int) -> Bool {\n  6 |     var previousBit = n & 1\n  7 |     n >>= 1\n    |       `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |     while n > 0 {\n  9 |         let currentBit = n & 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:14:11: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 12 |         }\n 13 |         previousBit = currentBit\n 14 |         n >>= 1\n    |           `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 15 |     }\n 16 |     return true\n",
      "expected" : "false",
      "input" : "n = 7",
      "slug" : "binary-number-with-alternating-bits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:7:7: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | func hasAlternatingBits(_ n: Int) -> Bool {\n  6 |     var previousBit = n & 1\n  7 |     n >>= 1\n    |       `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  8 |     while n > 0 {\n  9 |         let currentBit = n & 1\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-number-with-alternating-bits_2\/solution.swift:14:11: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 12 |         }\n 13 |         previousBit = currentBit\n 14 |         n >>= 1\n    |           `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n 15 |     }\n 16 |     return true\n",
      "expected" : "true",
      "input" : "n = 10",
      "slug" : "binary-number-with-alternating-bits",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "[1,0,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1,1,1]",
      "input" : "A = [0,1,1]",
      "slug" : "binary-prefix-divisible-by-5",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,0,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1,0,0]",
      "input" : "A = [1,1,1]",
      "slug" : "binary-prefix-divisible-by-5",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[1,0,0]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1,1,1]",
      "input" : "A = [0,1,1]",
      "slug" : "binary-prefix-divisible-by-5",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[0,0,0]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[1,0,0]",
      "input" : "A = [1,1,1]",
      "slug" : "binary-prefix-divisible-by-5",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-string-with-substrings-representing-1-to-n_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func queryString(_ S: String, _ N: Int) -> Bool {\n",
      "expected" : "true",
      "input" : "S = \"0110\", N = 3",
      "slug" : "binary-string-with-substrings-representing-1-to-n",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-string-with-substrings-representing-1-to-n_1\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func queryString(_ S: String, _ N: Int) -> Bool {\n",
      "expected" : "false",
      "input" : "S = \"0110\", N = 4",
      "slug" : "binary-string-with-substrings-representing-1-to-n",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-string-with-substrings-representing-1-to-n_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func queryString(_ S: String, _ N: Int) -> Bool {\n",
      "expected" : "true",
      "input" : "S = \"1011\", N = 3",
      "slug" : "binary-string-with-substrings-representing-1-to-n",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/binary-string-with-substrings-representing-1-to-n_2\/solution.swift:5:8: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |        import Foundation\n    |        `- error: declaration is only valid at file scope\n  6 | \n  7 |        func queryString(_ S: String, _ N: Int) -> Bool {\n",
      "expected" : "true",
      "input" : "S = \"0011\", N = 3",
      "slug" : "binary-string-with-substrings-representing-1-to-n",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bitwise-and-of-numbers-range_2\/solution.swift:4:83: error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func rangeBitwiseAnd(_ m: Int, _ n: Int) -> Int { var shift = 0; while m != n { m >>= 1; n >>= 1; shift += 1 }; return m << shift }\n    |                                                                                   `- error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bitwise-and-of-numbers-range_2\/solution.swift:4:92: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func rangeBitwiseAnd(_ m: Int, _ n: Int) -> Int { var shift = 0; while m != n { m >>= 1; n >>= 1; shift += 1 }; return m << shift }\n    |                                                                                            `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "m = 5, n = 7",
      "slug" : "bitwise-and-of-numbers-range",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bitwise-and-of-numbers-range_2\/solution.swift:4:83: error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func rangeBitwiseAnd(_ m: Int, _ n: Int) -> Int { var shift = 0; while m != n { m >>= 1; n >>= 1; shift += 1 }; return m << shift }\n    |                                                                                   `- error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/bitwise-and-of-numbers-range_2\/solution.swift:4:92: error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | func rangeBitwiseAnd(_ m: Int, _ n: Int) -> Int { var shift = 0; while m != n { m >>= 1; n >>= 1; shift += 1 }; return m << shift }\n    |                                                                                            `- error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n  5 | }\n  6 | \n",
      "expected" : "8",
      "input" : "m = 10, n = 15",
      "slug" : "bitwise-and-of-numbers-range",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-difference_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findTheDifference(_ s: String, _ t: String) -> Character { let countS = Dictionary(String(s).map { ($0, 1) }, uniquingKeysWith: +); let countT = Dictionary(String(t).map { ($0, 1) }, uniquingKeysWith: +); for (k, v) in countT { if countS[k] ?? 0 != v { return k } } fatalError() }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "e",
      "input" : "s = \"abcd\", t = \"abcde\"",
      "slug" : "find-the-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-difference_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findTheDifference(_ s: String, _ t: String) -> Character { let countS = Dictionary(String(s).map { ($0, 1) }, uniquingKeysWith: +); let countT = Dictionary(String(t).map { ($0, 1) }, uniquingKeysWith: +); for (k, v) in countT { if countS[k] ?? 0 != v { return k } } fatalError() }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "a",
      "input" : "s = \"\", t = \"a\"",
      "slug" : "find-the-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/find-the-difference_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func findTheDifference(_ s: String, _ t: String) -> Character { let countS = Dictionary(String(s).map { ($0, 1) }, uniquingKeysWith: +); let countT = Dictionary(String(t).map { ($0, 1) }, uniquingKeysWith: +); for (k, v) in countT { if countS[k] ?? 0 != v { return k } } fatalError() }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "a",
      "input" : "s = \"a\", t = \"aa\"",
      "slug" : "find-the-difference",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Swift\/StringCharacterView.swift:158: Fatal error: String index is out of bounds\n",
      "expected" : "2",
      "input" : "x = 1, y = 4",
      "slug" : "hamming-distance",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_1\/solution.swift:4:248: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var maxProduct = 0; for i in 0..<n { for j in (i+1)..<n { if !hasCommonCharacter(word1: words[i], word2: words[j]) { maxProduct = max(maxProduct, words[i].count * words[j].count) } } } return maxProduct }; func hasCommonCharacter(word1: String, word2: String) -> Bool { for char in word1 { if word2.contains(char) { return true } } return false }\n    |                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_1\/solution.swift:4:395: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var maxProduct = 0; for i in 0..<n { for j in (i+1)..<n { if !hasCommonCharacter(word1: words[i], word2: words[j]) { maxProduct = max(maxProduct, words[i].count * words[j].count) } } } return maxProduct }; func hasCommonCharacter(word1: String, word2: String) -> Bool { for char in word1 { if word2.contains(char) { return true } } return false }\n    |                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "16",
      "input" : "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"fxyz\",\"abc\"]",
      "slug" : "maximum-product-of-word-lengths",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_1\/solution.swift:4:248: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var maxProduct = 0; for i in 0..<n { for j in (i+1)..<n { if !hasCommonCharacter(word1: words[i], word2: words[j]) { maxProduct = max(maxProduct, words[i].count * words[j].count) } } } return maxProduct }; func hasCommonCharacter(word1: String, word2: String) -> Bool { for char in word1 { if word2.contains(char) { return true } } return false }\n    |                                                                                                                                                                                                                                                        `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_1\/solution.swift:4:395: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var maxProduct = 0; for i in 0..<n { for j in (i+1)..<n { if !hasCommonCharacter(word1: words[i], word2: words[j]) { maxProduct = max(maxProduct, words[i].count * words[j].count) } } } return maxProduct }; func hasCommonCharacter(word1: String, word2: String) -> Bool { for char in word1 { if word2.contains(char) { return true } } return false }\n    |                                                                                                                                                                                                                                                                                                                                                                                                           `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
      "slug" : "maximum-product-of-word-lengths",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_2\/solution.swift:4:184: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var masks = [Int](); var maxProduct = 0; for word in words { var mask = 0; for char in word { let bit = 1 << (Character(char).asciiValue! - 97); mask |= Int(bit) }; masks.append(mask) }; for i in 0..<n { for j in (i+1)..<n { if (masks[i] & masks[j]) == 0 { maxProduct = max(maxProduct, words[i].count * words[j].count) } } }; return maxProduct }\n    |                                                                                                                                                                                        `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n",
      "expected" : "16",
      "input" : "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"fxyz\",\"abc\"]",
      "slug" : "maximum-product-of-word-lengths",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-product-of-word-lengths_2\/solution.swift:4:184: error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  2 | \n  3 | class Solution {\n  4 | func maxProduct(words: [String]) -> Int { let n = words.count; var masks = [Int](); var maxProduct = 0; for word in words { var mask = 0; for char in word { let bit = 1 << (Character(char).asciiValue! - 97); mask |= Int(bit) }; masks.append(mask) }; for i in 0..<n { for j in (i+1)..<n { if (masks[i] & masks[j]) == 0 { maxProduct = max(maxProduct, words[i].count * words[j].count) } } }; return maxProduct }\n    |                                                                                                                                                                                        `- error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  5 | }\n  6 | \n",
      "expected" : "4",
      "input" : "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
      "slug" : "maximum-product-of-word-lengths",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Trie Optimization",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:13:57: error: cannot assign through subscript: 'children' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { let children = [Int:Int](); var EndOfNumber = false }\n    |                  `- note: change 'let' to 'var' to make it mutable\n  5 | let findMaximumXOR = { (nums: [Int]) -> Int in\n  6 |     var root = TrieNode()\n    :\n 11 |             let bit = tempNum & 1\n 12 |             tempNum >>= 1\n 13 |             if node.children[bit] == nil { node.children[bit] = TrieNode() }\n    |                                                         `- error: cannot assign through subscript: 'children' is a 'let' constant\n 14 |             node = node.children[bit]!\n 15 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:13:65: error: cannot assign value of type 'Solution.TrieNode' to subscript of type 'Int'\n 11 |             let bit = tempNum & 1\n 12 |             tempNum >>= 1\n 13 |             if node.children[bit] == nil { node.children[bit] = TrieNode() }\n    |                                                                 `- error: cannot assign value of type 'Solution.TrieNode' to subscript of type 'Int'\n 14 |             node = node.children[bit]!\n 15 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:265:23: error: value of type 'Solution' has no member 'find'\n263 | let arg0 = toInt(valueAt(args, 0))\n264 | let arg1 = valueAt(args, 1)\n265 | let result = solution.find(num: arg0, node: arg1)\n    |                       `- error: value of type 'Solution' has no member 'find'\n266 | let output: Any = result\n267 | print(jsonString(from: output))\n",
      "expected" : "15",
      "input" : "nums = [2,7,11,15]",
      "slug" : "maximum-xor-of-two-numbers-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Trie Optimization",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:13:57: error: cannot assign through subscript: 'children' is a 'let' constant\n  2 | \n  3 | class Solution {\n  4 | class TrieNode { let children = [Int:Int](); var EndOfNumber = false }\n    |                  `- note: change 'let' to 'var' to make it mutable\n  5 | let findMaximumXOR = { (nums: [Int]) -> Int in\n  6 |     var root = TrieNode()\n    :\n 11 |             let bit = tempNum & 1\n 12 |             tempNum >>= 1\n 13 |             if node.children[bit] == nil { node.children[bit] = TrieNode() }\n    |                                                         `- error: cannot assign through subscript: 'children' is a 'let' constant\n 14 |             node = node.children[bit]!\n 15 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:13:65: error: cannot assign value of type 'Solution.TrieNode' to subscript of type 'Int'\n 11 |             let bit = tempNum & 1\n 12 |             tempNum >>= 1\n 13 |             if node.children[bit] == nil { node.children[bit] = TrieNode() }\n    |                                                                 `- error: cannot assign value of type 'Solution.TrieNode' to subscript of type 'Int'\n 14 |             node = node.children[bit]!\n 15 |         }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/maximum-xor-of-two-numbers-in-an-array_2\/solution.swift:265:23: error: value of type 'Solution' has no member 'find'\n263 | let arg0 = toInt(valueAt(args, 0))\n264 | let arg1 = valueAt(args, 1)\n265 | let result = solution.find(num: arg0, node: arg1)\n    |                       `- error: value of type 'Solution' has no member 'find'\n266 | let output: Any = result\n267 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "nums = [0,1]",
      "slug" : "maximum-xor-of-two-numbers-in-an-array",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Bit Manipulation",
      "approachOrder" : 2,
      "expected" : "0",
      "input" : "1",
      "slug" : "number-complement",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Brian Kernighan's Algorithm",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "n = 11 (binary: 1011)",
      "slug" : "number-of-1-bits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Brian Kernighan's Algorithm",
      "approachOrder" : 1,
      "expected" : "1",
      "input" : "n = 128 (binary: 10000000)",
      "slug" : "number-of-1-bits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Brian Kernighan's Algorithm",
      "approachOrder" : 1,
      "expected" : "30",
      "input" : "n = 2147483645 (many 1s)",
      "slug" : "number-of-1-bits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "[\"AAAAACCCCC\"]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
      "input" : "s = \"AAAAACCCCCAAAAACCCCCC\"",
      "slug" : "repeated-dna-sequences",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Rolling Hash",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:26:85: error: cannot force unwrap value of non-optional type 'Int'\n 24 |         \/\/ Compute initial hash\n 25 |         for i in 0..<10 {\n 26 |             currentHash = (currentHash * base) % mod + nucleotideToIndex[sChars[i]]!!\n    |                                                                                     `- error: cannot force unwrap value of non-optional type 'Int'\n 27 |         }\n 28 |         \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:35:13: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 33 |         \/\/ Compute hashes for subsequent substrings\n 34 |         for i in 10..<(s.count) {\n 35 |             currentHash = (currentHash * base - nucleotideToIndex[sChars[i - 10]]! * power % mod + mod) % mod + nucleotideToIndex[sChars[i]]!!\n    |             `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 36 |             \n 37 |             if hashValues.contains(currentHash) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:63:79: error: cannot force unwrap value of non-optional type 'Int'\n 61 |         \n 62 |         for i in 0..<10 {\n 63 |             hash = (hash * base) % mod + nucleotideToIndex[substringChars[i]]!!\n    |                                                                               `- error: cannot force unwrap value of non-optional type 'Int'\n 64 |         }\n 65 |         \n",
      "expected" : "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
      "input" : "s = \"AAAAACCCCCAAAAACCCCCC\"",
      "slug" : "repeated-dna-sequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Rolling Hash",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:26:85: error: cannot force unwrap value of non-optional type 'Int'\n 24 |         \/\/ Compute initial hash\n 25 |         for i in 0..<10 {\n 26 |             currentHash = (currentHash * base) % mod + nucleotideToIndex[sChars[i]]!!\n    |                                                                                     `- error: cannot force unwrap value of non-optional type 'Int'\n 27 |         }\n 28 |         \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:35:13: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 33 |         \/\/ Compute hashes for subsequent substrings\n 34 |         for i in 10..<(s.count) {\n 35 |             currentHash = (currentHash * base - nucleotideToIndex[sChars[i - 10]]! * power % mod + mod) % mod + nucleotideToIndex[sChars[i]]!!\n    |             `- error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n 36 |             \n 37 |             if hashValues.contains(currentHash) {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/repeated-dna-sequences_2\/solution.swift:63:79: error: cannot force unwrap value of non-optional type 'Int'\n 61 |         \n 62 |         for i in 0..<10 {\n 63 |             hash = (hash * base) % mod + nucleotideToIndex[substringChars[i]]!!\n    |                                                                               `- error: cannot force unwrap value of non-optional type 'Int'\n 64 |         }\n 65 |         \n",
      "expected" : "[\"AAAAAAAAAA\"]",
      "input" : "s = \"AAAAAAAAAAA\"",
      "slug" : "repeated-dna-sequences",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "0",
      "approachName" : "Bit by Bit",
      "approachOrder" : 1,
      "expected" : "964176192 (00111001011110000010100101000000)",
      "input" : "n = 43261596 (00000010100101000001111010011100)",
      "slug" : "reverse-bits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "0",
      "approachName" : "Bit by Bit",
      "approachOrder" : 1,
      "expected" : "3221225471 (10111111111111111111111111111111)",
      "input" : "n = 4294967293 (11111111111111111111111111111101)",
      "slug" : "reverse-bits",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[2,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[2,3]",
      "input" : "nums = [1,2,2,4]",
      "slug" : "set-mismatch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[1,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[1,2]",
      "input" : "nums = [1,1]",
      "slug" : "set-mismatch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "[2,0]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[2,1]",
      "input" : "nums = [2,2]",
      "slug" : "set-mismatch",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "",
      "expected" : "[1,2]",
      "input" : "nums = [3,1]",
      "slug" : "set-mismatch",
      "status" : "RUNTIME_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "[5,3]",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "[3,5]",
      "input" : "nums = [1,2,1,3,2,5]",
      "slug" : "single-number-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[15,11]",
      "approachName" : "Bit Manipulation",
      "approachOrder" : 2,
      "expected" : "[11,15]",
      "input" : "nums = [2,7,11,15,2,7]",
      "slug" : "single-number-iii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "3",
      "input" : "nums = [1, 1, 2, 2, 3]",
      "slug" : "biggest-single-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "null",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "6",
      "input" : "nums = [4, 4, 5, 6]",
      "slug" : "biggest-single-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "3",
      "input" : "nums = [1, 1, 2, 2, 3]",
      "slug" : "biggest-single-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "null",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "6",
      "input" : "nums = [4, 4, 5, 6]",
      "slug" : "biggest-single-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "null",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "8",
      "input" : "nums = [7, 7, 8]",
      "slug" : "biggest-single-number",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:43: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:56: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "1",
      "input" : "1",
      "slug" : "count-and-say",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:43: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:56: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "11",
      "input" : "2",
      "slug" : "count-and-say",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:43: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                           `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/count-and-say_1\/solution.swift:11:56: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  9 |         while i < result.count {\n 10 |             var count = 1\n 11 |             while i + 1 < result.count && result[i] == result[i + 1] {\n    |                                                        `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 12 |                 i += 1\n 13 |                 count += 1\n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "21",
      "input" : "3",
      "slug" : "count-and-say",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "\"1211\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1211",
      "input" : "4",
      "slug" : "count-and-say",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"111221\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "111221",
      "input" : "5",
      "slug" : "count-and-say",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"312211\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "312211",
      "input" : "6",
      "slug" : "count-and-say",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"true\"",
      "input" : "\"USA\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"true\"",
      "input" : "\"leetcode\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"true\"",
      "input" : "\"Google\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "false",
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "expected" : "\"false\"",
      "input" : "\"gOogle\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 3
    },
    {
      "actual" : "true",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"true\"",
      "input" : "\"USA\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "true",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"true\"",
      "input" : "\"leetcode\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "true",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"true\"",
      "input" : "\"Google\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "\"false\"",
      "input" : "\"gOogle\"",
      "slug" : "detect-capital",
      "status" : "WRONG_ANSWER",
      "testIndex" : 3
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friend-requests-ii-who-has-the-most-friends_1\/solution.swift:254:19: warning: expression implicitly coerced from 'Int?' to 'Any'\n252 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n253 | let result = solution.findMostFriends(arg0)\n254 | let output: Any = result\n    |                   |- warning: expression implicitly coerced from 'Int?' to 'Any'\n    |                   |- note: provide a default value to avoid this warning\n    |                   |- note: force-unwrap the value to avoid this warning\n    |                   `- note: explicitly cast to 'Any' with 'as Any' to silence this warning\n255 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friend-requests-ii-who-has-the-most-friends_1\/solution.swift:11:51: error: cannot use mutating member on immutable value: subscript is get-only\n  9 |                    for request in requests {\n 10 |                        if let idx = friendships.firstIndex(where: { $0.value == request }) {\n 11 |                            friendships[idx].value.remove(at: 0)\n    |                                                   `- error: cannot use mutating member on immutable value: subscript is get-only\n 12 |                        } else {\n 13 |                            friendships[requests.firstIndex(of: request) ?? 0] = request\n",
      "expected" : "1",
      "input" : "requests = [[1,2],[2,3],[3,1],[4,5],[5,4]]",
      "slug" : "friend-requests-ii-who-has-the-most-friends",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friend-requests-ii-who-has-the-most-friends_1\/solution.swift:254:19: warning: expression implicitly coerced from 'Int?' to 'Any'\n252 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n253 | let result = solution.findMostFriends(arg0)\n254 | let output: Any = result\n    |                   |- warning: expression implicitly coerced from 'Int?' to 'Any'\n    |                   |- note: provide a default value to avoid this warning\n    |                   |- note: force-unwrap the value to avoid this warning\n    |                   `- note: explicitly cast to 'Any' with 'as Any' to silence this warning\n255 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/friend-requests-ii-who-has-the-most-friends_1\/solution.swift:11:51: error: cannot use mutating member on immutable value: subscript is get-only\n  9 |                    for request in requests {\n 10 |                        if let idx = friendships.firstIndex(where: { $0.value == request }) {\n 11 |                            friendships[idx].value.remove(at: 0)\n    |                                                   `- error: cannot use mutating member on immutable value: subscript is get-only\n 12 |                        } else {\n 13 |                            friendships[requests.firstIndex(of: request) ?? 0] = request\n",
      "expected" : "1",
      "input" : "requests = [[1,2],[3,4],[5,6],[7,8]]",
      "slug" : "friend-requests-ii-who-has-the-most-friends",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "2",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "requests = [[1,2],[2,3],[3,1],[4,5],[5,4]]",
      "slug" : "friend-requests-ii-who-has-the-most-friends",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "4",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "1",
      "input" : "requests = [[1,2],[3,4],[5,6],[7,8]]",
      "slug" : "friend-requests-ii-who-has-the-most-friends",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_1\/solution.swift:8:9: warning: variable 'words' was never mutated; consider changing to 'let' constant\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n  8 |     var words = S.components(separatedBy: \" \")\n    |         `- warning: variable 'words' was never mutated; consider changing to 'let' constant\n  9 |     var result = \"\"\n 10 |     \n",
      "expected" : "heTma uickqma rownbma oxfma umpedjma overma hetma azylma ogdma",
      "input" : "The quick brown fox jumped over the lazy dog",
      "slug" : "goat-latin",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_1\/solution.swift:8:9: warning: variable 'words' was never mutated; consider changing to 'let' constant\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n  8 |     var words = S.components(separatedBy: \" \")\n    |         `- warning: variable 'words' was never mutated; consider changing to 'let' constant\n  9 |     var result = \"\"\n 10 |     \n",
      "expected" : "Ima peaksma Goatma atinLma",
      "input" : "I speak Goat Latin",
      "slug" : "goat-latin",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n",
      "expected" : "heTma uickqma rownbma oxfma umpedjma overma hetma azylma ogdma",
      "input" : "The quick brown fox jumped over the lazy dog",
      "slug" : "goat-latin",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/goat-latin_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func toGoatLatin(_ S: String) -> String {\n",
      "expected" : "Ima peaksma Goatma atinLma",
      "input" : "I speak Goat Latin",
      "slug" : "goat-latin",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-last-word_2\/solution.swift:7:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 |     var length = 0 \n  6 |     var start = s.count - 1 \n  7 |     while start >= 0 && s[start] == \" \" { \n    |                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |         start -= 1 \n  9 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-last-word_2\/solution.swift:10:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |         start -= 1 \n  9 |     } \n 10 |     while start >= 0 && s[start] != \" \" { \n    |                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |         length += 1 \n 12 |         start -= 1 \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "5",
      "input" : "Hello World",
      "slug" : "length-of-last-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-last-word_2\/solution.swift:7:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  5 |     var length = 0 \n  6 |     var start = s.count - 1 \n  7 |     while start >= 0 && s[start] == \" \" { \n    |                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |         start -= 1 \n  9 |     } \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/length-of-last-word_2\/solution.swift:10:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n  8 |         start -= 1 \n  9 |     } \n 10 |     while start >= 0 && s[start] != \" \" { \n    |                         `- error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n 11 |         length += 1 \n 12 |         start -= 1 \n\nSwift.String.subscript:3:10: note: 'subscript(_:)' has been explicitly marked unavailable here\n1 | struct String {\n2 | @available(*, unavailable, message: \"cannot subscript String with an Int, use a String.Index instead.\")\n3 |   public subscript(i: Int) -> Character { get }}\n  |          `- note: 'subscript(_:)' has been explicitly marked unavailable here\n4 | \n",
      "expected" : "4",
      "input" : "   fly me   to   the moon  ",
      "slug" : "length-of-last-word",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "\"24A0r74k\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"2-4A0-R74K\"",
      "input" : "S = \"2-4A0r7-4k\", K = 4",
      "slug" : "license-key-formatting",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"5F3Z2e9w\"",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "\"5F3Z-2E9W\"",
      "input" : "S = \"5F3Z-2e-9-w\", K = 4",
      "slug" : "license-key-formatting",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"-24A0R74K\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"2-4A0-R74K\"",
      "input" : "S = \"2-4A0r7-4k\", K = 4",
      "slug" : "license-key-formatting",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "\"-5F3Z2E9W\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"5F3Z-2E9W\"",
      "input" : "S = \"5F3Z-2e-9-w\", K = 4",
      "slug" : "license-key-formatting",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "\"2-5G3J\"",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "\"2-5G-3J\"",
      "input" : "S = \"2-5g-3-J\", K = 2",
      "slug" : "license-key-formatting",
      "status" : "WRONG_ANSWER",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_1\/solution.swift:9:5: error: invalid redeclaration of 'S'\n  6 | let restLocal = String(Array(Array(parts[0]).dropFirst(3)).map { _ in \"*\" })\n  7 | return localName + restLocal + \"@\" + parts[1].lowercased() }\n  8 | let S = S.replacingOccurrences(of: \"+\", with: \"\")\n    |     `- note: 'S' previously declared here\n  9 | let S = S.replacingOccurrences(of: \"-\", with: \"\")\n    |     `- error: invalid redeclaration of 'S'\n 10 | if S.count > 13 { return \"***-***-\" + S.suffix(4) }\n 11 | if S.count > 10 { return \"*\" + String(S.dropFirst(1).prefix(3)) + \"-***-\" + S.suffix(4) }\n",
      "expected" : "\"l*****e@leetcode.com\"",
      "input" : "s = \"LeetCode@LeetCode.com\"",
      "slug" : "masking-personal-information",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_1\/solution.swift:9:5: error: invalid redeclaration of 'S'\n  6 | let restLocal = String(Array(Array(parts[0]).dropFirst(3)).map { _ in \"*\" })\n  7 | return localName + restLocal + \"@\" + parts[1].lowercased() }\n  8 | let S = S.replacingOccurrences(of: \"+\", with: \"\")\n    |     `- note: 'S' previously declared here\n  9 | let S = S.replacingOccurrences(of: \"-\", with: \"\")\n    |     `- error: invalid redeclaration of 'S'\n 10 | if S.count > 13 { return \"***-***-\" + S.suffix(4) }\n 11 | if S.count > 10 { return \"*\" + String(S.dropFirst(1).prefix(3)) + \"-***-\" + S.suffix(4) }\n",
      "expected" : "\"***-***-7890\"",
      "input" : "s = \"+1(234)567-890\"",
      "slug" : "masking-personal-information",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:4:91: error: invalid escape sequence in literal\n  2 | \n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n    |                                                                                           `- error: invalid escape sequence in literal\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:28: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                            `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:36: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                    `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:53: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                     `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:59: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                           `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:65: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                 `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:71: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                       `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected 'func' keyword in instance method declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:7: error: expected parameter name followed by ':'\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    :\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:231:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n229 | }\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n232 | let args = parseArgs(from: input, expectedCount: 1)\n233 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:232:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n232 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n233 | let hasInput = !args.isEmpty\n234 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:237:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n237 | let result = solution.maskPII(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:6:227: error: cannot find 's' in scope\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n    |                                                                                                                                                                                                                                   `- error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:7:36: error: cannot find 's' in scope\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n    |                                    `- error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:8:38: error: cannot find 's' in scope\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n    |                                      `- error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:9:213: error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n    |                                                                                                                                                                                                                     `- error: cannot find 's' in scope\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:10:19: error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n    |                   `- error: cannot find 's' in scope\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n 12 | return \"***-***-\" + fourDigits }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:18: error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                  `- error: cannot find 's' in scope\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:56: error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                                                        `- error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected '{' in body of function declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "\"l*****e@leetcode.com\"",
      "input" : "s = \"LeetCode@LeetCode.com\"",
      "slug" : "masking-personal-information",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:4:91: error: invalid escape sequence in literal\n  2 | \n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n    |                                                                                           `- error: invalid escape sequence in literal\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:28: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                            `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:36: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                    `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:53: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                     `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:59: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                           `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:65: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                 `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:71: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                       `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected 'func' keyword in instance method declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:7: error: expected parameter name followed by ':'\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    :\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:231:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n229 | }\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n232 | let args = parseArgs(from: input, expectedCount: 1)\n233 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:232:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n232 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n233 | let hasInput = !args.isEmpty\n234 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:237:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n237 | let result = solution.maskPII(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:6:227: error: cannot find 's' in scope\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n    |                                                                                                                                                                                                                                   `- error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:7:36: error: cannot find 's' in scope\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n    |                                    `- error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:8:38: error: cannot find 's' in scope\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n    |                                      `- error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:9:213: error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n    |                                                                                                                                                                                                                     `- error: cannot find 's' in scope\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:10:19: error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n    |                   `- error: cannot find 's' in scope\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n 12 | return \"***-***-\" + fourDigits }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:18: error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                  `- error: cannot find 's' in scope\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:56: error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                                                        `- error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected '{' in body of function declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "\"***-***-7890\"",
      "input" : "s = \"+1(234)567-890\"",
      "slug" : "masking-personal-information",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:4:91: error: invalid escape sequence in literal\n  2 | \n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n    |                                                                                           `- error: invalid escape sequence in literal\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:28: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                            `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:36: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                    `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:53: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                     `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:59: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                           `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:65: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                 `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:5:71: error: invalid escape sequence in literal\n  3 | class Solution {\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    |                                                                       `- error: invalid escape sequence in literal\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected 'func' keyword in instance method declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected 'func' keyword in instance method declaration\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:7: error: expected parameter name followed by ':'\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |       `- error: expected parameter name followed by ':'\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:32: error: expected '}' in class\n  1 | import Foundation\n  2 | \n  3 | class Solution {\n    |                `- note: to match this opening '{'\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n    :\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    |                                `- error: expected '}' in class\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:231:26: error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n229 | }\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n    |                          `- error: cannot use instance member 'inputData' within property initializer; property initializers run before 'self' is available\n232 | let args = parseArgs(from: input, expectedCount: 1)\n233 | let hasInput = !args.isEmpty\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:232:12: error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n230 | let inputData = FileHandle.standardInput.readDataToEndOfFile()\n231 | let input = String(data: inputData, encoding: .utf8) ?? \"\"\n232 | let args = parseArgs(from: input, expectedCount: 1)\n    |            `- error: cannot use instance member 'parseArgs' within property initializer; property initializers run before 'self' is available\n233 | let hasInput = !args.isEmpty\n234 | let solution = Solution()\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:12: error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |            `- error: cannot use instance member 'toString' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:236:21: error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n234 | let solution = Solution()\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n    |                     `- error: cannot use instance member 'valueAt' within property initializer; property initializers run before 'self' is available\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:237:14: error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n235 | \n236 | let arg0 = toString(valueAt(args, 0))\n237 | let result = solution.maskPII(arg0)\n    |              `- error: cannot use instance member 'solution' within property initializer; property initializers run before 'self' is available\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:6:227: error: cannot find 's' in scope\n  4 | func maskPII(_ S: String) -> String { let emailPattern = \"([a-zA-Z0-9]+)@([a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)+)\"\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n    |                                                                                                                                                                                                                                   `- error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:7:36: error: cannot find 's' in scope\n  5 | let phonePattern = \"([+-]?\\d{1,2})\\s?\\(?(\\d{3})\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\"\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n    |                                    `- error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:8:38: error: cannot find 's' in scope\n  6 | if let emailRegex = try? NSRegularExpression(pattern: emailPattern, options: .caseInsensitive), let emailMatch = emailRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let localName = String(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location, length: emailMatch.range(at: 1).length))).prefix(3))\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n    |                                      `- error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:9:213: error: cannot find 's' in scope\n  7 | let restLocal = String(Array(Array(s.substring(with: NSRange(location: emailMatch.range(at: 1).location + 3, length: emailMatch.range(at: 1).length - 3))).map { _ in \"*\" }))\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n    |                                                                                                                                                                                                                     `- error: cannot find 's' in scope\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:10:19: error: cannot find 's' in scope\n  8 | return localName + restLocal + \"@\" + s.substring(with: NSRange(location: emailMatch.range(at: 2).location, length: emailMatch.range(at: 2).length)).lowercased() }\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n    |                   `- error: cannot find 's' in scope\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n 12 | return \"***-***-\" + fourDigits }\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:18: error: cannot find 's' in scope\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                  `- error: cannot find 's' in scope\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:11:56: error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n  9 | if let phoneRegex = try? NSRegularExpression(pattern: phonePattern, options: .caseInsensitive), let phoneMatch = phoneRegex.firstMatch(in: S, options: [], range: NSRange(S.startIndex..., in: S)) { let areaCode = s.substring(with: NSRange(location: phoneMatch.range(at: 1).location, length: phoneMatch.range(at: 1).length))\n 10 | let threeDigits = s.substring(with: NSRange(location: phoneMatch.range(at: 2).location, length: phoneMatch.range(at: 2).length))\n 11 | let fourDigits = s.substring(with: NSRange(location: S.index(S.startIndex, offsetBy: S.count - 4), length: 4))\n    |                                                        `- error: cannot convert value of type 'String.Index' to expected argument type 'Int'\n 12 | return \"***-***-\" + fourDigits }\n 13 | return \"***-***-***\"\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/masking-personal-information_2\/solution.swift:239:1: error: expected '{' in body of function declaration\n237 | let result = solution.maskPII(arg0)\n238 | let output: Any = result\n239 | print(jsonString(from: output))\n    | `- error: expected '{' in body of function declaration\n",
      "expected" : "\"***-***-7890\"",
      "input" : "s = \"123-456-7890\"",
      "slug" : "masking-personal-information",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "actual" : "3",
      "approachName" : "Build Histograms",
      "approachOrder" : 1,
      "expected" : "6",
      "input" : "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"]]",
      "slug" : "maximal-rectangle",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_1\/solution.swift:244:23: error: value of type 'Solution' has no member 'ping'\n242 | \n243 | let arg0 = toInt(valueAt(args, 0))\n244 | let result = solution.ping(arg0)\n    |                       `- error: value of type 'Solution' has no member 'ping'\n245 | let output: Any = result\n246 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "RecentCounter().ping(1)",
      "slug" : "number-of-recent-calls",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_1\/solution.swift:244:23: error: value of type 'Solution' has no member 'ping'\n242 | \n243 | let arg0 = toInt(valueAt(args, 0))\n244 | let result = solution.ping(arg0)\n    |                       `- error: value of type 'Solution' has no member 'ping'\n245 | let output: Any = result\n246 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "RecentCounter().ping(100).ping(200).ping(300).ping(3001)",
      "slug" : "number-of-recent-calls",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class RecentCounter {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_2\/solution.swift:246:23: error: value of type 'Solution' has no member 'ping'\n244 | \n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let result = solution.ping(arg0)\n    |                       `- error: value of type 'Solution' has no member 'ping'\n247 | let output: Any = result\n248 | print(jsonString(from: output))\n",
      "expected" : "1",
      "input" : "RecentCounter().ping(1)",
      "slug" : "number-of-recent-calls",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | class RecentCounter {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/number-of-recent-calls_2\/solution.swift:246:23: error: value of type 'Solution' has no member 'ping'\n244 | \n245 | let arg0 = toInt(valueAt(args, 0))\n246 | let result = solution.ping(arg0)\n    |                       `- error: value of type 'Solution' has no member 'ping'\n247 | let output: Any = result\n248 | print(jsonString(from: output))\n",
      "expected" : "3",
      "input" : "RecentCounter().ping(100).ping(200).ping(300).ping(3001)",
      "slug" : "number-of-recent-calls",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "6",
      "input" : "s = \"   fly me   to   the moon  \t  \"",
      "slug" : "number-of-segments-in-a-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "actual" : "5",
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "expected" : "4",
      "input" : "s = \"   fly me   to   the moon  \t  \"",
      "slug" : "number-of-segments-in-a-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/positions-of-large-groups_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largeGroupPositions(s: String) -> [[Int]] { var res: [[Int]] = []; var count = 1; for i in 1...s.count - 1 { if s[s.index(s.startIndex, offsetBy: i)] == s[s.index(s.startIndex, offsetBy: i - 1)] { count += 1 } else { if count >= 3 { res.append([i - count, i - 1]) } count = 1 } }; if count >= 3 { res.append([s.count - count, s.count - 1]) }; return res }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[[3,5],[6,9]]",
      "input" : "aababbabba",
      "slug" : "positions-of-large-groups",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/positions-of-large-groups_1\/solution.swift:4:271: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func largeGroupPositions(s: String) -> [[Int]] { var res: [[Int]] = []; var count = 1; for i in 1...s.count - 1 { if s[s.index(s.startIndex, offsetBy: i)] == s[s.index(s.startIndex, offsetBy: i - 1)] { count += 1 } else { if count >= 3 { res.append([i - count, i - 1]) } count = 1 } }; if count >= 3 { res.append([s.count - count, s.count - 1]) }; return res }\n    |                                                                                                                                                                                                                                                                               `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "[]",
      "input" : "abc",
      "slug" : "positions-of-large-groups",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "[[3,5],[6,9]]",
      "input" : "aababbabba",
      "slug" : "positions-of-large-groups",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "[\"JFK\",\"MUC\"]",
      "approachName" : "Hierholzer's Algorithm",
      "approachOrder" : 1,
      "expected" : "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
      "input" : "[[\"MU\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
      "slug" : "reconstruct-itinerary",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "actual" : "3",
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "expected" : "4",
      "input" : "a = \"abc\", b = \"bcabca\"",
      "slug" : "repeated-string-match",
      "status" : "WRONG_ANSWER",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-string_1\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func rotateString(_ s: String, _ goal: String) -> Bool { let n = s.count; var rotations: [String] = []; for i in 0..<n { let rotation = String(s.dropFirst(i) + s.prefix(i)); rotations.append(rotation); } return rotations.contains(goal); }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "true",
      "input" : "s = 'abcde', goal = 'cdeab'",
      "slug" : "rotate-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/rotate-string_1\/solution.swift:4:204: error: consecutive statements on a line must be separated by ';'\n  2 | \n  3 | class Solution {\n  4 | func rotateString(_ s: String, _ goal: String) -> Bool { let n = s.count; var rotations: [String] = []; for i in 0..<n { let rotation = String(s.dropFirst(i) + s.prefix(i)); rotations.append(rotation); } return rotations.contains(goal); }\n    |                                                                                                                                                                                                            `- error: consecutive statements on a line must be separated by ';'\n  5 | }\n  6 | \n",
      "expected" : "false",
      "input" : "s = 'abcde', goal = 'abced'",
      "slug" : "rotate-string",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "false",
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "expected" : "true",
      "input" : "s = 'abcde', goal = 'cdeab'",
      "slug" : "rotate-string",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Preorder with Null Markers",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-binary-tree_1\/solution.swift:298:23: error: value of type 'Solution' has no member 'serialize'\n296 | \n297 | let arg0 = toTreeNode(valueAt(args, 0))\n298 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n299 | let output: Any = result\n300 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-binary-tree_1\/solution.swift:244:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n242 | func toTreeNode(_ value: Any) -> TreeNode? {\n243 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n244 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n245 |         if item is NSNull { return nil }\n246 |         return TreeNode(toInt(item))\n",
      "expected" : "[1,2,3,null,null,4,5]",
      "input" : "root = [1,2,3,null,null,4,5]",
      "slug" : "serialize-and-deserialize-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Preorder with Null Markers",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-binary-tree_1\/solution.swift:298:23: error: value of type 'Solution' has no member 'serialize'\n296 | \n297 | let arg0 = toTreeNode(valueAt(args, 0))\n298 | let result = solution.serialize(arg0)\n    |                       `- error: value of type 'Solution' has no member 'serialize'\n299 | let output: Any = result\n300 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/serialize-and-deserialize-binary-tree_1\/solution.swift:244:9: warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n242 | func toTreeNode(_ value: Any) -> TreeNode? {\n243 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n244 |     var nodes: [TreeNode?] = array.map { item in\n    |         `- warning: variable 'nodes' was never mutated; consider changing to 'let' constant\n245 |         if item is NSNull { return nil }\n246 |         return TreeNode(toInt(item))\n",
      "expected" : "[]",
      "input" : "root = []",
      "slug" : "serialize-and-deserialize-binary-tree",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TransposeFile {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:251:23: error: value of type 'Solution' has no member 'transpose'\n249 | \n250 | let arg0 = toString(valueAt(args, 0))\n251 | let result = solution.transpose(file: arg0)\n    |                       `- error: value of type 'Solution' has no member 'transpose'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:8:28: warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  6 | class TransposeFile {\n  7 |     static func transpose(file: String) -> String {\n  8 |         let content = try! String(contentsOfFile: file)\n    |                            `- warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var matrix: [[String]] = []\n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "1 4\\n2 5\\n3 6",
      "input" : "file1.txt containing: 1 2 3\\n4 5 6",
      "slug" : "transpose-file",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TransposeFile {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:251:23: error: value of type 'Solution' has no member 'transpose'\n249 | \n250 | let arg0 = toString(valueAt(args, 0))\n251 | let result = solution.transpose(file: arg0)\n    |                       `- error: value of type 'Solution' has no member 'transpose'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_1\/solution.swift:8:28: warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  6 | class TransposeFile {\n  7 |     static func transpose(file: String) -> String {\n  8 |         let content = try! String(contentsOfFile: file)\n    |                            `- warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var matrix: [[String]] = []\n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "a d\\nb e\\nc f",
      "input" : "file2.txt containing: a b c\\nd e f",
      "slug" : "transpose-file",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TransposeFile {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'transpose'\n249 | \n250 | let arg0 = toString(valueAt(args, 0))\n251 | let result = solution.transpose(file: arg0)\n    |                       `- error: value of type 'Solution' has no member 'transpose'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:8:28: warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  6 | class TransposeFile {\n  7 |     static func transpose(file: String) -> String {\n  8 |         let content = try! String(contentsOfFile: file)\n    |                            `- warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var dict: [Int: [String]] = [:]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:11:14: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var dict: [Int: [String]] = [:]\n 11 |         for (i, line) in lines.enumerated() {\n    |              `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 12 |             let words = line.components(separatedBy: \" \")\n 13 |             for (j, word) in words.enumerated() {\n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "1 4\\n2 5\\n3 6",
      "input" : "file1.txt containing: 1 2 3\\n4 5 6",
      "slug" : "transpose-file",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | class TransposeFile {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'transpose'\n249 | \n250 | let arg0 = toString(valueAt(args, 0))\n251 | let result = solution.transpose(file: arg0)\n    |                       `- error: value of type 'Solution' has no member 'transpose'\n252 | let output: Any = result\n253 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:8:28: warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  6 | class TransposeFile {\n  7 |     static func transpose(file: String) -> String {\n  8 |         let content = try! String(contentsOfFile: file)\n    |                            `- warning: 'init(contentsOfFile:)' was deprecated in macOS 15: Use `init(contentsOfFile:encoding:)` instead [#DeprecatedDeclaration]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var dict: [Int: [String]] = [:]\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/transpose-file_2\/solution.swift:11:14: warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n  9 |         let lines = content.components(separatedBy: \"\\n\")\n 10 |         var dict: [Int: [String]] = [:]\n 11 |         for (i, line) in lines.enumerated() {\n    |              `- warning: immutable value 'i' was never used; consider replacing with '_' or removing it [#no-usage]\n 12 |             let words = line.components(separatedBy: \" \")\n 13 |             for (j, word) in words.enumerated() {\n\n[#DeprecatedDeclaration]: <https:\/\/docs.swift.org\/compiler\/documentation\/diagnostics\/deprecated-declaration>\n",
      "expected" : "a d\\nb e\\nc f",
      "input" : "file2.txt containing: a b c\\nd e f",
      "slug" : "transpose-file",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:278:23: error: value of type 'Solution' has no member 'addChild'\n276 | \n277 | let arg0 = toTreeNode(valueAt(args, 0))\n278 | let result = solution.addChild(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addChild'\n279 | let output: Any = NSNull()\n280 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "Correct tree structure",
      "input" : "Tree with 5 nodes",
      "slug" : "tree-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:222:34: error: cannot find type 'TreeNode' in scope\n220 | }\n221 | \n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n    |                                  `- error: cannot find type 'TreeNode' in scope\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:240:30: error: cannot find type 'TreeNode' in scope\n238 | }\n239 | \n240 | func treeNodeToArray(_ root: TreeNode?) -> [Any] {\n    |                              `- error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:278:23: error: value of type 'Solution' has no member 'addChild'\n276 | \n277 | let arg0 = toTreeNode(valueAt(args, 0))\n278 | let result = solution.addChild(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addChild'\n279 | let output: Any = NSNull()\n280 | print(jsonString(from: output))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:224:17: error: cannot find type 'TreeNode' in scope\n222 | func toTreeNode(_ value: Any) -> TreeNode? {\n223 |     guard let array = value as? [Any], !array.isEmpty else { return nil }\n224 |     var nodes: [TreeNode?] = array.map { item in\n    |                 `- error: cannot find type 'TreeNode' in scope\n225 |         if item is NSNull { return nil }\n226 |         return TreeNode(toInt(item))\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_1\/solution.swift:243:17: error: cannot find type 'TreeNode' in scope\n241 |     guard let root else { return [] }\n242 |     var result: [Any] = []\n243 |     var queue: [TreeNode?] = [root]\n    |                 `- error: cannot find type 'TreeNode' in scope\n244 |     while !queue.isEmpty {\n245 |         let node = queue.removeFirst()\n",
      "expected" : "No output",
      "input" : "Empty tree",
      "slug" : "tree-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'addChild'\n249 | \n250 | let arg0 = toInt(valueAt(args, 0))\n251 | let result = solution.addChild(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addChild'\n252 | let output: Any = NSNull()\n253 | print(jsonString(from: output))\n",
      "expected" : "Correct traversal",
      "input" : "Deeply nested tree",
      "slug" : "tree-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/tree-node_2\/solution.swift:251:23: error: value of type 'Solution' has no member 'addChild'\n249 | \n250 | let arg0 = toInt(valueAt(args, 0))\n251 | let result = solution.addChild(arg0)\n    |                       `- error: value of type 'Solution' has no member 'addChild'\n252 | let output: Any = NSNull()\n253 | print(jsonString(from: output))\n",
      "expected" : "Error or infinite loop prevention",
      "input" : "Tree with cycles",
      "slug" : "tree-node",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/triangle-judgement_2\/solution.swift:14:19: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  6 |     var count = 0\n  7 |     for i in 0..<sortedArr.count-2 {\n  8 |         let k = i + 2\n    |         `- note: change 'let' to 'var' to make it mutable\n  9 |         for j in i+1..<sortedArr.count-1 {\n 10 |             while k < sortedArr.count && sortedArr[i] + sortedArr[j] > sortedArr[k] {\n    :\n 12 |                     count += 1\n 13 |                 }\n 14 |                 k += 1\n    |                   `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n 15 |             }\n 16 |         }\n",
      "expected" : "true",
      "input" : "x = 3, y = 4, z = 5",
      "slug" : "triangle-judgement",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/triangle-judgement_2\/solution.swift:14:19: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n  6 |     var count = 0\n  7 |     for i in 0..<sortedArr.count-2 {\n  8 |         let k = i + 2\n    |         `- note: change 'let' to 'var' to make it mutable\n  9 |         for j in i+1..<sortedArr.count-1 {\n 10 |             while k < sortedArr.count && sortedArr[i] + sortedArr[j] > sortedArr[k] {\n    :\n 12 |                     count += 1\n 13 |                 }\n 14 |                 k += 1\n    |                   `- error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n 15 |             }\n 16 |         }\n",
      "expected" : "false",
      "input" : "x = 1, y = 2, z = 3",
      "slug" : "triangle-judgement",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:41: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                         `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:58: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                                          `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:19: error: unterminated string literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                   `- error: unterminated string literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n",
      "expected" : "[\"(123) 456-7890\", \"123-456-7890\", \"1234567890\"]",
      "input" : "phoneNumbers = [\"(123) 456-7890\", \"123-456-7890\", \"1234567890\", \"1234567\"]",
      "slug" : "valid-phone-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:41: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                         `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:58: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                                          `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_1\/solution.swift:7:19: error: unterminated string literal\n  5 | \n  6 | func validPhoneNumbers(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                   `- error: unterminated string literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.filter { phoneNumber in\n",
      "expected" : "[\"123.456.7890\"]",
      "input" : "phoneNumbers = [\"1234\", \"12345678901\", \"123-4567\", \"123.456.7890\"]",
      "slug" : "valid-phone-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:41: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                         `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:58: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                                          `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:19: error: unterminated string literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                   `- error: unterminated string literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:9:25: error: value of type '[String]' has no member 'parallelMap'\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n    |                         `- error: value of type '[String]' has no member 'parallelMap'\n 10 |         let range = NSRange(phoneNumber.startIndex..., in: phoneNumber)\n 11 |         return regex.firstMatch(in: phoneNumber, options: [], range: range) != nil ? phoneNumber : nil\n",
      "expected" : "[\"(123) 456-7890\", \"123-456-7890\", \"1234567890\"]",
      "input" : "phoneNumbers = [\"(123) 456-7890\", \"123-456-7890\", \"1234567890\", \"1234567\"]",
      "slug" : "valid-phone-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:41: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                         `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:58: error: invalid escape sequence in literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                                                          `- error: invalid escape sequence in literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:7:19: error: unterminated string literal\n  5 | \n  6 | func validPhoneNumbersOptimized(_ phoneNumbers: [String]) -> [String] {\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n    |                   `- error: unterminated string literal\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/valid-phone-numbers_2\/solution.swift:9:25: error: value of type '[String]' has no member 'parallelMap'\n  7 |     let pattern = \"^\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})$\n  8 |     let regex = try! NSRegularExpression(pattern: pattern, options: []);\n  9 |     return phoneNumbers.parallelMap { phoneNumber -> String? in\n    |                         `- error: value of type '[String]' has no member 'parallelMap'\n 10 |         let range = NSRange(phoneNumber.startIndex..., in: phoneNumber)\n 11 |         return regex.firstMatch(in: phoneNumber, options: [], range: range) != nil ? phoneNumber : nil\n",
      "expected" : "[\"123.456.7890\"]",
      "input" : "phoneNumbers = [\"1234\", \"12345678901\", \"123-4567\", \"123.456.7890\"]",
      "slug" : "valid-phone-numbers",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n",
      "expected" : "\"IPv4\"",
      "input" : "IP = \"192.168.0.1\"",
      "slug" : "validate-ip-address",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_1\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n",
      "expected" : "\"IPv6\"",
      "input" : "IP = \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"",
      "slug" : "validate-ip-address",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:8:20: warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n    |                    `- warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  9 |                var host = urlComponents?.host\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:9:20: warning: variable 'host' was never mutated; consider changing to 'let' constant\n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n  9 |                var host = urlComponents?.host\n    |                    `- warning: variable 'host' was never mutated; consider changing to 'let' constant\n 10 | \n 11 |                if host?.contains(\":\") == true {\n",
      "expected" : "\"IPv4\"",
      "input" : "IP = \"172.16.254.1\"",
      "slug" : "validate-ip-address",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:8:20: warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n    |                    `- warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  9 |                var host = urlComponents?.host\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:9:20: warning: variable 'host' was never mutated; consider changing to 'let' constant\n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n  9 |                var host = urlComponents?.host\n    |                    `- warning: variable 'host' was never mutated; consider changing to 'let' constant\n 10 | \n 11 |                if host?.contains(\":\") == true {\n",
      "expected" : "\"IPv6\"",
      "input" : "IP = \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"",
      "slug" : "validate-ip-address",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:5:12: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 |            import Foundation\n    |            `- error: declaration is only valid at file scope\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:8:20: warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  6 | \n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n    |                    `- warning: variable 'urlComponents' was never mutated; consider changing to 'let' constant\n  9 |                var host = urlComponents?.host\n 10 | \n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/validate-ip-address_2\/solution.swift:9:20: warning: variable 'host' was never mutated; consider changing to 'let' constant\n  7 |            func validIPAddress(_ IP: String) -> String {\n  8 |                var urlComponents = URLComponents(string: \"http:\/\/(IP)\")\n  9 |                var host = urlComponents?.host\n    |                    `- warning: variable 'host' was never mutated; consider changing to 'let' constant\n 10 | \n 11 |                if host?.contains(\":\") == true {\n",
      "expected" : "\"Neither\"",
      "input" : "IP = \"256.256.256.256\"",
      "slug" : "validate-ip-address",
      "status" : "COMPILE_ERROR",
      "testIndex" : 2
    },
    {
      "approachName" : "Multi-source BFS",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/walls-and-gates_1\/solution.swift:250:23: error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n247 | let solution = Solution()\n248 | \n249 | let arg0 = toArray(valueAt(args, 0)) { toArray($0) { toInt($0) } }\n    | `- note: change 'let' to 'var' to make it mutable\n250 | let result = solution.wallsAndGates(arg0)\n    |                       `- error: cannot pass immutable value as inout argument: 'arg0' is a 'let' constant\n251 | let output: Any = NSNull()\n252 | print(jsonString(from: output))\n",
      "expected" : "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]",
      "input" : "rooms = [[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]]",
      "slug" : "walls-and-gates",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-frequency_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func wordFrequency(_ text: String) -> [String: Int] {\n",
      "expected" : "{\"the\": 2, \"quick\": 1, \"brown\": 1, \"fox\": 1, \"jumps\": 1, \"over\": 1, \"lazy\": 1, \"dog\": 1}",
      "input" : "text = \"The quick brown fox jumps over the lazy dog\"",
      "slug" : "word-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-frequency_1\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func wordFrequency(_ text: String) -> [String: Int] {\n",
      "expected" : "{\"hello\": 2, \"world\": 2}",
      "input" : "text = \"Hello world hello World\"",
      "slug" : "word-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-frequency_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func wordFrequency(_ text: String) -> [String: Int] {\n",
      "expected" : "{\"the\": 2, \"quick\": 1, \"brown\": 1, \"fox\": 1, \"jumps\": 1, \"over\": 1, \"lazy\": 1, \"dog\": 1}",
      "input" : "text = \"The quick brown fox jumps over the lazy dog\"",
      "slug" : "word-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/word-frequency_2\/solution.swift:4:1: error: declaration is only valid at file scope\n  2 | \n  3 | class Solution {\n  4 | import Foundation\n    | `- error: declaration is only valid at file scope\n  5 | \n  6 | func wordFrequency(_ text: String) -> [String: Int] {\n",
      "expected" : "{\"hello\": 2, \"world\": 2}",
      "input" : "text = \"Hello world hello World\"",
      "slug" : "word-frequency",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "actual" : "[]",
      "approachName" : "BFS + DFS",
      "approachOrder" : 1,
      "expected" : "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"]]",
      "input" : "beginWord = \"hit\", endWord = \"cog\", wordList = [...]",
      "slug" : "word-ladder-ii",
      "status" : "WRONG_ANSWER",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func convert(_ s: String, _ numRows: Int) -> String {\n",
      "expected" : "\"PAHNAPLSIIGYIR\"",
      "input" : "s = \"PAYPALISHIRING\", numRows = 3",
      "slug" : "zigzag-conversion",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_1\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func convert(_ s: String, _ numRows: Int) -> String {\n",
      "expected" : "\"PINALSIGYAHRPI\"",
      "input" : "s = \"PAYPALISHIRING\", numRows = 4",
      "slug" : "zigzag-conversion",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func convert(_ s: String, _ numRows: Int) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_2\/solution.swift:12:48: error: cannot convert value of type 'String' to expected argument type 'Character'\n 10 |     }\n 11 | \n 12 |     var result: [Character] = Array(repeating: \"\", count: s.count)\n    |                                                `- error: cannot convert value of type 'String' to expected argument type 'Character'\n 13 |     var index: Int = 0\n 14 |     var step: Int = 1\n",
      "expected" : "\"PAHNAPLSIIGYIR\"",
      "input" : "s = \"PAYPALISHIRING\", numRows = 3",
      "slug" : "zigzag-conversion",
      "status" : "COMPILE_ERROR",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_2\/solution.swift:5:1: error: declaration is only valid at file scope\n  3 | class Solution {\n  4 | \n  5 | import Foundation\n    | `- error: declaration is only valid at file scope\n  6 | \n  7 | func convert(_ s: String, _ numRows: Int) -> String {\n\n\/var\/folders\/52\/b7d9v37n6nbdt32xs7y1khhr0000gn\/T\/focus_validation_40457\/zigzag-conversion_2\/solution.swift:12:48: error: cannot convert value of type 'String' to expected argument type 'Character'\n 10 |     }\n 11 | \n 12 |     var result: [Character] = Array(repeating: \"\", count: s.count)\n    |                                                `- error: cannot convert value of type 'String' to expected argument type 'Character'\n 13 |     var index: Int = 0\n 14 |     var step: Int = 1\n",
      "expected" : "\"PINALSIGYAHRPI\"",
      "input" : "s = \"PAYPALISHIRING\", numRows = 4",
      "slug" : "zigzag-conversion",
      "status" : "COMPILE_ERROR",
      "testIndex" : 1
    }
  ],
  "passed" : 942,
  "skipped" : 144,
  "skips" : [
    {
      "approachName" : "Hash Table Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[2, 3]",
      "input" : "nums = [4,3,2,7,8,2,3,1]",
      "slug" : "find-all-duplicates-in-an-array",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Hash Table Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[1]",
      "input" : "nums = [1,1,2]",
      "slug" : "find-all-duplicates-in-an-array",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "In-Place Marking Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[2, 3]",
      "input" : "nums = [4,3,2,7,8,2,3,1]",
      "slug" : "find-all-duplicates-in-an-array",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "In-Place Marking Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[1]",
      "input" : "nums = [1,1,2]",
      "slug" : "find-all-duplicates-in-an-array",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "source = [\"\", \"\", \"\", \"No comment here\"]",
      "input" : "source = [\"\/*Block\", \"   comments\", \" *\/\", \"No comment here\"]",
      "slug" : "remove-comments",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "source = [\"\", \"No comment here\"]",
      "input" : "source = [\"\/\/Line comment\", \"No comment here\"]",
      "slug" : "remove-comments",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
      "input" : "R = 5, C = 6, r0 = 1, c0 = 4",
      "slug" : "spiral-matrix-iii",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
      "input" : "R = 5, C = 6, r0 = 1, c0 = 4",
      "slug" : "spiral-matrix-iii",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "6",
      "input" : "s = \"00110011\"",
      "slug" : "count-binary-substrings",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "4",
      "input" : "s = \"10101\"",
      "slug" : "count-binary-substrings",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "6",
      "input" : "s = \"00110011\"",
      "slug" : "count-binary-substrings",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "4",
      "input" : "s = \"10101\"",
      "slug" : "count-binary-substrings",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Hash Table",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[2,2]",
      "input" : "nums1 = [1,2,2,1], nums2 = [2,2]",
      "slug" : "intersection-of-two-arrays-ii",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Hash Table",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[4,9]",
      "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
      "slug" : "intersection-of-two-arrays-ii",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Two Pointers (Sorted Arrays)",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[2,2]",
      "input" : "nums1 = [1,2,2,1], nums2 = [2,2]",
      "slug" : "intersection-of-two-arrays-ii",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Two Pointers (Sorted Arrays)",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[4,9]",
      "input" : "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
      "slug" : "intersection-of-two-arrays-ii",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "\"()()\"",
      "input" : "s = \"(()())\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "\"()()()()\"",
      "input" : "s = \"(()())(())()\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "\"\"\"",
      "input" : "s = \"()()()\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 2
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "\"()()\"",
      "input" : "s = \"(()())\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "\"()()()()\"",
      "input" : "s = \"(()())(())()\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "\"\"\"",
      "input" : "s = \"()()()\"",
      "slug" : "remove-outermost-parentheses",
      "status" : "SKIP",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[\"i\",\"love\"]",
      "input" : "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
      "slug" : "top-k-frequent-words",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[\"the\",\"is\",\"sunny\",\"day\"]",
      "input" : "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
      "slug" : "top-k-frequent-words",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[\"i\",\"love\"]",
      "input" : "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
      "slug" : "top-k-frequent-words",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[\"the\",\"is\",\"sunny\",\"day\"]",
      "input" : "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
      "slug" : "top-k-frequent-words",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Inorder Traversal",
      "approachOrder" : 2,
      "error" : "No test cases",
      "expected" : "",
      "input" : "",
      "slug" : "validate-binary-search-tree",
      "status" : "SKIP",
      "testIndex" : -1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]",
      "input" : "numRows = 5",
      "slug" : "pascals-triangle",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[[1], [1,1], [1,2,1]]",
      "input" : "numRows = 3",
      "slug" : "pascals-triangle",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]",
      "input" : "numRows = 5",
      "slug" : "pascals-triangle",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Dynamic Programming Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[[1], [1,1], [1,2,1]]",
      "input" : "numRows = 3",
      "slug" : "pascals-triangle",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "7236",
      "input" : "num = 2736",
      "slug" : "maximum-swap",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "9973",
      "input" : "num = 9973",
      "slug" : "maximum-swap",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "7236",
      "input" : "num = 2736",
      "slug" : "maximum-swap",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "9973",
      "input" : "num = 9973",
      "slug" : "maximum-swap",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "2",
      "input" : "nums = [1, 2, 3]",
      "slug" : "minimum-moves-to-equal-array-elements",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "16",
      "input" : "nums = [1, 10, 2, 9]",
      "slug" : "minimum-moves-to-equal-array-elements",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "136",
      "input" : "nums = [4,8,3,1,2,5,6,0,7,9]",
      "slug" : "rotate-function",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "20",
      "input" : "nums = [1,2,3,4,5]",
      "slug" : "rotate-function",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "32",
      "input" : "n = 12, primes = [2,7,13,19]",
      "slug" : "super-ugly-number",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "12",
      "input" : "n = 10, primes = [2,3,5]",
      "slug" : "super-ugly-number",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "15",
      "input" : "nums = [2,7,11,15]",
      "slug" : "maximum-xor-of-two-numbers-in-an-array",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "1",
      "input" : "nums = [0,1]",
      "slug" : "maximum-xor-of-two-numbers-in-an-array",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "name: USA, population: 25000001, area: 1000000",
      "input" : "population = 25000001, area = 1000000",
      "slug" : "big-countries",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "name: Canada, population: 1000000, area: 8000000",
      "input" : "population = 1000000, area = 8000000",
      "slug" : "big-countries",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "name: USA, population: 25000001, area: 1000000",
      "input" : "population = 25000001, area = 1000000",
      "slug" : "big-countries",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "name: Canada, population: 1000000, area: 8000000",
      "input" : "population = 1000000, area = 8000000",
      "slug" : "big-countries",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Math",
      "input" : "CREATE TABLE courses (class varchar(255), student varchar(255)); INSERT INTO courses (class, student) VALUES ('Math', 'Alice'), ('Math', 'Bob'), ('Math', 'Charlie'), ('Math', 'David'), ('Math', 'Eve'), ('Science', 'Frank'), ('Science', 'George');",
      "slug" : "classes-with-at-least-5-students",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "History",
      "input" : "CREATE TABLE courses (class varchar(255), student varchar(255)); INSERT INTO courses (class, student) VALUES ('History', 'John'), ('History', 'Jane'), ('History', 'Jim'), ('History', 'Joan'), ('History', 'Joe');",
      "slug" : "classes-with-at-least-5-students",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach with Subqueries",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "English",
      "input" : "CREATE TABLE courses (class varchar(255), student varchar(255)); INSERT INTO courses (class, student) VALUES ('English', 'Kate'), ('English', 'Larry'), ('English', 'Mike'), ('English', 'Nancy'), ('English', 'Olive');",
      "slug" : "classes-with-at-least-5-students",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach with Subqueries",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Physics",
      "input" : "CREATE TABLE courses (class varchar(255), student varchar(255)); INSERT INTO courses (class, student) VALUES ('Physics', 'Peter'), ('Physics', 'Rachel'), ('Physics', 'Sam'), ('Physics', 'Tessa'), ('Physics', 'Uma');",
      "slug" : "classes-with-at-least-5-students",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[(John, Doe, New York, NY)]",
      "input" : "Table Person: [(1, John, Doe)], Table Address: [(1, New York, NY)]",
      "slug" : "combine-two-tables",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[(Jane, Smith, NULL, NULL)]",
      "input" : "Table Person: [(1, Jane, Smith)], Table Address: [(2, Chicago, IL)]",
      "slug" : "combine-two-tables",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[(John, Doe, New York, NY)]",
      "input" : "Table Person: [(1, John, Doe)], Table Address: [(1, New York, NY)]",
      "slug" : "combine-two-tables",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[(Jane, Smith, NULL, NULL)]",
      "input" : "Table Person: [(1, Jane, Smith)], Table Address: [(2, Chicago, IL)]",
      "slug" : "combine-two-tables",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "1",
      "input" : "Logs table with rows (1, 1), (2, 1), (3, 1), (4, 2), (5, 3), (6, 4)",
      "slug" : "consecutive-numbers",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "11",
      "input" : "Logs table with rows (1, 11), (2, 11), (3, 11)",
      "slug" : "consecutive-numbers",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "1",
      "input" : "Logs table with rows (1, 1), (2, 1), (3, 1), (4, 2), (5, 3), (6, 4)",
      "slug" : "consecutive-numbers",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "2",
      "input" : "Logs table with rows (1, 2), (2, 2), (3, 2)",
      "slug" : "consecutive-numbers",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "customer_id of the customer who placed the largest number of orders",
      "input" : "Orders table with customer_id and order_id columns",
      "slug" : "customer-placing-the-largest-number-of-orders",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "customer_id of the customer who placed the largest number of orders",
      "input" : "Orders table with duplicate customer_id values",
      "slug" : "customer-placing-the-largest-number-of-orders",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "customer_id of the customer who placed the largest number of orders",
      "input" : "Orders table with customer_id and order_id columns",
      "slug" : "customer-placing-the-largest-number-of-orders",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "customer_id of the customer who placed the largest number of orders",
      "input" : "Orders table with duplicate customer_id values",
      "slug" : "customer-placing-the-largest-number-of-orders",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "3 customers who never placed an order",
      "input" : "customers table has 5 customers, orders table has 3 orders for 2 customers",
      "slug" : "customers-who-never-order",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "7 customers who never placed an order",
      "input" : "customers table has 10 customers, orders table has 5 orders for 3 customers",
      "slug" : "customers-who-never-order",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "3 customers who never placed an order",
      "input" : "customers table has 5 customers, orders table has 3 orders for 2 customers",
      "slug" : "customers-who-never-order",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "7 customers who never placed an order",
      "input" : "customers table has 10 customers, orders table has 5 orders for 3 customers",
      "slug" : "customers-who-never-order",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com')]",
      "input" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'a@gmail.com')]",
      "slug" : "delete-duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'c@gmail.com')]",
      "input" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'c@gmail.com')]",
      "slug" : "delete-duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com')]",
      "input" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'a@gmail.com')]",
      "slug" : "delete-duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'c@gmail.com')]",
      "input" : "Person table with the following rows: [(1, 'a@gmail.com'), (2, 'b@gmail.com'), (3, 'c@gmail.com')]",
      "slug" : "delete-duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[{Department: 'Marketing', Employee: 'Jane', Salary: 20000}]",
      "input" : "Department table: [{id: 1, name: 'Sales'}, {id: 2, name: 'Marketing'}], Employee table: [{id: 1, name: 'John', departmentId: 1, salary: 10000}, {id: 2, name: 'Jane', departmentId: 2, salary: 20000}]",
      "slug" : "department-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[{Department: 'Sales', Employee: 'Jane', Salary: 20000}]",
      "input" : "Department table: [{id: 1, name: 'Sales'}, {id: 2, name: 'Marketing'}], Employee table: [{id: 1, name: 'John', departmentId: 1, salary: 10000}, {id: 2, name: 'Jane', departmentId: 1, salary: 20000}]",
      "slug" : "department-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[{Department: 'Marketing', Employee: 'Jane', Salary: 20000}]",
      "input" : "Department table: [{id: 1, name: 'Sales'}, {id: 2, name: 'Marketing'}], Employee table: [{id: 1, name: 'John', departmentId: 1, salary: 10000}, {id: 2, name: 'Jane', departmentId: 2, salary: 20000}]",
      "slug" : "department-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[{Department: 'Sales', Employee: 'Jane', Salary: 20000}]",
      "input" : "Department table: [{id: 1, name: 'Sales'}, {id: 2, name: 'Marketing'}], Employee table: [{id: 1, name: 'John', departmentId: 1, salary: 10000}, {id: 2, name: 'Jane', departmentId: 1, salary: 20000}]",
      "slug" : "department-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "['a','b']",
      "input" : "Person table with emails ['a','b','c','a','b']",
      "slug" : "duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[]",
      "input" : "Person table with emails ['a','b','c','d']",
      "slug" : "duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Solution",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "['a','b']",
      "input" : "Person table with emails ['a','b','c','a','b']",
      "slug" : "duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Solution",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[]",
      "input" : "Person table with emails ['a','b','c','d']",
      "slug" : "duplicate-emails",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "John's bonus as 1000, Jane's bonus as 2000, Joe's bonus as null",
      "input" : "Employee table contains John, Jane, Joe and Bonus table contains John's bonus as 1000, Jane's bonus as 2000",
      "slug" : "employee-bonus",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Empty table",
      "input" : "Employee table is empty and Bonus table is empty",
      "slug" : "employee-bonus",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "John's bonus as 1000, Jane's bonus as 2000, Joe's bonus as 0",
      "input" : "Employee table contains John, Jane, Joe and Bonus table contains John's bonus as 1000, Jane's bonus as 2000",
      "slug" : "employee-bonus",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "John's bonus as 0",
      "input" : "Employee table contains John and Bonus table is empty",
      "slug" : "employee-bonus",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Alice",
      "input" : "Employee table: [(1, 'John', 1, 10000), (2, 'Alice', 1, 20000), (3, 'Bob', 2, 15000)], id is the unique identifier, managerId is the id of the employee's manager",
      "slug" : "employees-earning-more-than-their-managers",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Alice, Bob",
      "input" : "Employee table: [(1, 'John', null, 10000), (2, 'Alice', 1, 20000), (3, 'Bob', 2, 15000)]",
      "slug" : "employees-earning-more-than-their-managers",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Alice",
      "input" : "Employee table: [(1, 'John', null, 10000), (2, 'Alice', 1, 20000), (3, 'Bob', 2, 15000)]",
      "slug" : "employees-earning-more-than-their-managers",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Bob",
      "input" : "Employee table: [(1, 'John', null, 10000), (2, 'Alice', 1, 8000), (3, 'Bob', 2, 25000)]",
      "slug" : "employees-earning-more-than-their-managers",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "new table with updated seat assignments",
      "input" : "seats table with id and student columns",
      "slug" : "exchange-seats",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "new table with updated seat assignments and correct handling of duplicate student names",
      "input" : "seats table with duplicate student names",
      "slug" : "exchange-seats",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "new table with updated seat assignments",
      "input" : "seats table with id and student columns",
      "slug" : "exchange-seats",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "new table with updated seat assignments and correct handling of duplicate student names",
      "input" : "seats table with duplicate student names",
      "slug" : "exchange-seats",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "The names of customers without a referee",
      "input" : "CREATE TABLE Customer (id INT, name VARCHAR(255), referee_id INT)",
      "slug" : "find-customer-referee",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Alice, Bob",
      "input" : "INSERT INTO Customer (id, name, referee_id) VALUES (1, 'John', 2), (2, 'Alice', NULL), (3, 'Bob', 1)",
      "slug" : "find-customer-referee",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "The names of customers without a referee",
      "input" : "CREATE TABLE Customer (id INT, name VARCHAR(255), referee_id INT)",
      "slug" : "find-customer-referee",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Alice, Bob",
      "input" : "INSERT INTO Customer (id, name, referee_id) VALUES (1, 'John', 2), (2, 'Alice', NULL), (3, 'Bob', 1)",
      "slug" : "find-customer-referee",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Alice, Bob, David, Eve",
      "input" : "INSERT INTO Customer (id, name, referee_id) VALUES (4, 'Eve', 3), (5, 'David', NULL)",
      "slug" : "find-customer-referee",
      "status" : "SKIP",
      "testIndex" : 2
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "2",
      "input" : "activity table with data: (1, '2016-03-01'), (2, '2016-03-01'), (1, '2016-03-02'), (3, '2016-03-01')",
      "slug" : "game-play-analysis-i",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "1",
      "input" : "activity table with data: (1, '2016-03-01'), (2, '2016-03-02'), (3, '2016-03-01')",
      "slug" : "game-play-analysis-i",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "2",
      "input" : "activity table with data: (1, '2016-03-01'), (2, '2016-03-01'), (1, '2016-03-02'), (3, '2016-03-01')",
      "slug" : "game-play-analysis-i",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "1",
      "input" : "activity table with data: (1, '2016-03-01'), (2, '2016-03-02'), (3, '2016-03-01')",
      "slug" : "game-play-analysis-i",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "2 players with their respective games played",
      "input" : "Activity table with 5 rows",
      "slug" : "game-play-analysis-iv",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "3 players with their respective games played",
      "input" : "Activity table with 10 rows",
      "slug" : "game-play-analysis-iv",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "2 players with their respective games played",
      "input" : "Activity table with 5 rows",
      "slug" : "game-play-analysis-iv",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "3 players with their respective games played",
      "input" : "Activity table with 10 rows",
      "slug" : "game-play-analysis-iv",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "total investment: 1000, total investments: 10",
      "input" : "investments table with 10 rows for 2016",
      "slug" : "investments-in-2016",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "total investment: 0, total investments: 0",
      "input" : "investments table with 100 rows for 2015",
      "slug" : "investments-in-2016",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "total investment: 100000, total investments: 1000",
      "input" : "investments table with 1000 rows for 2016",
      "slug" : "investments-in-2016",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "total investment: 0, total investments: 0",
      "input" : "investments table with 10000 rows for 2017",
      "slug" : "investments-in-2016",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Name of managers 1 and 2",
      "input" : "Employee table with IDs 1, 2, 3, 4, 5, 6 and manager IDs 1, 1, 2, 2, 2, 2",
      "slug" : "managers-with-at-least-5-direct-reports",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute-Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Name of manager 3",
      "input" : "Employee table with IDs 7, 8, 9 and manager IDs 3, 3, 3",
      "slug" : "managers-with-at-least-5-direct-reports",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Name of manager 4",
      "input" : "Employee table with IDs 10, 11, 12 and manager IDs 4, 4, 4",
      "slug" : "managers-with-at-least-5-direct-reports",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Name of manager 5",
      "input" : "Employee table with IDs 13, 14, 15, 16, 17 and manager IDs 5, 5, 5, 5, 5",
      "slug" : "managers-with-at-least-5-direct-reports",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "the row with id = 1",
      "input" : "id = 1, description = 'not boring'",
      "slug" : "not-boring-movies",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "no row",
      "input" : "id = 2, description = 'boring'",
      "slug" : "not-boring-movies",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "the row with id = 1",
      "input" : "id = 1, description = 'interesting'",
      "slug" : "not-boring-movies",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "no row",
      "input" : "id = 3, description = 'boring'",
      "slug" : "not-boring-movies",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "200",
      "input" : "CREATE TABLE Employee (id INT PRIMARY KEY, salary INT); INSERT INTO Employee (id, salary) VALUES (1, 100); INSERT INTO Employee (id, salary) VALUES (2, 200); INSERT INTO Employee (id, salary) VALUES (3, 300); CALL getNthHighestSalary(2)",
      "slug" : "nth-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "300",
      "input" : "CREATE TABLE Employee (id INT PRIMARY KEY, salary INT); INSERT INTO Employee (id, salary) VALUES (1, 100); INSERT INTO Employee (id, salary) VALUES (2, 200); INSERT INTO Employee (id, salary) VALUES (3, 300); CALL getNthHighestSalary(1)",
      "slug" : "nth-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "200",
      "input" : "CREATE TABLE Employee (id INT PRIMARY KEY, salary INT); INSERT INTO Employee (id, salary) VALUES (1, 100); INSERT INTO Employee (id, salary) VALUES (2, 200); INSERT INTO Employee (id, salary) VALUES (3, 300); CALL getNthHighestSalary(2)",
      "slug" : "nth-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "100",
      "input" : "CREATE TABLE Employee (id INT PRIMARY KEY, salary INT); INSERT INTO Employee (id, salary) VALUES (1, 100); INSERT INTO Employee (id, salary) VALUES (2, 200); INSERT INTO Employee (id, salary) VALUES (3, 300); CALL getNthHighestSalary(3)",
      "slug" : "nth-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "(100, 1), (200, 2), (50, 3)",
      "input" : "CREATE TABLE Scores (score INT); INSERT INTO Scores (score) VALUES (100), (200), (50);",
      "slug" : "rank-scores",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "(200, 1), (150, 2), (100, 3), (50, 4)",
      "input" : "CREATE TABLE Scores (score INT); INSERT INTO Scores (score) VALUES (100), (200), (50), (150);",
      "slug" : "rank-scores",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "(200, 1), (100, 2), (50, 3)",
      "input" : "CREATE TABLE Scores (score INT); INSERT INTO Scores (score) VALUES (100), (200), (50);",
      "slug" : "rank-scores",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "(200, 1), (150, 2), (100, 3), (50, 4)",
      "input" : "CREATE TABLE Scores (score INT); INSERT INTO Scores (score) VALUES (100), (200), (50), (150);",
      "slug" : "rank-scores",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "2, '2022-01-02'",
      "input" : "CREATE TABLE Weather (id INT, recordDate DATE, Temperature INT); INSERT INTO Weather (id, recordDate, Temperature) VALUES (1, '2022-01-01', 20), (2, '2022-01-02', 25), (3, '2022-01-03', 22);",
      "slug" : "rising-temperature",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "3, '2022-01-03'",
      "input" : "CREATE TABLE Weather (id INT, recordDate DATE, Temperature INT); INSERT INTO Weather (id, recordDate, Temperature) VALUES (1, '2022-01-01', 20), (2, '2022-01-02', 15), (3, '2022-01-03', 22);",
      "slug" : "rising-temperature",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "2, '2022-01-02'",
      "input" : "CREATE TABLE Weather (id INT, recordDate DATE, Temperature INT); INSERT INTO Weather (id, recordDate, Temperature) VALUES (1, '2022-01-01', 20), (2, '2022-01-02', 25), (3, '2022-01-03', 22);",
      "slug" : "rising-temperature",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "3, '2022-01-03'",
      "input" : "CREATE TABLE Weather (id INT, recordDate DATE, Temperature INT); INSERT INTO Weather (id, recordDate, Temperature) VALUES (1, '2022-01-01', 20), (2, '2022-01-02', 15), (3, '2022-01-03', 22);",
      "slug" : "rising-temperature",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[\"John\", \"Jane\"]",
      "input" : "salesperson table with 2 rows, customer table with 2 rows, each sales person has made sales to both customers",
      "slug" : "sales-person",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "[\"John\"]",
      "input" : "salesperson table with 2 rows, customer table with 3 rows, only one sales person has made sales to all customers",
      "slug" : "sales-person",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[\"John\", \"Jane\"]",
      "input" : "salesperson table with 2 rows, customer table with 2 rows, each sales person has made sales to both customers",
      "slug" : "sales-person",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "[\"John\"]",
      "input" : "salesperson table with 2 rows, customer table with 3 rows, only one sales person has made sales to all customers",
      "slug" : "sales-person",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "300",
      "input" : "Employee table with salaries 100, 200, 300, 400",
      "slug" : "second-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Baseline Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "NULL",
      "input" : "Employee table with salaries 100, 100, 100, 100",
      "slug" : "second-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "300",
      "input" : "Employee table with salaries 100, 200, 300, 400",
      "slug" : "second-highest-salary",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "NULL",
      "input" : "Employee table with salaries 100, 100, 100, 100",
      "slug" : "second-highest-salary",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Employees table with employees id = 1, name = 'John', sex = 'f' and id = 2, name = 'Jane', sex = 'm'",
      "input" : "Employees table with employees id = 1, name = 'John', sex = 'm' and id = 2, name = 'Jane', sex = 'f'",
      "slug" : "swap-sex-of-employees",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force Approach",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "Employees table with employees id = 1, name = 'Jim', sex = 'f', id = 2, name = 'Jill', sex = 'm', id = 3, name = 'Jack', sex = 'f'",
      "input" : "Employees table with employees id = 1, name = 'Jim', sex = 'm', id = 2, name = 'Jill', sex = 'f', id = 3, name = 'Jack', sex = 'm'",
      "slug" : "swap-sex-of-employees",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Employees table with employees id = 1, name = 'John', sex = 'f' and id = 2, name = 'Jane', sex = 'm'",
      "input" : "Employees table with employees id = 1, name = 'John', sex = 'm' and id = 2, name = 'Jane', sex = 'f'",
      "slug" : "swap-sex-of-employees",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized Approach",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "Employees table with employees id = 1, name = 'Jim', sex = 'f', id = 2, name = 'Jill', sex = 'm', id = 3, name = 'Jack', sex = 'f'",
      "input" : "Employees table with employees id = 1, name = 'Jim', sex = 'm', id = 2, name = 'Jill', sex = 'f', id = 3, name = 'Jack', sex = 'm'",
      "slug" : "swap-sex-of-employees",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "The 10th line of the file",
      "input" : "file.txt contains 10 lines of text",
      "slug" : "tenth-line",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Brute Force",
      "approachOrder" : 1,
      "error" : "Could not extract function signature",
      "expected" : "null or an error",
      "input" : "file.txt contains less than 10 lines of text",
      "slug" : "tenth-line",
      "status" : "SKIP",
      "testIndex" : 1
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "The 10th line of the file",
      "input" : "file.txt contains exactly 10 lines of text",
      "slug" : "tenth-line",
      "status" : "SKIP",
      "testIndex" : 0
    },
    {
      "approachName" : "Optimized",
      "approachOrder" : 2,
      "error" : "Could not extract function signature",
      "expected" : "The 10th line of the file",
      "input" : "file.txt contains more than 10 lines of text",
      "slug" : "tenth-line",
      "status" : "SKIP",
      "testIndex" : 1
    }
  ],
  "timestamp" : "2026-02-09T05:13:52Z",
  "total" : 2680
}