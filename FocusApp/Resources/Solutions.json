{
  "version": "1.0.0",
  "solutions": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "problemSlug": "reverse-linked-list",
      "summary": "Reverse the direction of pointers in a linked list. The key insight is that you need to track three nodes at once: previous, current, and next.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440101",
          "name": "Iterative",
          "order": 1,
          "intuition": "We traverse the list once, reversing each pointer as we go. At each step, we need to:\n1. Save the next node (before we lose the reference)\n2. Point current node backwards to previous\n3. Move both pointers forward",
          "approach": "1. Initialize prev as nil and curr as head\n2. While curr is not nil:\n   - Store next = curr.next (save reference)\n   - Set curr.next = prev (reverse pointer)\n   - Move prev = curr\n   - Move curr = next\n3. Return prev (the new head)",
          "explanation": "The trick is maintaining three pointers:\n- prev: the node we just processed\n- curr: the node we're currently processing\n- next: the node we'll process next\n\nBefore reversing curr's pointer, we must save curr.next, otherwise we lose access to the rest of the list. After the loop, prev points to what was the last node, which is now the new head.",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    \n    while curr != nil {\n        let next = curr?.next  // Save next\n        curr?.next = prev      // Reverse pointer\n        prev = curr            // Move prev forward\n        curr = next            // Move curr forward\n    }\n    \n    return prev\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We visit each node exactly once",
            "spaceExplanation": "Only use three pointers regardless of list size"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440201",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "[5,4,3,2,1]",
              "explanation": "Each arrow reverses: 1\u21922\u21923\u21924\u21925 becomes 5\u21924\u21923\u21922\u21921"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440202",
              "input": "[1,2]",
              "expectedOutput": "[2,1]",
              "explanation": "Simple case: 1\u21922 becomes 2\u21921"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440102",
          "name": "Recursive",
          "order": 2,
          "intuition": "Recursively reverse the rest of the list, then fix up the current node's pointers. The base case is when we reach the last node (which becomes our new head).",
          "approach": "1. Base case: if head is nil or head.next is nil, return head\n2. Recursively reverse the rest: newHead = reverseList(head.next)\n3. Make the next node point back: head.next.next = head\n4. Clear current node's next: head.next = nil\n5. Return newHead (propagate through all calls)",
          "explanation": "The recursion reaches the end of the list first, then as it unwinds:\n- At each step, head.next still points to the last node we processed\n- We make that node point back to us (head.next.next = head)\n- We clear our own next pointer (will be set by the previous recursive call)\n\nThe newHead is returned unchanged through all recursive calls.",
          "code": "func reverseList(_ head: ListNode?) -> ListNode? {\n    // Base case: empty or single node\n    guard let head = head, let next = head.next else {\n        return head\n    }\n    \n    // Recursively reverse the rest\n    let newHead = reverseList(next)\n    \n    // Fix pointers\n    next.next = head  // Make next point back to us\n    head.next = nil   // Clear our forward pointer\n    \n    return newHead\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Visit each node once via recursion",
            "spaceExplanation": "Recursive call stack uses O(n) space"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "reverse-linked-list-ii",
        "palindrome-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440002",
      "problemSlug": "merge-two-sorted-lists",
      "summary": "Merge two sorted linked lists by comparing nodes one at a time and building a new list. Use a dummy head to simplify edge cases.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440103",
          "name": "Iterative with Dummy",
          "order": 1,
          "intuition": "Compare the heads of both lists, take the smaller one, and advance that list's pointer. A dummy node avoids special-casing the first node.",
          "approach": "1. Create a dummy node to serve as the start\n2. Use a tail pointer to build the result\n3. While both lists have nodes:\n   - Compare values, append smaller to tail\n   - Advance the list we took from\n4. Append remaining nodes from non-empty list\n5. Return dummy.next",
          "explanation": "The dummy node trick is powerful: instead of tracking whether we've added the first node, we always have a valid tail to append to. At the end, dummy.next is our actual head.\n\nWhen one list is exhausted, we can directly link the remainder since it's already sorted.",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = list1\n    var l2 = list2\n    \n    while let node1 = l1, let node2 = l2 {\n        if node1.val <= node2.val {\n            tail.next = node1\n            l1 = node1.next\n        } else {\n            tail.next = node2\n            l2 = node2.next\n        }\n        tail = tail.next!\n    }\n    \n    // Append remaining nodes\n    tail.next = l1 ?? l2\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(1)",
            "timeExplanation": "Visit each node in both lists once",
            "spaceExplanation": "Only use a few pointers, reuse existing nodes"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440203",
              "input": "list1 = [1,2,4], list2 = [1,3,4]",
              "expectedOutput": "[1,1,2,3,4,4]",
              "explanation": "Compare 1\u22641, take l1. Compare 2>1, take l2. Continue..."
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440104",
          "name": "Recursive",
          "order": 2,
          "intuition": "The merged list starts with the smaller head, followed by the merge of the remaining elements.",
          "approach": "1. Base case: if either list is empty, return the other\n2. Compare heads, take the smaller one as current head\n3. Recursively merge the rest\n4. Return the current head",
          "explanation": "Each recursive call handles one node, choosing the smaller of the two heads. The recursion naturally unwinds to build the complete list.",
          "code": "func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n    guard let l1 = list1 else { return list2 }\n    guard let l2 = list2 else { return list1 }\n    \n    if l1.val <= l2.val {\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n    }\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(n + m)",
            "timeExplanation": "Each node processed once",
            "spaceExplanation": "Recursive stack depth equals total nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "merge-k-sorted-lists",
        "sort-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440003",
      "problemSlug": "linked-list-cycle",
      "summary": "Detect if a linked list has a cycle using Floyd's Tortoise and Hare algorithm. Two pointers moving at different speeds will meet if there's a cycle.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440105",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "intuition": "Use two pointers: slow moves 1 step, fast moves 2 steps. If there's a cycle, fast will eventually catch up to slow. If no cycle, fast will reach the end.",
          "approach": "1. Initialize slow and fast to head\n2. While fast and fast.next exist:\n   - Move slow one step\n   - Move fast two steps\n   - If they meet, return true\n3. Return false (fast reached end)",
          "explanation": "Why does this work? In a cycle, the fast pointer gains one position on slow each iteration. Eventually they must meet.\n\nMathematically: if cycle length is C, fast catches up by 1 each step, so they meet within C steps after slow enters the cycle.",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var slow = head\n    var fast = head\n    \n    while fast != nil && fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        \n        if slow === fast {\n            return true\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "At most 2n iterations before detection or end",
            "spaceExplanation": "Only two pointers used"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440204",
              "input": "[3,2,0,-4], pos = 1",
              "expectedOutput": "true",
              "explanation": "Tail connects to node at index 1 (value 2)"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440205",
              "input": "[1], pos = -1",
              "expectedOutput": "false",
              "explanation": "Single node with no cycle"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440106",
          "name": "Hash Set",
          "order": 2,
          "intuition": "Track visited nodes in a set. If we see a node twice, there's a cycle.",
          "approach": "1. Create an empty set of visited nodes\n2. Traverse the list:\n   - If current node is in set, return true\n   - Add current node to set\n3. Return false if we reach the end",
          "explanation": "Simple but uses extra space. We store node references (not values) to handle duplicate values correctly.",
          "code": "func hasCycle(_ head: ListNode?) -> Bool {\n    var visited = Set<ObjectIdentifier>()\n    var current = head\n    \n    while let node = current {\n        let id = ObjectIdentifier(node)\n        if visited.contains(id) {\n            return true\n        }\n        visited.insert(id)\n        current = node.next\n    }\n    \n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Visit each node once",
            "spaceExplanation": "Store up to n node references"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "linked-list-cycle-ii",
        "happy-number"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440004",
      "problemSlug": "reorder-list",
      "summary": "Reorder list from L0\u2192L1\u2192...\u2192Ln to L0\u2192Ln\u2192L1\u2192Ln-1\u2192... by finding middle, reversing second half, then merging alternately.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440107",
          "name": "Three-Step Approach",
          "order": 1,
          "intuition": "The reordered list alternates between taking from the start and end. We can achieve this by:\n1. Split the list into two halves\n2. Reverse the second half\n3. Merge both halves by alternating nodes",
          "approach": "1. Find the middle using slow/fast pointers\n2. Split the list at the middle\n3. Reverse the second half\n4. Merge by alternating: take from first, then second, repeat",
          "explanation": "This approach transforms the problem into three simpler sub-problems we already know how to solve:\n\n- Finding middle: slow/fast pointer technique (slow moves 1 step, fast moves 2)\n- Reversing: standard iterative reversal with prev/curr/next pointers\n- Merging: similar to merge two lists, but we alternate instead of comparing\n\nKey insight: after reversing the second half, both halves are the same length (\u00b11), so we can interleave them directly.",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head, head.next != nil else { return }\n    \n    // Step 1: Find middle\n    var slow = head\n    var fast = head\n    while fast.next != nil && fast.next?.next != nil {\n        slow = slow.next!\n        fast = fast.next!.next!\n    }\n    \n    // Step 2: Split and reverse second half\n    var second = slow.next\n    slow.next = nil  // Cut the list\n    second = reverseList(second)\n    \n    // Step 3: Merge alternately\n    var first: ListNode? = head\n    while second != nil {\n        let tmp1 = first?.next\n        let tmp2 = second?.next\n        first?.next = second\n        second?.next = tmp1\n        first = tmp1\n        second = tmp2\n    }\n}\n\nprivate func reverseList(_ head: ListNode?) -> ListNode? {\n    var prev: ListNode? = nil\n    var curr = head\n    while curr != nil {\n        let next = curr?.next\n        curr?.next = prev\n        prev = curr\n        curr = next\n    }\n    return prev\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each step (find middle, reverse, merge) is O(n), total is O(n)",
            "spaceExplanation": "Only use pointer variables, no extra data structures"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440206",
              "input": "[1,2,3,4]",
              "expectedOutput": "[1,4,2,3]",
              "explanation": "Split: [1,2] and [3,4]. Reverse second: [4,3]. Merge: 1\u21924\u21922\u21923"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440207",
              "input": "[1,2,3,4,5]",
              "expectedOutput": "[1,5,2,4,3]",
              "explanation": "Split: [1,2,3] and [4,5]. Reverse second: [5,4]. Merge: 1\u21925\u21922\u21924\u21923"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440108",
          "name": "Stack-Based",
          "order": 2,
          "intuition": "Use a stack to access nodes from the end. Push all nodes, then pop half while traversing from the front to interleave.",
          "approach": "1. Push all nodes onto a stack\n2. Calculate how many nodes to interleave (n/2)\n3. Traverse from head, pop from stack, insert popped nodes between current nodes\n4. Handle the final next pointer",
          "explanation": "The stack gives us O(1) access to the 'end' of the list. By pushing all nodes, the top of the stack is the last node, second-to-top is second-to-last, etc.\n\nWe only need to interleave n/2 nodes from the end, where n is the total count. After interleaving, we must set the final node's next to nil to avoid a cycle.",
          "code": "func reorderList(_ head: ListNode?) {\n    guard let head = head else { return }\n    \n    // Push all nodes to stack\n    var stack: [ListNode] = []\n    var node: ListNode? = head\n    while let n = node {\n        stack.append(n)\n        node = n.next\n    }\n    \n    let count = stack.count\n    var curr: ListNode? = head\n    \n    // Interleave n/2 nodes from the end\n    for _ in 0..<(count / 2) {\n        let end = stack.removeLast()\n        let next = curr?.next\n        curr?.next = end\n        end.next = next\n        curr = next\n    }\n    \n    // Terminate the list\n    curr?.next = nil\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Push n nodes, then interleave n/2 times",
            "spaceExplanation": "Stack stores all n nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "palindrome-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440005",
      "problemSlug": "remove-nth-node-from-end-of-list",
      "summary": "Remove the nth node from the end using two pointers with a gap of n. When the ahead pointer reaches the end, the behind pointer is at the node before the target.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440109",
          "name": "Two Pointers with Gap",
          "order": 1,
          "intuition": "If we maintain a gap of n nodes between two pointers, when the front pointer reaches the end, the back pointer will be exactly n nodes from the end.\n\nA dummy node handles edge cases like removing the head.",
          "approach": "1. Create dummy node pointing to head\n2. Initialize both pointers at dummy\n3. Move ahead pointer n+1 steps (creates gap of n)\n4. Move both pointers until ahead reaches nil\n5. Skip the target: behind.next = behind.next.next\n6. Return dummy.next",
          "explanation": "The key insight is the gap. If ahead is n+1 nodes ahead of behind, when ahead is nil (past the end), behind is at the node BEFORE the one we want to remove.\n\nWhy n+1 instead of n? Because we need behind to point to the predecessor of the target node so we can update its next pointer.\n\nThe dummy node elegantly handles removing the head: if n equals the list length, behind stays at dummy, and behind.next becomes the original head (which we skip).",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    var behind: ListNode? = dummy\n    var ahead: ListNode? = dummy\n    \n    // Create gap of n+1\n    for _ in 0...n {\n        ahead = ahead?.next\n    }\n    \n    // Move both until ahead reaches end\n    while ahead != nil {\n        behind = behind?.next\n        ahead = ahead?.next\n    }\n    \n    // Skip the nth node from end\n    behind?.next = behind?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(1)",
            "timeExplanation": "Single pass through the list where L is list length",
            "spaceExplanation": "Only use two pointer variables plus dummy"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440208",
              "input": "head = [1,2,3,4,5], n = 2",
              "expectedOutput": "[1,2,3,5]",
              "explanation": "Remove 4 (2nd from end). Gap of 2 means when ahead=nil, behind points to 3"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440209",
              "input": "head = [1], n = 1",
              "expectedOutput": "[]",
              "explanation": "Remove only node. Dummy handles this: behind stays at dummy, skips head"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440210",
              "input": "head = [1,2], n = 1",
              "expectedOutput": "[1]",
              "explanation": "Remove 2 (last node). behind ends at node 1, skips node 2"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440110",
          "name": "Two Pass",
          "order": 2,
          "intuition": "First pass counts the total length. Second pass removes the (length - n)th node from the beginning.",
          "approach": "1. First pass: count total nodes (length)\n2. Calculate target index: length - n\n3. Use dummy node for edge case handling\n4. Second pass: traverse to node at index (target - 1)\n5. Skip the target node",
          "explanation": "Converting 'nth from end' to 'kth from start' simplifies the problem. If list has L nodes, the nth from end is the (L-n)th from start (0-indexed).\n\nWe traverse to position (L-n-1) to reach the predecessor, then update its next pointer.\n\nLess elegant than one-pass but easier to understand and implement correctly.",
          "code": "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n    // First pass: count length\n    var length = 0\n    var node = head\n    while node != nil {\n        length += 1\n        node = node?.next\n    }\n    \n    let dummy = ListNode(0)\n    dummy.next = head\n    \n    // Find predecessor of target (at position length - n - 1 from dummy)\n    var curr: ListNode? = dummy\n    for _ in 0..<(length - n) {\n        curr = curr?.next\n    }\n    \n    // Skip target\n    curr?.next = curr?.next?.next\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(1)",
            "timeExplanation": "Two passes: first counts L nodes, second traverses L-n nodes",
            "spaceExplanation": "Only use counter and pointer variables"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "delete-the-middle-node-of-a-linked-list",
        "swapping-nodes-in-a-linked-list"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440006",
      "problemSlug": "merge-k-sorted-lists",
      "summary": "Merge k sorted linked lists into one sorted list. Use a min-heap for O(n log k) efficiency, or divide and conquer by repeatedly merging pairs.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440111",
          "name": "Min-Heap (Priority Queue)",
          "order": 1,
          "intuition": "Always pick the smallest available node across all k lists. A min-heap gives us O(log k) access to the minimum among k candidates.\n\nAt any time, the heap contains at most one node from each list (the current head).",
          "approach": "1. Create a min-heap ordered by node value\n2. Add the head of each non-empty list to the heap\n3. While heap is not empty:\n   - Pop the minimum node\n   - Append it to the result\n   - If that node has a next, push next to heap\n4. Return the merged list",
          "explanation": "The heap maintains the 'frontier' of each list - the next candidate node from each list. By always extracting the minimum, we build the sorted result.\n\nSwift doesn't have a built-in heap, so we implement a simple one or use an array with manual sorting (less efficient but simpler).\n\nKey insight: each node is pushed and popped exactly once, and each operation is O(log k).",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    // Simple approach using sorted array (for interview, explain heap would be better)\n    var nodes: [ListNode] = []\n    \n    // Collect all nodes\n    for list in lists {\n        var node = list\n        while let n = node {\n            nodes.append(n)\n            node = n.next\n        }\n    }\n    \n    // Sort by value\n    nodes.sort { $0.val < $1.val }\n    \n    // Rebuild list\n    let dummy = ListNode(0)\n    var tail = dummy\n    for node in nodes {\n        tail.next = node\n        tail = node\n    }\n    tail.next = nil\n    \n    return dummy.next\n}\n\n// Optimal with custom min-heap\nfunc mergeKListsHeap(_ lists: [ListNode?]) -> ListNode? {\n    var heap: [ListNode] = lists.compactMap { $0 }\n    \n    func heapifyUp(_ i: Int) {\n        var i = i\n        while i > 0 && heap[(i-1)/2].val > heap[i].val {\n            heap.swapAt(i, (i-1)/2)\n            i = (i-1)/2\n        }\n    }\n    \n    func heapifyDown(_ i: Int) {\n        var i = i\n        while 2*i + 1 < heap.count {\n            var smallest = 2*i + 1\n            if smallest + 1 < heap.count && heap[smallest+1].val < heap[smallest].val {\n                smallest += 1\n            }\n            if heap[i].val <= heap[smallest].val { break }\n            heap.swapAt(i, smallest)\n            i = smallest\n        }\n    }\n    \n    // Build heap\n    for i in (0..<heap.count).reversed() { heapifyDown(i) }\n    \n    let dummy = ListNode(0)\n    var tail = dummy\n    \n    while !heap.isEmpty {\n        let min = heap[0]\n        tail.next = min\n        tail = min\n        \n        if let next = min.next {\n            heap[0] = next\n            heapifyDown(0)\n        } else {\n            heap[0] = heap[heap.count - 1]\n            heap.removeLast()\n            if !heap.isEmpty { heapifyDown(0) }\n        }\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(N log k)",
            "space": "O(k)",
            "timeExplanation": "N total nodes, each pushed/popped once with O(log k) heap operations",
            "spaceExplanation": "Heap stores at most k nodes (one per list)"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440211",
              "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
              "expectedOutput": "[1,1,2,3,4,4,5,6]",
              "explanation": "Heap starts with [1,1,2]. Pop 1, push 4. Pop 1, push 3. Continue..."
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440212",
              "input": "lists = []",
              "expectedOutput": "[]",
              "explanation": "Empty input returns empty list"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440112",
          "name": "Divide and Conquer",
          "order": 2,
          "intuition": "Pair up the k lists and merge each pair. After one round, we have k/2 lists. Repeat until one list remains.\n\nThis is like merge sort's merge step, applied to lists instead of arrays.",
          "approach": "1. If lists is empty, return nil\n2. While we have more than one list:\n   - Pair up lists and merge each pair\n   - Replace lists with merged results\n3. Return the single remaining list",
          "explanation": "Each 'round' halves the number of lists: k \u2192 k/2 \u2192 k/4 \u2192 ... \u2192 1.\n\nThere are O(log k) rounds, and each round processes all N nodes once (spread across the merges). Total: O(N log k).\n\nThis approach reuses our merge-two-lists solution and is often easier to implement correctly than a heap.",
          "code": "func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n    var lists = lists.compactMap { $0 }  // Remove nils\n    if lists.isEmpty { return nil }\n    \n    while lists.count > 1 {\n        var merged: [ListNode] = []\n        for i in stride(from: 0, to: lists.count, by: 2) {\n            let l1 = lists[i]\n            let l2 = i + 1 < lists.count ? lists[i + 1] : nil\n            if let m = mergeTwoLists(l1, l2) {\n                merged.append(m)\n            }\n        }\n        lists = merged\n    }\n    \n    return lists.first\n}\n\nprivate func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var l1 = l1, l2 = l2\n    \n    while let n1 = l1, let n2 = l2 {\n        if n1.val <= n2.val {\n            tail.next = n1\n            l1 = n1.next\n        } else {\n            tail.next = n2\n            l2 = n2.next\n        }\n        tail = tail.next!\n    }\n    tail.next = l1 ?? l2\n    return dummy.next\n}",
          "complexity": {
            "time": "O(N log k)",
            "space": "O(1)",
            "timeExplanation": "log k rounds, each processing all N nodes",
            "spaceExplanation": "Merge is done in-place, only using pointers"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "merge-two-sorted-lists",
        "ugly-number-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440007",
      "problemSlug": "copy-list-with-random-pointer",
      "summary": "Create a deep copy of a linked list where each node has a random pointer. Use a hash map to map original nodes to copies, enabling O(1) lookup for random pointers.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440113",
          "name": "Hash Map (Two Pass)",
          "order": 1,
          "intuition": "The challenge is that random pointers can point to nodes we haven't created yet. Solution: first create all nodes, then wire up the pointers.\n\nA hash map lets us find the copy of any original node in O(1).",
          "approach": "1. First pass: create a copy of each node, store original\u2192copy mapping\n2. Second pass: for each original node:\n   - Set copy.next = map[original.next]\n   - Set copy.random = map[original.random]\n3. Return map[head]",
          "explanation": "The hash map is the key insight. When we encounter original.random pointing to some node X, we need to find the copy of X. The map gives us this in O(1).\n\nFirst pass creates all nodes (values only). Second pass wires up both next and random pointers using the map.\n\nNote: we handle nil by checking before map lookup.",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard let head = head else { return nil }\n    \n    var map: [ObjectIdentifier: Node] = [:]\n    \n    // First pass: create all nodes\n    var curr: Node? = head\n    while let node = curr {\n        map[ObjectIdentifier(node)] = Node(node.val)\n        curr = node.next\n    }\n    \n    // Second pass: wire up pointers\n    curr = head\n    while let node = curr {\n        let copy = map[ObjectIdentifier(node)]!\n        if let next = node.next {\n            copy.next = map[ObjectIdentifier(next)]\n        }\n        if let random = node.random {\n            copy.random = map[ObjectIdentifier(random)]\n        }\n        curr = node.next\n    }\n    \n    return map[ObjectIdentifier(head)]\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Two passes through n nodes, O(1) per node",
            "spaceExplanation": "Hash map stores n node mappings"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440213",
              "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
              "explanation": "Deep copy with same structure. Node 1's random points to node 0, etc."
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440114",
          "name": "Interleaving (O(1) Space)",
          "order": 2,
          "intuition": "Avoid the hash map by interleaving copies with originals: A\u2192A'\u2192B\u2192B'\u2192C\u2192C'. Now A'.random = A.random.next (the copy is right after the original).",
          "approach": "1. Insert copy after each original: A\u2192A'\u2192B\u2192B'\u2192...\n2. Set random pointers: copy.random = original.random?.next\n3. Separate the two lists: restore original, extract copies",
          "explanation": "The interleaving trick embeds the 'map' in the list structure itself. Original.next always points to its copy.\n\nPhase 1: Create copies, insert after originals.\nPhase 2: Wire random pointers using the interleaved structure.\nPhase 3: Carefully unweave the two lists.\n\nThe separation step is tricky - we must restore the original list while extracting the copy list.",
          "code": "func copyRandomList(_ head: Node?) -> Node? {\n    guard head != nil else { return nil }\n    \n    // Phase 1: Insert copies after originals\n    var curr = head\n    while let node = curr {\n        let copy = Node(node.val)\n        copy.next = node.next\n        node.next = copy\n        curr = copy.next\n    }\n    \n    // Phase 2: Set random pointers\n    curr = head\n    while let node = curr {\n        let copy = node.next\n        copy?.random = node.random?.next  // Random's copy is right after random\n        curr = copy?.next\n    }\n    \n    // Phase 3: Separate lists\n    let dummy = Node(0)\n    var copyTail = dummy\n    curr = head\n    while let node = curr {\n        let copy = node.next!\n        let nextOrig = copy.next\n        \n        // Extract copy\n        copyTail.next = copy\n        copyTail = copy\n        \n        // Restore original\n        node.next = nextOrig\n        curr = nextOrig\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Three passes, each O(n)",
            "spaceExplanation": "No extra data structures, only pointers (output doesn't count)"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "clone-graph",
        "clone-binary-tree-with-random-pointer"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440008",
      "problemSlug": "add-two-numbers",
      "summary": "Add two numbers represented as reversed linked lists. Simulate digit-by-digit addition with carry, building the result list as you go.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440115",
          "name": "Elementary Math Simulation",
          "order": 1,
          "intuition": "Since digits are in reverse order (ones place first), we can add them directly left-to-right, just like manual addition.\n\nKeep track of the carry: if sum >= 10, carry 1 to the next digit.",
          "approach": "1. Initialize carry = 0 and result with dummy head\n2. While either list has nodes OR carry > 0:\n   - Get digits (0 if list exhausted)\n   - sum = digit1 + digit2 + carry\n   - Create node with sum % 10\n   - Update carry = sum / 10\n3. Return dummy.next",
          "explanation": "The reverse order is a gift - it means we process from least significant to most significant, exactly as in manual addition.\n\nHandling unequal lengths: treat exhausted list as contributing 0.\n\nDon't forget the final carry! If sum of last digits produces a carry, we need one more node (e.g., 5+5=10 needs [0,1]).\n\nThe dummy node simplifies appending the first result node.",
          "code": "func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n    let dummy = ListNode(0)\n    var tail = dummy\n    var p1 = l1\n    var p2 = l2\n    var carry = 0\n    \n    while p1 != nil || p2 != nil || carry > 0 {\n        let val1 = p1?.val ?? 0\n        let val2 = p2?.val ?? 0\n        let sum = val1 + val2 + carry\n        \n        carry = sum / 10\n        tail.next = ListNode(sum % 10)\n        tail = tail.next!\n        \n        p1 = p1?.next\n        p2 = p2?.next\n    }\n    \n    return dummy.next\n}",
          "complexity": {
            "time": "O(max(m, n))",
            "space": "O(max(m, n))",
            "timeExplanation": "Process max(m,n) digits where m and n are list lengths",
            "spaceExplanation": "Result list has at most max(m,n)+1 nodes"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440214",
              "input": "l1 = [2,4,3], l2 = [5,6,4]",
              "expectedOutput": "[7,0,8]",
              "explanation": "342 + 465 = 807. Process: 2+5=7, 4+6=10 (carry 1), 3+4+1=8"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440215",
              "input": "l1 = [9,9,9], l2 = [1]",
              "expectedOutput": "[0,0,0,1]",
              "explanation": "999 + 1 = 1000. Final carry creates extra digit"
            }
          ]
        }
      ],
      "relatedProblems": [
        "add-two-numbers-ii",
        "multiply-strings"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440009",
      "problemSlug": "find-the-duplicate-number",
      "summary": "Find the duplicate in array of n+1 integers where each is in [1,n]. Use Floyd's cycle detection - treat values as pointers to create a linked list with a cycle at the duplicate.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440116",
          "name": "Floyd's Cycle Detection",
          "order": 1,
          "intuition": "Treat the array as a linked list where nums[i] points to index nums[i]. Since there's a duplicate, two indices point to the same location, creating a cycle.\n\nThe cycle's entry point is the duplicate value.",
          "approach": "1. Phase 1 - Find intersection:\n   - slow = nums[slow], fast = nums[nums[fast]]\n   - Continue until they meet (inside cycle)\n2. Phase 2 - Find entry point:\n   - Reset slow to start (index 0)\n   - Move both one step at a time\n   - They meet at the duplicate",
          "explanation": "Why does this work? Consider the array as a graph where index i has an edge to index nums[i].\n\nSince values are in [1,n] and we start at index 0, we never revisit 0. But since there's a duplicate value, some index is pointed to by two different indices - that's our cycle entry.\n\nThe math for why phase 2 works: if slow traveled distance d to the meeting point, and cycle length is C, then fast traveled 2d. The meeting point is d mod C steps into the cycle. The entry point is exactly d mod C steps back, which equals the distance from start.",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    // Phase 1: Find intersection point\n    var slow = nums[0]\n    var fast = nums[0]\n    \n    repeat {\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    } while slow != fast\n    \n    // Phase 2: Find cycle entry (the duplicate)\n    slow = nums[0]\n    while slow != fast {\n        slow = nums[slow]\n        fast = nums[fast]\n    }\n    \n    return slow\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each phase traverses at most n elements",
            "spaceExplanation": "Only use two pointer variables"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440216",
              "input": "[1,3,4,2,2]",
              "expectedOutput": "2",
              "explanation": "Graph: 0\u21921\u21923\u21922\u21924\u21922 (cycle at 2). Duplicate is 2"
            },
            {
              "id": "550e8400-e29b-41d4-a716-446655440217",
              "input": "[3,1,3,4,2]",
              "expectedOutput": "3",
              "explanation": "Graph: 0\u21923\u21924\u21922\u21923 (cycle at 3). Duplicate is 3"
            }
          ]
        },
        {
          "id": "550e8400-e29b-41d4-a716-446655440117",
          "name": "Binary Search on Value Range",
          "order": 2,
          "intuition": "Binary search on the answer space [1,n]. For a candidate mid, count numbers \u2264 mid. If count > mid, duplicate is in [1,mid].",
          "approach": "1. Set lo = 1, hi = n\n2. While lo < hi:\n   - mid = (lo + hi) / 2\n   - Count elements \u2264 mid\n   - If count > mid: hi = mid (duplicate in lower half)\n   - Else: lo = mid + 1\n3. Return lo",
          "explanation": "The pigeonhole principle: if we have more than mid numbers in [1,mid], at least one must be duplicated.\n\nThis doesn't find which number is duplicated directly - it narrows down the range until lo == hi, which is the duplicate.\n\nExample: [1,3,4,2,2]. Count \u2264 2 is 3 (elements 1,2,2). Since 3 > 2, duplicate is in [1,2]. Count \u2264 1 is 1. So duplicate is 2.",
          "code": "func findDuplicate(_ nums: [Int]) -> Int {\n    var lo = 1\n    var hi = nums.count - 1\n    \n    while lo < hi {\n        let mid = lo + (hi - lo) / 2\n        let count = nums.filter { $0 <= mid }.count\n        \n        if count > mid {\n            hi = mid  // Duplicate in lower half\n        } else {\n            lo = mid + 1  // Duplicate in upper half\n        }\n    }\n    \n    return lo\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(1)",
            "timeExplanation": "O(log n) binary search iterations, each counting O(n) elements",
            "spaceExplanation": "Only use a few variables"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "linked-list-cycle-ii",
        "missing-number"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440010",
      "problemSlug": "lru-cache",
      "summary": "Implement an LRU cache with O(1) get and put. Combine a hash map (O(1) lookup) with a doubly linked list (O(1) insertion/deletion) to track recency.",
      "approaches": [
        {
          "id": "550e8400-e29b-41d4-a716-446655440118",
          "name": "Hash Map + Doubly Linked List",
          "order": 1,
          "intuition": "We need two operations in O(1):\n1. Find a key \u2192 hash map\n2. Track/update recency \u2192 doubly linked list\n\nMost recently used at head, least recently used at tail. On access, move node to head.",
          "approach": "1. Doubly linked list with dummy head/tail\n2. Hash map: key \u2192 node reference\n3. get(key): if exists, move to head, return value\n4. put(key, value):\n   - If exists: update value, move to head\n   - If new: create node, add to head, add to map\n   - If over capacity: remove tail node, remove from map",
          "explanation": "The doubly linked list maintains order by recency. The hash map provides O(1) access to any node.\n\nWhy doubly linked? We need to remove a node from the middle in O(1). With a doubly linked list, given a node reference, we can update prev.next and next.prev directly.\n\nDummy head and tail simplify edge cases (empty list, single element). The actual nodes are always between these dummies.",
          "code": "class LRUCache {\n    private class Node {\n        let key: Int\n        var value: Int\n        var prev: Node?\n        var next: Node?\n        \n        init(_ key: Int, _ value: Int) {\n            self.key = key\n            self.value = value\n        }\n    }\n    \n    private let capacity: Int\n    private var cache: [Int: Node] = [:]\n    private let head = Node(0, 0)  // Dummy head\n    private let tail = Node(0, 0)  // Dummy tail\n    \n    init(_ capacity: Int) {\n        self.capacity = capacity\n        head.next = tail\n        tail.prev = head\n    }\n    \n    func get(_ key: Int) -> Int {\n        guard let node = cache[key] else { return -1 }\n        moveToHead(node)\n        return node.value\n    }\n    \n    func put(_ key: Int, _ value: Int) {\n        if let node = cache[key] {\n            node.value = value\n            moveToHead(node)\n        } else {\n            let node = Node(key, value)\n            cache[key] = node\n            addToHead(node)\n            \n            if cache.count > capacity {\n                let removed = removeTail()\n                cache.removeValue(forKey: removed.key)\n            }\n        }\n    }\n    \n    private func addToHead(_ node: Node) {\n        node.prev = head\n        node.next = head.next\n        head.next?.prev = node\n        head.next = node\n    }\n    \n    private func removeNode(_ node: Node) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n    }\n    \n    private func moveToHead(_ node: Node) {\n        removeNode(node)\n        addToHead(node)\n    }\n    \n    private func removeTail() -> Node {\n        let node = tail.prev!\n        removeNode(node)\n        return node\n    }\n}",
          "complexity": {
            "time": "O(1)",
            "space": "O(capacity)",
            "timeExplanation": "Both get and put are O(1) - hash lookup and list operations are constant time",
            "spaceExplanation": "Store at most 'capacity' nodes in map and list"
          },
          "testCases": [
            {
              "id": "550e8400-e29b-41d4-a716-446655440218",
              "input": "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]",
              "expectedOutput": "[null,null,null,1,null,-1,null,-1,3,4]",
              "explanation": "After put(3,3), cache is [1,3]. get(2) returns -1 (evicted). After put(4,4), cache is [3,4]."
            }
          ]
        }
      ],
      "relatedProblems": [
        "lfu-cache",
        "design-in-memory-file-system"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "113bd68d-ec6b-40ce-b8d5-e276ed1a6f55",
      "problemSlug": "invert-binary-tree",
      "summary": "Invert a binary tree by swapping every node's left and right child. The simplest way is a DFS that swaps then recurses.",
      "approaches": [
        {
          "id": "0d68f729-008b-4c44-a14b-5db7877db5b5",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "If you swap a node's left and right children, and then do the same for its children, the entire tree becomes its mirror image.",
          "approach": "1. If root is nil, return nil.\n2. Swap root.left and root.right.\n3. Recursively invert the left subtree.\n4. Recursively invert the right subtree.\n5. Return root.",
          "explanation": "Each node is visited once. Swapping children at each node creates the mirror image. The recursion unwinds after reaching leaves.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    let temp = root.left\n    root.left = root.right\n    root.right = temp\n    _ = invertTree(root.left)\n    _ = invertTree(root.right)\n    return root\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Every node is visited exactly once",
            "spaceExplanation": "Recursion stack depth equals tree height h"
          },
          "testCases": [
            {
              "id": "0f14dc66-108b-4b35-b924-5eff2f49797c",
              "input": "root = [4,2,7,1,3,6,9]",
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap."
            },
            {
              "id": "67919ef7-73d2-44f6-bf81-ae8463aacbbb",
              "input": "root = [2,1,3]",
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root."
            }
          ]
        },
        {
          "id": "f3ccd674-5539-4a80-a251-444b32df5cb2",
          "name": "Iterative BFS",
          "order": 2,
          "intuition": "A level-order traversal lets us swap children for every node without recursion.",
          "approach": "1. If root is nil, return nil.\n2. Push root to a queue.\n3. While queue not empty: pop a node, swap its children, push non-nil children.\n4. Return root.",
          "explanation": "The queue visits nodes level by level. Swapping children during the visit yields the same mirror as the recursive solution.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    var queue: [TreeNode] = [root]\n    var index = 0\n    while index < queue.count {\n        let node = queue[index]\n        index += 1\n        let temp = node.left\n        node.left = node.right\n        node.right = temp\n        if let left = node.left { queue.append(left) }\n        if let right = node.right { queue.append(right) }\n    }\n    return root\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is processed once",
            "spaceExplanation": "Queue can hold up to a full level of nodes"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "d60edf13-e40b-4234-9de4-80e19e97ae9d",
      "problemSlug": "maximum-depth-of-binary-tree",
      "summary": "Maximum depth is the length of the longest root-to-leaf path. Compute it via DFS recursion or BFS level counting.",
      "approaches": [
        {
          "id": "050c5512-9554-480c-99ec-4fb2c0986636",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "The depth of a node is 1 plus the maximum depth of its children.",
          "approach": "1. If root is nil, return 0.\n2. Recursively compute leftDepth and rightDepth.\n3. Return 1 + max(leftDepth, rightDepth).",
          "explanation": "The recursion bottoms out at empty subtrees (depth 0). Each call returns the depth of that subtree.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height h"
          },
          "testCases": [
            {
              "id": "d8ea7529-25a9-46df-a1d5-ad66d281758e",
              "input": "root = [3,9,20,null,null,15,7]",
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3 \u2192 20 \u2192 15 (or 7)."
            },
            {
              "id": "b57d4658-6b70-4a70-a4c2-e6cc4d34e311",
              "input": "root = [1,null,2]",
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1 \u2192 2."
            }
          ]
        },
        {
          "id": "4a6e14d7-b155-4d01-86fd-0e782f6bb436",
          "name": "BFS Level Order",
          "order": 2,
          "intuition": "Each BFS layer corresponds to one depth level.",
          "approach": "1. If root is nil, return 0.\n2. Push root to a queue.\n3. For each level, process all nodes in the queue, enqueue their children.\n4. Count levels.",
          "explanation": "BFS processes nodes level by level, so the number of levels processed equals the maximum depth.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    var queue: [TreeNode] = [root]\n    var depth = 0\n    var index = 0\n    while index < queue.count {\n        let levelCount = queue.count - index\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        depth += 1\n    }\n    return depth\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node enqueued and dequeued once",
            "spaceExplanation": "Queue stores up to one full level"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "invert-binary-tree",
        "minimum-depth-of-binary-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "e0d239e6-12c6-431f-881c-d362768f9b11",
      "problemSlug": "same-tree",
      "summary": "Two trees are the same if their structures match and all corresponding node values are equal. Compare them node by node.",
      "approaches": [
        {
          "id": "67ad78db-e53d-41e1-bfb6-fc5d00c078c7",
          "name": "Recursive DFS",
          "order": 1,
          "intuition": "Both trees are equal if the current values match and both left subtrees and right subtrees are equal.",
          "approach": "1. If both nodes are nil, return true.\n2. If only one is nil, return false.\n3. If values differ, return false.\n4. Recursively compare left and right children.",
          "explanation": "The recursion enforces structural equality and value equality at every position.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited at most once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "122dfbc8-09a4-45e0-a5f3-409788a05360",
              "input": "p = [1,2,3], q = [1,2,3]",
              "expectedOutput": "true",
              "explanation": "Same structure and values."
            },
            {
              "id": "d32e933d-3be7-4018-887f-a9570607ba37",
              "input": "p = [1,2], q = [1,null,2]",
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child)."
            },
            {
              "id": "2dbb90c1-24c7-4b23-bd27-a3af1e8dd072",
              "input": "p = [1,2,1], q = [1,1,2]",
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes."
            }
          ]
        },
        {
          "id": "9901b309-c7f0-4a01-9f62-cb632648a7d1",
          "name": "Iterative Stack",
          "order": 2,
          "intuition": "Use a stack to compare nodes in lockstep without recursion.",
          "approach": "1. Push (p, q) onto a stack.\n2. While stack not empty: pop, compare nodes similarly to recursion.\n3. Push child pairs.\n4. If any mismatch, return false; otherwise true.",
          "explanation": "This mirrors DFS recursion but uses an explicit stack to avoid call stack usage.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    var stack: [(TreeNode?, TreeNode?)] = [(p, q)]\n    while let (left, right) = stack.popLast() {\n        if left == nil && right == nil { continue }\n        guard let l = left, let r = right else { return false }\n        if l.val != r.val { return false }\n        stack.append((l.left, r.left))\n        stack.append((l.right, r.right))\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node pair processed once",
            "spaceExplanation": "Stack holds nodes along a path"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "subtree-of-another-tree",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "39b75eb0-0ce6-46cd-a8d0-18e7f882b767",
      "problemSlug": "subtree-of-another-tree",
      "summary": "Check every node in the main tree as a potential root and compare subtrees for equality.",
      "approaches": [
        {
          "id": "3b0434af-e80d-47ad-985c-7923e0154acd",
          "name": "DFS + Same Tree",
          "order": 1,
          "intuition": "If two trees are identical, then subRoot matches the subtree at that node. Try this at every node in root.",
          "approach": "1. If root is nil, return false (subRoot is non-nil).\n2. If isSameTree(root, subRoot) return true.\n3. Otherwise, recurse on root.left and root.right.",
          "explanation": "We reuse a same-tree check. The first match we find proves subRoot is a subtree.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    guard let root = root else { return false }\n    if isSameTree(root, subRoot) { return true }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}\n\nprivate func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "time": "O(n * m)",
            "space": "O(h)",
            "timeExplanation": "In the worst case, compare subRoot at every node",
            "spaceExplanation": "Recursion stack height of root tree"
          },
          "testCases": [
            {
              "id": "20a2a01b-f130-4d94-b320-438eca23093b",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot."
            },
            {
              "id": "e9aba558-e4fa-4d94-8296-6cbd49810888",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality."
            }
          ]
        },
        {
          "id": "2c55fff8-4140-49a2-b3c2-053861a7769e",
          "name": "Serialization",
          "order": 2,
          "intuition": "Serialize both trees with null markers; subRoot is a subtree if its serialization is a substring of root's serialization.",
          "approach": "1. Serialize root with preorder + null markers.\n2. Serialize subRoot similarly.\n3. Check if subRoot serialization is contained in root serialization.",
          "explanation": "Null markers prevent false matches where different structures have the same value sequence.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    let rootStr = serialize(root)\n    let subStr = serialize(subRoot)\n    return rootStr.contains(subStr)\n}\n\nprivate func serialize(_ node: TreeNode?) -> String {\n    guard let node = node else { return \"#\" }\n    return \"(\\(node.val)),\\(serialize(node.left)),\\(serialize(node.right))\"\n}",
          "complexity": {
            "time": "O(n + m)",
            "space": "O(n + m)",
            "timeExplanation": "Serialize both trees once",
            "spaceExplanation": "Serialized strings store all nodes and nulls"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "same-tree",
        "find-duplicate-subtrees"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "32841a93-64e4-40c2-8f8a-bee6d4c5f666",
      "problemSlug": "lowest-common-ancestor-of-a-binary-search-tree",
      "summary": "Use the BST ordering: if both targets are less than the current node, go left; if greater, go right; otherwise current is the LCA.",
      "approaches": [
        {
          "id": "153d1e3d-75a6-4b8e-86bc-81ea9dbc1dba",
          "name": "Iterative BST Walk",
          "order": 1,
          "intuition": "In a BST, all left values are smaller and all right values are larger. The first split point is the LCA.",
          "approach": "1. Start at root.\n2. If both p and q are smaller, move left.\n3. If both larger, move right.\n4. Otherwise, current node is the LCA.",
          "explanation": "The LCA is the node where the paths to p and q diverge (or where one equals the current node).",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    var node = root\n    guard let p = p, let q = q else { return nil }\n    while let current = node {\n        if p.val < current.val && q.val < current.val {\n            node = current.left\n        } else if p.val > current.val && q.val > current.val {\n            node = current.right\n        } else {\n            return current\n        }\n    }\n    return nil\n}",
          "complexity": {
            "time": "O(h)",
            "space": "O(1)",
            "timeExplanation": "Walks down one path of height h",
            "spaceExplanation": "Iterative, constant extra space"
          },
          "testCases": [
            {
              "id": "38f1a9a5-13a3-4905-a7d9-bd93b2027500",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
              "expectedOutput": "6",
              "explanation": "p and q split at 6, so 6 is the LCA."
            },
            {
              "id": "812c7249-8f40-4310-978c-f8f10b0a8f6f",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
              "expectedOutput": "2",
              "explanation": "p is an ancestor of q, so LCA is 2."
            }
          ]
        },
        {
          "id": "25e41dd6-c040-42ec-83e3-965baa348c08",
          "name": "Recursive BST",
          "order": 2,
          "intuition": "The BST property lets us eliminate half the tree at each step using recursion.",
          "approach": "1. If both values are less than root, recurse left.\n2. If both greater, recurse right.\n3. Otherwise, root is the LCA.",
          "explanation": "Same logic as the iterative approach, but expressed recursively.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root, let p = p, let q = q else { return nil }\n    if p.val < root.val && q.val < root.val {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if p.val > root.val && q.val > root.val {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n}",
          "complexity": {
            "time": "O(h)",
            "space": "O(h)",
            "timeExplanation": "Traverses one root-to-leaf path",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "56d579d8-24d9-4502-8d47-d9c3bf6a0301",
              "input": "root = [2,1], p = 2, q = 1",
              "expectedOutput": "2",
              "explanation": "Root is the ancestor of both nodes."
            }
          ]
        }
      ],
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-tree",
        "validate-binary-search-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "bf8d33be-a2fd-469f-9a92-9dee92c4d0fe",
      "problemSlug": "binary-tree-level-order-traversal",
      "summary": "Traverse the tree level by level using a queue, collecting values for each level as you go.",
      "approaches": [
        {
          "id": "25312294-5031-458e-90c6-4c8cab60dacb",
          "name": "BFS by Level",
          "order": 1,
          "intuition": "Breadth-first search naturally visits nodes in level order. If we process nodes in fixed-size batches per level, we can build the result list of lists.",
          "approach": "1. If root is nil, return [].\n2. Initialize a queue with root.\n3. While queue not empty: record current queue size, pop that many nodes, collect values, and enqueue children.\n4. Append each level list to the result.",
          "explanation": "The queue holds nodes in the next level to process. Capturing the queue size before processing ensures each iteration only handles one level at a time.",
          "code": "func levelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var index = 0\n\n    while index < queue.count {\n        let levelCount = queue.count - index\n        var level: [Int] = []\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(level)\n    }\n\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is enqueued and dequeued exactly once",
            "spaceExplanation": "Queue can hold up to one full level of nodes"
          },
          "testCases": [
            {
              "id": "9f2e77b8-7e7f-4d6b-a5d4-7655d72ac176",
              "input": "root = [3,9,20,null,null,15,7]",
              "expectedOutput": "[[3],[9,20],[15,7]]",
              "explanation": "Level 0: [3], level 1: [9,20], level 2: [15,7]."
            },
            {
              "id": "4151eab9-a595-48a9-8e25-859a8941a9c3",
              "input": "root = [1]",
              "expectedOutput": "[[1]]",
              "explanation": "Single node forms one level."
            },
            {
              "id": "21a31bc5-894f-494f-85d1-1d21f0008299",
              "input": "root = []",
              "expectedOutput": "[]",
              "explanation": "Empty tree produces empty result."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal-ii",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "0353cc5c-702e-4d1a-a450-1ccb23ae4ff3",
      "problemSlug": "validate-binary-search-tree",
      "summary": "A BST is valid if every node value lies within allowed bounds and both subtrees are valid. Use DFS with min/max bounds.",
      "approaches": [
        {
          "id": "89f02580-9ff3-4722-84a5-5c0266733222",
          "name": "DFS with Bounds",
          "order": 1,
          "intuition": "Each node must be greater than all values in its left ancestors and less than all values in its right ancestors.",
          "approach": "1. Recurse with optional min and max bounds.\n2. If node.val <= min or node.val >= max, return false.\n3. Recurse left with max = node.val, right with min = node.val.",
          "explanation": "Bounds carry the valid range down the tree, enforcing the BST rule at every node, not just locally.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    func dfs(_ node: TreeNode?, _ minVal: Int?, _ maxVal: Int?) -> Bool {\n        guard let node = node else { return true }\n        if let minVal = minVal, node.val <= minVal { return false }\n        if let maxVal = maxVal, node.val >= maxVal { return false }\n        return dfs(node.left, minVal, node.val) && dfs(node.right, node.val, maxVal)\n    }\n    return dfs(root, nil, nil)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "c2954d68-4c67-4523-88eb-70976739d27b",
              "input": "root = [2,1,3]",
              "expectedOutput": "true",
              "explanation": "All nodes satisfy BST ordering."
            },
            {
              "id": "dd924f21-6113-4c2b-8b02-b135313db87f",
              "input": "root = [5,1,4,null,null,3,6]",
              "expectedOutput": "false",
              "explanation": "Right subtree contains 3 which is less than 5."
            }
          ]
        },
        {
          "id": "b33d33bc-0d11-40c8-8325-73ad89c9a61a",
          "name": "Inorder Traversal",
          "order": 2,
          "intuition": "Inorder traversal of a BST yields a strictly increasing sequence.",
          "approach": "1. Traverse inorder while tracking previous value.\n2. If current value <= previous, return false.\n3. Otherwise continue.",
          "explanation": "A single pass through the inorder sequence is enough to verify strict ordering.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    var prev: Int? = nil\n    var stack: [TreeNode] = []\n    var node = root\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        if let prev = prev, current.val <= prev { return false }\n        prev = current.val\n        node = current.right\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is pushed/popped once",
            "spaceExplanation": "Stack holds at most one root-to-leaf path"
          },
          "testCases": []
        }
      ],
      "relatedProblems": [
        "validate-binary-search-tree",
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "8caca365-f1ea-4ee1-9d57-18b73d6ffa78",
      "problemSlug": "kth-smallest-element-in-a-bst",
      "summary": "The inorder traversal of a BST is sorted. Walk inorder and stop at the kth value.",
      "approaches": [
        {
          "id": "a4188ae4-1591-4141-a97d-54be7ab95628",
          "name": "Iterative Inorder",
          "order": 1,
          "intuition": "Inorder traversal returns values in increasing order, so the kth visited node is the answer.",
          "approach": "1. Use a stack to simulate inorder traversal.\n2. Pop nodes and count visits.\n3. When count reaches k, return the node value.",
          "explanation": "The stack walks left as far as possible, then processes nodes in ascending order.",
          "code": "func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n    var stack: [TreeNode] = []\n    var node = root\n    var remaining = k\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        remaining -= 1\n        if remaining == 0 { return current.val }\n        node = current.right\n    }\n    return 0\n}",
          "complexity": {
            "time": "O(h + k)",
            "space": "O(h)",
            "timeExplanation": "Walk down height h, then visit k nodes",
            "spaceExplanation": "Stack holds at most h nodes"
          },
          "testCases": [
            {
              "id": "e1c24e01-a57c-4661-a5bc-5c2f02f2a718",
              "input": "root = [3,1,4,null,2], k = 1",
              "expectedOutput": "1",
              "explanation": "Inorder sequence is [1,2,3,4], kth=1."
            },
            {
              "id": "5796f1a9-8de9-4dfc-8d34-dea87d368c27",
              "input": "root = [5,3,6,2,4,null,null,1], k = 3",
              "expectedOutput": "3",
              "explanation": "Inorder sequence is [1,2,3,4,5,6], kth=3."
            }
          ]
        }
      ],
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-search-tree-iterator"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "0f6835b4-c6b9-4e33-9ea7-7652f64e3434",
      "problemSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "summary": "Preorder gives the root, inorder splits left and right subtrees. Rebuild recursively using index boundaries.",
      "approaches": [
        {
          "id": "e371a4eb-53b2-4d10-96d8-2c3844972ffa",
          "name": "Recursive with Index Map",
          "order": 1,
          "intuition": "The first preorder value is always the root. In inorder, everything left of the root belongs to the left subtree, and everything right belongs to the right subtree.",
          "approach": "1. Build a map from inorder value to index.\n2. Use a preorder index pointer.\n3. Recurse on inorder ranges to construct left and right subtrees.",
          "explanation": "The map gives O(1) splits. The preorder index advances as we create nodes, preserving root-left-right ordering.",
          "code": "func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n    var indexMap: [Int: Int] = [:]\n    for (i, val) in inorder.enumerated() { indexMap[val] = i }\n    var preIndex = 0\n\n    func helper(_ left: Int, _ right: Int) -> TreeNode? {\n        if left > right { return nil }\n        let rootVal = preorder[preIndex]\n        preIndex += 1\n        let root = TreeNode(rootVal)\n        let mid = indexMap[rootVal] ?? 0\n        root.left = helper(left, mid - 1)\n        root.right = helper(mid + 1, right)\n        return root\n    }\n\n    return helper(0, inorder.count - 1)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is created once",
            "spaceExplanation": "Index map plus recursion stack"
          },
          "testCases": [
            {
              "id": "9769abcb-30d8-4e89-b038-dfa6aa7917c4",
              "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
              "expectedOutput": "[3,9,20,null,null,15,7]",
              "explanation": "Root 3 splits inorder into [9] and [15,20,7]."
            },
            {
              "id": "7b95b045-a63f-444a-8fe5-3117532115f5",
              "input": "preorder = [-1], inorder = [-1]",
              "expectedOutput": "[-1]",
              "explanation": "Single node tree."
            }
          ]
        }
      ],
      "relatedProblems": [
        "construct-binary-tree-from-inorder-and-postorder-traversal",
        "serialize-and-deserialize-binary-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "cd5da6fc-1d62-4a2a-860f-36786c25a511",
      "problemSlug": "binary-tree-maximum-path-sum",
      "summary": "Compute the maximum path sum by tracking the best gain from each node and updating a global maximum for paths that pass through the node.",
      "approaches": [
        {
          "id": "d9d42e75-cc17-4b5e-bfd9-711ee17cc498",
          "name": "DFS with Max Gain",
          "order": 1,
          "intuition": "For each node, the best path going up can include only one child. But the best path overall might use both children plus the node.",
          "approach": "1. DFS returns max gain from a node to its parent.\n2. At each node, compute leftGain and rightGain (ignore negatives).\n3. Update global answer with leftGain + node.val + rightGain.\n4. Return node.val + max(leftGain, rightGain).",
          "explanation": "This separates the path-to-parent (one side only) from the best path through a node (both sides). The global maximum is updated at every node.",
          "code": "func maxPathSum(_ root: TreeNode?) -> Int {\n    var best = Int.min\n\n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = max(0, dfs(node.left))\n        let right = max(0, dfs(node.right))\n        best = max(best, left + node.val + right)\n        return node.val + max(left, right)\n    }\n\n    _ = dfs(root)\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node is visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "01213095-ad3e-45dc-9ef2-a463c884ef88",
              "input": "root = [1,2,3]",
              "expectedOutput": "6",
              "explanation": "Best path is 2 -> 1 -> 3 with sum 6."
            },
            {
              "id": "bc57200e-8fb6-44ce-a318-49381be2bb4c",
              "input": "root = [-10,9,20,null,null,15,7]",
              "expectedOutput": "42",
              "explanation": "Best path is 15 -> 20 -> 7 with sum 42."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "binary-tree-maximum-path-sum-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "5631cebc-4b66-43d6-b7a3-e5cceade37a0",
      "problemSlug": "implement-trie-prefix-tree",
      "summary": "Store characters in a trie so insert/search/startsWith all run in time proportional to the word length.",
      "approaches": [
        {
          "id": "d23ec3a2-765a-4364-9cac-9fe8c9c8b47f",
          "name": "Array-Backed Trie",
          "order": 1,
          "intuition": "Each node keeps 26 children for a-z. Walking characters from the root visits the prefix path.",
          "approach": "1. Insert: create missing children for each character, then mark end.\n2. Search: walk characters and ensure end marker.\n3. StartsWith: walk characters and ensure path exists.",
          "explanation": "All operations traverse at most L nodes where L is the word length.",
          "code": "class Trie {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func insert(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        guard let node = walk(word) else { return false }\n        return node.isEnd\n    }\n\n    func startsWith(_ prefix: String) -> Bool {\n        return walk(prefix) != nil\n    }\n\n    private func walk(_ word: String) -> Node? {\n        var node: Node? = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            node = node?.children[index]\n            if node == nil { return nil }\n        }\n        return node\n    }\n}",
          "complexity": {
            "time": "O(L)",
            "space": "O(total chars)",
            "timeExplanation": "Each operation scans L characters",
            "spaceExplanation": "Trie stores one node per character inserted"
          },
          "testCases": [
            {
              "id": "d5b74d5e-0be1-4a54-9b51-b831e8f9a06b",
              "input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]",
              "expectedOutput": "[null,null,true,false,true,null,true]",
              "explanation": "search(\"app\") is false before inserting \"app\" and true afterward."
            }
          ]
        }
      ],
      "relatedProblems": [
        "design-add-and-search-words-data-structure",
        "word-search-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "5c72dc35-6d92-4233-8cab-5483ab374461",
      "problemSlug": "design-add-and-search-words-data-structure",
      "summary": "Use a trie with DFS to support wildcard dots in search while keeping addWord efficient.",
      "approaches": [
        {
          "id": "1439dfbb-c19a-451d-a4df-44f0ed92869e",
          "name": "Trie + DFS Wildcard",
          "order": 1,
          "intuition": "A dot can match any child, so search must branch when encountering a dot.",
          "approach": "1. addWord inserts into a trie.\n2. search uses DFS: if char is dot, try all children; otherwise follow the matching child.\n3. If end of word, require node.isEnd.",
          "explanation": "The trie compresses shared prefixes, and DFS handles the wildcard branching only when needed.",
          "code": "class WordDictionary {\n    class Node {\n        var children: [Node?] = Array(repeating: nil, count: 26)\n        var isEnd = false\n    }\n\n    private let root = Node()\n\n    func addWord(_ word: String) {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil {\n                node.children[index] = Node()\n            }\n            node = node.children[index]!\n        }\n        node.isEnd = true\n    }\n\n    func search(_ word: String) -> Bool {\n        let chars = Array(word)\n        func dfs(_ node: Node?, _ i: Int) -> Bool {\n            guard let node = node else { return false }\n            if i == chars.count { return node.isEnd }\n            let c = chars[i]\n            if c == \".\" {\n                for child in node.children {\n                    if dfs(child, i + 1) { return true }\n                }\n                return false\n            }\n            let index = Int(c.asciiValue! - Character(\"a\").asciiValue!)\n            return dfs(node.children[index], i + 1)\n        }\n        return dfs(root, 0)\n    }\n}",
          "complexity": {
            "time": "O(L) average, O(26^L) worst",
            "space": "O(total chars)",
            "timeExplanation": "Wildcards can branch across children in the worst case",
            "spaceExplanation": "Trie stores all inserted characters"
          },
          "testCases": [
            {
              "id": "528c7f9f-bd8d-46d8-8e95-c313e0b4b2e1",
              "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
              "expectedOutput": "[null,null,null,null,false,true,true,true]",
              "explanation": "Wildcards match any letter (\".ad\" matches bad/dad/mad)."
            }
          ]
        }
      ],
      "relatedProblems": [
        "implement-trie-prefix-tree",
        "word-search-ii"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "d90f3c15-1512-4eab-8c4d-7da3267a3264",
      "problemSlug": "word-search-ii",
      "summary": "Build a trie of all words, then DFS the board to find any paths that match trie prefixes.",
      "approaches": [
        {
          "id": "104fbf07-a53f-4c54-a1d8-f574d1b2edfd",
          "name": "Trie + DFS",
          "order": 1,
          "intuition": "A trie lets us prune searches early when a prefix does not exist. DFS explores valid paths on the board.",
          "approach": "1. Insert all words into a trie.\n2. For each board cell, DFS while tracking trie nodes.\n3. When a trie node contains a word, add it to results and mark as used.\n4. Mark cells as visited during DFS to avoid reuse.",
          "explanation": "The trie avoids checking every word separately, and DFS explores only viable prefixes from each cell.",
          "code": "func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\n    class TrieNode {\n        var children: [TrieNode?] = Array(repeating: nil, count: 26)\n        var word: String? = nil\n    }\n\n    let root = TrieNode()\n    for word in words {\n        var node = root\n        for char in word {\n            let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n            if node.children[index] == nil { node.children[index] = TrieNode() }\n            node = node.children[index]!\n        }\n        node.word = word\n    }\n\n    var board = board\n    let rows = board.count\n    let cols = board.first?.count ?? 0\n    var results: [String] = []\n    let dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    func dfs(_ r: Int, _ c: Int, _ node: TrieNode) {\n        let char = board[r][c]\n        let index = Int(char.asciiValue! - Character(\"a\").asciiValue!)\n        guard let next = node.children[index] else { return }\n\n        if let word = next.word {\n            results.append(word)\n            next.word = nil\n        }\n\n        board[r][c] = \"#\"\n        for (dr, dc) in dirs {\n            let nr = r + dr\n            let nc = c + dc\n            if nr >= 0, nr < rows, nc >= 0, nc < cols, board[nr][nc] != \"#\" {\n                dfs(nr, nc, next)\n            }\n        }\n        board[r][c] = char\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            dfs(r, c, root)\n        }\n    }\n    return results\n}",
          "complexity": {
            "time": "O(m * n * 4^L)",
            "space": "O(total chars + L)",
            "timeExplanation": "Worst-case DFS from each cell with pruning by trie",
            "spaceExplanation": "Trie plus recursion depth up to max word length"
          },
          "testCases": [
            {
              "id": "8134f717-85dc-4975-a0e3-7659b08d15a1",
              "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
              "expectedOutput": "[\"eat\",\"oath\"]",
              "explanation": "Only \"eat\" and \"oath\" can be formed by adjacent cells."
            },
            {
              "id": "061876ba-28aa-4184-b735-8db3209332ed",
              "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
              "expectedOutput": "[]",
              "explanation": "Cannot reuse the same cell twice to form \"abcb\"."
            }
          ]
        }
      ],
      "relatedProblems": [
        "word-search",
        "implement-trie-prefix-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "089040a5-891d-4aa8-8015-eec25ac45f8e",
      "problemSlug": "count-good-nodes-in-binary-tree",
      "summary": "Track the maximum value along the path from the root to each node; a node is good if it is at least that maximum.",
      "approaches": [
        {
          "id": "8c3fe2b2-84c5-446c-8794-99ae762f95e0",
          "name": "DFS with Path Maximum",
          "order": 1,
          "intuition": "A node is good if its value is greater than or equal to all values seen so far on the path.",
          "approach": "1. DFS from the root with current max value.\n2. If node.val >= max, count it as good.\n3. Update max and recurse on children.",
          "explanation": "The max value on the path fully determines whether a node is good.",
          "code": "func goodNodes(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?, _ currentMax: Int) -> Int {\n        guard let node = node else { return 0 }\n        let isGood = node.val >= currentMax ? 1 : 0\n        let nextMax = max(currentMax, node.val)\n        return isGood + dfs(node.left, nextMax) + dfs(node.right, nextMax)\n    }\n    guard let root = root else { return 0 }\n    return dfs(root, root.val)\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(h)",
            "timeExplanation": "Each node visited once",
            "spaceExplanation": "Recursion stack depth equals tree height"
          },
          "testCases": [
            {
              "id": "e37487e8-c61c-4bdf-ab6c-e62ce931337a",
              "input": "root = [3,1,4,3,null,1,5]",
              "expectedOutput": "4",
              "explanation": "Good nodes are 3,4,5,3 (left grandchild)."
            },
            {
              "id": "68ad95d2-659d-4f24-b8f1-eed1d5fa6459",
              "input": "root = [3,3,null,4,2]",
              "expectedOutput": "3",
              "explanation": "All except node 2 are good."
            },
            {
              "id": "954e0167-f0a8-4e0f-9a59-d47c51cd61fc",
              "input": "root = [1]",
              "expectedOutput": "1",
              "explanation": "Root is always good."
            }
          ]
        }
      ],
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "same-tree"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "9dc90726-ad7b-42b7-bbf9-4f34ef32ba8c",
      "problemSlug": "serialize-and-deserialize-binary-tree",
      "summary": "Use preorder traversal with null markers to serialize, then rebuild the tree by consuming the token list in order.",
      "approaches": [
        {
          "id": "296bba88-9dd2-4f56-bce6-600215ee37fc",
          "name": "Preorder with Null Markers",
          "order": 1,
          "intuition": "Preorder with explicit nulls uniquely represents the tree structure.",
          "approach": "1. Serialize by DFS preorder, output value or \"#\" for nil.\n2. Deserialize by reading tokens in order and rebuilding nodes recursively.",
          "explanation": "Null markers make the structure unambiguous, so a single pass over tokens can reconstruct the original tree.",
          "code": "class Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var result: [String] = []\n        func dfs(_ node: TreeNode?) {\n            guard let node = node else {\n                result.append(\"#\")\n                return\n            }\n            result.append(String(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        }\n        dfs(root)\n        return result.joined(separator: \",\")\n    }\n\n    func deserialize(_ data: String) -> TreeNode? {\n        let tokens = data.split(separator: \",\").map(String.init)\n        var index = 0\n\n        func dfs() -> TreeNode? {\n            if index >= tokens.count { return nil }\n            let token = tokens[index]\n            index += 1\n            if token == \"#\" { return nil }\n            let node = TreeNode(Int(token) ?? 0)\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        }\n\n        return dfs()\n    }\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each node is visited once in both serialize and deserialize",
            "spaceExplanation": "Tokens plus recursion stack"
          },
          "testCases": [
            {
              "id": "bac9f4b5-62ce-43dd-8019-472f11c5deb1",
              "input": "root = [1,2,3,null,null,4,5]",
              "expectedOutput": "[1,2,3,null,null,4,5]",
              "explanation": "Serialization and deserialization preserve the same shape and values."
            },
            {
              "id": "9d538869-272a-4bd4-97b7-e8d55f231969",
              "input": "root = []",
              "expectedOutput": "[]",
              "explanation": "Empty tree serializes to a null marker and deserializes to nil."
            }
          ]
        }
      ],
      "relatedProblems": [
        "serialize-and-deserialize-bst",
        "construct-binary-tree-from-preorder-and-inorder-traversal"
      ],
      "lastUpdated": "2026-02-04T00:00:00Z"
    },
    {
      "id": "b6205791-50c7-4360-819a-607401b4f57a",
      "problemSlug": "two-sum",
      "summary": "Find two indices whose values add up to the target by tracking seen numbers in a hash map.",
      "approaches": [
        {
          "id": "5609529b-e80d-4064-b4df-b5cda6084880",
          "name": "Hash Map",
          "order": 1,
          "intuition": "As we scan the array, if we already saw a value equal to (target - current), we can return that index immediately.\nStoring value -> index lets us find the complement in O(1) time.",
          "approach": "1. Create an empty dictionary valueToIndex.\n2. For each number in nums:\n   - Let complement = target - num.\n   - If complement exists in the dictionary, return [indexOfComplement, currentIndex].\n   - Otherwise store num -> currentIndex.\n3. If no pair found, return an empty array (not expected per constraints).",
          "explanation": "The key is to decide in one pass whether the current number completes a previously seen pair.\nThis avoids the O(n^2) brute-force check and keeps time linear.",
          "code": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    var valueToIndex: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        let complement = target - num\n        if let j = valueToIndex[complement] {\n            return [j, i]\n        }\n        valueToIndex[num] = i\n    }\n    return []\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each number is processed once with O(1) hash lookups.",
            "spaceExplanation": "The hash map can store up to n elements."
          },
          "testCases": [
            {
              "id": "3d3717cb-c805-47a5-923f-5819a87a6b52",
              "input": "nums = [2,7,11,15], target = 9",
              "expectedOutput": "[0,1]",
              "explanation": "2 + 7 = 9, so indices 0 and 1."
            },
            {
              "id": "6c706226-e832-445c-8206-154a288fe2d9",
              "input": "nums = [3,2,4], target = 6",
              "expectedOutput": "[1,2]",
              "explanation": "2 + 4 = 6."
            },
            {
              "id": "0c8fd92c-84f2-4eb9-84b3-1206d534bc08",
              "input": "nums = [3,3], target = 6",
              "expectedOutput": "[0,1]",
              "explanation": "Same value used twice at different indices."
            }
          ]
        }
      ],
      "relatedProblems": [
        "two-sum-ii-input-array-is-sorted",
        "3sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "4aacfe82-e270-4dce-9d65-712c0250a335",
      "problemSlug": "valid-parentheses",
      "summary": "Use a stack to match opening and closing brackets in the correct order.",
      "approaches": [
        {
          "id": "a36e7d66-0c0d-4795-aa09-af72c4b1f241",
          "name": "Stack",
          "order": 1,
          "intuition": "Every closing bracket must match the most recent unmatched opening bracket.\nA stack naturally models this last-in-first-out requirement.",
          "approach": "1. Initialize an empty stack.\n2. For each character:\n   - If it's an opening bracket, push it.\n   - If it's a closing bracket, pop and ensure types match.\n3. The string is valid only if the stack is empty at the end.",
          "explanation": "Any mismatch or premature closing bracket invalidates the string immediately.\nRemaining items in the stack after processing mean unmatched openings.",
          "code": "func isValid(_ s: String) -> Bool {\n    var stack: [Character] = []\n    for ch in s {\n        switch ch {\n        case \"(\", \"{\", \"[\":\n            stack.append(ch)\n        case \")\":\n            if stack.popLast() != \"(\" { return false }\n        case \"}\":\n            if stack.popLast() != \"{\" { return false }\n        case \"]\":\n            if stack.popLast() != \"[\" { return false }\n        default:\n            break\n        }\n    }\n    return stack.isEmpty\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each character is processed once.",
            "spaceExplanation": "The stack can hold up to n opening brackets."
          },
          "testCases": [
            {
              "id": "ba1346c7-9119-4061-b157-8f689e073a07",
              "input": "s = \"()\"",
              "expectedOutput": "true",
              "explanation": "Simple matching pair."
            },
            {
              "id": "809050df-90a2-4163-b33d-7ae30b99c763",
              "input": "s = \"()[]{}\"",
              "expectedOutput": "true",
              "explanation": "All bracket types match in order."
            },
            {
              "id": "236a46f7-4902-4e31-a0fe-37019eb89f6f",
              "input": "s = \"(]\"",
              "expectedOutput": "false",
              "explanation": "Mismatched bracket types."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-remove-to-make-valid-parentheses",
        "generate-parentheses"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "23f4748b-97c7-48ee-b352-423fbcbfd2b2",
      "problemSlug": "contains-duplicate",
      "summary": "Track seen values in a set; a repeat indicates a duplicate.",
      "approaches": [
        {
          "id": "6966b214-f4ce-4778-886f-94a0b3f47720",
          "name": "Hash Set",
          "order": 1,
          "intuition": "If any number appears twice, it will already exist in the set when we see it again.",
          "approach": "1. Create an empty set.\n2. For each number:\n   - If it is in the set, return true.\n   - Otherwise insert it.\n3. Return false if no duplicates are found.",
          "explanation": "Sets provide O(1) average lookup/insert, making this linear time.",
          "code": "func containsDuplicate(_ nums: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) { return true }\n        seen.insert(num)\n    }\n    return false\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass with O(1) set checks.",
            "spaceExplanation": "The set can store all unique elements."
          },
          "testCases": [
            {
              "id": "fb1e2b00-0d16-47e1-853d-2eaefef9fa8a",
              "input": "nums = [1,2,3,1]",
              "expectedOutput": "true",
              "explanation": "1 appears twice."
            },
            {
              "id": "6f11889d-5920-43a0-8b23-d5d19a5d5770",
              "input": "nums = [1,2,3,4]",
              "expectedOutput": "false",
              "explanation": "All elements are unique."
            },
            {
              "id": "fa7882d8-0b93-4cab-931b-8029e5c5b4cb",
              "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
              "expectedOutput": "true",
              "explanation": "Multiple duplicates present."
            }
          ]
        }
      ],
      "relatedProblems": [
        "contains-duplicate-ii",
        "contains-duplicate-iii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "22650355-1394-4a7f-8415-15cfe774ea97",
      "problemSlug": "best-time-to-buy-and-sell-stock",
      "summary": "Track the minimum price so far and update the max profit as you scan.",
      "approaches": [
        {
          "id": "c9cfb94b-b023-477e-9e26-9c69c36ae2c1",
          "name": "One Pass",
          "order": 1,
          "intuition": "The best profit ending today is today's price minus the minimum price seen before today.",
          "approach": "1. Initialize minPrice to a large value and bestProfit = 0.\n2. For each price:\n   - Update minPrice = min(minPrice, price).\n   - Update bestProfit = max(bestProfit, price - minPrice).\n3. Return bestProfit.",
          "explanation": "This ensures the buy happens before the sell because minPrice is computed from earlier elements.",
          "code": "func maxProfit(_ prices: [Int]) -> Int {\n    var minPrice = Int.max\n    var best = 0\n    for price in prices {\n        minPrice = min(minPrice, price)\n        best = max(best, price - minPrice)\n    }\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Single pass through the prices.",
            "spaceExplanation": "Only two tracking variables are used."
          },
          "testCases": [
            {
              "id": "5953fc34-b62c-4575-8b2a-b399f798db13",
              "input": "prices = [7,1,5,3,6,4]",
              "expectedOutput": "5",
              "explanation": "Buy at 1, sell at 6."
            },
            {
              "id": "2ad31b7a-6363-4ec5-b36c-a17bb1b55e57",
              "input": "prices = [7,6,4,3,1]",
              "expectedOutput": "0",
              "explanation": "No profitable transaction."
            }
          ]
        }
      ],
      "relatedProblems": [
        "best-time-to-buy-and-sell-stock-ii",
        "best-time-to-buy-and-sell-stock-with-cooldown"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "d9518775-be8b-4eee-a812-7c426fa80106",
      "problemSlug": "valid-anagram",
      "summary": "Count characters in the first string and subtract counts using the second.",
      "approaches": [
        {
          "id": "aa408334-2951-4317-85bb-dae695cb3ac7",
          "name": "Frequency Map",
          "order": 1,
          "intuition": "Two strings are anagrams if every character appears the same number of times in both.",
          "approach": "1. If lengths differ, return false.\n2. Count each character in s.\n3. Decrement for each character in t; if any count becomes negative, return false.\n4. If all counts are zero, return true.",
          "explanation": "Using a dictionary keeps the solution clean and works for any character set.",
          "code": "func isAnagram(_ s: String, _ t: String) -> Bool {\n    if s.count != t.count { return false }\n    var counts: [Character: Int] = [:]\n    for ch in s { counts[ch, default: 0] += 1 }\n    for ch in t {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Each string is scanned once.",
            "spaceExplanation": "The map stores counts for distinct characters."
          },
          "testCases": [
            {
              "id": "a82a4a86-78fe-4b64-ae62-2e098816859c",
              "input": "s = \"anagram\", t = \"nagaram\"",
              "expectedOutput": "true",
              "explanation": "All letters match counts."
            },
            {
              "id": "fce32cc3-1f00-4d32-b058-648e801addaf",
              "input": "s = \"rat\", t = \"car\"",
              "expectedOutput": "false",
              "explanation": "Different letters."
            }
          ]
        }
      ],
      "relatedProblems": [
        "group-anagrams",
        "find-all-anagrams-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "751df843-f7df-4040-a033-b2fd1cfc0050",
      "problemSlug": "ransom-note",
      "summary": "Count available letters in the magazine and consume them for the ransom note.",
      "approaches": [
        {
          "id": "8d6b33ea-7830-4e29-a0d6-56d6ea03ab6b",
          "name": "Frequency Map",
          "order": 1,
          "intuition": "Each letter in the ransom note must be supplied by the magazine. If any count is insufficient, it fails.",
          "approach": "1. Count each character in magazine.\n2. For each character in ransomNote, decrement its count.\n3. If any count goes negative, return false. Otherwise return true.",
          "explanation": "This is a direct application of a frequency map: availability vs. demand.",
          "code": "func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {\n    var counts: [Character: Int] = [:]\n    for ch in magazine { counts[ch, default: 0] += 1 }\n    for ch in ransomNote {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity": {
            "time": "O(m + n)",
            "space": "O(1)",
            "timeExplanation": "Scan magazine and ransom note once.",
            "spaceExplanation": "Character counts are bounded by alphabet size."
          },
          "testCases": [
            {
              "id": "aa950b65-3fb0-478f-8048-cb5ddc162234",
              "input": "ransomNote = \"a\", magazine = \"b\"",
              "expectedOutput": "false",
              "explanation": "Missing letter a."
            },
            {
              "id": "07eea518-2a35-467d-adaf-87edaf1b9eb2",
              "input": "ransomNote = \"aa\", magazine = \"aab\"",
              "expectedOutput": "true",
              "explanation": "Magazine has enough a's."
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-anagram",
        "first-unique-character-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "77394785-c09e-47cc-b524-b42c90507419",
      "problemSlug": "binary-search",
      "summary": "Use classic binary search to find the target in a sorted array.",
      "approaches": [
        {
          "id": "42f5fcff-d6d3-416c-811c-91910896d0c2",
          "name": "Binary Search",
          "order": 1,
          "intuition": "The array is sorted, so we can eliminate half the search space each step.",
          "approach": "1. Set left = 0 and right = n - 1.\n2. While left <= right:\n   - mid = (left + right) / 2\n   - If nums[mid] == target, return mid.\n   - If nums[mid] < target, search the right half; else search the left half.\n3. Return -1 if not found.",
          "explanation": "Binary search guarantees O(log n) time by halving the range each iteration.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "The search range halves each step.",
            "spaceExplanation": "Only constant extra space is used."
          },
          "testCases": [
            {
              "id": "d4c9f72b-8f48-43d1-971d-2b39cdc33656",
              "input": "nums = [-1,0,3,5,9,12], target = 9",
              "expectedOutput": "4",
              "explanation": "9 is at index 4."
            },
            {
              "id": "0fc7cc73-24c8-4531-814c-542ecdb498c2",
              "input": "nums = [-1,0,3,5,9,12], target = 2",
              "expectedOutput": "-1",
              "explanation": "2 is not in the array."
            }
          ]
        }
      ],
      "relatedProblems": [
        "search-in-rotated-sorted-array",
        "first-bad-version"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "e3586dfa-a556-4688-8b3e-7c988f871267",
      "problemSlug": "climbing-stairs",
      "summary": "Each step can be reached from the previous two steps; this forms a Fibonacci sequence.",
      "approaches": [
        {
          "id": "718a7245-392c-498d-82a2-cc018254ba43",
          "name": "DP (Fibonacci)",
          "order": 1,
          "intuition": "The number of ways to reach step i equals ways(i-1) + ways(i-2).",
          "approach": "1. Handle small n (1 or 2) directly.\n2. Iterate from 3 to n, keeping only the last two values.\n3. Return the final value.",
          "explanation": "This is a classic DP problem that collapses to a constant-space Fibonacci computation.",
          "code": "func climbStairs(_ n: Int) -> Int {\n    if n <= 2 { return n }\n    var a = 1\n    var b = 2\n    for _ in 3...n {\n        let c = a + b\n        a = b\n        b = c\n    }\n    return b\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We compute each step once.",
            "spaceExplanation": "Only two integers are stored."
          },
          "testCases": [
            {
              "id": "f9a175ed-00a1-4238-a6cd-94f239da68e7",
              "input": "n = 2",
              "expectedOutput": "2",
              "explanation": "(1+1), (2)."
            },
            {
              "id": "3f2247d4-81b4-488b-9f66-e2db963edaf6",
              "input": "n = 3",
              "expectedOutput": "3",
              "explanation": "(1+1+1), (1+2), (2+1)."
            },
            {
              "id": "f33c3263-9025-4305-81f6-7e0c92dd5514",
              "input": "n = 5",
              "expectedOutput": "8",
              "explanation": "Fibonacci growth."
            }
          ]
        }
      ],
      "relatedProblems": [
        "min-cost-climbing-stairs",
        "house-robber"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "5c11fa1e-3d2c-48ba-b657-8147f2306374",
      "problemSlug": "longest-substring-without-repeating-characters",
      "summary": "Use a moving window and last-seen indices to keep all characters unique.",
      "approaches": [
        {
          "id": "27c88a35-bf8d-4b65-932f-ef95acdc2481",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "When a repeat appears, move the left boundary just past the previous occurrence.",
          "approach": "1. Convert the string to an array of characters for indexing.\n2. Track last seen index of each character in a dictionary.\n3. Maintain a left pointer for the start of the current window.\n4. Update the best window length as you iterate.",
          "explanation": "The left pointer only moves forward, so each character is processed at most twice.",
          "code": "func lengthOfLongestSubstring(_ s: String) -> Int {\n    let chars = Array(s)\n    var lastIndex: [Character: Int] = [:]\n    var left = 0\n    var best = 0\n    for (right, ch) in chars.enumerated() {\n        if let prev = lastIndex[ch], prev >= left {\n            left = prev + 1\n        }\n        lastIndex[ch] = right\n        best = max(best, right - left + 1)\n    }\n    return best\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(min(n, k))",
            "timeExplanation": "Each index moves forward at most once.",
            "spaceExplanation": "Map stores last index per distinct character."
          },
          "testCases": [
            {
              "id": "857fc085-7360-4555-9c7d-d324eb1a4c03",
              "input": "s = \"abcabcbb\"",
              "expectedOutput": "3",
              "explanation": "Longest substring is \"abc\"."
            },
            {
              "id": "d75e0eb2-181f-4052-92f3-16d6d6f774fa",
              "input": "s = \"bbbbb\"",
              "expectedOutput": "1",
              "explanation": "Only one unique character."
            },
            {
              "id": "0460080e-0b23-4245-ab89-72bdc20b8121",
              "input": "s = \"pwwkew\"",
              "expectedOutput": "3",
              "explanation": "Longest substring is \"wke\"."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-window-substring",
        "longest-substring-with-at-most-k-distinct-characters"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "8003a7c4-b302-40f5-a143-6e9006052256",
      "problemSlug": "group-anagrams",
      "summary": "Group strings by their sorted characters (anagram signature).",
      "approaches": [
        {
          "id": "01f071e5-54c6-44da-86f1-bad42a893aa6",
          "name": "Hash by Sorted Key",
          "order": 1,
          "intuition": "Anagrams share the same multiset of letters, so sorting makes identical keys for the group.",
          "approach": "1. For each string, sort its characters to form a key.\n2. Append the string to the bucket for that key.\n3. Return all buckets.",
          "explanation": "Sorting each word is the dominant cost, but it keeps the implementation simple and reliable.",
          "code": "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups: [String: [String]] = [:]\n    for s in strs {\n        let key = String(s.sorted())\n        groups[key, default: []].append(s)\n    }\n    return Array(groups.values)\n}",
          "complexity": {
            "time": "O(n * k log k)",
            "space": "O(n * k)",
            "timeExplanation": "Sorting each of n strings of length k dominates.",
            "spaceExplanation": "All strings are stored in grouped buckets."
          },
          "testCases": [
            {
              "id": "cf59af36-fcff-4d7c-b446-f32138d0f4e9",
              "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
              "expectedOutput": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
              "explanation": "Strings with the same sorted key are grouped (order may vary)."
            },
            {
              "id": "ff99e033-fb51-4eb3-972b-18a4a8c5acef",
              "input": "strs = [\"\"]",
              "expectedOutput": "[[\"\"]]",
              "explanation": "Single empty string forms one group."
            },
            {
              "id": "a4399698-b4e5-43f4-99f5-223620ca26be",
              "input": "strs = [\"a\"]",
              "expectedOutput": "[[\"a\"]]",
              "explanation": "Single string forms one group."
            }
          ]
        }
      ],
      "relatedProblems": [
        "valid-anagram",
        "find-all-anagrams-in-a-string"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "51f4815d-a558-4057-b255-58209dea4db8",
      "problemSlug": "top-k-frequent-elements",
      "summary": "Count frequencies and collect elements from high to low frequency buckets.",
      "approaches": [
        {
          "id": "2e212fcc-957a-4b1d-a01d-2694e9b90bd9",
          "name": "Bucket Sort",
          "order": 1,
          "intuition": "If we bucket elements by frequency, we can gather the k most frequent without full sorting.",
          "approach": "1. Count occurrences of each number in a dictionary.\n2. Create buckets where index = frequency.\n3. Iterate buckets from high to low, collecting elements until k are gathered.",
          "explanation": "This avoids O(n log n) sorting and stays linear on average.",
          "code": "func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var counts: [Int: Int] = [:]\n    for num in nums { counts[num, default: 0] += 1 }\n    var buckets = Array(repeating: [Int](), count: nums.count + 1)\n    for (num, count) in counts {\n        buckets[count].append(num)\n    }\n    var result: [Int] = []\n    for freq in stride(from: buckets.count - 1, through: 1, by: -1) {\n        for num in buckets[freq] {\n            result.append(num)\n            if result.count == k { return result }\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Counting plus bucket traversal is linear.",
            "spaceExplanation": "Buckets and map store up to n items."
          },
          "testCases": [
            {
              "id": "25771fef-0ab3-4b28-a731-fa97a89188d5",
              "input": "nums = [1,1,1,2,2,3], k = 2",
              "expectedOutput": "[1,2]",
              "explanation": "1 appears 3 times, 2 appears 2 times."
            },
            {
              "id": "0779a404-ce3f-4756-916f-5d20b5106742",
              "input": "nums = [1], k = 1",
              "expectedOutput": "[1]",
              "explanation": "Single element is the answer."
            }
          ]
        }
      ],
      "relatedProblems": [
        "top-k-frequent-words",
        "kth-largest-element-in-an-array"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "ce775cc2-53fd-4963-bb91-9c8f6b5dcb4c",
      "problemSlug": "product-of-array-except-self",
      "summary": "Compute prefix products and suffix products to avoid division.",
      "approaches": [
        {
          "id": "cad14ea0-646e-49fd-bc22-69e4b5e08203",
          "name": "Prefix/Suffix",
          "order": 1,
          "intuition": "The product for index i is (product of all elements before i) * (product of all elements after i).",
          "approach": "1. Build result where result[i] is the product of all elements before i.\n2. Traverse from right, maintaining a suffix product and multiply into result[i].",
          "explanation": "This keeps O(1) extra space besides the output array and handles zeros correctly.",
          "code": "func productExceptSelf(_ nums: [Int]) -> [Int] {\n    var result = Array(repeating: 1, count: nums.count)\n    var prefix = 1\n    for i in 0..<nums.count {\n        result[i] = prefix\n        prefix *= nums[i]\n    }\n    var suffix = 1\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        result[i] *= suffix\n        suffix *= nums[i]\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Two linear passes.",
            "spaceExplanation": "Only constant extra space besides the output."
          },
          "testCases": [
            {
              "id": "ea2462d9-4c77-4f66-a78a-0882e8eeed6c",
              "input": "nums = [1,2,3,4]",
              "expectedOutput": "[24,12,8,6]",
              "explanation": "Products excluding each index."
            },
            {
              "id": "c2ddebb8-39b4-494d-9b47-e5c6da74e2bc",
              "input": "nums = [-1,1,0,-3,3]",
              "expectedOutput": "[0,0,9,0,0]",
              "explanation": "Handles zeros correctly."
            }
          ]
        }
      ],
      "relatedProblems": [
        "maximum-product-subarray",
        "subarray-product-less-than-k"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "09218b74-9f9a-490a-ae70-c1ac4dec5ca8",
      "problemSlug": "subarray-sum-equals-k",
      "summary": "Count how often each prefix sum appears to find subarrays summing to k.",
      "approaches": [
        {
          "id": "8fdde843-fc09-448d-bf2e-00ec0b0885c5",
          "name": "Prefix Sum + Map",
          "order": 1,
          "intuition": "If currentSum - k has been seen before, each occurrence defines a subarray ending here with sum k.",
          "approach": "1. Keep a dictionary of prefixSum -> count (start with 0 -> 1).\n2. Iterate nums, updating currentSum.\n3. Add counts of (currentSum - k) to the answer.\n4. Increment the count for currentSum.",
          "explanation": "This avoids O(n^2) enumeration by using prefix sums and frequencies.",
          "code": "func subarraySum(_ nums: [Int], _ k: Int) -> Int {\n    var count = 0\n    var sum = 0\n    var freq: [Int: Int] = [0: 1]\n    for num in nums {\n        sum += num\n        if let c = freq[sum - k] { count += c }\n        freq[sum, default: 0] += 1\n    }\n    return count\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(n)",
            "timeExplanation": "Single pass with O(1) hash operations.",
            "spaceExplanation": "Prefix sums stored in the map."
          },
          "testCases": [
            {
              "id": "36b9d5fd-4a58-46fb-ae4f-6fb5cfb8a641",
              "input": "nums = [1,1,1], k = 2",
              "expectedOutput": "2",
              "explanation": "Subarrays [1,1] at indices (0,1) and (1,2)."
            },
            {
              "id": "b9c9fbd2-7155-46a9-8270-792727582b7c",
              "input": "nums = [1,2,3], k = 3",
              "expectedOutput": "2",
              "explanation": "Subarrays [1,2] and [3]."
            }
          ]
        }
      ],
      "relatedProblems": [
        "minimum-size-subarray-sum",
        "continuous-subarray-sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "f94dfe99-f818-417f-b555-81d2d78b2212",
      "problemSlug": "permutation-in-string",
      "summary": "Use a fixed-size sliding window and compare character counts to detect a permutation.",
      "approaches": [
        {
          "id": "82f82071-c8e4-4992-8de8-e36f7d88d1d8",
          "name": "Sliding Window",
          "order": 1,
          "intuition": "Any permutation of s1 has the same character counts, so we just need a window in s2 with matching counts.",
          "approach": "1. Build a frequency array for s1 and for the first window in s2.\n2. Track how many of the 26 counts match.\n3. Slide the window, updating counts and matches.\n4. If all 26 counts match, return true.",
          "explanation": "The matching-counts trick avoids comparing full arrays on each step.",
          "code": "func checkInclusion(_ s1: String, _ s2: String) -> Bool {\n    let a = Array(s1)\n    let b = Array(s2)\n    if a.count > b.count { return false }\n\n    var count1 = Array(repeating: 0, count: 26)\n    var count2 = Array(repeating: 0, count: 26)\n\n    for ch in a {\n        let idx = Int(ch.asciiValue! - 97)\n        count1[idx] += 1\n    }\n    for i in 0..<a.count {\n        let idx = Int(b[i].asciiValue! - 97)\n        count2[idx] += 1\n    }\n\n    var matches = 0\n    for i in 0..<26 {\n        if count1[i] == count2[i] { matches += 1 }\n    }\n\n    var left = 0\n    for right in a.count..<b.count {\n        if matches == 26 { return true }\n\n        let rIndex = Int(b[right].asciiValue! - 97)\n        count2[rIndex] += 1\n        if count2[rIndex] == count1[rIndex] { matches += 1 }\n        else if count2[rIndex] == count1[rIndex] + 1 { matches -= 1 }\n\n        let lIndex = Int(b[left].asciiValue! - 97)\n        count2[lIndex] -= 1\n        if count2[lIndex] == count1[lIndex] { matches += 1 }\n        else if count2[lIndex] == count1[lIndex] - 1 { matches -= 1 }\n\n        left += 1\n    }\n\n    return matches == 26\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "Each index is processed once in the sliding window.",
            "spaceExplanation": "Two fixed-size arrays of length 26."
          },
          "testCases": [
            {
              "id": "2708a68f-d53b-49fe-9227-b4884fd084ce",
              "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
              "expectedOutput": "true",
              "explanation": "Substring \"ba\" is a permutation of \"ab\"."
            },
            {
              "id": "7e0e6c56-3a13-4d0c-a138-83d2f21fe73d",
              "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
              "expectedOutput": "false",
              "explanation": "No permutation appears in s2."
            }
          ]
        }
      ],
      "relatedProblems": [
        "find-all-anagrams-in-a-string",
        "check-if-a-string-contains-all-binary-codes-of-size-k"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "82ca8435-3b76-41f5-9985-8646f575a687",
      "problemSlug": "3sum",
      "summary": "Sort the array and fix one element, then use two pointers to find pairs that sum to the negative.",
      "approaches": [
        {
          "id": "fa457d53-4a83-48c1-970e-eaf8ac79fa61",
          "name": "Sort + Two Pointers",
          "order": 1,
          "intuition": "Sorting allows us to skip duplicates and adjust pointers based on the sum.",
          "approach": "1. Sort the array.\n2. For each index i, use two pointers (l, r) to find pairs where nums[i] + nums[l] + nums[r] == 0.\n3. Skip duplicate values for i, l, and r.",
          "explanation": "Sorting enables a linear scan for each fixed i, resulting in O(n^2) time.",
          "code": "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let nums = nums.sorted()\n    var result: [[Int]] = []\n    if nums.count < 3 { return result }\n\n    for i in 0..<(nums.count - 2) {\n        if i > 0 && nums[i] == nums[i - 1] { continue }\n        var left = i + 1\n        var right = nums.count - 1\n        while left < right {\n            let sum = nums[i] + nums[left] + nums[right]\n            if sum == 0 {\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right && nums[left] == nums[left - 1] { left += 1 }\n                while left < right && nums[right] == nums[right + 1] { right -= 1 }\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n^2)",
            "space": "O(1)",
            "timeExplanation": "For each i, two pointers scan the rest of the array.",
            "spaceExplanation": "Sorting is in-place; extra space is constant (excluding output)."
          },
          "testCases": [
            {
              "id": "6952a73f-5e39-4a3c-b7e4-212d9d10d643",
              "input": "nums = [-1,0,1,2,-1,-4]",
              "expectedOutput": "[[-1,-1,2],[-1,0,1]]",
              "explanation": "Two unique triplets sum to 0."
            },
            {
              "id": "e88c71f1-6f39-4502-a988-d62d817a8e42",
              "input": "nums = [0,1,1]",
              "expectedOutput": "[]",
              "explanation": "No triplet sums to 0."
            },
            {
              "id": "1caf588c-d8b4-4469-9a6d-a8f0c0dcc42b",
              "input": "nums = [0,0,0]",
              "expectedOutput": "[[0,0,0]]",
              "explanation": "Single unique triplet."
            }
          ]
        }
      ],
      "relatedProblems": [
        "two-sum",
        "4sum"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "f4aa35fd-22bb-466c-8dae-e6567cb0141a",
      "problemSlug": "search-in-rotated-sorted-array",
      "summary": "Binary search while determining which half is sorted at each step.",
      "approaches": [
        {
          "id": "43e27307-58c2-4a0e-a8b9-75238275fb4a",
          "name": "Modified Binary Search",
          "order": 1,
          "intuition": "In a rotated array, at least one half of the current range is sorted. We can use that to decide where the target may lie.",
          "approach": "1. Use left and right pointers.\n2. Find mid; if it's the target, return it.\n3. Determine which half is sorted and adjust the search range accordingly.",
          "explanation": "This preserves O(log n) time because each step discards half the range.",
          "code": "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if nums[mid] == target { return mid }\n        if nums[left] <= nums[mid] {\n            if nums[left] <= target && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}",
          "complexity": {
            "time": "O(log n)",
            "space": "O(1)",
            "timeExplanation": "Binary search halves the range each step.",
            "spaceExplanation": "Constant extra space."
          },
          "testCases": [
            {
              "id": "3399773a-ab67-467e-8fe0-059e42126ffe",
              "input": "nums = [4,5,6,7,0,1,2], target = 0",
              "expectedOutput": "4",
              "explanation": "Target found at index 4."
            },
            {
              "id": "800110ec-ac97-4755-971f-6d84cc314656",
              "input": "nums = [4,5,6,7,0,1,2], target = 3",
              "expectedOutput": "-1",
              "explanation": "Target not present."
            },
            {
              "id": "192471d2-017f-4ff5-8035-74cea4b4674a",
              "input": "nums = [1], target = 0",
              "expectedOutput": "-1",
              "explanation": "Single element not equal to target."
            }
          ]
        }
      ],
      "relatedProblems": [
        "search-in-rotated-sorted-array-ii",
        "find-minimum-in-rotated-sorted-array"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "0562ba51-0891-44cc-8ef8-e9d3dd5be2e0",
      "problemSlug": "merge-intervals",
      "summary": "Sort intervals by start and merge overlapping ranges in one pass.",
      "approaches": [
        {
          "id": "804d61a0-ef94-4021-a081-82fa69522244",
          "name": "Sort + Merge",
          "order": 1,
          "intuition": "After sorting by start, any overlap can only occur with the most recent merged interval.",
          "approach": "1. Sort intervals by start.\n2. Initialize result with the first interval.\n3. For each subsequent interval, either merge it into the last or append it.",
          "explanation": "Sorting ensures overlaps are adjacent, so we only compare with the last merged interval.",
          "code": "func merge(_ intervals: [[Int]]) -> [[Int]] {\n    if intervals.isEmpty { return [] }\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var result: [[Int]] = [sorted[0]]\n    for interval in sorted.dropFirst() {\n        if interval[0] <= result[result.count - 1][1] {\n            result[result.count - 1][1] = max(result[result.count - 1][1], interval[1])\n        } else {\n            result.append(interval)\n        }\n    }\n    return result\n}",
          "complexity": {
            "time": "O(n log n)",
            "space": "O(n)",
            "timeExplanation": "Sorting dominates the time cost.",
            "spaceExplanation": "Result list can store up to n intervals."
          },
          "testCases": [
            {
              "id": "e1a38ac4-6f16-43f9-8eae-772092c14f3b",
              "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
              "expectedOutput": "[[1,6],[8,10],[15,18]]",
              "explanation": "[1,3] and [2,6] merge into [1,6]."
            },
            {
              "id": "f70a956c-ec5b-4b71-bf26-526b1ad92c3f",
              "input": "intervals = [[1,4],[4,5]]",
              "expectedOutput": "[[1,5]]",
              "explanation": "Touching intervals also merge."
            }
          ]
        }
      ],
      "relatedProblems": [
        "insert-interval",
        "meeting-rooms-ii"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "3d011264-1955-48cf-99a3-28cb75d173a0",
      "problemSlug": "spiral-matrix",
      "summary": "Walk the matrix in layers by shrinking the top, bottom, left, and right boundaries.",
      "approaches": [
        {
          "id": "3cc9ef2e-fea5-401a-aa0a-595369e016c9",
          "name": "Boundary Traversal",
          "order": 1,
          "intuition": "Each spiral layer is a rectangle. After traversing its edges, we move the boundaries inward.",
          "approach": "1. Initialize top, bottom, left, right bounds.\n2. Traverse right, down, left, and up while bounds are valid.\n3. Shrink bounds after each side.",
          "explanation": "This orderly boundary scan avoids revisiting cells and handles non-square matrices.",
          "code": "func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n    guard !matrix.isEmpty else { return [] }\n    var top = 0\n    var bottom = matrix.count - 1\n    var left = 0\n    var right = matrix[0].count - 1\n    var result: [Int] = []\n\n    while top <= bottom && left <= right {\n        for col in left...right { result.append(matrix[top][col]) }\n        top += 1\n        if top > bottom { break }\n\n        for row in top...bottom { result.append(matrix[row][right]) }\n        right -= 1\n        if left > right { break }\n\n        for col in stride(from: right, through: left, by: -1) { result.append(matrix[bottom][col]) }\n        bottom -= 1\n        if top > bottom { break }\n\n        for row in stride(from: bottom, through: top, by: -1) { result.append(matrix[row][left]) }\n        left += 1\n    }\n\n    return result\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(1)",
            "timeExplanation": "Each cell is visited exactly once.",
            "spaceExplanation": "No extra space besides the output array."
          },
          "testCases": [
            {
              "id": "40d28244-749c-499c-8684-5141ef7ad57b",
              "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
              "expectedOutput": "[1,2,3,6,9,8,7,4,5]",
              "explanation": "Classic 3x3 spiral."
            },
            {
              "id": "1794fb06-b57a-4d9a-ae73-8323c7c50b14",
              "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
              "expectedOutput": "[1,2,3,4,8,12,11,10,9,5,6,7]",
              "explanation": "Spiral for rectangular matrix."
            }
          ]
        }
      ],
      "relatedProblems": [
        "spiral-matrix-ii",
        "rotate-image"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "6f18a7ea-1f71-41c6-ad8a-91f28173bbb2",
      "problemSlug": "number-of-islands",
      "summary": "Count islands by flooding each discovered land cell with DFS.",
      "approaches": [
        {
          "id": "623b0613-cf2f-476d-b645-283a712a2085",
          "name": "DFS Flood Fill",
          "order": 1,
          "intuition": "Each island is a connected component of '1's. Marking a component prevents double counting.",
          "approach": "1. Iterate all cells.\n2. When you find land, increment count and DFS to mark the entire island as water.",
          "explanation": "DFS visits all connected land cells, so each island is counted once.",
          "code": "func numIslands(_ grid: [[Character]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var count = 0\n\n    func dfs(_ r: Int, _ c: Int) {\n        if r < 0 || r >= rows || c < 0 || c >= cols { return }\n        if grid[r][c] != \"1\" { return }\n        grid[r][c] = \"0\"\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    }\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == \"1\" {\n                count += 1\n                dfs(r, c)\n            }\n        }\n    }\n    return count\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(m * n)",
            "timeExplanation": "Every cell is visited at most once.",
            "spaceExplanation": "DFS recursion stack can reach all cells in the worst case."
          },
          "testCases": [
            {
              "id": "fa57d4ea-0dec-463a-8a3b-e5d06b3fb13e",
              "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
              "expectedOutput": "1",
              "explanation": "All land is connected."
            },
            {
              "id": "5164b72d-7171-48da-aa64-47e45e594562",
              "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
              "expectedOutput": "3",
              "explanation": "Three separate islands."
            }
          ]
        }
      ],
      "relatedProblems": [
        "max-area-of-island",
        "surrounded-regions"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "ad4417ac-7912-43ec-b99c-b98060877efe",
      "problemSlug": "rotting-oranges",
      "summary": "Use BFS from all rotten oranges to simulate minute-by-minute spread.",
      "approaches": [
        {
          "id": "33f1b3ba-ac87-4e04-8610-23e61eb07e5d",
          "name": "BFS Multi-Source",
          "order": 1,
          "intuition": "Each minute, all currently rotten oranges infect adjacent fresh ones. BFS levels model this time expansion.",
          "approach": "1. Add all rotten oranges to a queue; count fresh oranges.\n2. Process the queue level by level, rotting adjacent fresh oranges.\n3. Increment minutes after each level.\n4. If fresh oranges remain, return -1; otherwise return minutes.",
          "explanation": "BFS naturally tracks the minimum time to reach each orange because it expands in waves.",
          "code": "func orangesRotting(_ grid: [[Int]]) -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid.first?.count ?? 0\n    var queue: [(Int, Int)] = []\n    var fresh = 0\n\n    for r in 0..<rows {\n        for c in 0..<cols {\n            if grid[r][c] == 2 { queue.append((r, c)) }\n            else if grid[r][c] == 1 { fresh += 1 }\n        }\n    }\n\n    let directions = [(1,0),(-1,0),(0,1),(0,-1)]\n    var minutes = 0\n    var head = 0\n\n    while head < queue.count && fresh > 0 {\n        let levelCount = queue.count - head\n        for _ in 0..<levelCount {\n            let (r, c) = queue[head]\n            head += 1\n            for (dr, dc) in directions {\n                let nr = r + dr\n                let nc = c + dc\n                if nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1 {\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n                }\n            }\n        }\n        minutes += 1\n    }\n\n    return fresh == 0 ? minutes : -1\n}",
          "complexity": {
            "time": "O(m * n)",
            "space": "O(m * n)",
            "timeExplanation": "Each cell is processed at most once.",
            "spaceExplanation": "Queue may hold all cells in the grid."
          },
          "testCases": [
            {
              "id": "963f04ce-46ca-4f77-84ee-f13640cb6a5a",
              "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
              "expectedOutput": "4",
              "explanation": "All oranges rot in 4 minutes."
            },
            {
              "id": "8e19da01-63c9-42cb-a384-85cbb69562de",
              "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
              "expectedOutput": "-1",
              "explanation": "Some oranges are unreachable."
            },
            {
              "id": "2efd6748-b2da-4ee7-aeac-9dbe9e4071a8",
              "input": "grid = [[0,2]]",
              "expectedOutput": "0",
              "explanation": "No fresh oranges to rot."
            }
          ]
        }
      ],
      "relatedProblems": [
        "01-matrix",
        "shortest-path-in-binary-matrix"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "b5852c33-2b98-45c6-8c16-c292beb01185",
      "problemSlug": "reverse-linked-list-ii",
      "summary": "Reverse the nodes between two positions using head insertion within the sublist.",
      "approaches": [
        {
          "id": "1b727499-28ed-4e69-ae36-0d335a4f4c55",
          "name": "Sublist Reversal",
          "order": 1,
          "intuition": "If we fix the node before the sublist, we can repeatedly move the next node to the front of that sublist.",
          "approach": "1. Use a dummy node and move `pre` to the node just before `left`.\n2. Let `start` be the first node in the sublist and `then` be start.next.\n3. For each step, move `then` to the front of the sublist.",
          "explanation": "This reverses the sublist in-place without touching nodes outside the range.",
          "code": "func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n    if head == nil || left == right { return head }\n    let dummy = ListNode(0)\n    dummy.next = head\n    var pre: ListNode? = dummy\n\n    var pos = 1\n    while pos < left {\n        pre = pre?.next\n        pos += 1\n    }\n\n    let start = pre?.next\n    var then = start?.next\n    var i = 0\n    while i < right - left {\n        start?.next = then?.next\n        then?.next = pre?.next\n        pre?.next = then\n        then = start?.next\n        i += 1\n    }\n\n    return dummy.next\n}",
          "complexity": {
            "time": "O(n)",
            "space": "O(1)",
            "timeExplanation": "We traverse the list once and reverse the sublist in place.",
            "spaceExplanation": "Only a few pointers are used."
          },
          "testCases": [
            {
              "id": "1272d27f-24bc-4442-bf9a-626f1fe6c565",
              "input": "head = [1,2,3,4,5], left = 2, right = 4",
              "expectedOutput": "[1,4,3,2,5]",
              "explanation": "Sublist 2..4 is reversed."
            },
            {
              "id": "e8309d6a-9f8f-49ce-b125-1afc3423b163",
              "input": "head = [5], left = 1, right = 1",
              "expectedOutput": "[5]",
              "explanation": "Single node remains unchanged."
            }
          ]
        }
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "reorder-list"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    },
    {
      "id": "c4d3ba80-256e-421e-a8cd-00902e73d355",
      "problemSlug": "coin-change",
      "summary": "Compute the minimum coins needed for every amount up to target.",
      "approaches": [
        {
          "id": "b55a038f-25b6-43b9-a7b6-8b9c281971f8",
          "name": "DP (Unbounded)",
          "order": 1,
          "intuition": "The optimal way to make amount A depends on the optimal way to make A - coin for each coin.",
          "approach": "1. Initialize dp[0] = 0 and dp[i] = amount + 1 as infinity.\n2. For each amount from 1 to target, try each coin.\n3. If coin <= amount, dp[amount] = min(dp[amount], dp[amount - coin] + 1).\n4. Return dp[amount] if reachable, else -1.",
          "explanation": "This is a classic unbounded knapsack: each coin can be used multiple times.",
          "code": "func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n    if amount == 0 { return 0 }\n    var dp = Array(repeating: amount + 1, count: amount + 1)\n    dp[0] = 0\n\n    if amount > 0 {\n        for a in 1...amount {\n            for coin in coins where coin <= a {\n                dp[a] = min(dp[a], dp[a - coin] + 1)\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount]\n}",
          "complexity": {
            "time": "O(amount * coins)",
            "space": "O(amount)",
            "timeExplanation": "For each amount we test all coins.",
            "spaceExplanation": "DP array of size amount + 1."
          },
          "testCases": [
            {
              "id": "02761a1e-687a-443d-ad55-42ec7bfee4be",
              "input": "coins = [1,2,5], amount = 11",
              "expectedOutput": "3",
              "explanation": "11 = 5 + 5 + 1."
            },
            {
              "id": "722491b7-e337-4740-b52c-143a5b9af547",
              "input": "coins = [2], amount = 3",
              "expectedOutput": "-1",
              "explanation": "Cannot make 3 with only 2s."
            },
            {
              "id": "f4c25e0b-fd8f-40bf-a433-ce41c17606e9",
              "input": "coins = [1], amount = 0",
              "expectedOutput": "0",
              "explanation": "Zero amount needs zero coins."
            }
          ]
        }
      ],
      "relatedProblems": [
        "coin-change-2",
        "minimum-cost-for-tickets"
      ],
      "lastUpdated": "2026-02-06T00:00:00Z"
    }
  ]
}
