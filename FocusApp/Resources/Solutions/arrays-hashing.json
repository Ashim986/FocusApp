{
  "solutions" : [
    {
      "approaches" : [
        {
          "approach" : "Start from the beginning of the sequence. For each character, if it's '1', check the next character. If the next character is '1' or '0', then it's a 2-bit character. If it's '0', then it's a 1-bit character.",
          "code" : "func isOneBitCharacter(_ bits: [Int]) -> Bool { var i = 0; while i < bits.count - 1 { if bits[i] == 1 { i += 2 } else { i += 1 } }; return bits[i] == 0 }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1), as we are not using any extra space.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n), where n is the number of bits. This is because in the worst-case scenario, we need to iterate through each character in the sequence."
          },
          "explanation" : "This solution works because it checks every possible combination of characters in the sequence.",
          "id" : "e6fad778-9417-4fbe-9940-164057643a6d",
          "intuition" : "We will manually iterate through each character in the sequence, checking for both 1-bit and 2-bit characters.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "We start at the beginning of the sequence and see a '1'. Since the next character is '0', it's a 2-bit character. Then, we have a '1', which is a 1-bit character. So, the last character is a '1', which means it's not a 1-bit character and we return true.",
              "id" : "70aeccb0-118c-45bd-972d-72b5c963f500",
              "input" : "bits = [1, 0, 1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "We start at the beginning of the sequence and see a '1'. Since the next character is '1', it's a 2-bit character. Then, we have another '1', which is a 2-bit character with the '0'. So, the last character is not a 1-bit character and we return false.",
              "id" : "f063fb2c-8e59-4653-8800-0a604aa89b2a",
              "input" : "bits = [1, 1, 1, 0]"
            }
          ]
        },
        {
          "approach" : "Start from the beginning of the sequence. If the current character is '1', move to the next character. If the current character is '0', just move to the next character.",
          "code" : "func isOneBitCharacter(_ bits: [Int]) -> Bool { var i = 0; while i < bits.count { if i == bits.count - 1 { return bits[i] == 0 }; if bits[i] == 1 { i += 2 } else { i += 1 } }; return false }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1), as we are not using any extra space.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n), where n is the number of bits. This is because in the worst-case scenario, we need to iterate through each character in the sequence."
          },
          "explanation" : "This solution works because it takes advantage of the properties of 1-bit and 2-bit characters.",
          "id" : "e3ea2fda-29a5-4554-9b29-f61af3f68bc7",
          "intuition" : "We can improve the brute-force approach by keeping track of the index and checking for the conditions of 1-bit and 2-bit characters.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "We start at the beginning of the sequence and see a '1'. Since the next character is '1', it's a 2-bit character. Then, we have another '1', which is a 2-bit character with the '0'. So, the last character is not a 1-bit character and we return false.",
              "id" : "b51bcba9-528a-4f90-b154-15486ed8e75b",
              "input" : "bits = [1, 1, 1, 0]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "We start at the beginning of the sequence and see a '1'. Since the next character is '0', it's a 2-bit character. Then, we have a '1', which is a 1-bit character. So, the last character is a '1', which means it's not a 1-bit character and we return true.",
              "id" : "be5276a1-bbda-4db1-8ef5-26c57fbdb25e",
              "input" : "bits = [1, 0, 1]"
            }
          ]
        }
      ],
      "id" : "e0e57151-3e65-4c00-97a9-eae722351152",
      "lastUpdated" : "2026-02-06T21:35:43Z",
      "problemSlug" : "1-bit-and-2-bit-characters",
      "relatedProblems" : [
        "single-number",
        "plus-one"
      ],
      "summary" : "We have a sequence of 1-bit and 2-bit characters. A 1-bit character can be represented as '1' or '0', while a 2-bit character can be '00' or '11'. The key insight is to iterate through the sequence and check for the presence of a valid character."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize a variable to store the count of tuples. 2. Iterate over all pairs of numbers. 3. For each pair, check all remaining pairs to see if their sum is 0. 4. If a pair with sum 0 is found, increment the count.",
          "code" : "func fourSumCount(_ A: [Int], _ B: [Int], _ C: [Int], _ D: [Int]) -> Int { var count = 0; for a in A { for b in B { for c in C { for d in D { if a + b + c + d == 0 { count += 1 } } } } }; return count }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are not using any extra space that scales with the input size.",
            "time" : "O(n^4)",
            "timeExplanation" : "The time complexity is O(n^4) because we are iterating over all pairs of numbers and checking all remaining pairs for each pair."
          },
          "explanation" : "This approach has a high time complexity because it involves iterating over all pairs of numbers and checking all remaining pairs for each pair. This results in a lot of repeated calculations and makes the approach inefficient for large inputs.",
          "id" : "ebd86fe4-3a49-48bc-8624-9e7a7b80ec6a",
          "intuition" : "This approach works by iterating over all pairs of numbers and checking if their sum is 0, then checking all remaining pairs to see if their sum is 0. However, this approach is inefficient as it has a high time complexity.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two tuples are (-2,-1,1,2) and (-1,0,1,2).",
              "id" : "7c30ce51-e55e-459d-a566-52711bf5cb49",
              "input" : "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]"
            },
            {
              "expectedOutput" : "10",
              "explanation" : "There are 10 tuples with sum 0: (0,0,0,0), (0,0,0,2), (0,0,1,1), (0,0,2,0), (0,1,0,1), (0,1,1,0), (0,2,0,0), (1,0,0,1), (1,0,1,0), (1,1,0,0).",
              "id" : "b38b67c0-4ad9-4770-be7a-cd0f6e476f2c",
              "input" : "A = [0,1,2], B = [0,1,2], C = [0,1,2], D = [0,1,2]"
            }
          ]
        },
        {
          "approach" : "1. Initialize a hash table to store the sum of pairs from two arrays. 2. Iterate over the two arrays and store the sum of each pair in the hash table. 3. Iterate over the other two arrays and check the hash table for the complement of each pair. 4. If the complement is found, increment the count.",
          "code" : "func fourSumCount(_ A: [Int], _ B: [Int], _ C: [Int], _ D: [Int]) -> Int { var count = 0; var abSum: [Int: Int] = [:]; for a in A { for b in B { abSum[a + b] = (abSum[a + b] ?? 0) + 1 } }; for c in C { for d in D { count += abSum[-(c + d)] ?? 0 } }; return count }",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The space complexity is O(n^2) because we are using a hash table to store the sum of pairs, which can contain up to n^2 elements.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are iterating over all pairs of numbers from two arrays and storing their sum in a hash table."
          },
          "explanation" : "This approach has a lower time complexity than the brute force approach because it uses a hash table to store the sum of pairs, allowing for faster lookup.",
          "id" : "84fd3574-152a-4eca-8387-fa37d9e5c1f9",
          "intuition" : "This approach works by using a hash table to store the sum of pairs from two arrays, then checking the other two arrays for the complement of each pair.",
          "name" : "Hash Table",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The two tuples are (-2,-1,1,2) and (-1,0,1,2).",
              "id" : "5cc32b2d-8f04-42f4-b51b-482112c60cd1",
              "input" : "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]"
            },
            {
              "expectedOutput" : "10",
              "explanation" : "There are 10 tuples with sum 0: (0,0,0,0), (0,0,0,2), (0,0,1,1), (0,0,2,0), (0,1,0,1), (0,1,1,0), (0,2,0,0), (1,0,0,1), (1,0,1,0), (1,1,0,0).",
              "id" : "034dff3f-15c2-45c6-b7f2-52a866383d0b",
              "input" : "A = [0,1,2], B = [0,1,2], C = [0,1,2], D = [0,1,2]"
            }
          ]
        }
      ],
      "id" : "687634e7-3489-4664-9d7c-b2501d5de191",
      "lastUpdated" : "2026-02-06T21:19:55Z",
      "problemSlug" : "4sum-ii",
      "relatedProblems" : [
        "two-sum-ii-input-array-is-sorted",
        "four-sum"
      ],
      "summary" : "The problem asks to find the number of tuples (i, j, k, l) where i, j, k, l are distinct indices and a[i] + a[j] + a[k] + a[l] equals 0. A key insight is to use a hash table to store the sum of pairs and then check for the complement."
    },
    {
      "approaches" : [
        {
          "approach" : "Initialize an empty set to keep track of visited indices, then for each index in the array, perform DFS to find the longest nesting sequence starting from that index.",
          "code" : "\n           import Foundation\n\n           class Solution {\n               func arrayNesting(_ nums: [Int]) -> Int {\n                   var maxLen = 0\n                   var visited: Set<Int> = Set()\n                   \n                   for (i, _) in nums.enumerated() {\n                       maxLen = max(maxLen, dfs(i, nums, &visited))\n                   }\n                   \n                   return maxLen\n               }\n               \n               func dfs(_ i: Int, _ nums: [Int], _ visited: inout Set<Int>) -> Int {\n                   if visited.contains(i) {\n                       return 0\n                   }\n                   \n                   visited.insert(i)\n                   return 1 + dfs(nums[i], nums, &visited)\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the recursive call stack and the set used to keep track of visited indices.",
            "time" : "O(n^2)",
            "timeExplanation" : "In the worst-case scenario, DFS is performed for each index in the array, resulting in a time complexity of O(n^2)."
          },
          "explanation" : "During DFS, mark the current index as visited and recursively call DFS on the next index in the sequence. Keep track of the length of the current sequence and update the maximum length if necessary.",
          "id" : "46be8a89-f336-4b16-ba6b-8a94ea43230a",
          "intuition" : "The brute-force approach involves trying all possible nesting sequences and keeping track of the longest one found so far.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The longest nesting sequence is 0 -> 5 -> 2 -> 2",
              "id" : "3de367ec-65bf-4b9a-8742-7b43b07c590f",
              "input" : "nums = [5,4,0,3,1,6,2]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The longest nesting sequence is 4 -> 6 -> 7 -> 4",
              "id" : "045c4ce8-0d11-4c85-be6f-479e81dbd496",
              "input" : "nums = [9,0,4,6,7,1]"
            }
          ]
        },
        {
          "approach" : "Initialize an empty set to keep track of visited indices, then for each index in the array, perform DFS to find the longest nesting sequence starting from that index if it has not been visited before.",
          "code" : "\n           import Foundation\n\n           class Solution {\n               func arrayNesting(_ nums: [Int]) -> Int {\n                   var maxLen = 0\n                   var visited: Set<Int> = Set()\n                   var n = nums.count\n                   \n                   for i in 0..<n {\n                       if !visited.contains(i) {\n                           var len = 0\n                           var j = i\n                           while !visited.contains(j) {\n                               visited.insert(j)\n                               len += 1\n                               j = nums[j]\n                           }\n                           maxLen = max(maxLen, len)\n                       }\n                   }\n                   \n                   return maxLen\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the set used to keep track of visited indices.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) since each index is visited at most once."
          },
          "explanation" : "During DFS, mark the current index as visited and recursively call DFS on the next index in the sequence. Keep track of the length of the current sequence and update the maximum length if necessary.",
          "id" : "83efd373-f146-49ca-ab8b-efc73c37fd28",
          "intuition" : "The optimized approach involves using a single pass through the array and using a set to keep track of visited indices.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "The longest nesting sequence is 0 -> 5 -> 2 -> 2",
              "id" : "3fa0708f-508b-4013-af86-51173991d624",
              "input" : "nums = [5,4,0,3,1,6,2]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The longest nesting sequence is 4 -> 6 -> 7 -> 4",
              "id" : "a6b996ae-0afa-4b3e-8db0-55df14e8a966",
              "input" : "nums = [9,0,4,6,7,1]"
            }
          ]
        }
      ],
      "id" : "bf00618e-13a1-4701-be85-96bdfe32a992",
      "lastUpdated" : "2026-02-06T21:26:27Z",
      "problemSlug" : "array-nesting",
      "relatedProblems" : [
        "find-minimum-time-to-finish-all-jobs",
        "minimum-length-of-string-after-deleting-similar-ends"
      ],
      "summary" : "The Array Nesting problem requires finding the longest nesting sequence in a given array, with the key insight being to use depth-first search (DFS) to traverse the nested sequences."
    },
    {
      "approaches" : [
        {
          "approach" : "Start at the rook's position, then iterate over each row and column of the board, checking each position for a piece that can be captured by the rook.",
          "code" : "\n           func numRookCaptures(_ board: [[Character]]) -> Int {\n               var x = 0\n               var y = 0\n               for i in 0...7 {\n                   for j in 0...7 {\n                       if board[i][j] == \"R\" {\n                           x = i\n                           y = j\n                           break\n                       }\n                   }\n                   if x != 0 {\n                       break\n                   }\n               }\n               var res = 0\n               \/\/ check up\n               for i in stride(from: x - 1, through: 0, by: -1) {\n                   if board[i][y] == \"p\" {\n                       res += 1\n                       break\n                   } else if board[i][y] == \"B\" {\n                       break\n                   }\n               }\n               \/\/ check down\n               for i in stride(from: x + 1, through: 7, by: 1) {\n                   if board[i][y] == \"p\" {\n                       res += 1\n                       break\n                   } else if board[i][y] == \"B\" {\n                       break\n                   }\n               }\n               \/\/ check left\n               for i in stride(from: y - 1, through: 0, by: -1) {\n                   if board[x][i] == \"p\" {\n                       res += 1\n                       break\n                   } else if board[x][i] == \"B\" {\n                       break\n                   }\n               }\n               \/\/ check right\n               for i in stride(from: y + 1, through: 7, by: 1) {\n                   if board[x][i] == \"p\" {\n                       res += 1\n                       break\n                   } else if board[x][i] == \"B\" {\n                       break\n                   }\n               }\n               return res\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The solution uses a constant amount of space.",
            "time" : "O(1)",
            "timeExplanation" : "The solution runs in constant time as the size of the board is fixed at 8x8."
          },
          "explanation" : "This solution works by scanning the rows and columns of the chessboard from the given position of the rook, checking for pieces that the rook can capture. If a piece is found, it is counted as a potential capture. However, if another piece is found before it (blocking the rook's attack), the scan in that direction is stopped.",
          "id" : "bbf04ad1-a5e9-417c-bd9a-d987018bfca2",
          "intuition" : "This approach involves checking every square on the chessboard from the rook's position to see if there are any pieces that can be captured.",
          "name" : "Naive Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The rook can capture one piece to its down direction.",
              "id" : "8edad632-2529-4a48-bd0c-d70bb3577b82",
              "input" : "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The rook can capture one piece to its down direction.",
              "id" : "d34f025d-e123-4f69-a9c2-13e534976a6a",
              "input" : "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
            }
          ]
        },
        {
          "approach" : "Start at the rook's position, then iterate over each row and column of the board in all four directions (up, down, left, right). If a piece is found, it is counted as a potential capture, and the iteration in that direction is stopped.",
          "code" : "\n           func numRookCaptures(_ board: [[Character]]) -> Int {\n               var res = 0\n               for i in 0...7 {\n                   for j in 0...7 {\n                       if board[i][j] == \"R\" {\n                           var x = i\n                           var y = j\n                           \/\/ check up\n                           while x > 0 {\n                               x -= 1\n                               if board[x][y] == \"p\" {\n                                   res += 1\n                                   break\n                               } else if board[x][y] == \"B\" {\n                                   break\n                               }\n                           }\n                           \/\/ check down\n                           x = i\n                           while x < 7 {\n                               x += 1\n                               if board[x][y] == \"p\" {\n                                   res += 1\n                                   break\n                               } else if board[x][y] == \"B\" {\n                                   break\n                               }\n                           }\n                           \/\/ check left\n                           x = i\n                           while y > 0 {\n                               y -= 1\n                               if board[x][y] == \"p\" {\n                                   res += 1\n                                   break\n                               } else if board[x][y] == \"B\" {\n                                   break\n                               }\n                           }\n                           \/\/ check right\n                           y = j\n                           while y < 7 {\n                               y += 1\n                               if board[x][y] == \"p\" {\n                                   res += 1\n                                   break\n                               } else if board[x][y] == \"B\" {\n                                   break\n                               }\n                           }\n                       }\n                   }\n               }\n               return res\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The solution uses a constant amount of space.",
            "time" : "O(1)",
            "timeExplanation" : "The solution runs in constant time as the size of the board is fixed at 8x8."
          },
          "explanation" : "This solution works similarly to the naive approach but it stops scanning in a given direction as soon as it encounters a piece, which can improve the efficiency if there are many pieces on the board.",
          "id" : "a014d0f2-d4e7-4266-9d28-9bb99121ed70",
          "intuition" : "This approach involves using the fact that the rook can capture pieces either horizontally or vertically, and stops as soon as it encounters a piece in the given direction.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The rook can capture one piece to its down direction.",
              "id" : "749bb755-f016-40fb-b6f3-315e3987ea7d",
              "input" : "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The rook can capture one piece to its down direction.",
              "id" : "78de5e56-9a6b-4ea4-80d6-3bb1ada2f5f9",
              "input" : "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
            }
          ]
        }
      ],
      "id" : "c4f6f29c-aba2-4f63-9aa1-de045a348cbc",
      "lastUpdated" : "2026-02-06T21:54:32Z",
      "problemSlug" : "available-captures-for-rook",
      "relatedProblems" : [
        "knight-probability",
        "queens-that-can-attack-the-king"
      ],
      "summary" : "This problem involves a rook on an 8x8 chessboard that can capture other pieces either horizontally or vertically, and the goal is to determine how many pieces are under attack. The key insight is to scan the rows and columns of the given position of the rook for potential captures."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate over the entire board, and for each cell, check if it is a top-left corner of a ship by checking if the cell to the left and the cell above are not 'X'. If the cell is a top-left corner, increment the count.",
          "code" : "let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\nlet result = countBattleships(board)\nprint(result)\nfunc countBattleships(_ board: [[Character]]) -> Int {\n    var count = 0\n    for i in 0..<board.count {\n        for j in 0..<board[0].count {\n            if board[i][j] == \"X\" {\n                if i == 0 || board[i-1][j] != \"X\" {\n                    if j == 0 || board[i][j-1] != \"X\" {\n                        count += 1\n                    }\n                }\n            }\n        }\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the count variable.",
            "time" : "O(m*n)",
            "timeExplanation" : "We iterate over the entire board once, where m is the number of rows and n is the number of columns."
          },
          "explanation" : "We start by initializing a count variable to 0. Then, we iterate over the board row by row. For each cell, we check if it is a top-left corner of a ship. If the cell is 'X' and the cell to the left is not 'X' or out of bounds, and the cell above is not 'X' or out of bounds, we increment the count. After iterating over the entire board, the count variable will hold the number of ships on the board.",
          "id" : "76ff756f-f2cb-414d-a4b2-3b2929ed3bb6",
          "intuition" : "This approach works by iterating over the entire board and for each cell, it checks if the cell is a top-left corner of a ship and if so, it increments the count.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "There are two ships on the board, one at the top-left and one at the bottom-right.",
              "id" : "83d8b1b1-52c2-4095-837d-f5057a74f7f7",
              "input" : "board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] "
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no ships on the board.",
              "id" : "d0d1a536-54ca-40e5-ba9e-7a19ef493eb4",
              "input" : "board = [[\".\",\".\",\".\",\".\"]]"
            }
          ]
        },
        {
          "approach" : "Iterate over the board and for each cell, if the cell is a top-left corner of a ship, increment the count and then perform a DFS to mark all cells in the ship as visited.",
          "code" : "let board: [[Character]] = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\nlet result = countBattleships(board)\nprint(result)\nfunc countBattleships(_ board: [[Character]]) -> Int {\n    var count = 0\n    var visited: Set<String> = Set<String>()\n    for i in 0..<board.count {\n        for j in 0..<board[0].count {\n            if board[i][j] == \"X\" && !visited.contains(\"(i),(j)\") {\n                if i == 0 || board[i-1][j] != \"X\" {\n                    if j == 0 || board[i][j-1] != \"X\" {\n                        count += 1\n                    }\n                }\n                dfs(board, i, j, &visited)\n            }\n        }\n    }\n    return count\n}\nfunc dfs(_ board: [[Character]], _ i: Int, _ j: Int, _ visited: inout Set<String>) {\n    if i < 0 || i >= board.count || j < 0 || j >= board[0].count || board[i][j] != \"X\" || visited.contains(\"(i),(j)\") {\n        return\n    }\n    visited.insert(\"(i),(j)\")\n    dfs(board, i-1, j, &visited)\n    dfs(board, i+1, j, &visited)\n    dfs(board, i, j-1, &visited)\n    dfs(board, i, j+1, &visited)\n}",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "We use a set to keep track of the visited cells, which in the worst case, can be the entire board.",
            "time" : "O(m*n)",
            "timeExplanation" : "We iterate over the entire board once, and for each cell, we may perform a DFS, but since we use a visited set, each cell is visited at most once."
          },
          "explanation" : "We start by initializing a count variable to 0. Then, we iterate over the board row by row. For each cell, we check if it is a top-left corner of a ship. If the cell is 'X' and the cell to the left is not 'X' or out of bounds, and the cell above is not 'X' or out of bounds, we increment the count and perform a DFS to mark all cells in the ship as visited. After iterating over the entire board, the count variable will hold the number of ships on the board.",
          "id" : "e2ebed03-a348-4a79-a258-143955bc2b42",
          "intuition" : "This approach works by iterating over the board only when we find a top-left corner of a ship, and we use a visited set to keep track of the cells we have visited.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "There are two ships on the board, one at the top-left and one at the bottom-right.",
              "id" : "225adb50-9c7d-4485-a44e-51ede861a5b7",
              "input" : "board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] "
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no ships on the board.",
              "id" : "cb178889-3eca-4026-b072-cf03094d3d8f",
              "input" : "board = [[\".\",\".\",\".\",\".\"]]"
            }
          ]
        }
      ],
      "id" : "73af8a4c-c817-4977-a3c2-9d1dd85e79b8",
      "lastUpdated" : "2026-02-06T21:17:30Z",
      "problemSlug" : "battleships-in-a-board",
      "relatedProblems" : [
        "surrounded-regions",
        "number-of-islands"
      ],
      "summary" : "The problem asks to count the number of Battleships in a Board, where a Battleship is defined by the cells it occupies on the board, and the key insight is that we can count the number of ships by counting the top-left corners of the ships."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize an empty hashmap to store the edges. 2. Iterate through each brick and its edges. 3. For each edge, check if it exists in the hashmap and increment the count if it does. 4. Return the maximum count.",
          "code" : "func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; for row in wall { var curEdge: Int = 0; for brick in row { if brick == row[row.count - 1] { break; } curEdge += brick; edges[curEdge, default: 0] += 1; } } let maxCount = edges.values.max() ?? 0; return wall.count - maxCount; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the edges in a hashmap.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because we are iterating through each brick in each row."
          },
          "explanation" : "The brute force approach is straightforward but has a high time complexity due to the repeated iterations through the bricks.",
          "id" : "6d364b03-1333-4493-b219-162295e034c8",
          "intuition" : "This approach works by iterating through each brick edge and checking if it aligns with the previous edge.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The minimum number of cuts is 2.",
              "id" : "9b855b9a-6695-47e9-bee1-9ee492fcc524",
              "input" : "wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The minimum number of cuts is 3.",
              "id" : "fc4d14d0-a8bc-40e5-b07b-bdaeb2ad6519",
              "input" : "wall = [[1],[1],[1]]"
            }
          ]
        },
        {
          "approach" : "1. Initialize an empty hashmap to store the edges and their counts. 2. Iterate through each brick and its edges. 3. For each edge, increment the count in the hashmap. 4. Find the maximum count in the hashmap. 5. Return the total number of rows minus the maximum count.",
          "code" : "func leastBricks(_ wall: [[Int]]) -> Int { var edges: [Int: Int] = [:]; var maxWidth: Int = 0; for row in wall { maxWidth += row[0]; } maxWidth -= 1; for row in wall { var curEdge: Int = 0; for i in 0..<row.count - 1 { curEdge += row[i]; edges[curEdge, default: 0] += 1; } } var maxCount: Int = 0; for (_, count) in edges { maxCount = max(maxCount, count); } return wall.count - maxCount; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the edges in a hashmap.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because we are iterating through each brick in each row."
          },
          "explanation" : "The optimized approach has a lower time complexity because it uses a hashmap to store the edges and their counts.",
          "id" : "fefe90fd-3f71-40b4-bb23-448ee4c95e2e",
          "intuition" : "This approach works by using a hashmap to store the edges and their counts, then finding the maximum count.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The minimum number of cuts is 2.",
              "id" : "b204d105-da56-4632-abee-649672856649",
              "input" : "wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The minimum number of cuts is 3.",
              "id" : "7057ba3b-56c6-4897-92d8-9ae0ef6b0d73",
              "input" : "wall = [[1],[1],[1]]"
            }
          ]
        }
      ],
      "id" : "a4785c6f-7e77-4b99-baa0-e9b7916e8e77",
      "lastUpdated" : "2026-02-06T21:25:53Z",
      "problemSlug" : "brick-wall",
      "relatedProblems" : [
        "subarray-sum-equals-k",
        "valid-parentheses"
      ],
      "summary" : "The problem is to find the minimum number of cuts in a brick wall such that the bricks are aligned. The key insight is to use a hashmap to store the edges of the bricks."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all permutations of the string, compare each with the target string, and return true if exactly one pair differs",
          "code" : "func buddyStrings(_ s: String, _ goal: String) -> Bool {\n  if s.count != goal.count { return false }\n  var res = false\n  for i in s.indices {\n    for j in i+1..<s.count {\n      var sNew = Array(s)\n      let temp = sNew[i]\n      sNew[i] = sNew[j]\n      sNew[j] = temp\n      if String(sNew) == goal {\n        if res { return false }\n        res = true\n      }\n    }\n  }\n  return res\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are creating a copy of the input string",
            "time" : "O(n^2)",
            "timeExplanation" : "Time complexity is exponential due to nested loops"
          },
          "explanation" : "This approach is inefficient due to its exponential time complexity but can be a useful baseline for understanding the problem",
          "id" : "08481434-3691-4d3b-b2a3-5163df88749a",
          "intuition" : "Check all permutations of the strings and compare them",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The strings can be buddies by swapping 'a' and 'b'",
              "id" : "fbe54aa7-f5dd-4b0f-9d2a-92ec140b4b50",
              "input" : "s = \"ab\", goal = \"ba\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "No swap can make 'ab' and 'ab' buddies without repetition",
              "id" : "0d2a2523-531c-4632-9647-21f60fe3aa79",
              "input" : "s = \"ab\", goal = \"ab\""
            }
          ]
        },
        {
          "approach" : "Iterate over both strings and compare differing characters",
          "code" : "func buddyStrings(_ s: String, _ goal: String) -> Bool {\n  if s.count != goal.count { return false }\n  if s == goal {\n    var sCounts = [Character: Int]()\n    for char in s {\n      if let count = sCounts[char] {\n        sCounts[char] = count + 1\n      } else {\n        sCounts[char] = 1\n      }\n    }\n    return sCounts.values.contains { $0 > 1 }\n  }\n  var mismatch = [(Character, Character)]()\n  for (sc, gc) in zip(s, goal) {\n    if sc != gc {\n      if mismatch.count > 1 { return false }\n      mismatch.append((sc, gc))\n    }\n  }\n  return mismatch.count == 1 && mismatch[0].0 == mismatch[0].1 && mismatch[0].0 != mismatch[0].1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No additional data structures are needed beyond a few variables",
            "time" : "O(n)",
            "timeExplanation" : "We only iterate over the input strings once"
          },
          "explanation" : "This solution only requires a single pass over the input strings",
          "id" : "04f76e2e-7880-49ed-8091-01330a4a72c4",
          "intuition" : "Use hash table to track character frequencies",
          "name" : "Optimized Solution",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The condition checks for duplicate characters in 's'",
              "id" : "0e9adf14-c13e-4566-b077-376f7780a529",
              "input" : "s = \"aa\", goal = \"aa\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "The strings can be buddies by swapping 'a' and 'b'",
              "id" : "3d2a128f-6ba5-446c-a20a-29d7fcffd153",
              "input" : "s = \"ab\", goal = \"ba\""
            }
          ]
        }
      ],
      "id" : "9eeda171-d7f8-489c-ab2b-fa8d58037d1e",
      "lastUpdated" : "2026-02-06T21:44:53Z",
      "problemSlug" : "buddy-strings",
      "relatedProblems" : [
        "valid-anagram",
        "isomorphic-strings"
      ],
      "summary" : "The problem requires checking if two strings can be buddies by swapping at most one pair of characters. The key insight is to identify common characters or differing characters."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize counters for bulls and cows, Step 2: Iterate through the secret and the guess, Step 3: If a digit matches, increment the bulls counter, otherwise, check for non-matches and increment the cows counter, Step 4: Return the result as a string",
          "code" : "\nfunc getHint(_ secret: String, _ guess: String) -> String {\n    var bulls = 0\n    var cows = 0\n    var secretCount = [Character: Int]()\n    var guessCount = [Character: Int]()\n\n    for (i, char) in secret.enumerated() {\n        if char == guess[i] {\n            bulls += 1\n        } else {\n            secretCount[char] = (secretCount[char] ?? 0) + 1\n            guessCount[guess[i]] = (guessCount[guess[i]] ?? 0) + 1\n        }\n    }\n\n    for (key, value) in secretCount {\n        if let guessValue = guessCount[key] {\n            cows += min(value, guessValue)\n        }\n    }\n\n    return \"(bulls)A(cows)B\"\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we're using hash tables to store the counts of digits in the secret and the guess.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) where n is the length of the secret, because we're iterating through the secret and the guess once."
          },
          "explanation" : "The brute-force approach involves iterating through each digit of the secret and the guess, checking for matches (bulls) and non-matches (cows), and returning the result as a string",
          "id" : "a9dc0bfe-76e7-40a4-b440-9cb9d0fe854b",
          "intuition" : "This approach works by iterating through each digit of the secret and the guess, counting the matches (bulls) and non-matches (cows).",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1A3B",
              "explanation" : "The digit '8' in the secret and the guess is a match (bull), and the digits '0', '7', and '1' are non-matches (cows)",
              "id" : "07847329-ad67-4c08-b4f3-ad755508cd2d",
              "input" : "secret = \"1807\", guess = \"7810\""
            },
            {
              "expectedOutput" : "1A1B",
              "explanation" : "The digit '1' in the secret and the guess is a match (bull), and one of the digits '1' in the guess is a non-match (cow)",
              "id" : "7e5f3417-f957-4d5e-8bdc-beca7b65bf29",
              "input" : "secret = \"1123\", guess = \"0111\""
            }
          ]
        },
        {
          "approach" : "Step 1: Initialize counters for bulls and cows, and two hash tables for the secret and the guess, Step 2: Iterate through the secret and the guess, Step 3: If a digit matches, increment the bulls counter, otherwise, increment the counts in the hash tables, Step 4: Iterate through the hash tables to count the non-matches (cows), Step 5: Return the result as a string",
          "code" : "\nfunc getHint(_ secret: String, _ guess: String) -> String {\n    var bulls = 0\n    var cows = 0\n    var secretCount = [Character: Int]()\n    var guessCount = [Character: Int]()\n\n    let secretArray = Array(secret)\n    let guessArray = Array(guess)\n\n    for i in 0..<secretArray.count {\n        if secretArray[i] == guessArray[i] {\n            bulls += 1\n        } else {\n            secretCount[secretArray[i]] = (secretCount[secretArray[i]] ?? 0) + 1\n            guessCount[guessArray[i]] = (guessCount[guessArray[i]] ?? 0) + 1\n        }\n    }\n\n    for (key, value) in secretCount {\n        if let guessValue = guessCount[key] {\n            cows += min(value, guessValue)\n        }\n    }\n\n    return \"(bulls)A(cows)B\"\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we're using hash tables to store the counts of digits in the secret and the guess.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) where n is the length of the secret, because we're iterating through the secret and the guess once."
          },
          "explanation" : "The optimized approach involves using two hash tables to count the matches and non-matches, iterating through the secret and the guess only once, and returning the result as a string",
          "id" : "71f4437c-f313-4b13-84e0-de28155e163b",
          "intuition" : "This approach works by using two hash tables to count the matches and non-matches, iterating through the secret and the guess only once.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1A3B",
              "explanation" : "The digit '8' in the secret and the guess is a match (bull), and the digits '0', '7', and '1' are non-matches (cows)",
              "id" : "1656de32-d0db-4a50-9ee0-bffbbad55861",
              "input" : "secret = \"1807\", guess = \"7810\""
            },
            {
              "expectedOutput" : "1A1B",
              "explanation" : "The digit '1' in the secret and the guess is a match (bull), and one of the digits '1' in the guess is a non-match (cow)",
              "id" : "67c7778c-6d8b-4d30-a5c1-187385afddfc",
              "input" : "secret = \"1123\", guess = \"0111\""
            }
          ]
        }
      ],
      "id" : "72a76674-6602-4f2a-8d4c-cc0a1ef83bb2",
      "lastUpdated" : "2026-02-06T21:12:16Z",
      "problemSlug" : "bulls-and-cows",
      "relatedProblems" : [
        "number-of-good-paths",
        "find-all-anagrams-in-a-string",
        "minimum-window-substring"
      ],
      "summary" : "Bulls and Cows is a code-breaking game where a player tries to guess a secret number, it's solved by counting and matching digits in the secret and the guess. The key insight is to use a hash table to count the matches."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible flip combinations and calculate the number of flips for each combination. Keep track of the minimum number of flips found so far.",
          "code" : "func flipgame(_ fronts: [Int], _ backs: [Int]) -> Int { let n = fronts.count; var ans = n; func dfs(_ index: Int, _ currFlips: Int) { if index == n { ans = min(ans, currFlips); return }; dfs(index + 1, currFlips + (fronts[index] == 0 ? 1 : 0)); dfs(index + 1, currFlips + (backs[index] == 0 ? 1 : 0)); }; dfs(0, 0); return ans; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we use a recursive call stack of maximum depth n.",
            "time" : "O(2^n)",
            "timeExplanation" : "The time complexity is exponential because we generate all possible flip combinations."
          },
          "explanation" : "This approach is straightforward but inefficient. It involves generating 2^n possible combinations where n is the number of cards.",
          "id" : "973dbcbc-a029-455c-bbbd-3986285849d4",
          "intuition" : "This approach involves trying all possible flip combinations and finding the one with the minimum number of flips.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "We can flip all the cards to their back side to get all zeros.",
              "id" : "23fc3cf8-dac4-4cd6-8759-66e579155ff2",
              "input" : "fronts = [1,2,4,4,7], backs = [1,3,4,1,3]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "We need to flip one card to its back side to get all zeros.",
              "id" : "156490ab-2148-40c1-9ca4-b6bb4d176159",
              "input" : "fronts = [0,0,0,1], backs = [1,1,0,1]"
            }
          ]
        },
        {
          "approach" : "Create a set of unique cards and initialize a variable to track the minimum number of flips. For each card, if it is not in the set, add it to the set and increment the minimum number of flips.",
          "code" : "func flipgame(_ fronts: [Int], _ backs: [Int]) -> Int { var same = Set<Int>(); for (a, b) in zip(fronts, backs) { if a == b { same.insert(a); } }; var ans = Int.max; for x in fronts + backs { if !same.contains(x) { ans = min(ans, x); } }; return ans == Int.max ? 0 : ans; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we use a set to store unique cards.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we iterate through the cards once."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it avoids duplicate flips.",
          "id" : "e8a0837a-e74c-4420-a6c8-9841228986cd",
          "intuition" : "This approach involves using a hash table to track the cards that have been flipped and finding the minimum number of flips by avoiding duplicate flips.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "We can flip all the cards to their back side to get all zeros.",
              "id" : "6f1d35d0-7f0f-4217-8588-beac70d283f5",
              "input" : "fronts = [1,2,4,4,7], backs = [1,3,4,1,3]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "We need to flip one card to its back side to get all zeros.",
              "id" : "fb753a61-8355-4343-8109-cc681ae7efef",
              "input" : "fronts = [0,0,0,1], backs = [1,1,0,1]"
            }
          ]
        }
      ],
      "id" : "56be0ad1-93c8-4f51-b14f-4dd50509be63",
      "lastUpdated" : "2026-02-06T21:42:12Z",
      "problemSlug" : "card-flipping-game",
      "relatedProblems" : [
        "minimum-window-substring",
        "reverse-words-in-a-string-iii"
      ],
      "summary" : "The problem involves finding the minimum number of flips to make all the cards face down. The key insight is to use a hash table to track the cards that have been flipped."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create an empty set.\n2. For each number:\n   - If it is in the set, return true.\n   - Otherwise insert it.\n3. Return false if no duplicates are found.",
          "code" : "func containsDuplicate(_ nums: [Int]) -> Bool {\n    var seen = Set<Int>()\n    for num in nums {\n        if seen.contains(num) { return true }\n        seen.insert(num)\n    }\n    return false\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The set can store all unique elements.",
            "time" : "O(n)",
            "timeExplanation" : "Single pass with O(1) set checks."
          },
          "explanation" : "Sets provide O(1) average lookup\/insert, making this linear time.",
          "id" : "6966b214-f4ce-4778-886f-94a0b3f47720",
          "intuition" : "If any number appears twice, it will already exist in the set when we see it again.",
          "name" : "Hash Set",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "1 appears twice.",
              "id" : "fb1e2b00-0d16-47e1-853d-2eaefef9fa8a",
              "input" : "nums = [1,2,3,1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "All elements are unique.",
              "id" : "6f11889d-5920-43a0-8b23-d5d19a5d5770",
              "input" : "nums = [1,2,3,4]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Multiple duplicates present.",
              "id" : "fa7882d8-0b93-4cab-931b-8029e5c5b4cb",
              "input" : "nums = [1,1,1,3,3,4,3,2,4,2]"
            }
          ]
        }
      ],
      "id" : "23f4748b-97c7-48ee-b352-423fbcbfd2b2",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "contains-duplicate",
      "relatedProblems" : [
        "contains-duplicate-ii",
        "contains-duplicate-iii"
      ],
      "summary" : "Track seen values in a set; a repeat indicates a duplicate."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through the array, and for each element, check every subarray starting from it. Count the number of 0s and 1s in each subarray and return the maximum length of the subarray with equal number of 0s and 1s.",
          "code" : "\n       func findMaxLength(_ nums: [Int]) -> Int {\n           let n = nums.count\n           var maxLength = 0\n           for i in 0..<n {\n               for j in i..<n {\n                   var countZero = 0\n                   var countOne = 0\n                   for k in i...j {\n                       if nums[k] == 0 {\n                           countZero += 1\n                       } else {\n                           countOne += 1\n                       }\n                   }\n                   if countZero == countOne {\n                       maxLength = max(maxLength, j - i + 1)\n                   }\n               }\n           }\n           return maxLength\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because only a constant amount of space is used to store variables.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is O(n^3) because there are three nested loops: two for iterating through the array and one for counting 0s and 1s in each subarray."
          },
          "explanation" : "This approach is straightforward but inefficient because it involves checking every possible subarray. It has a time complexity of O(n^3) due to the nested loops.",
          "id" : "1ddaa3e2-d2d2-4281-8872-053321ab4a92",
          "intuition" : "The brute-force approach involves checking every possible subarray and counting the number of 0s and 1s to see if they are equal.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The subarray [0,1] has equal number of 0s and 1s, and it has length 2.",
              "id" : "558cf834-fd04-4af3-b69a-838ae2df6c74",
              "input" : "nums = [0,1]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The subarray [0,1] has equal number of 0s and 1s, and it has length 2.",
              "id" : "e60197c3-141f-444c-bb32-7a05570800c8",
              "input" : "nums = [0,1,0]"
            }
          ]
        },
        {
          "approach" : "Iterate through the array, and at each position, increment the count of 1s if the element is 1, or decrement the count if the element is 0. Store the cumulative sum in a dictionary. If the cumulative sum is seen before, update the maximum length of the subarray.",
          "code" : "\n       func findMaxLength(_ nums: [Int]) -> Int {\n           let n = nums.count\n           var maxLength = 0\n           var count = 0\n           var prefixSum: [Int: Int] = [0: -1]\n           for i in 0..<n {\n               if nums[i] == 0 {\n                   count -= 1\n               } else {\n                   count += 1\n               }\n               if let j = prefixSum[count] {\n                   maxLength = max(maxLength, i - j)\n               } else {\n                   prefixSum[count] = i\n               }\n           }\n           return maxLength\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, every element might be stored in the dictionary.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because only one pass is made through the array."
          },
          "explanation" : "This approach is efficient because it only requires one pass through the array and uses a dictionary to store the cumulative sum.",
          "id" : "ea2efb50-4fe7-4152-b6ee-1f8b553a81f8",
          "intuition" : "The prefix sum approach involves using a dictionary to store the difference between 0s and 1s at each position.",
          "name" : "Prefix Sum Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The subarray [0,1] has equal number of 0s and 1s, and it has length 2.",
              "id" : "9528c88b-d89c-4a21-bfa8-566256f7c58b",
              "input" : "nums = [0,1]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The subarray [0,1] has equal number of 0s and 1s, and it has length 2.",
              "id" : "516ab328-031b-403f-9198-54cc21e4fdcf",
              "input" : "nums = [0,1,0]"
            }
          ]
        }
      ],
      "id" : "1f355a57-db64-4fbe-a00b-fb8c2ef8b6c4",
      "lastUpdated" : "2026-02-06T21:24:15Z",
      "problemSlug" : "contiguous-array",
      "relatedProblems" : [
        "single-number",
        "subarray-sum-equals-k"
      ],
      "summary" : "Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. The key insight is to use a prefix sum approach to track the difference between 0s and 1s."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create an empty string to store the result. 2. Iterate over the custom order string. For each character in the custom order, append the characters from the string. 3. Append the remaining characters not present in the custom order to the result.",
          "code" : "func customSortString(_ S: String, _ T: String) -> String { var result = \"\"; let SArray = Array(S); let TArray = Array(T); var TCount: [Character: Int] = [:]; for char in TArray { if TCount[char] == nil { TCount[char] = 1 } else { TCount[char]! += 1 } }; for char in SArray { if TCount[char] != nil { result += String(repeating: char, count: TCount[char]!); TCount[char] = nil }; }; for (char, count) in TCount { result += String(repeating: char, count: count); }; return result; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the use of the TCount dictionary and the result string.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) due to the nested loop."
          },
          "explanation" : "This approach is a simple and straightforward solution to the custom sort string problem. It uses no additional data structures other than the result string and has a time complexity of O(n^2) due to the nested loop.",
          "id" : "2f4d03d9-48b3-472a-8679-8a9227aeac05",
          "intuition" : "This approach works by iterating over the custom order string and appending the characters from the string. Then it appends the remaining characters not present in the custom order.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"cbad\"",
              "explanation" : "The custom order is \"cba\", so 'c' and 'b' come before 'a' and 'd'.",
              "id" : "58fc3672-70ef-441f-b2cf-2f5c552729cc",
              "input" : "S = \"cba\", T = \"abcd\""
            },
            {
              "expectedOutput" : "\"kqeepq\"",
              "explanation" : "The custom order is \"kqep\", so 'k' and 'q' come before 'e' and 'p'.",
              "id" : "c3f82ed7-59ce-43bb-9a0e-d2d20849f86d",
              "input" : "S = \"kqep\", T = \"pekepq\""
            }
          ]
        },
        {
          "approach" : "1. Create a hash table to store the count of each character in the string. 2. Iterate over the custom order string. For each character in the custom order, append the characters based on their count. 3. Append the remaining characters not present in the custom order.",
          "code" : "func customSortString(_ S: String, _ T: String) -> String { let SArray = Array(S); let TArray = Array(T); var TCount: [Character: Int] = [:]; var result = \"\"; for char in TArray { TCount[char, default: 0] += 1 }; for char in SArray { if let count = TCount[char] { result += String(repeating: char, count: count); TCount[char] = nil }; }; for (char, count) in TCount { result += String(repeating: char, count: count); }; return result; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the use of the TCount dictionary and the result string.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) due to the single pass through the string."
          },
          "explanation" : "This approach is an optimized solution to the custom sort string problem. It uses a hash table to store the count of each character, reducing the time complexity to O(n).",
          "id" : "aee6e6b9-6116-4fa5-b545-6590a09a33c0",
          "intuition" : "This approach works by using a hash table to store the count of each character in the string. Then it iterates over the custom order string and appends the characters based on their count.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"cbad\"",
              "explanation" : "The custom order is \"cba\", so 'c' and 'b' come before 'a' and 'd'.",
              "id" : "42730aca-dc9f-40f1-ad78-fe3f24a51093",
              "input" : "S = \"cba\", T = \"abcd\""
            },
            {
              "expectedOutput" : "\"kqeepq\"",
              "explanation" : "The custom order is \"kqep\", so 'k' and 'q' come before 'e' and 'p'.",
              "id" : "2b2bfe92-4e7b-4a82-b07b-9cd940603d57",
              "input" : "S = \"kqep\", T = \"pekepq\""
            }
          ]
        }
      ],
      "id" : "b18c6a24-bedd-4731-8c83-431f6d0d141d",
      "lastUpdated" : "2026-02-06T21:39:56Z",
      "problemSlug" : "custom-sort-string",
      "relatedProblems" : [
        "relative-ranks",
        "sort-array-by-parity"
      ],
      "summary" : "Custom sort string problem requires ordering characters based on a custom order string. The key insight is to use hash tables and sorting."
    },
    {
      "approaches" : [
        {
          "approach" : "First, initialize variables to keep track of the maximum frequency and the minimum length of the subarray with the maximum frequency. Then, iterate over each unique element in the array and check its frequency. If the frequency of the current element is greater than the maximum frequency found so far, update the maximum frequency and the minimum length of the subarray.",
          "code" : "func findShortestSubArray(_ nums: [Int]) -> Int { let count = Dictionary(grouping: nums, by: { $0 }).mapValues { $0.count }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in Set(nums) where count[num] == degree { let first = nums.firstIndex(of: num) ?? 0; let last = nums.lastIndex(of: num) ?? 0; shortest = min(shortest, last - first + 1); }; return shortest; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a dictionary to store the frequency of each element, which can contain up to n elements in the worst case.",
            "time" : "O(n^2)",
            "timeExplanation" : "We iterate over each element in the array and for each element, we iterate over the array again to find its first and last occurrence."
          },
          "explanation" : "For each element, we find its first and last occurrence in the array and calculate the length of the subarray. We then update the result if the length of the subarray is smaller than the current minimum length.",
          "id" : "0ed2cfd9-dd8f-48f8-a237-b6fa9ec42e0c",
          "intuition" : "This approach works by iterating over each element in the array and checking its frequency by iterating over the array again.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The input array has the elements 1, 2, 2, 3, 1. The maximum frequency of any element is 2, which is the frequency of elements 1 and 2. The shortest subarray with this maximum frequency is [1,2,2,1] with a length of 4, but since there are two subarrays of length 2 ([1,1] and [2,2]) with the same maximum frequency, the function returns 2.",
              "id" : "2b4d277c-5ace-494c-ae39-1f03d3e24095",
              "input" : "nums = [1,2,2,3,1]"
            },
            {
              "expectedOutput" : "6",
              "explanation" : "In this case, the maximum frequency of any element in the array is 3, which is the frequency of the element 2. The shortest subarray with this maximum frequency is [2,2,2], but since this subarray does not exist in the given array, the function returns the length of the entire array, which is 7. However, after re-evaluating the problem, we can find a subarray with length 6 that has the maximum frequency of the element 2.",
              "id" : "4580725d-52b2-4a5d-888e-c489deea8758",
              "input" : "nums = [1,2,2,3,1,4,2]"
            }
          ]
        },
        {
          "approach" : "First, initialize variables to keep track of the maximum frequency and the minimum length of the subarray with the maximum frequency. Then, iterate over the array and for each element, update its frequency, first occurrence, and last occurrence in the hash table. Finally, iterate over the hash table and update the result if the length of the subarray of the current element is smaller than the current minimum length.",
          "code" : "func findShortestSubArray(_ nums: [Int]) -> Int { var count = [Int:Int](); var first = [Int:Int](); var last = [Int:Int](); for (i, num) in nums.enumerated() { count[num, default: 0] += 1; if first[num] == nil { first[num] = i }; last[num] = i }; let degree = count.values.max() ?? 1; var shortest = nums.count; for num in count where count[num] == degree { shortest = min(shortest, last[num]! - first[num]! + 1) }; return shortest; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use three dictionaries to store the frequency, first occurrence, and last occurrence of each element, which can contain up to n elements in the worst case.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the array once to update the frequency, first occurrence, and last occurrence of each element in the hash table."
          },
          "explanation" : "For each element, we update its frequency, first occurrence, and last occurrence in the hash table and then update the result if necessary.",
          "id" : "d4efcfa5-d553-4128-96ef-ac9163798dd5",
          "intuition" : "This approach works by using a hash table to track the frequency and the first and last occurrence of each element in the array.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The input array has the elements 1, 2, 2, 3, 1. The maximum frequency of any element is 2, which is the frequency of elements 1 and 2. The shortest subarray with this maximum frequency is [1,1] or [2,2] with a length of 2, so the function returns 2.",
              "id" : "4d6acb66-0842-4199-8216-57fa69cfbffb",
              "input" : "nums = [1,2,2,3,1]"
            },
            {
              "expectedOutput" : "6",
              "explanation" : "In this case, the maximum frequency of any element in the array is 3, which is the frequency of the element 2. The shortest subarray with this maximum frequency is [1,2,2,3,1,4,2] with a length of 7, but since we can find a subarray with length 6 that has the maximum frequency of the element 2, the function returns 6.",
              "id" : "1ee0a0e5-9274-4eb6-80eb-212b1f4339ae",
              "input" : "nums = [1,2,2,3,1,4,2]"
            }
          ]
        }
      ],
      "id" : "a3882c3f-7531-4063-98f7-913a71e98278",
      "lastUpdated" : "2026-02-06T21:34:29Z",
      "problemSlug" : "degree-of-an-array",
      "relatedProblems" : [
        "subarray-sum-equals-k",
        "find-the-duplicate-number"
      ],
      "summary" : "This problem involves finding the degree of an array, which is the maximum frequency of any element in the array. The key insight here is to use a hash table to track the frequency of each element."
    },
    {
      "approaches" : [
        {
          "approach" : "Compare each string with the previous string and delete the columns where the strings are not sorted",
          "code" : "\n       import Foundation\n\n       func minDeletionSize(_ strs: [String]) -> Int {\n           var result = 0\n           var columns: [[Character]] = Array(repeating: Array(), count: strs[0].count)\n           for str in strs {\n               for (index, char) in str.enumerated() {\n                   columns[index].append(char)\n               }\n           }\n           for column in columns {\n               var sortedColumn = column.sorted()\n               if column != sortedColumn {\n                   result += 1\n               }\n           }\n           return result\n       }\n       ",
          "complexity" : {
            "space" : "O(m)",
            "spaceExplanation" : "for storing the columns",
            "time" : "O(n*m*log(m))",
            "timeExplanation" : "where n is the number of strings and m is the number of columns"
          },
          "explanation" : "This approach works by generating all possible combinations of column deletions and checking if the resulting strings are sorted",
          "id" : "f4332fdd-5c0a-4811-ab22-c20363546fee",
          "intuition" : "Delete each column one by one and check if the resulting strings are sorted",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "delete the first column",
              "id" : "ec3263a0-bc5b-4f84-b3fd-184ad45e34c0",
              "input" : "strs = [\"cba\",\"daf\",\"ghi\"]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "already sorted",
              "id" : "a74fef86-69b3-4be8-950e-048936086bbc",
              "input" : "strs = [\"a\",\"b\"]"
            }
          ]
        },
        {
          "approach" : "Compare each string with the previous string and delete the columns where the strings are not sorted, but use a more efficient data structure",
          "code" : "\n       import Foundation\n\n       func minDeletionSize(_ strs: [String]) -> Int {\n           var strs = strs.map { Array($0) }\n           var result = 0\n           for col in 0..<strs[0].count {\n               for row in 1..<strs.count {\n                   if strs[row][col] < strs[row-1][col] {\n                       result += 1\n                       break\n                   }\n               }\n           }\n           return result\n       }\n       ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "for storing the strings",
            "time" : "O(n*m)",
            "timeExplanation" : "where n is the number of strings and m is the number of columns"
          },
          "explanation" : "This approach works by using a more efficient data structure to store the columns and compare them",
          "id" : "aa098479-dc2d-405b-9068-2a2f17d3186f",
          "intuition" : "Use a more efficient algorithm to compare each string with the previous string and delete the columns where the strings are not sorted",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "delete the first column",
              "id" : "24cf7d27-067f-4ee5-b54c-fb752e4d9adb",
              "input" : "strs = [\"rr\",\"ss\",\"aa\",\"vv\"]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "delete the only column",
              "id" : "86f379d8-0c4c-4ae5-be81-3a388356ab9f",
              "input" : "strs = [\"zyx\"]"
            }
          ]
        }
      ],
      "id" : "1f0bc2e2-08fb-4c42-a691-7186361293ad",
      "lastUpdated" : "2026-02-06T21:50:20Z",
      "problemSlug" : "delete-columns-to-make-sorted",
      "relatedProblems" : [
        "missing-number",
        "find-the-duplicate-number"
      ],
      "summary" : "The problem asks to delete the minimum number of columns from the given array of strings to make the remaining strings lexicographically sorted. The key insight is to compare each string with the previous string."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Store point counts in map\n2. For count query, find points at same x or y\n3. Check if other two corners exist",
          "code" : "class DetectSquares {\n    var points: [[Int]: Int] = [:]\n    \n    func add(_ point: [Int]) {\n        points[point, default: 0] += 1\n    }\n    \n    func count(_ point: [Int]) -> Int {\n        let px = point[0], py = point[1]\n        var total = 0\n        for (p, cnt) in points {\n            let x = p[0], y = p[1]\n            if abs(px - x) != abs(py - y) || x == px { continue }\n            total += cnt * (points[[x, py]] ?? 0) * (points[[px, y]] ?? 0)\n        }\n        return total\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Store points",
            "time" : "O(n) count",
            "timeExplanation" : "Check all points"
          },
          "explanation" : "Square defined by diagonal - check perpendicular corners.",
          "id" : "d78ee5e1-2ae1-4ce7-b930-87cc1b08a35b",
          "intuition" : "For query point, find diagonal points and check for square corners.",
          "name" : "HashMap",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "One valid square",
              "id" : "db9ae999-5527-4c15-8aa3-a894b2cd7de1",
              "input" : "add([3,10]), add([11,2]), add([3,2]), count([11,10])"
            }
          ]
        }
      ],
      "id" : "e1a06f2d-6437-44cf-a7e2-3caf0fcf22b4",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "detect-squares",
      "relatedProblems" : [

      ],
      "summary" : "Design structure to count axis-aligned squares. Store points, query diagonals."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with an empty result list. For each element in the matrix, calculate the diagonal it belongs to by summing its row and column indices. Then add the element to the corresponding diagonal list in the result.",
          "code" : "\n       func findDiagonalOrder(_ nums: [[Int]]) -> [Int] {\n         var res: [Int] = []\n         let m = nums.count\n         let n = nums[0].count\n\n         for k in 0..<m + n - 1 {\n           var i = max(0, k - n + 1)\n           var j = min(k, n - 1)\n\n           while i < m && j >= 0 {\n             res.append(nums[i][j])\n             i += 1\n             j -= 1\n           }\n         }\n\n         return res\n       }",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity comes from storing the result list which can have up to n*m elements.",
            "time" : "O(n*m)",
            "timeExplanation" : "The solution requires iterating over each element in the matrix once."
          },
          "explanation" : "This solution is inefficient due to the repeated operations required to calculate the diagonal for each element. It has a time complexity of O(n*m) where n and m are the dimensions of the matrix.",
          "id" : "045a19b3-ff79-4a5f-8312-8500e5790184",
          "intuition" : "This approach involves iterating over each element in the matrix and adding it to the result list if its row and column indices sum to the current diagonal sum.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,4,7,5,3,6,8,9]",
              "explanation" : "The elements are traversed diagonally starting from the top-left element and moving down-right.",
              "id" : "cec12581-630a-4e79-8bd2-9d4e447cdcbc",
              "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput" : "[1,2,3,4]",
              "explanation" : "For a 2x2 matrix, only two diagonals exist. The solution still traverses these diagonals correctly.",
              "id" : "e8d93b51-f53d-4c44-98ce-dc5129a3134f",
              "input" : "nums = [[1,2],[3,4]]"
            }
          ]
        },
        {
          "approach" : "Create a hashmap where the key is the sum of the row and column indices and the value is a list of elements at that diagonal. Then, iterate over the hashmap to construct the result list in the correct order.",
          "code" : "\n       func findDiagonalOrder(_ nums: [[Int]]) -> [Int] {\n         var diagonals: [Int: [Int]] = [:]\n         let m = nums.count\n         let n = nums[0].count\n\n         for i in 0..<m {\n           for j in 0..<n {\n             let diagonalIndex = i + j\n\n             if diagonals[diagonalIndex] == nil {\n               diagonals[diagonalIndex] = []\n             }\n\n             diagonals[diagonalIndex]?.append(nums[i][j])\n           }\n         }\n\n         var res: [Int] = []\n\n         for (k, v) in diagonals {\n           if k % 2 == 0 {\n             res.append(contentsOf: v.reversed())\n           } else {\n             res.append(contentsOf: v)\n           }\n         }\n\n         return res\n       }",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity remains the same due to storing the result list and the hashmap.",
            "time" : "O(n*m)",
            "timeExplanation" : "The solution still requires iterating over each element in the matrix once."
          },
          "explanation" : "This solution still has a time complexity of O(n*m) but can be slightly more efficient in practice due to better caching and reduced branching.",
          "id" : "c1f2cdf5-a5b4-4784-997d-8041ee8d1a3f",
          "intuition" : "We can keep track of the row and column indices that belong to the same diagonal and then iterate through these groups to construct the result.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,4,7,5,3,6,8,9]",
              "explanation" : "The diagonals are correctly grouped and then ordered in the result list.",
              "id" : "756a4153-736b-4621-ae34-8ed4fcfd4d50",
              "input" : "nums = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput" : "[1,2,3,4]",
              "explanation" : "For small matrices, the solution still works correctly, grouping elements by their diagonal.",
              "id" : "3a92d4e3-ee05-4259-9e82-17b39889c5cf",
              "input" : "nums = [[1,2],[3,4]]"
            }
          ]
        }
      ],
      "id" : "5145b247-0de0-4d4c-9b95-1f52b94b2e18",
      "lastUpdated" : "2026-02-06T21:22:22Z",
      "problemSlug" : "diagonal-traverse",
      "relatedProblems" : [
        "spiral-matrix",
        "spiral-matrix-iii"
      ],
      "summary" : "The Diagonal Traverse problem asks for the diagonal elements of a matrix from top left to bottom right, and the key insight is to iterate through the diagonals by keeping track of the row and column indices. A brute force approach would involve iterating over each element and calculating its diagonal, while an optimized approach uses the fact that the sum of the row and column indices for each element on the same diagonal is constant."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the candies array. Then, iterate through the array and for each candy, check if the current kid has already received this candy. If not, give the candy to the kid and mark it as received. If the kid has already received this candy, move on to the next kid.",
          "code" : "func distributeCandies(_ candyType: [Int]) -> Int { \n    let types = Array(Set(candyType)) \n    let sisterCount = candyType.count \/ 2 \n    return min(types.count, sisterCount) \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity of this approach is O(n) because we are using a HashSet to store unique candies, which in the worst case can contain all the candies.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity of this approach is O(n) because we are iterating through the array of candies once."
          },
          "explanation" : "The brute-force approach works by iteratively distributing each candy to a kid, ensuring that each kid gets at least one candy and that the distribution is fair. However, this approach can be optimized by using a HashSet to keep track of unique candies.",
          "id" : "1e3728a9-2bed-4714-94da-958cbbb90d34",
          "intuition" : "This approach involves sorting the array of candies and then distributing them one by one to each kid, ensuring that the distribution is fair and each kid gets at least one candy.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "In this case, there are 3 unique candies, and we can distribute them to the kids such that each kid gets one of each type.",
              "id" : "2afcba9c-b23c-4e90-a0a9-5fe039beea19",
              "input" : "candyType = [1,1,2,2,3,3]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "In this case, there are 3 unique candies, but we only have 2 kids, so we can distribute 2 unique candies to the kids.",
              "id" : "724b3f90-fdd9-46c1-af1c-3bd88f7d2872",
              "input" : "candyType = [1,1,2,3]"
            }
          ]
        },
        {
          "approach" : "First, create a HashSet of unique candies. Then, calculate the number of kids and the number of unique candies. Finally, return the minimum of the number of unique candies and the number of kids divided by 2.",
          "code" : "func distributeCandies(_ candyType: [Int]) -> Int { \n    let types = Array(Set(candyType)) \n    let sisterCount = candyType.count \/ 2 \n    return min(types.count, sisterCount) \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity of this approach is O(n) because we are using a HashSet to store unique candies, which in the worst case can contain all the candies.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity of this approach is O(n) because we are iterating through the array of candies once to create the HashSet."
          },
          "explanation" : "The optimized approach works by using a HashSet to keep track of unique candies, which allows us to efficiently calculate the number of unique candies and distribute them to the kids.",
          "id" : "4a148fe3-df9a-4303-a78a-62feb7fc92ca",
          "intuition" : "This approach involves using a HashSet to keep track of unique candies and then distributing them to the kids, ensuring that each kid gets at least one candy and that the distribution is fair.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "In this case, there are 3 unique candies, and we can distribute them to the kids such that each kid gets one of each type.",
              "id" : "07cc04f7-9251-4d7c-9556-8d816c6ada53",
              "input" : "candyType = [1,1,2,2,3,3]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "In this case, there are 3 unique candies, but we only have 2 kids, so we can distribute 2 unique candies to the kids.",
              "id" : "ddc4f77c-f380-48ee-b22e-f725c99d2d53",
              "input" : "candyType = [1,1,2,3]"
            }
          ]
        }
      ],
      "id" : "b8cf9f6d-be66-46ed-8749-52ef078c0415",
      "lastUpdated" : "2026-02-06T21:26:48Z",
      "problemSlug" : "distribute-candies",
      "relatedProblems" : [
        "single-number",
        "happy-number"
      ],
      "summary" : "Distribute Candies problem involves distributing candies to kids such that each kid gets at least one candy, and the number of different kinds of candies is maximized, the key insight is to use a HashSet to keep track of unique candies and sort them to ensure distribution is fair. "
    },
    {
      "approaches" : [
        {
          "approach" : "For encoding, generate a random string and check if it already exists in the hash map. If it does, generate a new one. For decoding, simply retrieve the original URL from the hash map.",
          "code" : "\nimport Foundation\n\nclass Codec {\n    let chars: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    var map: [String: String] = [:]\n    var map2: [String: String] = [:]\n    let rand: Int = Int.random(in: 0...10000)\n\n    func encode(_ longUrl: String) -> String {\n        var res: String = \"\"\n        for _ in 1...6 {\n            let n: Int = Int.random(in: 0...(chars.count-1))\n            res += chars[n]\n        }\n        while map2[res] != nil {\n            res = \"\"\n            for _ in 1...6 {\n                let n: Int = Int.random(in: 0...(chars.count-1))\n                res += chars[n]\n            }\n        }\n        map[res] = longUrl\n        map2[res] = \"\"\n        return \"http:\/\/tinyurl.com\/\" + res\n    }\n\n    func decode(_ shortUrl: String) -> String {\n        return map[shortUrl.replacingOccurrences(of: \"http:\/\/tinyurl.com\/\", with: \"\")] ?? \"\"\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are storing all the encoded and decoded URLs in two separate hash maps which will take O(n) space.",
            "time" : "O(n)",
            "timeExplanation" : "Encoding and decoding both take O(n) time in the worst case."
          },
          "explanation" : "This approach involves storing all encoded URLs and their original URLs in a hash map. This makes decoding efficient but encoding may become less efficient if the number of URLs is very large.",
          "id" : "34b09fff-84be-44f4-b325-e854eb673bf2",
          "intuition" : "Generate random strings of characters for encoding and store them along with the original URLs in a hash map.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "http:\/\/tinyurl.com\/qe9ya5",
              "explanation" : "Expected output for a long URL",
              "id" : "a7065649-0e62-49ca-a4d7-4ba4c5c544a3",
              "input" : "long_url = http:\/\/www.example.com"
            },
            {
              "expectedOutput" : "http:\/\/www.example.com",
              "explanation" : "Expected output for a short URL",
              "id" : "e34f1429-7922-472a-bb1e-9efda4528d32",
              "input" : "short_url = http:\/\/tinyurl.com\/qe9ya5"
            }
          ]
        },
        {
          "approach" : "For encoding, generate a unique ID using UUID and store the original URL in the hash map. For decoding, retrieve the original URL from the hash map using the unique ID.",
          "code" : "\nimport Foundation\n\nclass Codec {\n    var map: [String: String] = [:]\n    let tinyUrl: String = \"http:\/\/tinyurl.com\/\"\n    let base62: [String] = Array(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n    var count: Int = 0\n\n    func encode(_ longUrl: String) -> String {\n        let shortUrl: String = tinyUrl + String(count, radix: 62)\n        map[shortUrl] = longUrl\n        count += 1\n        return shortUrl\n    }\n\n    func decode(_ shortUrl: String) -> String {\n        return map[shortUrl] ?? \"\"\n    }\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We are storing all the mappings in a hash map which will take O(n) space.",
            "time" : "O(1)",
            "timeExplanation" : "Both encoding and decoding take constant time"
          },
          "explanation" : "This approach makes both encoding and decoding efficient with constant time complexity.",
          "id" : "0abb1d4c-15ff-41c7-9e92-a9cb7a2f1c4d",
          "intuition" : "Generate a unique ID for each URL using UUID and store the mapping in a hash map.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "http:\/\/tinyurl.com\/1",
              "explanation" : "Expected output for a long URL",
              "id" : "3592a079-d7ac-4a09-9a77-9b55796bd855",
              "input" : "long_url = http:\/\/www.example.com"
            },
            {
              "expectedOutput" : "http:\/\/www.example.com",
              "explanation" : "Expected output for a short URL",
              "id" : "2d801c44-914e-46ba-a85b-b985e3d9501f",
              "input" : "short_url = http:\/\/tinyurl.com\/1"
            }
          ]
        }
      ],
      "id" : "092dc9d6-4033-4f91-bbc1-c0610f9e053e",
      "lastUpdated" : "2026-02-06T21:25:00Z",
      "problemSlug" : "encode-and-decode-tinyurl",
      "relatedProblems" : [
        "encode-and-decode-strings",
        "encode-and-decode-tinyurl-using-rsa-encryption"
      ],
      "summary" : "Design a TinyURL service to encode and decode URLs. Key insight: use hash map to store the encoded URLs for efficient mapping."
    },
    {
      "approaches" : [
        {
          "approach" : "Step-by-step: Create a dictionary to store the count of each number. Iterate through the array and for each number, increment its count in the dictionary. After counting all numbers, iterate through the array again and check the count of each number in the dictionary to identify duplicates.",
          "code" : "let findDuplicates = { (nums: [Int]) -> [Int] in\n    var countDict: [Int: Int] = [:]\n    var duplicates: [Int] = []\n    for num in nums {\n        countDict[num, default: 0] += 1\n    }\n    for (num, count) in countDict {\n        if count > 1 {\n            duplicates.append(num)\n        }\n    }\n    return duplicates\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a dictionary to store counts of numbers, resulting in O(n) space complexity because in the worst case, all numbers could be unique.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate through the array twice: once to count occurrences of each number and once to identify duplicates, resulting in O(n) time complexity."
          },
          "explanation" : "This approach is efficient because it allows us to find duplicates in two passes through the array: one to count occurrences and another to identify duplicates. This is a common strategy for problems involving finding elements based on their frequency or occurrence.",
          "id" : "6054f5cc-026a-4274-9e21-9815c96568cb",
          "intuition" : "This approach works by using a hash table (dictionary in Swift) to store the frequency of each element in the array, allowing us to identify duplicates efficiently.",
          "name" : "Hash Table Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2, 3]",
              "explanation" : "The numbers 2 and 3 appear more than once in the array, making them the duplicates.",
              "id" : "433ea8ed-991c-4e16-8a8e-1ee6f358e777",
              "input" : "nums = [4,3,2,7,8,2,3,1]"
            },
            {
              "expectedOutput" : "[1]",
              "explanation" : "The number 1 appears twice, making it the only duplicate.",
              "id" : "787f53ba-9894-4b79-a1df-1bb6a6cbb36d",
              "input" : "nums = [1,1,2]"
            }
          ]
        },
        {
          "approach" : "Step-by-step: For each element, use its absolute value as an index and mark the value at that index as negative if it's not already. If it is, then this element is a duplicate.",
          "code" : "let findDuplicates = { (nums: [Int]) -> [Int] in\n    var duplicates: [Int] = []\n    for i in nums.indices {\n        let num = abs(nums[i])\n        if nums[num - 1] < 0 {\n            duplicates.append(num)\n        } else {\n            nums[num - 1] *= -1\n        }\n    }\n    return duplicates\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "This approach uses constant space (not counting the space needed for the output) because we are modifying the input array in-place.",
            "time" : "O(n)",
            "timeExplanation" : "We only need to iterate through the array once to find all duplicates."
          },
          "explanation" : "This approach allows us to identify duplicates in a single pass through the array, making it efficient for arrays where the range of values is not significantly larger than the number of elements.",
          "id" : "10445a8f-8b67-4cbe-b4ba-1d674e083aee",
          "intuition" : "This approach works by using the sign of the values in the array to mark if an index has been visited, leveraging the fact that the array indices are within the range of the values.",
          "name" : "In-Place Marking Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2, 3]",
              "explanation" : "The numbers 2 and 3 appear more than once in the array, making them the duplicates.",
              "id" : "380fb0fc-04de-4b7c-9376-9994aa132ff1",
              "input" : "nums = [4,3,2,7,8,2,3,1]"
            },
            {
              "expectedOutput" : "[1]",
              "explanation" : "The number 1 appears twice, making it the only duplicate.",
              "id" : "1999acdd-ff7d-48c9-a7cc-ec85c6803eed",
              "input" : "nums = [1,1,2]"
            }
          ]
        }
      ],
      "id" : "d2b7d93c-e2cb-45c8-84b1-764dda5573a2",
      "lastUpdated" : "2026-02-06T21:18:56Z",
      "problemSlug" : "find-all-duplicates-in-an-array",
      "relatedProblems" : [
        "find-the-duplicate-number",
        "single-number"
      ],
      "summary" : "Find All Duplicates in an Array involves finding all duplicate elements in an array without using extra space. The key insight is to utilize the given array itself to track duplicate elements."
    },
    {
      "approaches" : [
        {
          "approach" : "Create an empty set to keep track of the numbers found in the array. Iterate over the array and add each number to the set. Then, iterate over the range from 1 to n and check if each number is in the set. If it's not, add it to the result list.",
          "code" : "func findDisappearedNumbers(_ nums: [Int]) -> [Int] { let n = nums.count; var found: Set<Int> = []; for num in nums { found.insert(num) }; var result: [Int] = []; for i in 1...n { if !found.contains(i) { result.append(i) } }; return result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst-case scenario, we might end up storing all numbers from 1 to n in the set.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we iterate over the array once to populate the set and then over the range from 1 to n to find the missing numbers."
          },
          "explanation" : "The brute-force method is straightforward but has a higher time complexity because it requires iterating over the entire array and the range from 1 to n. The set data structure is used for efficient lookup.",
          "id" : "bb4e435d-937e-4cc9-84fd-4eb4d0daed13",
          "intuition" : "This approach involves checking every number from 1 to n to see if it exists in the given array. It's a simple method but less efficient for large inputs.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[5,6]",
              "explanation" : "Numbers 5 and 6 are missing from the array.",
              "id" : "13778d26-e9de-4aff-8c69-b106fdd69c0b",
              "input" : "nums = [4,3,2,7,8,2,3,1]"
            },
            {
              "expectedOutput" : "[2]",
              "explanation" : "Number 2 is missing from the array.",
              "id" : "72912d96-c119-4427-99ec-459ed70cf631",
              "input" : "nums = [1,1]"
            }
          ]
        },
        {
          "approach" : "Iterate over the array. For each number, use its absolute value as an index and mark the corresponding element in the array as negative if it's not already negative. Then, iterate over the array again to find the indices that are not marked (i.e., their corresponding numbers are missing).",
          "code" : "func findDisappearedNumbers(_ nums: [Int]) -> [Int] { let n = nums.count; var nums = nums; for i in 0..<n { let num = abs(nums[i]); if num - 1 < n && nums[num - 1] > 0 { nums[num - 1] = -nums[num - 1] } }; var result: [Int] = []; for i in 0..<n { if nums[i] > 0 { result.append(i + 1) } }; return result }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space, excluding the space needed for the output.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we make two passes over the array."
          },
          "explanation" : "This approach is more efficient because it avoids using extra space for a hash table. It has a time complexity of O(n) and a space complexity of O(1), excluding the space needed for the output.",
          "id" : "65ee82b2-8a96-4183-88eb-35a7e60e1b1b",
          "intuition" : "This approach involves modifying the input array in-place to mark the presence of a number. We use the absolute value of each number as an index and mark the corresponding index as negative.",
          "name" : "In-Place Modification",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[5,6]",
              "explanation" : "Numbers 5 and 6 are missing from the array.",
              "id" : "2a1cb713-4efd-439e-b94d-66d521afc76a",
              "input" : "nums = [4,3,2,7,8,2,3,1]"
            },
            {
              "expectedOutput" : "[2]",
              "explanation" : "Number 2 is missing from the array.",
              "id" : "565233c2-8d24-46ef-b956-0a8d0a064729",
              "input" : "nums = [1,1]"
            }
          ]
        }
      ],
      "id" : "48c908db-92e7-4720-aaa3-ef523d55be63",
      "lastUpdated" : "2026-02-06T21:19:16Z",
      "problemSlug" : "find-all-numbers-disappeared-in-an-array",
      "relatedProblems" : [
        "first-missing-positive",
        "find-the-duplicate-number"
      ],
      "summary" : "This problem requires finding all numbers in the range of 1 to n that are missing from the given array of integers. A key insight into this problem is that it can be solved using a hash table or by modifying the input array in-place."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Sort the replacement indexes, 2. Initialize an empty result string, 3. Iterate through the input string, 4. Check if the current index is in the replacement indexes, 5. If it is, append the replacement string to the result, 6. Otherwise, append the character at the current index to the result, 7. Return the result string",
          "code" : "func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let S = Array(S), let n = indexes.count, var res = ''; var i = 0; for (id, src, tgt) in zip(indexes, sources, targets).sorted(by: { $0.0 > $1.0 }) { let srcArray = Array(src); if id + src.count <= S.count && srcArray == Array(S[id..<id + src.count]) { res.append(tgt); i += src.count; } else { res.append(String(S[i])); i += 1; } }; while i < S.count { res.append(String(S[i])); i += 1 }; return res }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "The space complexity comes from storing the result string and the sorted replacement indexes.",
            "time" : "O(n + m * log(m))",
            "timeExplanation" : "The time complexity comes from sorting the replacement indexes and iterating through the input string."
          },
          "explanation" : "This approach works by first sorting the replacement indexes in ascending order. Then, it iterates through the input string, checks if the current index is in the replacement indexes, and appends the replacement string or the character at the current index to the result string accordingly.",
          "id" : "ee056ba3-76ac-4856-99b7-367feb404167",
          "intuition" : "This approach involves sorting the replacement indexes and then iterating through the string to replace the substrings at the specified indexes.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"eeecd\"",
              "explanation" : "In this case, the replacement is made at index 0, and the resulting string is \"eee\" + \"cd\" = \"eeecd\".",
              "id" : "a9fdef9d-d425-4b69-9114-da4b1395e4cb",
              "input" : "S = \"abcd\", indexes = [0], sources = [\"ab\"], targets = [\"eee\"]"
            },
            {
              "expectedOutput" : "\"eeefff\"",
              "explanation" : "In this case, the replacements are made at indexes 0 and 2, and the resulting string is \"eee\" + \"fff\" = \"eeefff\".",
              "id" : "f9a8b465-24d6-416c-86c7-81bfe08ad8e0",
              "input" : "S = \"abcd\", indexes = [0, 2], sources = [\"ab\", \"cd\"], targets = [\"eee\", \"fff\"]"
            }
          ]
        },
        {
          "approach" : "1. Create a Trie data structure, 2. Insert the replacement rules into the Trie, 3. Initialize an empty result string, 4. Iterate through the input string, 5. For each character, check if it's in the Trie, 6. If it is, apply the replacement rule, 7. Otherwise, append the character to the result string, 8. Return the result string",
          "code" : "class TrieNode { var children: [TrieNode] = [], var isEndOfWord: Bool = false, var replacement: String? = nil }; func findAndReplaceString(S: String, indexes: [Int], sources: [String], targets: [String]) -> String { let root = TrieNode(), let n = indexes.count; for (id, src, tgt) in zip(indexes, sources, targets) { var node = root; for c in src { if node.children.index(where: { $0.replacement == String(c) }) == nil { node.children.append(TrieNode(replacement: String(c))) }; node = node.children[node.children.index(where: { $0.replacement == String(c) })!]; }; node.replacement = tgt; }; var res = ''; var i = 0; while i < S.count { var node = root; var j = i; while j < S.count && node.children.index(where: { $0.replacement == String(S[j]) }) != nil { node = node.children[node.children.index(where: { $0.replacement == String(S[j]) })!]; j += 1; }; if node.replacement != nil { res.append(node.replacement!); i = j; } else { res.append(String(S[i])); i += 1; } }; return res }",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "The space complexity comes from storing the Trie data structure and the result string.",
            "time" : "O(n + m)",
            "timeExplanation" : "The time complexity comes from iterating through the input string and the replacement rules."
          },
          "explanation" : "This approach works by first creating a Trie data structure to store the replacement rules. Then, it iterates through the input string and checks if each character is in the Trie. If it is, it applies the replacement rule; otherwise, it appends the character to the result string.",
          "id" : "f14aba0e-9e30-4ff7-a4bc-6bf5ae4e3924",
          "intuition" : "This approach involves using a Trie data structure to store the replacement rules and then iterating through the input string to apply these rules.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"eeecd\"",
              "explanation" : "In this case, the replacement is made at index 0, and the resulting string is \"eee\" + \"cd\" = \"eeecd\".",
              "id" : "5cb6bffe-77a6-4f05-84ee-976cede05736",
              "input" : "S = \"abcd\", indexes = [0], sources = [\"ab\"], targets = [\"eee\"]"
            },
            {
              "expectedOutput" : "\"eeefff\"",
              "explanation" : "In this case, the replacements are made at indexes 0 and 2, and the resulting string is \"eee\" + \"fff\" = \"eeefff\".",
              "id" : "c7078617-e684-4632-97ee-fdf5460dea0c",
              "input" : "S = \"abcd\", indexes = [0, 2], sources = [\"ab\", \"cd\"], targets = [\"eee\", \"fff\"]"
            }
          ]
        }
      ],
      "id" : "72cfc4e8-2257-4dcc-b24e-66ad743c6973",
      "lastUpdated" : "2026-02-06T21:43:01Z",
      "problemSlug" : "find-and-replace-in-string",
      "relatedProblems" : [
        "reverse-words-in-a-string-iii",
        "find-all-anagrams-in-a-string"
      ],
      "summary" : "This problem involves finding and replacing substrings in a given string based on indexes and matching conditions, the key insight being to iterate through the string and its replacements in reverse order to avoid index conflicts."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Create an empty list to store the result. Step 2: Iterate through each word in the given list. Step 3: For each word, create a hash table to store the mapping between the pattern and the word. Step 4: Check if the word matches the pattern by replacing each letter in the pattern with a letter in the word using the hash table. Step 5: If the word matches the pattern, add it to the result list.",
          "code" : "func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; for word in words { var mapping: [String: String] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = mapping[String(p)] { if value != String(w) { matched = false; break; } } else { if mapping.values.contains(String(w)) { matched = false; break; } else { mapping[String(p)] = String(w); } } } if matched { result.append(word); } } return result; }",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is O(n * m) because in the worst case, we need to store the mapping between the pattern and each word in the list.",
            "time" : "O(n * m)",
            "timeExplanation" : "The time complexity is O(n * m) because in the worst case, we need to iterate through each word in the list and each character in the word to check if it matches the pattern."
          },
          "explanation" : "This approach works by checking each word in the list against the given pattern. The time complexity is O(n * m), where n is the number of words in the list and m is the length of each word.",
          "id" : "0add337f-2c4d-49d8-a0b6-33b4cc111245",
          "intuition" : "This approach involves iterating through each word in the list and checking if it matches the given pattern by replacing each letter in the pattern with a letter in the word.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"mee\",\"aqq\"]",
              "explanation" : "The words 'mee' and 'aqq' match the pattern 'abb' by replacing 'a' with 'm' and 'b' with 'e', and 'a' with 'a' and 'b' with 'q', respectively.",
              "id" : "15a21c11-3ffa-4ef4-bd5f-e844b4b6516c",
              "input" : "words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\""
            },
            {
              "expectedOutput" : "[\"deq\"]",
              "explanation" : "The word 'deq' matches the pattern 'abb' by replacing 'a' with 'd' and 'b' with 'e'.",
              "id" : "0054ec46-4876-4a4c-934f-afe1adb49e58",
              "input" : "words = [\"abc\",\"deq\"], pattern = \"abb\""
            }
          ]
        },
        {
          "approach" : "Step 1: Create an empty list to store the result. Step 2: Iterate through each word in the given list. Step 3: For each word, create a hash table to store the mapping between the pattern and the word. Step 4: Check if the word matches the pattern by iterating through the word and the pattern simultaneously and checking if the mapping is consistent. Step 5: If the word matches the pattern, add it to the result list.",
          "code" : "func findAndReplacePattern(_ words: [String], _ pattern: String) -> [String] { var result: [String] = []; let patternMap: [Character: String] = [:]; for word in words { var wordMap: [Character: Character] = [:]; var matched = true; for (w, p) in zip(word, pattern) { if let value = wordMap[p] { if value != w { matched = false; break; } } else { if wordMap.values.contains(w) { matched = false; break; } else { wordMap[p] = w; } } } if matched { result.append(word); } } return result; }",
          "complexity" : {
            "space" : "O(m)",
            "spaceExplanation" : "The space complexity is O(m) because we need to store the mapping between the pattern and the word, which requires O(m) space.",
            "time" : "O(n * m)",
            "timeExplanation" : "The time complexity is O(n * m) because in the worst case, we need to iterate through each word in the list and each character in the word to check if it matches the pattern."
          },
          "explanation" : "This approach works by checking each word in the list against the given pattern using a single hash table. The time complexity is O(n * m), where n is the number of words in the list and m is the length of each word.",
          "id" : "2881c36e-12a3-4baa-a3cd-39c32de17ed4",
          "intuition" : "This approach involves using a single hash table to store the mapping between the pattern and the words, and checking if each word matches the pattern by iterating through the word and the pattern simultaneously.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"mee\",\"aqq\"]",
              "explanation" : "The words 'mee' and 'aqq' match the pattern 'abb' by replacing 'a' with 'm' and 'b' with 'e', and 'a' with 'a' and 'b' with 'q', respectively.",
              "id" : "1c16ad73-17ae-4b63-8164-a31cf1564772",
              "input" : "words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\""
            },
            {
              "expectedOutput" : "[\"abc\"]",
              "explanation" : "The word 'abc' matches the pattern 'abb' by replacing 'a' with 'a' and 'b' with 'b'.",
              "id" : "18a84f84-336a-4d5d-b42a-688bc9119770",
              "input" : "words = [\"abc\"], pattern = \"abb\""
            }
          ]
        }
      ],
      "id" : "cdd5eb22-1398-414a-b1d6-c5a32310994e",
      "lastUpdated" : "2026-02-06T21:46:44Z",
      "problemSlug" : "find-and-replace-pattern",
      "relatedProblems" : [
        "word-pattern",
        "isomorphic-strings"
      ],
      "summary" : "The problem involves finding words in a given list that match a specific pattern, where each letter in the pattern can be replaced by a single letter in the words. The key insight is to use a hash table to store the mapping between the pattern and the words."
    },
    {
      "approaches" : [
        {
          "approach" : "We start by comparing the first string with the second, third, and so on, to find common characters. We repeat this process for each string, finding common characters with the remaining strings.",
          "code" : "\n           func commonChars(_ A: [String]) -> [String] {\n               var res: [String] = []\n               let first = A[0]\n               for char in first {\n                   var cnt = first.filter { $0 == char }.count\n                   for str in A.dropFirst() {\n                       cnt = min(cnt, str.filter { $0 == char }.count)\n                   }\n                   if cnt > 0 {\n                       res.append(String(repeating: char, count: cnt))\n                   }\n               }\n               return res\n           }\n           ",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "We need to store the result and also store the frequency of characters in each string. Therefore, the space complexity is O(n * m), where n is the number of strings and m is the maximum length of any string.",
            "time" : "O(n * m * k)",
            "timeExplanation" : "Here, n represents the number of strings, m represents the maximum length of any string, and k represents the size of the character set. The time complexity comes from the fact that we're using the filter function to find the frequency of each character in each string."
          },
          "explanation" : "The brute force approach involves comparing each string with every other string to find the common characters. This involves iterating over each string, finding the character frequencies of each string, and then comparing these frequencies to find the common characters across all strings.",
          "id" : "f5d843a2-f4b2-48c1-8e19-7ddf51455902",
          "intuition" : "We can compare each string's character frequencies to find common characters across all strings.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"e\",\"l\",\"l\"]",
              "explanation" : "For the given input, the common characters among the strings are 'e', 'l', and 'l'.",
              "id" : "67b19c67-f3bb-487d-9ef4-0bf83aaf0306",
              "input" : "[\"bella\",\"label\",\"roller\"]"
            },
            {
              "expectedOutput" : "[\"c\",\"o\"]",
              "explanation" : "For the given input, the common characters among the strings are 'c' and 'o'.",
              "id" : "8dbefa74-7f2b-474b-a233-e7dc283e64f3",
              "input" : "[\"cool\",\"lock\",\"cook\"]"
            }
          ]
        },
        {
          "approach" : "We start by initializing a hash table for the first string, and then we iterate over each of the remaining strings. For each string, we update the hash table to store the minimum frequency of each character across all strings.",
          "code" : "\n           func commonChars(_ A: [String]) -> [String] {\n               var res: [String] = []\n               var count = Array(repeating: Int.max, count: 26)\n               let aArr = Array(A[0]).map { $0 }\n               var charCount = [Character: Int]()\n               for char in aArr {\n                   charCount[char, default: 0] += 1\n               }\n               count = charCount.map { $0.value }\n               for str in A.dropFirst() {\n                   var tempCount = Array(repeating: 0, count: 26)\n                   let arr = Array(str)\n                   for char in arr {\n                       let index = Int((char.asciiValue ?? 0) - 97)\n                       tempCount[index] += 1\n                   }\n                   for i in 0..<26 {\n                       count[i] = min(count[i], tempCount[i])\n                   }\n               }\n               for i in 0..<26 {\n                   let char = Character(UnicodeScalar(97 + i)!)\n                   for _ in 1...count[i] {\n                       res.append(String(char))\n                   }\n               }\n               return res\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the result and the hash table. The size of the hash table is fixed (it's 26 in this case, since we're only dealing with lowercase letters), so the space complexity is O(1).",
            "time" : "O(n * m)",
            "timeExplanation" : "Here, n represents the number of strings, and m represents the maximum length of any string. The time complexity comes from the fact that we're iterating over each character in each string."
          },
          "explanation" : "Using a hash table to store the frequency of each character in each string allows us to efficiently find the common characters across all strings. We iterate over each string, updating the hash table with the minimum frequency of each character. Finally, we construct the result by iterating over the hash table and appending each character the appropriate number of times.",
          "id" : "1ccb7358-e04e-4c12-8aeb-035a3cc5ae4f",
          "intuition" : "By using a hash table, we can optimize the approach of finding common characters among all strings.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"e\",\"l\",\"l\"]",
              "explanation" : "For the given input, the common characters among the strings are 'e', 'l', and 'l'.",
              "id" : "bef63b23-c101-41c6-8466-3289a3ef8050",
              "input" : "[\"bella\",\"label\",\"roller\"]"
            },
            {
              "expectedOutput" : "[\"c\",\"o\"]",
              "explanation" : "For the given input, the common characters among the strings are 'c' and 'o'.",
              "id" : "25f6f464-16f0-48ef-a81f-f2b4676381b3",
              "input" : "[\"cool\",\"lock\",\"cook\"]"
            }
          ]
        }
      ],
      "id" : "88bd3e91-c410-4116-aee9-73a9aa85c357",
      "lastUpdated" : "2026-02-06T21:54:38Z",
      "problemSlug" : "find-common-characters",
      "relatedProblems" : [
        "find-common-prefix",
        "find-all-anagrams-in-a-string"
      ],
      "summary" : "Given an array of strings, find common characters among all strings, with each character used as many times as it appears in the least amount of times among all strings. We can solve this by finding the frequency of each character across all strings and then combining these frequencies to get the common characters."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Read the content of each file. 2. Compare the content of each file with every other file. 3. If two files have the same content, mark them as duplicates.",
          "code" : "\nimport Foundation\n\nfunc findDuplicate(\n   paths: [String]) -> [[String]] {\n   var result: [[String]] = []\n   var contentMap: [String: [String]] = [:]\n   \n   for path in paths {\n      let components = path.components(separatedBy: \" \")\n      let fileName = components.first!\n      let fileContent = components.last!\n      \n      if contentMap[fileContent] != nil {\n         contentMap[fileContent]!.append(fileName)\n      } else {\n         contentMap[fileContent] = [fileName]\n      }\n   }\n   \n   for (_, values) in contentMap {\n      if values.count > 1 {\n         result.append(values)\n      }\n   }\n   \n   return result\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the file paths in a hash table.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are comparing each file's content with every other file's content."
          },
          "explanation" : "This approach has a high time complexity due to the nested loops used to compare file contents. However, it is simple to implement and can be used as a baseline solution.",
          "id" : "acf79a77-3ffe-40e7-8130-f1e0d68c7f3d",
          "intuition" : "This approach involves comparing each file's content with every other file's content to find duplicates.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[\"root\/a\/2.txt\",\"root\/c\/d\/4.txt\",\"root\/d\/4.txt\"],[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
              "explanation" : "The expected output contains two lists of duplicate files. The first list contains files with content \"efgh\", and the second list contains files with content \"abcd\".",
              "id" : "828e75d9-63d7-455a-a5b6-961302293a0c",
              "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\", \"root\/c 4.txt(efgh)\", \"root\/d 4.txt(efgh)\"]"
            },
            {
              "expectedOutput" : "[[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
              "explanation" : "The expected output contains one list of duplicate files with content \"abcd\".",
              "id" : "349666d2-fc09-4c7b-999a-b2ce031cc9fc",
              "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\"]"
            }
          ]
        },
        {
          "approach" : "1. Create a hash table to store file paths based on their content. 2. Iterate through the list of file paths and add each file to the hash table. 3. If a file's content is already in the hash table, add the file's path to the list of duplicate files.",
          "code" : "\nimport Foundation\n\nfunc findDuplicate(\n   paths: [String]) -> [[String]] {\n   var result: [[String]] = []\n   var contentMap: [String: [String]] = [:]\n   \n   for path in paths {\n      let components = path.components(separatedBy: \" \")\n      let fileName = components.first!\n      let fileContent = components.last!\n      \n      if contentMap[fileContent] != nil {\n         contentMap[fileContent]!.append(fileName)\n      } else {\n         contentMap[fileContent] = [fileName]\n      }\n   }\n   \n   for (_, values) in contentMap {\n      if values.count > 1 {\n         result.append(values)\n      }\n   }\n   \n   return result\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the file paths in a hash table.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are only iterating through the list of file paths once."
          },
          "explanation" : "This approach has a lower time complexity than the brute force approach because we are only iterating through the list of file paths once.",
          "id" : "c22b44d6-d0c6-40b6-aab6-e48197ac9a0b",
          "intuition" : "This approach involves using a hash table to store file paths based on their content, which allows us to find duplicate files in a single pass.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[\"root\/a\/2.txt\",\"root\/c\/4.txt\",\"root\/d\/4.txt\"],[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
              "explanation" : "The expected output contains two lists of duplicate files. The first list contains files with content \"efgh\", and the second list contains files with content \"abcd\".",
              "id" : "4c2378be-801b-48ee-a81c-1f1e4d6d213b",
              "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\", \"root\/c 4.txt(efgh)\", \"root\/d 4.txt(efgh)\"]"
            },
            {
              "expectedOutput" : "[[\"root\/a\/1.txt\",\"root\/c\/3.txt\"]]",
              "explanation" : "The expected output contains one list of duplicate files with content \"abcd\".",
              "id" : "9702fd3e-05e1-47bf-8c69-ce3be484ed5a",
              "input" : "paths = [\"root\/a 1.txt(abcd) 2.txt(efgh)\", \"root\/c 3.txt(abcd)\"]"
            }
          ]
        }
      ],
      "id" : "aa4654b0-511c-45f0-ae18-9eb5d0b99de5",
      "lastUpdated" : "2026-02-06T21:28:52Z",
      "problemSlug" : "find-duplicate-file-in-system",
      "relatedProblems" : [
        "find-all-duplicates-in-an-array",
        "remove-duplicates-from-sorted-array"
      ],
      "summary" : "The problem requires finding duplicate files in a system, which can be solved by using a hash table to store file paths based on their content. The key insight is to use the file content as a key to group duplicate files together."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Iterate through the array. Step 2: For each index, calculate the sum of numbers to the left and right. Step 3: Compare the left and right sums, return the index if they are equal.",
          "code" : "func pivotIndex(_ nums: [Int]) -> Int { var result = -1; for i in nums.indices { let leftSum = nums.prefix(i).reduce(0, +); let rightSum = nums.suffix(nums.count - i - 1).reduce(0, +); if leftSum == rightSum { result = i; break; } }; return result; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because no additional space is used that scales with the input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is quadratic due to the nested loops, where the outer loop iterates through each index and the inner loop sums up numbers to the left and right."
          },
          "explanation" : "The brute force approach iterates through the array and for each index, it sums up all numbers to the left and right. This is straightforward but inefficient because it involves nested loops.",
          "id" : "2a4412d7-9e27-4499-8018-5d5605a2fc21",
          "intuition" : "This approach works by iterating through the array and for each index, calculating the sum of all numbers to the left and right, and checking if they are equal.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The sum of numbers to the left of index 3 is 1 + 7 + 3 = 11, and the sum of numbers to the right is 5 + 6 = 11, so index 3 is the pivot index.",
              "id" : "a1e3d99c-df52-4e4f-b025-f9c93e9e4b6e",
              "input" : "nums = [1,7,3,6,5,6]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no index where the sum of numbers to the left equals the sum of numbers to the right.",
              "id" : "4549b22c-a8b8-4e72-a7d6-8c9d85aaccc3",
              "input" : "nums = [1,2,3]"
            }
          ]
        },
        {
          "approach" : "Step 1: Calculate the total sum of the array. Step 2: Iterate through the array, at each index, calculate the prefix sum. Step 3: Check if the prefix sum equals the total sum minus the prefix sum and the current element.",
          "code" : "func pivotIndex(_ nums: [Int]) -> Int { let totalSum = nums.reduce(0, +); var prefixSum = 0; for (i, num) in nums.enumerated() { if prefixSum == totalSum - prefixSum - num { return i }; prefixSum += num }; return -1; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because only a fixed amount of space is used to store the total sum, prefix sum, and index.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because the solution involves a single pass through the array."
          },
          "explanation" : "The prefix sum approach efficiently finds the pivot index by avoiding the need for nested loops. It calculates the total sum once and then iterates through the array only once.",
          "id" : "a07f5451-f98e-465f-9e8a-b37c1b607e4b",
          "intuition" : "This approach works by first calculating the total sum of the array and the prefix sum at each index. The pivot index is found when the prefix sum is equal to the total sum minus the prefix sum and the current element.",
          "name" : "Prefix Sum",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "The sum of numbers to the left of index 0 is 0 (since there are no numbers to the left), and the sum of numbers to the right is 1 + (-1) = 0, so index 0 is the pivot index.",
              "id" : "532d1e7b-d4df-4899-bf91-fc81c022b8b5",
              "input" : "nums = [2,1,-1]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no index where the sum of numbers to the left equals the sum of numbers to the right.",
              "id" : "5c08a657-f80b-42a8-b890-314e443ea147",
              "input" : "nums = [2,7,11,15]"
            }
          ]
        }
      ],
      "id" : "0cf3047f-36b3-401e-8642-65a8caa49475",
      "lastUpdated" : "2026-02-06T21:36:23Z",
      "problemSlug" : "find-pivot-index",
      "relatedProblems" : [
        "max-subarray",
        "search-a-2d-matrix-ii"
      ],
      "summary" : "This problem is about finding the pivot index in an array where the total sum of all numbers to the left of the index is equal to the total sum of all numbers to the right. A key insight is to use prefix sums to simplify the calculation of left and right sums."
    },
    {
      "approaches" : [
        {
          "approach" : "Create an adjacency list to represent the trust graph, then iterate over all persons to check if each person satisfies the conditions",
          "code" : "\n           class Solution {\n               func findJudge(_ n: Int, _ trust: [[Int]]) -> Int {\n                   var trustGraph: [[Int]] = Array(repeating: [], count: n + 1)\n                   for edge in trust {\n                       trustGraph[edge[0]].append(edge[1])\n                   }\n                   for person in 1...n {\n                       if trustGraph[person].count == 0 {\n                           var incomingEdges = 0\n                           for i in 1...n {\n                               if i != person {\n                                   incomingEdges += trustGraph[i].contains(person) ? 1 : 0\n                               }\n                           }\n                           if incomingEdges == n - 1 {\n                               return person\n                           }\n                       }\n                   }\n                   return -1\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n + m)",
            "spaceExplanation" : "We need space to store the trust graph",
            "time" : "O(n^2 + m)",
            "timeExplanation" : "We need to iterate over all persons and all edges to build the trust graph and check the conditions"
          },
          "explanation" : "This solution works but has a high time complexity because we need to check all persons and all edges in the graph",
          "id" : "bf64d3d7-3396-4a4c-b6c8-1870cd319531",
          "intuition" : "We can try all possible persons and check if each person is trusted by n-1 other persons and does not trust anyone else",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Person 3 is the town judge because persons 1 and 2 trust person 3, but person 3 does not trust anyone else",
              "id" : "28f0109f-5648-43ee-aa85-ce6869a43788",
              "input" : "n = 3, trust = [[1,3],[2,3]]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no town judge because person 3 does not satisfy the conditions",
              "id" : "a2930d8e-a90b-4c0c-8a7e-ef8bc304f77e",
              "input" : "n = 3, trust = [[1,3],[2,3],[3,1]]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Person 2 is the town judge because person 1 trusts person 2, but person 2 does not trust anyone else",
              "id" : "0c0696e1-52f3-4d45-9f2f-07df59f5fb87",
              "input" : "n = 2, trust = [[1,2]]"
            }
          ]
        },
        {
          "approach" : "Create an array to store the trust scores, then iterate over all edges to update the trust scores",
          "code" : "\n           class Solution {\n               func findJudge(_ n: Int, _ trust: [[Int]]) -> Int {\n                   var trustScores: [Int] = Array(repeating: 0, count: n + 1)\n                   for edge in trust {\n                       trustScores[edge[0]] -= 1\n                       trustScores[edge[1]] += 1\n                   }\n                   for person in 1...n {\n                       if trustScores[person] == n - 1 {\n                           return person\n                       }\n                   }\n                   return -1\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need space to store the trust scores",
            "time" : "O(n + m)",
            "timeExplanation" : "We need to iterate over all edges to update the trust scores"
          },
          "explanation" : "This solution is more efficient because we only need to iterate over all edges once",
          "id" : "3cb81050-dec3-4c9d-8543-fb80405241de",
          "intuition" : "We can calculate the trust score for each person by subtracting the number of outgoing edges from the number of incoming edges",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Person 3 is the town judge because persons 1 and 2 trust person 3, but person 3 does not trust anyone else",
              "id" : "7ef358ba-cdb4-4d45-91c0-8fdac42c269f",
              "input" : "n = 3, trust = [[1,3],[2,3]]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no town judge because person 3 does not satisfy the conditions",
              "id" : "10003d3b-c8a1-43ca-9d09-249943965185",
              "input" : "n = 3, trust = [[1,3],[2,3],[3,1]]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Person 2 is the town judge because person 1 trusts person 2, but person 2 does not trust anyone else",
              "id" : "343de7e3-440a-452b-be7b-a46c35918a5c",
              "input" : "n = 2, trust = [[1,2]]"
            }
          ]
        }
      ],
      "id" : "e26b3850-3148-4b6e-b701-9a5fd142656a",
      "lastUpdated" : "2026-02-06T21:54:11Z",
      "problemSlug" : "find-the-town-judge",
      "relatedProblems" : [
        "array-partition-i",
        "degree-of-an-array"
      ],
      "summary" : "The problem Find the Town Judge involves finding a person who is trusted by everyone else in the town but does not trust anyone else. The key insight is to look for a person with n-1 incoming edges and no outgoing edges in the trust graph."
    },
    {
      "approaches" : [
        {
          "approach" : "1. For each position, swap nums[i] to its correct position nums[i]-1\n2. Keep swapping until number is out of range or already correct\n3. Scan for first i where nums[i] != i+1",
          "code" : "func firstMissingPositive(_ nums: [Int]) -> Int {\n    var nums = nums\n    let n = nums.count\n    for i in 0..<n {\n        while nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] {\n            nums.swapAt(i, nums[i]-1)\n        }\n    }\n    for i in 0..<n {\n        if nums[i] != i + 1 { return i + 1 }\n    }\n    return n + 1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place",
            "time" : "O(n)",
            "timeExplanation" : "Each element moved at most once"
          },
          "explanation" : "By placing numbers in their 'home' positions, we can find the missing one in linear time. Numbers > n or <= 0 are ignored since answer is in [1, n+1].",
          "id" : "722ce15e-4216-4dda-8d68-b11968c4e0ca",
          "intuition" : "Place each positive number i at index i-1. Then scan for first position where nums[i] != i+1.",
          "name" : "Cyclic Sort \/ Index Mapping",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "After sorting: [1,-1,3,4]. Position 1 should have 2.",
              "id" : "d8d9a770-3fcd-407d-adbd-c7ed2dd86362",
              "input" : "nums = [3,4,-1,1]"
            }
          ]
        }
      ],
      "id" : "5762a62b-66ee-4ddf-8439-fe521956b799",
      "lastUpdated" : "2026-02-06T00:56:20.970Z",
      "problemSlug" : "first-missing-positive",
      "relatedProblems" : [
        "missing-number",
        "find-all-numbers-disappeared-in-an-array"
      ],
      "summary" : "Find smallest missing positive integer in O(n) time and O(1) space. Use array itself as hash map by placing each number at index num-1."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a function that iterates through each character in the string, and for each character, iterate through the string again to count its occurrences. If a character has an occurrence count of 1, return its index.",
          "code" : "\n       import Foundation\n\n       func firstUniqChar(_ s: String) -> Int {\n         for (index, char) in s.enumerated() {\n           var count = 0\n           for c in s {\n             if c == char {\n               count += 1\n             }\n           }\n           if count == 1 {\n             return index\n           }\n         }\n         return -1\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we're not using any additional space that scales with input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because for each character in the string, we're potentially iterating through the entire string again."
          },
          "explanation" : "This approach is straightforward but inefficient because it has a time complexity of O(n^2) due to the nested loops.",
          "id" : "e0d7bb9d-5aee-4352-af78-61d156fc8018",
          "intuition" : "This approach works by iterating through each character in the string and checking if it's unique by counting its occurrences in the string.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "The first unique character in \"leetcode\" is 'l' at index 0.",
              "id" : "d8da5cbf-48bf-4f86-9db2-e68251bb1e6c",
              "input" : "s = \"leetcode\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The first unique character in \"loveleetcode\" is 'v' at index 2.",
              "id" : "994339cc-4fac-4768-9945-9937303f6aca",
              "input" : "s = \"loveleetcode\""
            }
          ]
        },
        {
          "approach" : "Create a function that uses a dictionary to count the frequency of each character in a single pass. Then, iterate through the string and return the index of the first character that has a count of 1 in the dictionary.",
          "code" : "\n       import Foundation\n\n       func firstUniqChar(_ s: String) -> Int {\n         var charCount: [Character: Int] = [:]\n         for char in s {\n           if let count = charCount[char] {\n             charCount[char] = count + 1\n           } else {\n             charCount[char] = 1\n           }\n         }\n         for (index, char) in s.enumerated() {\n           if charCount[char]! == 1 {\n             return index\n           }\n         }\n         return -1\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, we might store every character in the dictionary.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we make two passes through the string."
          },
          "explanation" : "This approach is efficient because it only requires two passes through the string, resulting in a time complexity of O(n).",
          "id" : "bde55d3c-7eab-41a8-97a8-354604063aa2",
          "intuition" : "This approach works by counting character frequencies in a single pass and then iterating through the string to find the first character with a count of 1.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "0",
              "explanation" : "The first unique character in \"leetcode\" is 'l' at index 0.",
              "id" : "6545df2b-0691-4b63-a82f-fab87272b6d9",
              "input" : "s = \"leetcode\""
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The first unique character in \"loveleetcode\" is 'v' at index 2.",
              "id" : "6a677466-176b-462c-98f0-93d0de4eccd4",
              "input" : "s = \"loveleetcode\""
            }
          ]
        }
      ],
      "id" : "eae67d7a-b6fc-4d69-874d-b6812f5630ab",
      "lastUpdated" : "2026-02-06T21:15:38Z",
      "problemSlug" : "first-unique-character-in-a-string",
      "relatedProblems" : [
        "single-number",
        "majority-element"
      ],
      "summary" : "The problem asks for the first unique character in a string. The key insight is to count character frequencies and then iterate through the string to find the first character with a count of 1."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Count live neighbors for each cell\n2. Encode: 0dead, 1live, 2deadlive, 3livedead\n3. Final pass: convert to final state",
          "code" : "func gameOfLife(_ board: inout [[Int]]) {\n    let m = board.count, n = board[0].count\n    let dirs = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            var live = 0\n            for (di, dj) in dirs {\n                let ni = i + di, nj = j + dj\n                if ni >= 0 && ni < m && nj >= 0 && nj < n {\n                    live += board[ni][nj] & 1\n                }\n            }\n            if board[i][j] == 1 && (live == 2 || live == 3) {\n                board[i][j] = 3  \/\/ 01 -> 11 (live->live)\n            } else if board[i][j] == 0 && live == 3 {\n                board[i][j] = 2  \/\/ 00 -> 10 (dead->live)\n            }\n        }\n    }\n    \n    for i in 0..<m {\n        for j in 0..<n {\n            board[i][j] >>= 1\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place encoding",
            "time" : "O(mn)",
            "timeExplanation" : "Visit each cell twice"
          },
          "explanation" : "Two LSBs: current state, next state encoded in higher bit.",
          "id" : "0ddb188b-6144-4e36-a1d0-d4efc71113ca",
          "intuition" : "Use additional bits to store both current and next state.",
          "name" : "In-place with State Encoding",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
              "explanation" : "One generation step",
              "id" : "734d76b8-2a2b-4f2b-96ab-af8aad2bdd5c",
              "input" : "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]"
            }
          ]
        }
      ],
      "id" : "644e4176-14bb-44d6-9d01-79074510e469",
      "lastUpdated" : "2026-02-06T14:42:10Z",
      "problemSlug" : "game-of-life",
      "relatedProblems" : [

      ],
      "summary" : "Simulate one step of Game of Life. Encode states in-place using extra bits."
    },
    {
      "approaches" : [
        {
          "approach" : "1. For each string, sort its characters to form a key.\n2. Append the string to the bucket for that key.\n3. Return all buckets.",
          "code" : "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups: [String: [String]] = [:]\n    for s in strs {\n        let key = String(s.sorted())\n        groups[key, default: []].append(s)\n    }\n    return Array(groups.values)\n}",
          "complexity" : {
            "space" : "O(n * k)",
            "spaceExplanation" : "All strings are stored in grouped buckets.",
            "time" : "O(n * k log k)",
            "timeExplanation" : "Sorting each of n strings of length k dominates."
          },
          "explanation" : "Sorting each word is the dominant cost, but it keeps the implementation simple and reliable.",
          "id" : "01f071e5-54c6-44da-86f1-bad42a893aa6",
          "intuition" : "Anagrams share the same multiset of letters, so sorting makes identical keys for the group.",
          "name" : "Hash by Sorted Key",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
              "explanation" : "Strings with the same sorted key are grouped (order may vary).",
              "id" : "cf59af36-fcff-4d7c-b446-f32138d0f4e9",
              "input" : "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]"
            },
            {
              "expectedOutput" : "[[\"\"]]",
              "explanation" : "Single empty string forms one group.",
              "id" : "ff99e033-fb51-4eb3-972b-18a4a8c5acef",
              "input" : "strs = [\"\"]"
            },
            {
              "expectedOutput" : "[[\"a\"]]",
              "explanation" : "Single string forms one group.",
              "id" : "a4399698-b4e5-43f4-99f5-223620ca26be",
              "input" : "strs = [\"a\"]"
            }
          ]
        }
      ],
      "id" : "8003a7c4-b302-40f5-a143-6e9006052256",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "group-anagrams",
      "relatedProblems" : [
        "valid-anagram",
        "find-all-anagrams-in-a-string"
      ],
      "summary" : "Group strings by their sorted characters (anagram signature)."
    },
    {
      "approaches" : [
        {
          "approach" : "First, generate all possible pairs of strings and then compare each pair to check if they are special-equivalent.",
          "code" : "\n       import Foundation\n\n       func numSpecialEquivGroups(_ A: [String]) -> Int {\n           var groups = Set<String>()\n           for s in A {\n               var even = String()\n               var odd = String()\n               for (index, char) in s.enumerated() {\n                   if index % 2 == 0 {\n                       even += String(char)\n                   } else {\n                       odd += String(char)\n                   }\n               }\n               let sortedEven = String(even.sorted())\n               let sortedOdd = String(odd.sorted())\n               groups.insert(sortedEven + sortedOdd)\n           }\n           return groups.count\n       }\n       ",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is O(n * m) because in the worst case, we might have to store all input strings in the groups set.",
            "time" : "O(n * m * log(m))",
            "timeExplanation" : "The time complexity is dominated by the sorting operation for each string, which takes O(m * log(m)) time, and this is repeated for n strings."
          },
          "explanation" : "This brute force approach checks all possible pairs of strings, which results in a high time complexity and thus is not efficient for large inputs.",
          "id" : "adc539d1-30d2-4b66-b2bd-224ce934d0f8",
          "intuition" : "This approach involves comparing each string with every other string to determine equivalence, resulting in a time complexity of O(n^2 * m), where n is the number of strings and m is the average length of the strings.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The special-equivalent groups are {\"a\", \"b\"} and {\"ab\", \"ba\"}.",
              "id" : "bc9b7bbd-581d-4ca3-9a83-2ff2f4c37b3c",
              "input" : "A = [\"a\",\"b\",\"ab\",\"ba\"]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The special-equivalent groups are {\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"} which actually can be divided into {\"abc\", \"acb\"}, {\"bac\", \"bca\"}, and {\"cab\", \"cba\"}.",
              "id" : "f07b800c-a6db-4d98-ac57-aa20701fea01",
              "input" : "A = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]"
            }
          ]
        },
        {
          "approach" : "First, sort the characters at even indices for each string, then sort the characters at odd indices, and finally concatenate these two sorted strings to get a signature for each input string.",
          "code" : "\n       import Foundation\n\n       func numSpecialEquivGroups(_ A: [String]) -> Int {\n           var groups = Set<String>()\n           for s in A {\n               var signature = String()\n               var evenChars = [Character]()\n               var oddChars = [Character]()\n               for (index, char) in s.enumerated() {\n                   if index % 2 == 0 {\n                       evenChars.append(char)\n                   } else {\n                       oddChars.append(char)\n                   }\n               }\n               let sortedEven = String(evenChars.sorted())\n               let sortedOdd = String(oddChars.sorted())\n               signature = sortedEven + sortedOdd\n               groups.insert(signature)\n           }\n           return groups.count\n       }\n       ",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is O(n * m) because in the worst case, we might have to store all input strings in the groups set.",
            "time" : "O(n * m * log(m))",
            "timeExplanation" : "The time complexity is dominated by the sorting operation for each string, which takes O(m * log(m)) time, and this is repeated for n strings."
          },
          "explanation" : "This optimized approach efficiently creates a unique signature for each special-equivalent group of strings, allowing for a more efficient grouping process.",
          "id" : "4bdc9317-62da-4591-846c-49e6f2c762f8",
          "intuition" : "This approach involves creating a signature for each string by sorting the characters at even and odd indices separately and then concatenating these sorted strings.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The special-equivalent groups are {\"a\", \"b\"} and {\"ab\", \"ba\"}.",
              "id" : "7d48ec23-f9fa-4fb9-950b-bc64925d659c",
              "input" : "A = [\"a\",\"b\",\"ab\",\"ba\"]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The special-equivalent groups are {\"abc\", \"acb\"}, {\"bac\", \"bca\"}, and {\"cab\", \"cba\"}.",
              "id" : "ff495cb8-1e9d-4625-9b0f-6b7792fb3444",
              "input" : "A = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]"
            }
          ]
        }
      ],
      "id" : "4383c81f-d1b8-4b3e-b3da-33f043ee9ecb",
      "lastUpdated" : "2026-02-06T21:46:54Z",
      "problemSlug" : "groups-of-special-equivalent-strings",
      "relatedProblems" : [
        "groups-of-special-equivalent-strings",
        "number-of-equivalent-domino-pairs"
      ],
      "summary" : "The problem requires us to group special-equivalent strings based on a custom definition of equivalence, where two strings are equivalent if and only if they have the same characters at even indices and the same characters at odd indices. The key insight is to create a signature string for each input string that captures this property."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the citations in descending order. Then, iterate over the sorted citations and for each citation, calculate its h-index by taking the minimum of the citation count and the paper number. Keep track of the maximum h-index found.",
          "code" : "func hIndex(citations: [Int]) -> Int { \n    let sortedCitations = citations.sorted { $0 > $1 } \n    var maxHIndex = 0 \n    for i in 0..<sortedCitations.count { \n        let hIndex = min(sortedCitations[i], i + 1) \n        maxHIndex = max(maxHIndex, hIndex) \n    } \n    return maxHIndex \n} \n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the sorted citations.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the sorting step."
          },
          "explanation" : "This approach works because the h-index for each paper is the minimum of the citation count and the paper number. By iterating over the sorted citations, we can ensure that we consider all possible h-indices for each paper.",
          "id" : "79a12a19-c046-4c6b-b141-8e441cf4836e",
          "intuition" : "This approach involves sorting the citations in descending order and then iterating over the sorted citations to find the h-index for each paper.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The h-indices for the papers are [3,0,3,1,2], so the maximum h-index is 3.",
              "id" : "48fae7c1-3984-46ad-ae78-f93ac1514c14",
              "input" : "citations = [3,0,6,1,5]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The h-indices for the papers are [1,1,1], so the maximum h-index is 1.",
              "id" : "e16ea00b-42ce-4611-8741-aae5978bb3db",
              "input" : "citations = [1,3,1]"
            }
          ]
        },
        {
          "approach" : "Create an array of buckets, where each bucket represents a possible h-index. Iterate over the citations and for each citation, increment the corresponding bucket. Then, iterate over the buckets in reverse order and for each bucket, calculate the h-index by taking the minimum of the bucket value and the bucket number. Keep track of the maximum h-index found.",
          "code" : "func hIndex(citations: [Int]) -> Int { \n    let n = citations.count \n    var buckets = Array(repeating: 0, count: n + 1) \n    for citation in citations { \n        if citation >= n { \n            buckets[n] += 1 \n        } else { \n            buckets[citation] += 1 \n        } \n    } \n    var papers = 0 \n    var maxHIndex = 0 \n    for i in stride(from: n, to: -1, by: -1) { \n        papers += buckets[i] \n        maxHIndex = max(maxHIndex, min(papers, i)) \n    } \n    return maxHIndex \n} \n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the buckets.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we iterate over the citations and buckets once."
          },
          "explanation" : "This approach works because the h-index for each paper is the minimum of the citation count and the paper number. By using a bucket sort, we can efficiently calculate the h-index for each paper.",
          "id" : "b5c112d6-e830-45c6-917e-93bf5b8ea221",
          "intuition" : "This approach involves using a bucket sort to efficiently calculate the h-index.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The h-indices for the papers are [3,0,3,1,2], so the maximum h-index is 3.",
              "id" : "dbd4e057-a1d5-432f-bcfd-a219269d9305",
              "input" : "citations = [3,0,6,1,5]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The h-indices for the papers are [1,1,1], so the maximum h-index is 1.",
              "id" : "7524776d-28a1-4411-b32f-cf26d2636bd4",
              "input" : "citations = [1,3,1]"
            }
          ]
        }
      ],
      "id" : "6c9a3dea-8d12-43cc-9883-8dd704330ac7",
      "lastUpdated" : "2026-02-06T21:11:52Z",
      "problemSlug" : "h-index",
      "relatedProblems" : [
        "h-index-ii",
        "largest-number"
      ],
      "summary" : "The H-Index problem involves calculating an author's h-index from a list of citations, where the h-index is the largest number of papers included in the h-index. The key insight is to sort the citations in descending order and calculate the h-index for each paper."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over each possible position where the two images can overlap. 2. At each position, calculate the overlap between the two images by comparing the corresponding pixels. 3. Keep track of the position with the maximum overlap.",
          "code" : "func largestOverlap(img1: [[Int]], img2: [[Int]]) -> Int {\n    let m = img1.count\n    let n = img1[0].count\n    var maxOverlap = 0\n    for dx in -m+1...m-1 {\n        for dy in -n+1...n-1 {\n            var overlap = 0\n            for x in 0..<m {\n                for y in 0..<n {\n                    if x+dx >= 0 && x+dx < m && y+dy >= 0 && y+dy < n && img1[x][y] == 1 && img2[x+dx][y+dy] == 1 {\n                        overlap += 1\n                    }\n                }\n            }\n            maxOverlap = max(maxOverlap, overlap)\n        }\n    }\n    return maxOverlap\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the maximum overlap and the current overlap.",
            "time" : "O(m^2*n^2)",
            "timeExplanation" : "We have four nested loops, each of which iterates over the size of the images."
          },
          "explanation" : "This approach is straightforward but inefficient because it involves a lot of repeated calculations. It can be useful for small images but is not scalable for large images.",
          "id" : "a8f80478-2e1e-4948-beef-1df35312d1a1",
          "intuition" : "This approach works by iterating over each possible position where the two images can overlap and calculating the overlap at each position.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum overlap is 3 when img1 is placed at the top-left corner of img2 and shifted right by one pixel.",
              "id" : "1524b374-bf4d-430a-bf40-078a0356ee71",
              "input" : "img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The maximum overlap is 1 when img1 is placed at the same position as img2.",
              "id" : "82b593ca-a83e-4571-ac1c-ede648d884ec",
              "input" : "img1 = [[1]], img2 = [[1]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The maximum overlap is 0 when img1 is placed at the same position as img2 but both are empty.",
              "id" : "ff2c97c5-b41d-454d-8ee4-26cec55682f9",
              "input" : "img1 = [[0]], img2 = [[0]]"
            }
          ]
        },
        {
          "approach" : "1. Create a hashmap to store the count of each pixel's position in the first image. 2. Iterate over the second image and for each pixel, calculate the overlap by looking up the count of the corresponding pixel in the hashmap. 3. Keep track of the position with the maximum overlap.",
          "code" : "func largestOverlap(img1: [[Int]], img2: [[Int]]) -> Int {\n    let m = img1.count\n    let n = img1[0].count\n    var maxOverlap = 0\n    var count = [String: Int]()\n    for x in 0..<m {\n        for y in 0..<n {\n            if img1[x][y] == 1 {\n                for dx in -m+1...m-1 {\n                    for dy in -n+1...n-1 {\n                        let key = \"(dx),(dy)\"\n                        count[key, default: 0] += 1\n                    }\n                }\n            }\n        }\n    }\n    for x in 0..<m {\n        for y in 0..<n {\n            if img2[x][y] == 1 {\n                for dx in -m+1...m-1 {\n                    for dy in -n+1...n-1 {\n                        let key = \"(dx),(dy)\"\n                        maxOverlap = max(maxOverlap, count[key, default: 0])\n                    }\n                }\n            }\n        }\n    }\n    return maxOverlap\n}",
          "complexity" : {
            "space" : "O(m^2*n^2)",
            "spaceExplanation" : "We use a hashmap to store the count of each pixel's position, which requires O(m^2*n^2) space.",
            "time" : "O(m^2*n^2)",
            "timeExplanation" : "We have four nested loops, each of which iterates over the size of the images."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it uses a hashmap to avoid repeated calculations.",
          "id" : "8b9396c0-b782-44cf-816f-043957fbc85c",
          "intuition" : "This approach works by using a hashmap to store the count of each pixel's position in the first image and then iterating over the second image to calculate the overlap.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum overlap is 3 when img1 is placed at the top-left corner of img2 and shifted right by one pixel.",
              "id" : "5cd5277c-1406-4a33-b760-91ace9207d7b",
              "input" : "img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The maximum overlap is 1 when img1 is placed at the same position as img2.",
              "id" : "0a5f782f-a2bd-490d-aa4e-6c731ba086ea",
              "input" : "img1 = [[1]], img2 = [[1]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "The maximum overlap is 0 when img1 is placed at the same position as img2 but both are empty.",
              "id" : "97f12db1-b563-46ed-93a3-56868902cb84",
              "input" : "img1 = [[0]], img2 = [[0]]"
            }
          ]
        }
      ],
      "id" : "827b3821-1228-431f-a923-22d3f4a4f53d",
      "lastUpdated" : "2026-02-06T21:43:13Z",
      "problemSlug" : "image-overlap",
      "relatedProblems" : [
        "minesweeper",
        "number-of-islands"
      ],
      "summary" : "Image Overlap is a problem of finding the overlap between two binary images. The key insight is to use matrix operations and bitwise shift to efficiently calculate the overlap."
    },
    {
      "approaches" : [
        {
          "approach" : "For each pixel, we check all its neighboring pixels (up to 8 neighbors) and calculate the average based on those neighbors that are within the image boundaries.",
          "code" : "\n           func imageSmoother(_ M: [[Int]]) -> [[Int]] {\n               let rows = M.count\n               let cols = M[0].count\n               var result = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n               for i in 0..<rows {\n                   for j in 0..<cols {\n                       var sum = M[i][j]\n                       var count = 1\n                       for x in -1...1 {\n                           for y in -1...1 {\n                               if (x == 0 && y == 0) {\n                                   continue\n                               }\n                               let row = i + x\n                               let col = j + y\n                               if row >= 0 && row < rows && col >= 0 && col < cols {\n                                   sum += M[row][col]\n                                   count += 1\n                               }\n                           }\n                       }\n                       result[i][j] = sum \/ count\n                   }\n               }\n               return result\n           }\n           ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity is O(n*m) as we are storing the result in a separate matrix of the same size as the input image.",
            "time" : "O(n*m*9)",
            "timeExplanation" : "The time complexity is O(n*m*9) where n and m are the dimensions of the image. This is because for each pixel, we are checking up to 8 neighboring pixels."
          },
          "explanation" : "This approach provides a clear and straightforward solution to the problem. However, it might not be efficient for large images because it involves multiple nested loops.",
          "id" : "392d743d-29e6-4ef1-9fb1-649c605c5fd0",
          "intuition" : "This approach works by iterating over each pixel in the image, and for each pixel, iterating over its neighboring pixels to calculate the average.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0],[0,0,0],[0,0,0]]",
              "explanation" : "The average of all pixels is 1, so the smoothed image will be the same as the original image.",
              "id" : "3bbad7cb-6ba7-4fa4-8650-175c52855133",
              "input" : "M = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput" : "[[2,2,2],[2,1,2],[2,2,2]]",
              "explanation" : "The average of all pixels is 2 except for the middle pixel which is 1, so the smoothed image will be mostly the same as the original image except for the middle pixel which will be the average of its neighbors.",
              "id" : "598a290f-865f-405f-8db0-73f1af11520d",
              "input" : "M = [[2,2,2],[2,1,2],[2,2,2]]"
            }
          ]
        },
        {
          "approach" : "For each pixel, instead of iterating over all its neighboring pixels, we can calculate the sum and count of its neighboring pixels directly by checking the boundaries of the image.",
          "code" : "\n           func imageSmoother(_ M: [[Int]]) -> [[Int]] {\n               let rows = M.count\n               let cols = M[0].count\n               var result = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n               for i in 0..<rows {\n                   for j in 0..<cols {\n                       var sum = M[i][j]\n                       var count = 1\n                       for direction in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] {\n                           let row = i + direction.0\n                           let col = j + direction.1\n                           if row >= 0 && row < rows && col >= 0 && col < cols {\n                               sum += M[row][col]\n                               count += 1\n                           }\n                       }\n                       result[i][j] = sum \/ count\n                   }\n               }\n               return result\n           }\n           ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "The space complexity is O(n*m) as we are storing the result in a separate matrix of the same size as the input image.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n and m are the dimensions of the image. This is because we are iterating over each pixel in the image."
          },
          "explanation" : "This approach provides a more efficient solution to the problem than the brute force approach. It reduces the number of operations needed to calculate the average of neighboring pixels.",
          "id" : "e5ab062c-d1fc-44bd-b38d-a8dcab6ba304",
          "intuition" : "This approach works by using the same idea as the brute force approach but improves it by reducing the number of operations needed to calculate the average of neighboring pixels.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0],[0,0,0],[0,0,0]]",
              "explanation" : "The average of all pixels is 1, so the smoothed image will be the same as the original image.",
              "id" : "f3cb359b-430a-47ed-b501-491f410d7da0",
              "input" : "M = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput" : "[[2,2,2],[2,1,2],[2,2,2]]",
              "explanation" : "The average of all pixels is 2 except for the middle pixel which is 1, so the smoothed image will be mostly the same as the original image except for the middle pixel which will be the average of its neighbors.",
              "id" : "ee0c8b04-9860-4e48-81bc-43ca394515ff",
              "input" : "M = [[2,2,2],[2,1,2],[2,2,2]]"
            }
          ]
        }
      ],
      "id" : "71c71daa-e810-4a2c-bd4a-43518291c75c",
      "lastUpdated" : "2026-02-06T21:32:02Z",
      "problemSlug" : "image-smoother",
      "relatedProblems" : [
        "image-smoother-ii",
        "matrix-block-sum"
      ],
      "summary" : "Image Smoother is an array and matrix problem where we need to smooth an image by averaging neighboring pixels. The key insight is to traverse each pixel and calculate its average value based on its neighboring pixels."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over all cells in the grid. 2. For each land cell, check its four neighbors (up, down, left, right). 3. If a neighbor is water or the boundary of the grid, increment the perimeter.",
          "code" : "func islandPerimeter(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var perimeter = 0\n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                if i == 0 || grid[i-1][j] == 0 {\n                    perimeter += 1\n                }\n                if i == m-1 || grid[i+1][j] == 0 {\n                    perimeter += 1\n                }\n                if j == 0 || grid[i][j-1] == 0 {\n                    perimeter += 1\n                }\n                if j == n-1 || grid[i][j+1] == 0 {\n                    perimeter += 1\n                }\n            }\n        }\n    }\n    return perimeter\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the perimeter.",
            "time" : "O(m*n)",
            "timeExplanation" : "We iterate over the grid once, which has m*n cells."
          },
          "explanation" : "This brute-force approach is straightforward but inefficient as it requires checking all cells and their neighbors in the grid.",
          "id" : "3bf7793e-4fe4-41c3-a492-fe5bf3575b56",
          "intuition" : "This approach calculates the perimeter by checking all cells in the grid, counting land cells and checking their neighbors.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "16",
              "explanation" : "The island in this grid has a perimeter of 16.",
              "id" : "64644548-c979-4b44-847d-2bfc96f78adf",
              "input" : "grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "A single cell island has a perimeter of 4.",
              "id" : "506d3111-f456-410e-9001-977895f4eff1",
              "input" : "grid = [[1]]"
            }
          ]
        },
        {
          "approach" : "1. Initialize perimeter to 0. 2. Iterate over all cells in the grid. 3. For each land cell, increment perimeter by the number of edges that are not shared with neighboring land cells.",
          "code" : "func islandPerimeter(_ grid: [[Int]]) -> Int {\n    let m = grid.count\n    let n = grid[0].count\n    var perimeter = 0\n    for i in 0..<m {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                let neighbors = [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]\n                for (x, y) in neighbors {\n                    if x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == 0 {\n                        perimeter += 1\n                    }\n                }\n            }\n        }\n    }\n    return perimeter\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We still only use a constant amount of space to store the perimeter.",
            "time" : "O(m*n)",
            "timeExplanation" : "We still iterate over the grid once, which has m*n cells."
          },
          "explanation" : "This optimized approach is more efficient as it makes a single pass over the grid.",
          "id" : "14894ae2-7db3-4028-a868-d9b2d0388160",
          "intuition" : "This approach still calculates the perimeter by counting the number of edges that are not shared with neighboring land cells, but uses a single pass to do so.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "16",
              "explanation" : "The island in this grid has a perimeter of 16.",
              "id" : "e7ae4cc8-ed51-43e4-bfa2-87cdc603499f",
              "input" : "grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "A single cell island has a perimeter of 4.",
              "id" : "746e8912-b13c-4aef-aac0-e6971cb0329c",
              "input" : "grid = [[1]]"
            }
          ]
        }
      ],
      "id" : "70be1834-8345-48b6-8574-bb72e1f9aaf1",
      "lastUpdated" : "2026-02-06T21:20:35Z",
      "problemSlug" : "island-perimeter",
      "relatedProblems" : [
        "max-area-of-island",
        "number-of-islands"
      ],
      "summary" : "This problem asks to calculate the perimeter of a given island in a 2D grid, with the key insight being to count the number of edges that are not shared with neighboring land cells. We can solve this by using a brute-force approach or an optimized approach using a single pass."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate over each character in the strings, and for each character, check if it has been mapped before. If not, check if the target character has been used before.",
          "code" : "func isIsomorphic(_ s: String, _ t: String) -> Bool { let s = Array(s); let t = Array(t); if s.count != t.count { return false }; var sToT: [Character: Character] = [:]; var tToS: [Character: Character] = [:]; for (sChar, tChar) in zip(s, t) { if let tValue = sToT[sChar] { if tValue != tChar { return false }; } else if let sValue = tToS[tChar] { if sValue != sChar { return false }; } else { sToT[sChar] = tChar; tToS[tChar] = sChar }; }; return true; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use two hash tables to keep track of character mappings, which requires up to n space.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the characters in the strings once."
          },
          "explanation" : "This approach works because it checks all possible mappings between characters in the strings. However, it's inefficient because it involves a lot of repeated work.",
          "id" : "fc839758-768c-4487-8591-fb39dba4f652",
          "intuition" : "This approach involves checking every possible mapping of characters between the two strings.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "This works because we can replace 'e' with 'a' and 'g' with 'd'.",
              "id" : "733c7791-e0c3-4058-acee-96d1c198541b",
              "input" : "s = \"egg\", t = \"add\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "This doesn't work because we can't replace 'o' with two different characters 'a' and 'r'.",
              "id" : "34f3f695-f4b8-4ba4-920f-c76af5f4abe3",
              "input" : "s = \"foo\", t = \"bar\""
            }
          ]
        },
        {
          "approach" : "Iterate over each character in the strings. For each character, check if it has been mapped before. If not, check if the target character has been used before.",
          "code" : "func isIsomorphic(_ s: String, _ t: String) -> Bool { let s = Array(s); let t = Array(t); if s.count != t.count { return false }; var sToTMap: [Character: Character] = [:]; var tToSMap: [Character: Character] = [:]; for i in 0..<s.count { if let tValue = sToTMap[s[i]] { if tValue != t[i] { return false }; } else if let sValue = tToSMap[t[i]] { if sValue != s[i] { return false }; } else { sToTMap[s[i]] = t[i]; tToSMap[t[i]] = s[i]; }; }; return true; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use two hash tables to keep track of character mappings, which requires up to n space.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the characters in the strings once."
          },
          "explanation" : "This approach works because it avoids repeated work by using hash tables to store character mappings. It's efficient and scalable for large inputs.",
          "id" : "db3f0bd1-0f97-40bd-b2d8-5ced1131ccb3",
          "intuition" : "This approach involves using two hash tables to keep track of character mappings between the two strings.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "This works because we can replace 'p' with 't', 'a' with 'i', 'e' with 'l', and 'r' with 'e'.",
              "id" : "e24316ce-7df5-4eb8-8e9c-43a17da91ad0",
              "input" : "s = \"paper\", t = \"title\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "This doesn't work because we can't replace 'a' with two different characters 'a' and 'b'.",
              "id" : "4f2e9c56-852f-48f6-9725-87400f50ae72",
              "input" : "s = \"ab\", t = \"aa\""
            }
          ]
        }
      ],
      "id" : "1949fc15-a330-471d-beff-44091115f9c7",
      "lastUpdated" : "2026-02-06T21:10:25Z",
      "problemSlug" : "isomorphic-strings",
      "relatedProblems" : [
        "roman-to-integer",
        "valid-anagram"
      ],
      "summary" : "This problem involves determining whether two given strings are isomorphic, meaning the characters in one string can be replaced to get the other string. The key insight is to use hash tables to keep track of character mappings."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize a counter for the number of jewels found. 2. Iterate over each stone in the stones string. 3. For each stone, check if it's in the jewels string. 4. If it is, increment the counter.",
          "code" : "func numJewelsInStones(_ J: String, _ S: String) -> Int { var count = 0; for stone in S { if J.contains(stone) { count += 1 } }; return count }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We're only using a constant amount of space to store the counter and the current stone, so the space complexity is O(1).",
            "time" : "O(n*m)",
            "timeExplanation" : "We're iterating over each stone in the stones string and checking if it's in the jewels string, which takes O(m) time for each stone. Since there are n stones, the total time complexity is O(n*m)."
          },
          "explanation" : "We simply iterate over each stone in the stones string and check if it's in the jewels string, incrementing a counter each time we find a match.",
          "id" : "855270ff-596a-4294-bb03-261d956fef93",
          "intuition" : "This approach works by iterating over each stone in the stones string and checking if it's in the jewels string.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The stones 'a', 'A', and 'a' in S are also jewels because they are in J.",
              "id" : "e89a3e6f-1fa2-47c9-b504-0a42253894ab",
              "input" : "J = 'aA', S = 'aAAbbbb'"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no stones in S that are also jewels because 'z' is not in S.",
              "id" : "baa2ff73-3086-4261-87be-7c918dd3b640",
              "input" : "J = 'z', S = 'ZZ'"
            }
          ]
        },
        {
          "approach" : "1. Create a hash table that maps each stone to its frequency in the stones string. 2. Iterate over each jewel in the jewels string. 3. For each jewel, add the frequency of that stone from the hash table to the total count.",
          "code" : "func numJewelsInStones(_ J: String, _ S: String) -> Int { let stoneFreq = Array(S).reduce(into: [Character:Int]()) { $0[$1, default:0] += 1 }; return Array(J).reduce(0) { $0 + (stoneFreq[$1] ?? 0) } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We're storing the frequency of each stone in a hash table, which takes O(n) space in the worst case.",
            "time" : "O(n + m)",
            "timeExplanation" : "We're iterating over each stone in the stones string to create the hash table, which takes O(n) time. Then we're iterating over each jewel in the jewels string, which takes O(m) time. The total time complexity is O(n + m)."
          },
          "explanation" : "We create a hash table to store the frequency of each stone in the stones string, then iterate over each jewel in the jewels string and add the frequency of that stone to the total count.",
          "id" : "df7c50bc-d8fa-430b-a857-2c181f3dda3e",
          "intuition" : "This approach works by leveraging a hash table to store the frequency of each stone and then counting the frequency of each jewel in the jewels string.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The stones 'a', 'A', and 'a' in S are also jewels because they are in J.",
              "id" : "e8318986-4e64-4de6-94cb-57aea4ca7b55",
              "input" : "J = 'aA', S = 'aAAbbbb'"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no stones in S that are also jewels because 'z' is not in S.",
              "id" : "413d3557-d4af-4f3e-9a5d-b16e8f431611",
              "input" : "J = 'z', S = 'ZZ'"
            }
          ]
        }
      ],
      "id" : "9ea62ad5-8a87-41dd-82cb-f8f095c48284",
      "lastUpdated" : "2026-02-06T21:38:56Z",
      "problemSlug" : "jewels-and-stones",
      "relatedProblems" : [
        "binary-tree-inorder-traversal",
        "maximum-subarray"
      ],
      "summary" : "Given a string representing the types of stones you have and another representing the jewels you want, return the number of stones that are also jewels. The key insight is to leverage string operations and hash tables to count the frequency of each stone and jewel."
    },
    {
      "approaches" : [
        {
          "approach" : "First, identify the rows of the keyboard and store them as strings. Then, iterate through each word in the list and check if all its letters are present in any one of the keyboard rows.",
          "code" : "func findWords(_ words: [String]) -> [String] { let rows = [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); for row in rows { if canBeTyped(row, word: lowerWord) { result.append(word); break; } } } return result }; func canBeTyped(_ row: String, word: String) -> Bool { for char in word { if !row.contains(char) { return false } } return true }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, all words can be typed using a single row, so we store all words in the result array.",
            "time" : "O(n*m*k)",
            "timeExplanation" : "Here, n is the number of words, m is the average length of a word, and k is the number of rows in the keyboard. The time complexity is O(n*m*k) because for each word, we are potentially checking all its characters against all the rows."
          },
          "explanation" : "We iterate through each character in the word and check if it is present in any of the rows. If we find a character that is not in the current row, we move to the next row and repeat the process.",
          "id" : "32ccdcb0-4cf9-4d9a-b4c3-c6838347fa26",
          "intuition" : "This approach involves iterating through each word in the list and checking if it can be typed using only the letters of a single row on the keyboard.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"Alaska\", \"Dad\"]",
              "explanation" : "The words \"Alaska\" and \"Dad\" can be typed using a single row of the keyboard.",
              "id" : "2831523f-9dca-40c6-be26-20c64f8dc448",
              "input" : "words = [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]"
            },
            {
              "expectedOutput" : "[\"omg\", \"fv\", \"pq\"]",
              "explanation" : "All the given words can be typed using a single row of the keyboard.",
              "id" : "2956732d-3410-4e46-978a-fd2d19f5dc81",
              "input" : "words = [\"omg\", \"fv\", \"pq\"]"
            }
          ]
        },
        {
          "approach" : "First, create a HashSet for each row of the keyboard. Then, for each word, create a HashSet of its characters and check if it is a subset of any of the row sets.",
          "code" : "func findWords(_ words: [String]) -> [String] { let rows = [Set(\"qwertyuiop\"), Set(\"asdfghjkl\"), Set(\"zxcvbnm\")]; var result: [String] = []; for word in words { let lowerWord = word.lowercased(); let wordSet = Set(lowerWord); for row in rows { if row.isSuperset(of: wordSet) { result.append(word); break; } } } return result }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because in the worst case, all words can be typed using a single row, so we store all words in the result array.",
            "time" : "O(n*m)",
            "timeExplanation" : "Here, n is the number of words and m is the average length of a word. The time complexity is O(n*m) because creating the set for each word takes O(m) time, and we do this for n words."
          },
          "explanation" : "Using a HashSet for each row and for each word allows us to check if a word can be typed using a single row in constant time per character, reducing the overall time complexity.",
          "id" : "732703b8-ddbe-4820-a390-739d8f9092ab",
          "intuition" : "This approach optimizes the brute force method by using a HashSet to store the characters in each row, allowing for faster lookup times.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"Alaska\", \"Dad\"]",
              "explanation" : "The words \"Alaska\" and \"Dad\" can be typed using a single row of the keyboard.",
              "id" : "68404b75-843d-4a80-b448-de00b9a6bd10",
              "input" : "words = [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]"
            },
            {
              "expectedOutput" : "[\"omg\", \"fv\", \"pq\"]",
              "explanation" : "All the given words can be typed using a single row of the keyboard.",
              "id" : "b2d9aaf9-2259-4515-be8e-6043491ab33a",
              "input" : "words = [\"omg\", \"fv\", \"pq\"]"
            }
          ]
        }
      ],
      "id" : "edc6b368-dbd5-4d37-be37-3a78585820b3",
      "lastUpdated" : "2026-02-06T21:22:35Z",
      "problemSlug" : "keyboard-row",
      "relatedProblems" : [
        "valid-tic-tac-toe-state",
        "toeplitz-matrix"
      ],
      "summary" : "This problem involves determining which words in a given list can be typed using only the letters of a single row on a standard QWERTY keyboard layout. The key insight is to first identify the rows of the keyboard and then check each word against these rows."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Find the maximum number in the array. 2. Compare the maximum number with every other number to check if it is at least twice as large.",
          "code" : "\n           func dominantIndex(_ nums: [Int]) -> Int {\n               let sortedNums = nums.sorted()\n               if sortedNums.count == 1 {\n                   return 0\n               }\n               let maxNum = sortedNums.last!\n               let secondMaxNum = sortedNums[sortedNums.count - 2]\n               if maxNum >= secondMaxNum * 2 {\n                   return nums.firstIndex(of: maxNum)!\n               }\n               return -1\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the sorted array.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the sorting operation."
          },
          "explanation" : "The brute-force approach has a time complexity of O(n) because it involves finding the maximum number and then comparing it with every other number in the array.",
          "id" : "f2fe08da-c145-46b3-81f9-7c1afac39d12",
          "intuition" : "This approach involves finding the maximum number in the array and then comparing it with every other number to check if it is at least twice as large.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The largest number 6 is at least twice as large as every other number.",
              "id" : "0022d2b2-a9f7-424c-9ce0-38a975cea0b4",
              "input" : "nums = [3,6,1,0]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no number that is at least twice as large as every other number.",
              "id" : "2410276a-01a1-40bd-a610-52fd4202b3fc",
              "input" : "nums = [1,2,3,4]"
            }
          ]
        },
        {
          "approach" : "1. Initialize variables to store the maximum and the second maximum number. 2. Iterate through the array to find the maximum and the second maximum number. 3. Compare the maximum number with the second maximum number to check if it is at least twice as large.",
          "code" : "\n           func dominantIndex(_ nums: [Int]) -> Int {\n               var maxNum = Int.min\n               var secondMaxNum = Int.min\n               var maxIndex = -1\n               for (index, num) in nums.enumerated() {\n                   if num > maxNum {\n                       secondMaxNum = maxNum\n                       maxNum = num\n                       maxIndex = index\n                   } else if num > secondMaxNum {\n                       secondMaxNum = num\n                   }\n               }\n               if maxNum >= secondMaxNum * 2 {\n                   return maxIndex\n               }\n               return -1\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are using a constant amount of space.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we are iterating through the array once."
          },
          "explanation" : "The optimized approach has a time complexity of O(n) because it involves a single pass through the array.",
          "id" : "594b5d1f-fab1-4980-ae96-21e7dab70f7e",
          "intuition" : "This approach involves finding the maximum and the second maximum number in a single pass through the array, and then checking if the maximum number is at least twice as large as the second maximum number.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The largest number 6 is at least twice as large as every other number.",
              "id" : "150327b2-d7d9-483b-92e6-62174b59112f",
              "input" : "nums = [3,6,1,0]"
            },
            {
              "expectedOutput" : "-1",
              "explanation" : "There is no number that is at least twice as large as every other number.",
              "id" : "c7a1792b-18ad-4a90-9905-299409d01473",
              "input" : "nums = [1,2,3,4]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The largest number 1 is at least twice as large as every other number.",
              "id" : "79ff9eda-a01f-4590-9a5c-a14299ef1701",
              "input" : "nums = [0,0,0,1]"
            }
          ]
        }
      ],
      "id" : "d394e190-beaf-4c31-a422-62304678d156",
      "lastUpdated" : "2026-02-06T21:37:07Z",
      "problemSlug" : "largest-number-at-least-twice-of-others",
      "relatedProblems" : [
        "maximum-subarray",
        "array-partition-i"
      ],
      "summary" : "This problem requires finding the largest number in an array that is at least twice as large as every other number. The key insight is to identify the largest number and then verify if it meets the given condition."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Handle empty array edge case\n2. Use first string as reference\n3. For each character position i in first string:\n   a. Check if position i exists in all strings\n   b. Check if all strings have same character at position i\n   c. If mismatch or end, return prefix so far\n4. Return first string if loop completes",
          "code" : "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    let first = Array(strs[0])\n    \n    for i in 0..<first.count {\n        let char = first[i]\n        for str in strs {\n            let arr = Array(str)\n            if i >= arr.count || arr[i] != char {\n                return String(first[0..<i])\n            }\n        }\n    }\n    \n    return strs[0]\n}",
          "complexity" : {
            "space" : "O(m)",
            "spaceExplanation" : "Converting first string to array takes O(m) where m is its length",
            "time" : "O(S)",
            "timeExplanation" : "S is the sum of all characters in all strings. Worst case compares all characters."
          },
          "explanation" : "We iterate through character positions (columns) rather than strings (rows). At each position, we verify all strings have the same character. This is efficient when the common prefix is short, as we stop early on mismatch.",
          "id" : "4bf80104-769c-45fc-acc5-bec036b84363",
          "intuition" : "Compare characters column by column (same position across all strings). Stop when we find a mismatch or reach the end of any string.",
          "name" : "Vertical Scanning",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"fl\"",
              "explanation" : "All start with 'f', then 'l', then differ at position 2 (o vs i)",
              "id" : "ee631f8a-80b4-436a-a9e9-a8b65def5dff",
              "input" : "strs = [\"flower\",\"flow\",\"flight\"]"
            },
            {
              "expectedOutput" : "\"\"",
              "explanation" : "No common prefix - first characters differ (d vs r vs c)",
              "id" : "2bab7c2c-383d-4f33-bfd5-5d2e8c252298",
              "input" : "strs = [\"dog\",\"racecar\",\"car\"]"
            }
          ]
        },
        {
          "approach" : "1. Start with prefix = first string\n2. For each subsequent string:\n   a. While string doesn't start with prefix\n   b. Remove last character from prefix\n   c. If prefix becomes empty, return \"\"\n3. Return prefix",
          "code" : "func longestCommonPrefix(_ strs: [String]) -> String {\n    guard !strs.isEmpty else { return \"\" }\n    \n    var prefix = strs[0]\n    \n    for i in 1..<strs.count {\n        while !strs[i].hasPrefix(prefix) {\n            prefix = String(prefix.dropLast())\n            if prefix.isEmpty { return \"\" }\n        }\n    }\n    \n    return prefix\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only using the prefix variable, no extra data structures",
            "time" : "O(S)",
            "timeExplanation" : "S is sum of all characters. Worst case: all strings identical, we compare all."
          },
          "explanation" : "We assume the entire first string is the common prefix, then trim it down as needed when comparing with each string. If a string doesn't start with our current prefix, we shorten the prefix until it does.",
          "id" : "e0ca2b94-8cdf-406d-8c18-8af36fd49823",
          "intuition" : "Start with the first string as the prefix. Iteratively shrink it by comparing with each subsequent string until it matches as a prefix of all strings.",
          "name" : "Horizontal Scanning",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"fl\"",
              "explanation" : "Start with 'flower'. 'flow' doesn't have prefix 'flower', shrink to 'flowe', 'flow', then matches. 'flight' doesn't have prefix 'flow', shrink to 'flo', 'fl', matches.",
              "id" : "9e30c508-a50b-4b6b-81cb-2cbf031ef19c",
              "input" : "strs = [\"flower\",\"flow\",\"flight\"]"
            },
            {
              "expectedOutput" : "\"a\"",
              "explanation" : "Single string - the entire string is the common prefix",
              "id" : "eade3dd4-0be4-4281-bb62-822212eb0118",
              "input" : "strs = [\"a\"]"
            },
            {
              "expectedOutput" : "\"\"",
              "explanation" : "Empty string means no common prefix possible",
              "id" : "0134b93a-0905-4121-aaaa-2adb99922852",
              "input" : "strs = [\"\"]"
            }
          ]
        }
      ],
      "id" : "516ec92a-4848-482b-a3ff-81abccb0745a",
      "lastUpdated" : "2026-02-06T08:24:18Z",
      "problemSlug" : "longest-common-prefix",
      "relatedProblems" : [
        "longest-common-suffix"
      ],
      "summary" : "Find the longest common prefix among an array of strings. Compare characters at each position across all strings until a mismatch is found or a string ends."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create set from nums\n2. For each num: if num-1 not in set, count consecutive\n3. Track max length",
          "code" : "func longestConsecutive(_ nums: [Int]) -> Int {\n    let numSet = Set(nums)\n    var maxLength = 0\n    \n    for num in numSet {\n        \/\/ Only start if this is beginning of sequence\n        if !numSet.contains(num - 1) {\n            var current = num\n            var length = 1\n            while numSet.contains(current + 1) {\n                current += 1\n                length += 1\n            }\n            maxLength = max(maxLength, length)\n        }\n    }\n    \n    return maxLength\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Set storage",
            "time" : "O(n)",
            "timeExplanation" : "Each element visited at most twice"
          },
          "explanation" : "Only counting from sequence starts ensures O(n) - each element visited at most twice.",
          "id" : "550e8400-e29b-41d4-a716-446655440153",
          "intuition" : "Put all in set. For each number, if n-1 not in set, it's a sequence start. Count forward.",
          "name" : "Hash Set",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "Sequence [1,2,3,4]",
              "id" : "550e8400-e29b-41d4-a716-446655440259",
              "input" : "[100,4,200,1,3,2]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440042",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "longest-consecutive-sequence",
      "relatedProblems" : [
        "binary-tree-longest-consecutive-sequence"
      ],
      "summary" : "Find longest consecutive sequence in O(n). Use set, only start counting from sequence starts."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with an empty subsequence and try adding each element from the array, checking if the new subsequence is still increasing, then keep track of the longest increasing subsequence found so far.",
          "code" : "func findLengthOfLCIS(nums: [Int]) -> Int { let n = nums.count; var maxLength = 1; for i in 0..<n { var currentLength = 1; for j in i+1..<n { if nums[j] > nums[j-1] { currentLength += 1 } else { break } }; if currentLength > maxLength { maxLength = currentLength } }; return maxLength }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are using a fixed amount of space to store the variables.",
            "time" : "O(n^2)",
            "timeExplanation" : "The outer loop runs n times and the inner loop also runs up to n times, leading to quadratic time complexity."
          },
          "explanation" : "This method involves generating all possible subsequences of the array and checking each one to see if it is an increasing subsequence, which results in high time complexity due to the exponential number of subsequences.",
          "id" : "4feb51fc-0f7e-44f4-b658-4234e67d985a",
          "intuition" : "This approach works by iterating through the array and checking every possible subsequence to see if it is an increasing subsequence.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The longest continuous increasing subsequence is [1,3,5].",
              "id" : "ea848b08-a589-48c5-8f2f-35d4d2dfefa0",
              "input" : "nums = [1,3,5,4,7]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The longest continuous increasing subsequence is [2].",
              "id" : "1cf69c1f-b886-4680-8620-2a6269435188",
              "input" : "nums = [2,2,2,2,2]"
            }
          ]
        },
        {
          "approach" : "Start with a current length of 1 and iterate through the array, if the current element is greater than the previous one, increment the current length, otherwise reset it to 1.",
          "code" : "func findLengthOfLCIS(nums: [Int]) -> Int { if nums.count == 0 { return 0 }; var maxLength = 1; var currentLength = 1; for i in 1..<nums.count { if nums[i] > nums[i-1] { currentLength += 1 } else { currentLength = 1 } }; if currentLength > maxLength { maxLength = currentLength }; return maxLength }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are using a fixed amount of space to store the variables.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are making a single pass through the array."
          },
          "explanation" : "This method involves single-pass iteration through the array, resulting in linear time complexity.",
          "id" : "d6b14b6e-fe3c-4271-b9fb-677fd29ce8b9",
          "intuition" : "This approach works by iterating through the array and keeping track of the current length of the increasing subsequence, resetting it whenever we encounter a non-increasing element.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The longest continuous increasing subsequence is [1,3,5].",
              "id" : "695ab9b7-723c-4bcf-9387-f04fb3739374",
              "input" : "nums = [1,3,5,4,7]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The longest continuous increasing subsequence is [2].",
              "id" : "eb1b9496-6a0d-445d-a166-316982c6f14e",
              "input" : "nums = [2,2,2,2,2]"
            }
          ]
        }
      ],
      "id" : "fab941d2-d161-437d-a106-bcc3f2f10637",
      "lastUpdated" : "2026-02-06T21:32:53Z",
      "problemSlug" : "longest-continuous-increasing-subsequence",
      "relatedProblems" : [
        "longest-increasing-subsequence",
        "maximum-subarray"
      ],
      "summary" : "The problem requires finding the length of the longest continuous increasing subsequence in a given array of integers, where a key insight is to track the length of the current increasing subsequence as we iterate through the array."
    },
    {
      "approaches" : [
        {
          "approach" : "1. candidate=first, count=1\n2. For each element: if matches candidate, count++; else count--\n3. If count=0, new candidate\n4. Return candidate",
          "code" : "func majorityElement(_ nums: [Int]) -> Int {\n    var candidate = nums[0]\n    var count = 1\n    for i in 1..<nums.count {\n        if count == 0 {\n            candidate = nums[i]\n            count = 1\n        } else if nums[i] == candidate {\n            count += 1\n        } else {\n            count -= 1\n        }\n    }\n    return candidate\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Two variables",
            "time" : "O(n)",
            "timeExplanation" : "Single pass"
          },
          "explanation" : "When count reaches 0, we've seen equal numbers of candidate and non-candidate elements. The majority still has more remaining than any other.",
          "id" : "e7a35fb1-6142-4421-9210-db37cbbbdf72",
          "intuition" : "Pairs of different elements cancel out. Majority element survives because it has more than half.",
          "name" : "Boyer-Moore Voting",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "3 appears 2 times > 3\/2",
              "id" : "ad4712e5-d896-4a24-a993-47a365dfc5dc",
              "input" : "nums = [3,2,3]"
            }
          ]
        }
      ],
      "id" : "a6c1f591-a1d5-41cf-a9c1-de9fb94ad8b7",
      "lastUpdated" : "2026-02-06T00:56:20.970Z",
      "problemSlug" : "majority-element",
      "relatedProblems" : [
        "majority-element-ii"
      ],
      "summary" : "Find element appearing more than n\/2 times. Boyer-Moore voting: maintain candidate and count, guaranteed to find majority."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over the array to count the frequency of each element using a hash table. 2. Iterate over the hash table to find elements with frequency more than n\/3.",
          "code" : "func majorityElement(_ nums: [Int]) -> [Int] { let count = nums.count; var freq: [Int:Int] = [:]; for num in nums { freq[num, default: 0] += 1 }; return freq.filter { $0.value > count\/3 }.map { $0.key } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a hash table to store the frequencies of elements, which can take up to n space in the worst case.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the array twice: once to count the frequencies and once to find the majority elements."
          },
          "explanation" : "This approach involves two passes over the data: one to count the frequencies and one to find the majority elements. It is simple but not efficient for large arrays.",
          "id" : "0894629e-c861-45f6-8cdb-8290ec7fa629",
          "intuition" : "This approach works by counting the frequency of each element in the array and checking if it appears more than n\/3 times.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[3]",
              "explanation" : "The element 3 appears more than n\/3 times in the array.",
              "id" : "a140d612-4bcf-4de0-8170-f016ba6c1425",
              "input" : "nums = [3,2,3]"
            },
            {
              "expectedOutput" : "[1,2]",
              "explanation" : "The elements 1 and 2 both appear more than n\/3 times in the array.",
              "id" : "e0290e3c-b325-42b3-8cad-d6c699a3f5d0",
              "input" : "nums = [1,1,1,3,3,2,2,2]"
            }
          ]
        },
        {
          "approach" : "1. Initialize two candidate variables and their respective counts to zero. 2. Iterate over the array, updating the candidate variables and their counts based on the elements. 3. Verify the candidates by counting their occurrences in the array.",
          "code" : "func majorityElement(_ nums: [Int]) -> [Int] { var candidate1 = 0, candidate2 = 1, count1 = 0, count2 = 0; for num in nums { if num == candidate1 { count1 += 1 } else if num == candidate2 { count2 += 1 } else if count1 == 0 { candidate1 = num; count1 = 1 } else if count2 == 0 { candidate2 = num; count2 = 1 } else { count1 -= 1; count2 -= 1 } }; var res: [Int] = []; let count = nums.count; if nums.filter { $0 == candidate1 }.count > count\/3 { res.append(candidate1) }; if nums.filter { $0 == candidate2 }.count > count\/3 { res.append(candidate2) }; return res }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the candidate variables and their counts.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over the array twice: once to find the candidates and once to verify them."
          },
          "explanation" : "This approach involves one pass over the data to find the candidates and one pass to verify them. It is more efficient than the brute force approach for large arrays.",
          "id" : "e9c06a21-86a3-438d-a0d2-3e9693d3f771",
          "intuition" : "This approach works by maintaining two candidate variables and their respective counts, and updating them based on the elements in the array.",
          "name" : "Optimized Boyer-Moore Majority Vote",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[3]",
              "explanation" : "The element 3 appears more than n\/3 times in the array.",
              "id" : "c831394e-53e1-4ee6-9d8b-b1e68d1e6194",
              "input" : "nums = [3,2,3]"
            },
            {
              "expectedOutput" : "[1,2]",
              "explanation" : "The elements 1 and 2 both appear more than n\/3 times in the array.",
              "id" : "36c0df3f-3c39-4cfe-b35d-3cd698f4a10e",
              "input" : "nums = [1,1,1,3,3,2,2,2]"
            }
          ]
        }
      ],
      "id" : "ccb27d08-9861-49fc-8dd5-05bdb0622ae6",
      "lastUpdated" : "2026-02-06T21:11:04Z",
      "problemSlug" : "majority-element-ii",
      "relatedProblems" : [
        "majority-element",
        "majority-element-ii"
      ],
      "summary" : "The Majority Element II problem asks to find all elements in an array that appear more than n\/3 times, where n is the length of the array. The key insight is to use a hash table or a modified Boyer-Moore Majority Vote algorithm to count the frequency of elements and identify the majority elements."
    },
    {
      "approaches" : [
        {
          "approach" : "Initialize the maximum count of consecutive ones to 0, then iterate over the array with two nested loops to generate all possible subarrays. For each subarray, count the number of consecutive ones and update the maximum count if necessary.",
          "code" : "func findMaxConsecutiveOnes(_ nums: [Int]) -> Int { \n    var maxCount = 0 \n    for i in 0..<nums.count { \n        for j in i..<nums.count { \n            var count = 0 \n            for k in i...j { \n                if nums[k] == 1 { \n                    count += 1 \n                } \n            } \n            maxCount = max(maxCount, count) \n        } \n    } \n    return maxCount \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the maximum count and the loop variables.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is O(n^3) due to the three nested loops."
          },
          "explanation" : "This approach has a high time complexity due to the nested loops, but it is simple to implement and can be used as a baseline for comparison with more optimized approaches.",
          "id" : "2f5b5e1e-199f-4ae5-82ff-90b5990f9fd7",
          "intuition" : "This approach works by checking every possible subarray in the given array and counting the maximum number of consecutive ones in each subarray.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum number of consecutive ones is 3, which can be found in the subarray [1,1,1].",
              "id" : "69ae5cb1-ddfc-4b3a-a821-3f88be374726",
              "input" : "nums = [1,1,0,1,1,1]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The maximum number of consecutive ones is 4, which can be found in the subarray [1,1,1,1].",
              "id" : "b7570deb-b6a5-41f8-94ef-0174aefc9c1a",
              "input" : "nums = [1,1,1,1,0,1,1]"
            }
          ]
        },
        {
          "approach" : "Initialize the maximum count of consecutive ones to 0 and the current count of consecutive ones to 0. Then, iterate over the array and update the current count of consecutive ones based on the current element. If the current element is 1, increment the current count; otherwise, reset the current count to 0. Update the maximum count if the current count is greater than the maximum count.",
          "code" : "func findMaxConsecutiveOnes(_ nums: [Int]) -> Int { \n    var maxCount = 0 \n    var currentCount = 0 \n    for num in nums { \n        if num == 1 { \n            currentCount += 1 \n            maxCount = max(maxCount, currentCount) \n        } else { \n            currentCount = 0 \n        } \n    } \n    return maxCount \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we only use a constant amount of space to store the maximum count and the current count.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we only need to iterate over the array once."
          },
          "explanation" : "This approach has a low time complexity because it only requires a single loop to iterate over the array.",
          "id" : "618871cd-78eb-432a-a0f4-5a1fcaf647bc",
          "intuition" : "This approach works by using a single loop to iterate over the array and keep track of the maximum count of consecutive ones.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum number of consecutive ones is 3, which can be found in the subarray [1,1,1].",
              "id" : "564f9b45-a2aa-474b-89e0-92a60b3c31e3",
              "input" : "nums = [1,1,0,1,1,1]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The maximum number of consecutive ones is 4, which can be found in the subarray [1,1,1,1].",
              "id" : "a6477c28-2cf4-4ed5-888d-077a38832e5b",
              "input" : "nums = [1,1,1,1,0,1,1]"
            }
          ]
        }
      ],
      "id" : "a528d0d0-d260-44e5-be16-6d8099be6adf",
      "lastUpdated" : "2026-02-06T21:21:39Z",
      "problemSlug" : "max-consecutive-ones",
      "relatedProblems" : [
        "contains-duplicate",
        "max-subarray"
      ],
      "summary" : "The problem is to find the maximum number of consecutive ones in a given binary array, and the key insight is to use a sliding window approach to keep track of the maximum count of consecutive ones."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a loop to go through each seat in the row. 2. For each seat, calculate the minimum distance to the closest person. 3. Update the maximum distance if the current distance is larger.",
          "code" : "\n           import Foundation\n\n           func maxDistToClosest(_ seats: [Int]) -> Int {\n               var maxDist = 0\n\n               for i in 0..<seats.count {\n                   if seats[i] == 0 {\n                       var minDist = seats.count\n                       for j in 0..<seats.count {\n                           if seats[j] == 1 {\n                               minDist = min(minDist, abs(i - j))\n                           }\n                       }\n                       maxDist = max(maxDist, minDist)\n                   }\n               }\n               return maxDist\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use a constant amount of space to store the maximum distance and the current seat index.",
            "time" : "O(n^2)",
            "timeExplanation" : "We use two nested loops to calculate the minimum distance to the closest person for each seat."
          },
          "explanation" : "The brute-force approach works by checking every seat and calculating the minimum distance to the closest person. It uses two nested loops to achieve this, resulting in a time complexity of O(n^2).",
          "id" : "d81b361e-5ca4-44b9-bb12-c3552805b2ab",
          "intuition" : "This approach checks every possible seat and calculates the minimum distance to the closest person.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The maximum distance we can achieve from the closest person is 2 units, which can be achieved by sitting at the seat with index 3 or 4.",
              "id" : "bbc278cc-ad4c-4304-8660-2c4458467500",
              "input" : "seats = [1,0,0,0,1,0,1]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum distance we can achieve from the closest person is 3 units, which can be achieved by sitting at the last seat.",
              "id" : "6e76fd6b-336a-452f-9dc4-81941956bf3f",
              "input" : "seats = [1,0,0,0]"
            }
          ]
        },
        {
          "approach" : "1. Initialize the maximum distance to 0. 2. Calculate the distance from the first occupied seat to the left edge of the row and update the maximum distance. 3. Iterate over the occupied seats, calculate the distance between the current seat and the previous occupied seat, and update the maximum distance. 4. Calculate the distance from the last occupied seat to the right edge of the row and update the maximum distance.",
          "code" : "\n           import Foundation\n\n           func maxDistToClosest(_ seats: [Int]) -> Int {\n               var occupiedSeats: [Int] = []\n\n               for i in 0..<seats.count {\n                   if seats[i] == 1 {\n                       occupiedSeats.append(i)\n                   }\n               }\n\n               var maxDist = 0\n\n               if !occupiedSeats.isEmpty {\n                   maxDist = max(maxDist, occupiedSeats[0])\n                   maxDist = max(maxDist, seats.count - 1 - occupiedSeats[occupiedSeats.count - 1])\n               }\n\n               for i in 1..<occupiedSeats.count {\n                   maxDist = max(maxDist, (occupiedSeats[i] - occupiedSeats[i-1]) \/ 2)\n               }\n\n               return maxDist\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "In the worst case, we need to store all the occupied seats in the row.",
            "time" : "O(n)",
            "timeExplanation" : "We only need to iterate over the seats once to find the occupied seats."
          },
          "explanation" : "This optimized approach works by only considering the occupied seats and the edges of the row, resulting in a time complexity of O(n).",
          "id" : "f04da012-b8a3-43ac-8b8a-b58e21ae4035",
          "intuition" : "We can find the maximum distance by checking the distances between the occupied seats and the edges of the row.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The maximum distance we can achieve from the closest person is 2 units, which can be achieved by sitting at the seat with index 3 or 4.",
              "id" : "2c6b2419-aaaa-487b-8ec9-6e6345e46833",
              "input" : "seats = [1,0,0,0,1,0,1]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The maximum distance we can achieve from the closest person is 3 units, which can be achieved by sitting at the last seat.",
              "id" : "b23ecc94-1a02-45e9-a9a7-bf8d1ba1131a",
              "input" : "seats = [1,0,0,0]"
            }
          ]
        }
      ],
      "id" : "ac19cad0-7117-4b44-908b-9e3ee10b962c",
      "lastUpdated" : "2026-02-06T21:44:22Z",
      "problemSlug" : "maximize-distance-to-closest-person",
      "relatedProblems" : [
        "max-consecutive-ones",
        "shortest-unsorted-continuous-subarray"
      ],
      "summary" : "This problem involves finding the maximum distance we can achieve from the closest person in a row of seats. The key insight is to iterate over the occupied seats and calculate the distances between them."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the array in ascending order. Then, initialize the maximum gap as the difference between the first two elements. Iterate over the sorted array, updating the maximum gap whenever a larger gap is found.",
          "code" : "\nfunc maximumGap(_ nums: [Int]) -> Int {\n    guard nums.count > 1 else { return 0 }\n    \n    let sortedNums = nums.sorted()\n    var maxGap = sortedNums[1] - sortedNums[0]\n    \n    for i in 1...sortedNums.count - 1 {\n        maxGap = max(maxGap, sortedNums[i] - sortedNums[i - 1])\n    }\n    \n    return maxGap\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the sorted array.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is dominated by the sorting step, which takes O(n log n) time in Swift."
          },
          "explanation" : "This approach works by first arranging the numbers in order, making it easy to compare adjacent numbers and find the maximum gap. However, this approach is not efficient for large inputs due to the sorting step.",
          "id" : "fde0c04a-19a8-47b1-b96d-19819ead5b11",
          "intuition" : "The brute force approach involves sorting the array first and then iterating over the sorted array to find the maximum gap between any two adjacent numbers.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "After sorting, the array becomes [1, 3, 6, 9], and the maximum gap is between 3 and 6, which is 3.",
              "id" : "364e52e5-4e03-4a4f-bdef-73c4916b3688",
              "input" : "nums = [3, 6, 9, 1]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is only one number in the array, so the maximum gap is 0.",
              "id" : "76afa72b-d061-44b8-9a4e-0d1a584b0081",
              "input" : "nums = [10]"
            }
          ]
        },
        {
          "approach" : "First, find the minimum and maximum numbers in the array. Then, calculate the bucket size and create empty buckets. Distribute the numbers into the buckets, and finally, iterate over the non-empty buckets to find the maximum gap.",
          "code" : "\nfunc maximumGap(_ nums: [Int]) -> Int {\n    guard nums.count > 1 else { return 0 }\n    \n    let minNum = nums.min()!\n    let maxNum = nums.max()!\n    \n    if minNum == maxNum {\n        return 0\n    }\n    \n    let bucketSize = max(1, (maxNum - minNum) \/ (nums.count - 1))\n    let bucketCount = (maxNum - minNum) \/ bucketSize + 1\n    \n    var buckets: [[Int]] = Array(repeating: [], count: bucketCount)\n    \n    for num in nums {\n        let bucketIndex = (num - minNum) \/ bucketSize\n        buckets[bucketIndex].append(num)\n    }\n    \n    var maxGap = 0\n    var prevMax = minNum\n    \n    for i in 0...bucketCount - 1 {\n        if !buckets[i].isEmpty {\n            if i > 0 {\n                maxGap = max(maxGap, buckets[i].first! - prevMax)\n            }\n            prevMax = buckets[i].max()!\n        }\n    }\n    \n    return maxGap\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) due to the buckets array.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we iterate over the numbers twice: once to distribute them into buckets and once to find the maximum gap."
          },
          "explanation" : "This approach works by distributing the numbers into buckets of equal size, ensuring that the maximum gap is either within a bucket or between two adjacent buckets. By only considering non-empty buckets, the approach efficiently finds the maximum gap without having to compare all pairs of numbers.",
          "id" : "01aa21f6-86cc-4384-8adb-2e7319960d09",
          "intuition" : "The bucket sort approach maximizes the utilization of each bucket by distributing the numbers into buckets of equal size, making it possible to find the maximum gap efficiently.",
          "name" : "Bucket Sort",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "After distributing the numbers into buckets, the maximum gap is between 3 and 6, which is 3.",
              "id" : "6a20223a-f8e7-4d13-871b-b827da988735",
              "input" : "nums = [3, 6, 9, 1]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There is only one number in the array, so the maximum gap is 0.",
              "id" : "27d1fc0f-146d-4d82-8284-f4d272333df7",
              "input" : "nums = [10]"
            }
          ]
        }
      ],
      "id" : "c99fa014-f194-4e18-a991-8c90ba805426",
      "lastUpdated" : "2026-02-06T21:07:45Z",
      "problemSlug" : "maximum-gap",
      "relatedProblems" : [
        "top-k-frequent-elements",
        "kth-largest-element-in-an-array"
      ],
      "summary" : "The maximum gap problem asks to find the maximum gap between any two adjacent numbers in a sorted array, which can be solved using a bucket sort approach by maximizing the utilization of each bucket."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Start from any node\n2. Use min-heap to track cheapest edges to unvisited nodes\n3. Add cheapest edge, mark node visited\n4. Add all edges from new node to heap\n5. Repeat until all nodes connected",
          "code" : "func minCostConnectPoints(_ points: [[Int]]) -> Int {\n    let n = points.count\n    var visited = [Bool](repeating: false, count: n)\n    var minCost = [Int](repeating: Int.max, count: n)\n    minCost[0] = 0\n    var totalCost = 0\n    \n    for _ in 0..<n {\n        var minIdx = -1\n        var minVal = Int.max\n        for j in 0..<n {\n            if !visited[j] && minCost[j] < minVal {\n                minVal = minCost[j]\n                minIdx = j\n            }\n        }\n        \n        visited[minIdx] = true\n        totalCost += minVal\n        \n        for j in 0..<n {\n            if !visited[j] {\n                let dist = abs(points[minIdx][0] - points[j][0]) + \n                           abs(points[minIdx][1] - points[j][1])\n                minCost[j] = min(minCost[j], dist)\n            }\n        }\n    }\n    \n    return totalCost\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Visited and minCost arrays",
            "time" : "O(n)",
            "timeExplanation" : "n iterations, each scans n nodes"
          },
          "explanation" : "Prim's builds MST by always picking minimum weight edge to expand the tree.",
          "id" : "550e8400-e29b-41d4-a716-446655440172",
          "intuition" : "Greedily add cheapest edge connecting MST to a new node.",
          "name" : "Prim's Algorithm",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "20",
              "explanation" : "Connect points with minimum total Manhattan distance",
              "id" : "550e8400-e29b-41d4-a716-446655440278",
              "input" : "[[0,0],[2,2],[3,10],[5,2],[7,0]]"
            }
          ]
        }
      ],
      "id" : "550e8400-e29b-41d4-a716-446655440061",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "min-cost-to-connect-all-points",
      "relatedProblems" : [
        "minimum-spanning-tree",
        "connecting-cities-with-minimum-cost"
      ],
      "summary" : "Minimum spanning tree of points using Manhattan distance. Use Prim's or Kruskal's."
    },
    {
      "approaches" : [
        {
          "approach" : "Start from each unrevealed cell and use DFS to explore and reveal the cells.",
          "code" : "import Foundation\n\nclass Solution {\n    func updateBoard(_ board: [[Character]], _ click: [Int]) -> [[Character]] {\n        let (x, y) = (click[0], click[1])\n        let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n        var board = board\n        if board[x][y] == \"M\" {\n            board[x][y] = \"X\"\n            return board\n        }\n        var queue = [(x, y)]\n        while !queue.isEmpty {\n            let (currX, currY) = queue.removeFirst()\n            var count = 0\n            for dir in directions {\n                let newX = currX + dir[0]\n                let newY = currY + dir[1]\n                if newX >= 0 && newX < board.count && newY >= 0 && newY < board[0].count && board[newX][newY] == \"M\" {\n                    count += 1\n                }\n            }\n            if count > 0 {\n                board[currX][currY] = Character(String(count))\n            } else {\n                board[currX][currY] = \"B\"\n                for dir in directions {\n                    let newX = currX + dir[0]\n                    let newY = currY + dir[1]\n                    if newX >= 0 && newX < board.count && newY >= 0 && newY < board[0].count && board[newX][newY] == \"E\" {\n                        queue.append((newX, newY))\n                    }\n                }\n            }\n        }\n        return board\n    }\n}",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because we need to store the queue of cells to be explored, and in the worst-case scenario, the queue can contain every cell in the matrix.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because in the worst-case scenario, we may need to explore every cell in the matrix."
          },
          "explanation" : "This approach is not efficient because it involves checking every cell in the matrix and using DFS to reveal the cells, resulting in a lot of repeated work.",
          "id" : "8376ff50-9bcb-439e-98ca-df1e588c6c51",
          "intuition" : "This approach involves checking every cell in the matrix and using DFS to reveal the cells.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
              "explanation" : "This test case involves clicking on a cell that has no adjacent mines.",
              "id" : "c56f3389-0b35-4235-b5b4-9708e021d5d9",
              "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"]], [1,2]"
            },
            {
              "expectedOutput" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
              "explanation" : "This test case involves clicking on a cell that has an adjacent mine.",
              "id" : "2c842be1-ef54-4659-b324-9440d59210e9",
              "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], [3,0]"
            }
          ]
        },
        {
          "approach" : "Start from the clicked cell and use BFS to explore and reveal the cells, and check the number of adjacent mines for each cell before exploring it.",
          "code" : "import Foundation\n\nclass Solution {\n    func updateBoard(_ board: [[Character]], _ click: [Int]) -> [[Character]] {\n        let (x, y) = (click[0], click[1])\n        let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n        var board = board\n        if board[x][y] == \"M\" {\n            board[x][y] = \"X\"\n            return board\n        }\n        var queue = [(x, y)]\n        board[x][y] = \"B\"\n        while !queue.isEmpty {\n            let (currX, currY) = queue.removeFirst()\n            for dir in directions {\n                let newX = currX + dir[0]\n                let newY = currY + dir[1]\n                if newX >= 0 && newX < board.count && newY >= 0 && newY < board[0].count {\n                    if board[newX][newY] == \"E\" {\n                        var count = 0\n                        for dir2 in directions {\n                            let newX2 = newX + dir2[0]\n                            let newY2 = newY + dir2[1]\n                            if newX2 >= 0 && newX2 < board.count && newY2 >= 0 && newY2 < board[0].count && board[newX2][newY2] == \"M\" {\n                                count += 1\n                            }\n                        }\n                        if count > 0 {\n                            board[newX][newY] = Character(String(count))\n                        } else {\n                            board[newX][newY] = \"B\"\n                            queue.append((newX, newY))\n                        }\n                    }\n                }\n            }\n        }\n        return board\n    }\n}",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because we need to store the queue of cells to be explored, and in the worst-case scenario, the queue can contain every cell in the matrix.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because in the worst-case scenario, we may need to explore every cell in the matrix."
          },
          "explanation" : "This approach is more efficient than the brute-force approach because it avoids exploring cells that have already been revealed, and it also avoids exploring cells that have no adjacent mines.",
          "id" : "1b08ea23-ba3a-429d-8094-f56ada370e13",
          "intuition" : "This approach involves using a BFS algorithm to explore and reveal the cells, and it also involves checking the number of adjacent mines for each cell before exploring it.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
              "explanation" : "This test case involves clicking on a cell that has no adjacent mines.",
              "id" : "9ec07287-9da2-4b13-a7f7-d48a984e25a5",
              "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], [3,0]"
            },
            {
              "expectedOutput" : "[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]",
              "explanation" : "This test case involves clicking on a cell that has an adjacent mine.",
              "id" : "6cc360c7-2c29-43fa-a0c5-bc2b8bc43db3",
              "input" : "[[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\",\"E\"]], [1,2]"
            }
          ]
        }
      ],
      "id" : "a8d9073b-0d76-4f81-b478-4d4e39c184d1",
      "lastUpdated" : "2026-02-06T21:24:38Z",
      "problemSlug" : "minesweeper",
      "relatedProblems" : [
        "number_of_islands",
        "rotting_oranges"
      ],
      "summary" : "The Minesweeper problem involves a matrix where each cell represents a space that may or may not contain a mine, and the goal is to reveal all safe cells without detonating a mine. The key insight is to use a Depth-First Search (DFS) or Breadth-First Search (BFS) algorithm to explore and reveal the cells."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a nested loop structure to compare each element in the first list with each element in the second list. Keep track of the minimum sum and the indices that achieve this sum.",
          "code" : "func findRestaurant(list1: [String], list2: [String]) -> [Int] { let len1 = list1.count; let len2 = list2.count; var minSum = Int.max; var result: [Int] = []; for i in 0..<len1 { for j in 0..<len2 { if list1[i] == list2[j] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } } return result; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are only using a constant amount of space to store the minimum sum and the indices.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because for each element in the first list, we are potentially iterating over all elements in the second list."
          },
          "explanation" : "The time complexity of this approach is O(n*m) because for each element in the first list, we are potentially iterating over all elements in the second list. The space complexity is O(1) because we are only using a constant amount of space to store the minimum sum and the indices.",
          "id" : "c96a13ac-6eb2-4363-a8b6-6326b1da5b30",
          "intuition" : "This approach works by iterating over each element in the first list and then iterating over each element in the second list to find the minimum index sum.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0]",
              "explanation" : "The minimum index sum is achieved by the restaurant 'Shogun' which is at index 0 in both lists.",
              "id" : "1f0ac4b3-b4bc-4971-a29b-ec7a1eee86ba",
              "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]"
            },
            {
              "expectedOutput" : "[1,2]",
              "explanation" : "The minimum index sum is achieved by the restaurants 'Shogun' and 'Burger King' which have the same index sum in both lists.",
              "id" : "28db8770-8f92-4b76-a21b-5c08919653e4",
              "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]"
            }
          ]
        },
        {
          "approach" : "Create a hash table to store the indices of the elements in the first list. Then, iterate over the second list and for each element, check if it exists in the hash table. If it does, calculate the index sum and update the minimum sum and the indices if necessary.",
          "code" : "func findRestaurant(list1: [String], list2: [String]) -> [Int] { var dict: [String: Int] = [:]; var minSum = Int.max; var result: [Int] = []; for i in 0..<list1.count { dict[list1[i]] = i; } for j in 0..<list2.count { if let i = dict[list2[j]] { let sum = i + j; if sum < minSum { minSum = sum; result = [i, j]; } else if sum == minSum { result.append(i); result.append(j); } } } return result; }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are using a hash table to store the indices of the elements in the first list.",
            "time" : "O(n + m)",
            "timeExplanation" : "The time complexity is O(n + m) because we are iterating over each list once."
          },
          "explanation" : "The time complexity of this approach is O(n + m) because we are iterating over each list once. The space complexity is O(n) because we are using a hash table to store the indices of the elements in the first list.",
          "id" : "693b8142-0efa-4f36-a53d-e426d50a5425",
          "intuition" : "This approach works by using a hash table to store the indices of the first list and then iterating over the second list to find the minimum index sum.",
          "name" : "Hash Table",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[0]",
              "explanation" : "The minimum index sum is achieved by the restaurant 'Shogun' which is at index 0 in the first list and index 3 in the second list.",
              "id" : "0ab2deff-4f29-4660-bdfc-c9742d815d69",
              "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]"
            },
            {
              "expectedOutput" : "[1,2]",
              "explanation" : "The minimum index sum is achieved by the restaurants 'Shogun' and 'Burger King' which have the same index sum in both lists.",
              "id" : "b6b8c3e6-6577-45a5-9c4e-d1d6f0957af1",
              "input" : "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]"
            }
          ]
        }
      ],
      "id" : "1b3515bc-e102-4e60-b876-2644161f28bb",
      "lastUpdated" : "2026-02-06T21:28:09Z",
      "problemSlug" : "minimum-index-sum-of-two-lists",
      "relatedProblems" : [
        "intersection-of-two-arrays",
        "single-number"
      ],
      "summary" : "This problem involves finding the minimum index sum of two lists. The key insight is to use a hash table to store the indices of the first list and then iterate over the second list to find the minimum sum."
    },
    {
      "approaches" : [
        {
          "approach" : "Create two separate boolean functions to check for increasing and decreasing sequences, and then combine them.",
          "code" : "\nfunc isMonotonic(_ nums: [Int]) -> Bool {\n    var increasing = true\n    var decreasing = true\n\n    for i in 1..<nums.count {\n        if nums[i] < nums[i-1] {\n            increasing = false\n        }\n        if nums[i] > nums[i-1] {\n            decreasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No additional space is used that scales with the input size.",
            "time" : "O(n)",
            "timeExplanation" : "The solution has to iterate through each element in the array once."
          },
          "explanation" : "The brute-force method involves checking every element in the array against each other, leading to a higher time complexity but is more straightforward.",
          "id" : "2df80390-b880-46a4-8c6e-75e2a2e3f0ed",
          "intuition" : "Check every possible pair of elements in the array to see if it's monotonically increasing or decreasing.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Array is monotonically increasing.",
              "id" : "820f14f0-693d-40b0-a115-06f3dd655b34",
              "input" : "nums = [1,2,2,3]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Array is monotonically decreasing.",
              "id" : "e85e000c-7ae4-43bb-8184-6b85c5007d59",
              "input" : "nums = [6,5,4,4]"
            }
          ]
        },
        {
          "approach" : "Iterate through the array once, checking for both increasing and decreasing conditions with a single set of loop variables.",
          "code" : "\nfunc isMonotonic(_ nums: [Int]) -> Bool {\n    var increasing = false\n    var decreasing = false\n\n    for i in 1..<nums.count {\n        if nums[i] > nums[i-1] {\n            increasing = true\n        }\n        if nums[i] < nums[i-1] {\n            decreasing = true\n        }\n        if increasing && decreasing {\n            return false\n        }\n    }\n    \n    return true\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only a constant amount of space is used to store the state of increasing and decreasing checks.",
            "time" : "O(n)",
            "timeExplanation" : "Only a single pass through the array is needed."
          },
          "explanation" : "Maintain variables to track if an increase or decrease has occurred. Once both have occurred, return false. If the loop completes without returning false, the array is monotonic.",
          "id" : "40e96d14-58b2-4f3d-9372-b167f5f970e5",
          "intuition" : "Instead of using additional space or more complex operations, the optimized solution maintains a single pass through the array and uses the same increasing and decreasing checks.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Array remains unchanged for a portion and then increases.",
              "id" : "e6ecb58a-bb1f-4b86-90b1-a1e4f928e732",
              "input" : "nums = [1,2,2,3]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Array decreases throughout.",
              "id" : "95729872-2abe-40cd-95f1-4398a851419d",
              "input" : "nums = [6,5,4,2,1]"
            }
          ]
        }
      ],
      "id" : "586825db-2d82-4e77-8e75-66fad9cb6901",
      "lastUpdated" : "2026-02-06T21:47:03Z",
      "problemSlug" : "monotonic-array",
      "relatedProblems" : [
        "height-checker",
        "min-cost-climbing-stairs"
      ],
      "summary" : "The problem asks to determine whether an array is monotonic, i.e., it is either monotonically increasing or decreasing. The key insight is to check for both increasing and decreasing conditions."
    },
    {
      "approaches" : [
        {
          "approach" : "Split the paragraph into words, iterate over each word, and check if it's banned. If not, increment its frequency count. Finally, find the word with the highest frequency.",
          "code" : "\n       func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\n         let paragraph = paragraph.lowercased().replacingOccurrences(of: \"$|\", with: \"\", options: .regularExpression)\n         let words = paragraph.components(separatedBy: \" \")\n         var wordCount: [String: Int] = [:]\n         for word in words {\n           if !banned.contains(word) {\n             wordCount[word] = (wordCount[word] ?? 0) + 1\n           }\n         }\n         let sortedWords = wordCount.sorted(by: { $0.value > $1.value })\n         return sortedWords.first!.key\n       }\n       ",
          "complexity" : {
            "space" : "O(n+m)",
            "spaceExplanation" : "We store the word counts in a dictionary (O(n)) and the banned words in an array (O(m)).",
            "time" : "O(n*m*log(m))",
            "timeExplanation" : "We iterate over each word in the paragraph (O(n)) and then check if it's in the list of banned words (O(m)). We also sort the word counts (O(m*log(m)))."
          },
          "explanation" : "We start by converting the paragraph to lowercase and splitting it into words. We then iterate over each word and check if it's in the list of banned words. If it's not, we increment its frequency count in a dictionary. After counting all the words, we find the word with the highest frequency.",
          "id" : "1bc1984f-7551-4102-83be-e86c2ca41a32",
          "intuition" : "This approach works by iterating over each word in the paragraph and checking if it's banned. If not, it increments the word's frequency count.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "ball",
              "explanation" : "The word 'hit' is banned, so we ignore it. The word 'ball' appears twice, so it's the most frequent word.",
              "id" : "8b7ef8d9-93a3-479d-914b-ede8afd4c41e",
              "input" : "paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]"
            },
            {
              "expectedOutput" : "a",
              "explanation" : "There are no banned words, so we simply count the frequency of each word. The word 'a' appears once, so it's the most frequent word.",
              "id" : "4fbe5bb0-edbd-4095-bab7-c2ed44d2af50",
              "input" : "paragraph = \"a.\", banned = []"
            }
          ]
        },
        {
          "approach" : "Split the paragraph into words, use a set to store the banned words, and a dictionary to count the word frequencies.",
          "code" : "\n       func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\n         let paragraph = paragraph.lowercased().replacingOccurrences(of: \"$|\", with: \"\", options: .regularExpression)\n         let words = paragraph.components(separatedBy: \" \")\n         var wordCount: [String: Int] = [:]\n         let bannedSet = Set(banned.map { $0.lowercased() })\n         for word in words {\n           if !bannedSet.contains(word) {\n             wordCount[word] = (wordCount[word] ?? 0) + 1\n           }\n         }\n         let sortedWords = wordCount.sorted(by: { $0.value > $1.value })\n         return sortedWords.first!.key\n       }\n       ",
          "complexity" : {
            "space" : "O(n+m)",
            "spaceExplanation" : "We store the word counts in a dictionary (O(n)) and the banned words in a set (O(m)).",
            "time" : "O(n+m)",
            "timeExplanation" : "We iterate over each word in the paragraph (O(n)) and create a set of banned words (O(m))."
          },
          "explanation" : "We start by converting the paragraph to lowercase and splitting it into words. We then create a set of banned words for faster lookup. We iterate over each word and check if it's in the set of banned words. If it's not, we increment its frequency count in a dictionary. After counting all the words, we find the word with the highest frequency.",
          "id" : "e3544fb0-5944-43a5-8c75-90615c43536a",
          "intuition" : "This approach works by using a set to store the banned words for faster lookup, and a dictionary to count the word frequencies.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "ball",
              "explanation" : "The word 'hit' is banned, so we ignore it. The word 'ball' appears twice, so it's the most frequent word.",
              "id" : "f3f95a77-b2c7-4083-821d-e9058e517684",
              "input" : "paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]"
            },
            {
              "expectedOutput" : "a",
              "explanation" : "There are no banned words, so we simply count the frequency of each word. The word 'a' appears once, so it's the most frequent word.",
              "id" : "26195891-5f32-42f6-b79e-eb5a516d6bdf",
              "input" : "paragraph = \"a.\", banned = []"
            }
          ]
        }
      ],
      "id" : "a4668322-09d9-47cb-a724-a2c07504b90f",
      "lastUpdated" : "2026-02-06T21:41:58Z",
      "problemSlug" : "most-common-word",
      "relatedProblems" : [
        "word-ladder",
        "minimum-window-substring"
      ],
      "summary" : "Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. The key insight is to split the paragraph into words, count their frequencies, and then exclude banned words."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a graph where each stone is a node, and two nodes are connected if the stones have the same row or column. Then, try all possible subsets of stones and check if the subset is connected.",
          "code" : "\n           import Foundation\n\n           func removeStones(_ stones: [[Int]]) -> Int {\n               var visited = Array(repeating: false, count: stones.count)\n               var count = 0\n               for i in 0..<stones.count {\n                   if !visited[i] {\n                       count += 1\n                       dfs(stones, &visited, i)\n                   }\n               }\n               return stones.count - count\n           }\n\n           func dfs(_ stones: [[Int]], _ visited: inout [Bool], _ index: Int) {\n               visited[index] = true\n               let stone = stones[index]\n               for i in 0..<stones.count {\n                   if !visited[i] && (stone[0] == stones[i][0] || stone[1] == stones[i][1]) {\n                       dfs(stones, &visited, i)\n                   }\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the visited status of each stone.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because in the worst case, we need to perform a depth-first search for each stone."
          },
          "explanation" : "This approach is a straightforward solution, but it is inefficient for large inputs because it has to try all possible subsets of stones.",
          "id" : "2670139a-f2fc-42fb-8288-f3fe716e1952",
          "intuition" : "This approach works by trying all possible combinations of stones and checking if they are connected.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The stones can be removed in the following order: (0,0), (0,1), (1,0), (1,2), (2,1). The stone (2,2) cannot be removed.",
              "id" : "398ef4d0-7e4f-4869-a7ad-f094973ff7ec",
              "input" : "stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The stones can be removed in the following order: (0,0), (0,2), (2,0). The stone (1,1) and (2,2) cannot be removed.",
              "id" : "3232c001-8f5f-4c90-8b77-b035ae23f070",
              "input" : "stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]"
            }
          ]
        },
        {
          "approach" : "Create a graph where each stone is a node, and two nodes are connected if the stones have the same row or column. Then, use the union-find data structure to keep track of the connected components.",
          "code" : "\n           import Foundation\n\n           class UnionFind {\n               var parent: [Int]\n               var rank: [Int]\n               var count: Int\n\n               init(_ n: Int) {\n                   parent = Array(repeating: 0, count: n)\n                   rank = Array(repeating: 0, count: n)\n                   count = n\n                   for i in 0..<n {\n                       parent[i] = i\n                   }\n               }\n\n               func find(_ x: Int) -> Int {\n                   if parent[x] != x {\n                       parent[x] = find(parent[x])\n                   }\n                   return parent[x]\n               }\n\n               func union(_ x: Int, _ y: Int) {\n                   let rootX = find(x)\n                   let rootY = find(y)\n                   if rootX != rootY {\n                       if rank[rootX] > rank[rootY] {\n                           parent[rootY] = rootX\n                       } else if rank[rootX] < rank[rootY] {\n                           parent[rootX] = rootY\n                       } else {\n                           parent[rootY] = rootX\n                           rank[rootX] += 1\n                       }\n                       count -= 1\n                   }\n               }\n           }\n\n           func removeStones(_ stones: [[Int]]) -> Int {\n               let n = stones.count\n               let uf = UnionFind(n)\n               for i in 0..<n {\n                   for j in i+1..<n {\n                       if stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1] {\n                           uf.union(i, j)\n                       }\n                   }\n               }\n               return n - uf.count\n           }\n           ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the parent and rank of each stone.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we need to iterate over all stones to union the connected components."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it avoids trying all possible subsets of stones.",
          "id" : "393f3015-65ee-40f2-b000-5f00f15491a3",
          "intuition" : "This approach works by using a union-find data structure to keep track of connected components.",
          "name" : "Union-Find",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "5",
              "explanation" : "The stones can be removed in the following order: (0,0), (0,1), (1,0), (1,2), (2,1). The stone (2,2) cannot be removed.",
              "id" : "b8705b78-a7f3-4121-9418-e4ba3ed5f960",
              "input" : "stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The stones can be removed in the following order: (0,0), (0,2), (2,0). The stone (1,1) and (2,2) cannot be removed.",
              "id" : "e0c9406a-ca59-451e-9842-525f2200e431",
              "input" : "stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]"
            }
          ]
        }
      ],
      "id" : "d67eeb56-99d0-4818-9e3b-973c72bc2a21",
      "lastUpdated" : "2026-02-06T21:50:34Z",
      "problemSlug" : "most-stones-removed-with-same-row-or-column",
      "relatedProblems" : [
        "friends-of-appropriate-ages",
        "reconstruct-itinerary"
      ],
      "summary" : "This problem involves removing stones with the same row or column, and the key insight is to use a union-find data structure to keep track of connected components. The goal is to find the maximum number of stones that can be removed."
    },
    {
      "approaches" : [
        {
          "approach" : "We will use a for loop to iterate through the array and count the occurrences of each number using a hash map. Once the count equals N, we will return that number.",
          "code" : "func repeatedNTimes(_ nums: [Int]) -> Int { let count = [Int:Int](); for num in nums { count[num, default: 0] += 1 }; return Array(count.keys)[Array(count.values).firstIndex(of: nums.count\/2)!] }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need a hash map to store the frequencies.",
            "time" : "O(n)",
            "timeExplanation" : "This is because we are doing a constant amount of work for each element."
          },
          "explanation" : "This approach is a simple frequency count that checks every element against all others and relies on the definition of the problem for correctness.",
          "id" : "928d9248-8cf9-404b-b4cc-ac61729e66c2",
          "intuition" : "This approach works by manually counting the occurrence of each element and identifying the N-repeated element.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The N-repeated element in the size 2N array [1,2,3,3] is 3.",
              "id" : "e4f71acc-01da-458a-bcff-c5d63184c719",
              "input" : "nums = [1,2,3,3]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The N-repeated element in the size 2N array [2,1,2,5,3,2] is 2.",
              "id" : "66423856-ff7f-4d82-b112-5388229c6b5c",
              "input" : "nums = [2,1,2,5,3,2]"
            }
          ]
        },
        {
          "approach" : "We will iterate through the array and check if the current number or the next number matches the number that is N steps ahead. Once we find a match, we return the number.",
          "code" : "func repeatedNTimes(_ nums: [Int]) -> Int { for i in 0..<nums.count-1 { if nums[i] == nums[i+1] { return nums[i] } } return -1 }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space.",
            "time" : "O(n)",
            "timeExplanation" : "This is because we are doing a constant amount of work for each element."
          },
          "explanation" : "This approach relies on the mathematical properties of the problem and uses constant space, making it more efficient for large inputs.",
          "id" : "7dcaa767-39d5-461a-b3b2-cf4dc2611e10",
          "intuition" : "This approach relies on the fact that in a size 2N array with one N-repeated element, each element can only be repeated at most 2 times except for the N-repeated element.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The N-repeated element in the size 2N array [1,2,3,3] is 3.",
              "id" : "10f373c2-5cd4-40ea-8239-e8937b08a760",
              "input" : "nums = [1,2,3,3]"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "The N-repeated element in the size 2N array [2,1,2,5,3,2] is 2.",
              "id" : "9cd0ed58-059d-48b4-b04c-2a361eb1c967",
              "input" : "nums = [2,1,2,5,3,2]"
            }
          ]
        }
      ],
      "id" : "c171b08c-3b96-431d-afe0-38a6172fd128",
      "lastUpdated" : "2026-02-06T21:51:38Z",
      "problemSlug" : "n-repeated-element-in-size-2n-array",
      "relatedProblems" : [
        "majority-element",
        "majority-element-ii"
      ],
      "summary" : "In a size 2N array, we need to find the N-repeated element. The key insight is that since there is only one N-repeated element, we can use a frequency hash map or simply observe the majority vote."
    },
    {
      "approaches" : [
        {
          "approach" : "For each element in the array, create a new array with the current element changed to the value of the previous element or the next element, and then check if the new array is non-decreasing.",
          "code" : "func checkPossibility(_ nums: [Int]) -> Bool { var nums = nums; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if !nums.sorted() == nums { return false } } } return true }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space is linear due to the extra space needed to store the new arrays.",
            "time" : "O(n^2)",
            "timeExplanation" : "Generating new arrays for each element and then checking each new array takes quadratic time."
          },
          "explanation" : "This approach involves generating new arrays for each element and checking them, which leads to inefficiency but serves as a baseline understanding of the problem.",
          "id" : "775be757-69ae-4aba-8409-a79e43c84ce0",
          "intuition" : "Try changing each element to make the array non-decreasing and check the result.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Change the 4 to a 2 or less to make the array [2,2,3].",
              "id" : "f523f3d1-5273-48af-a7e5-bd8398c8d7ec",
              "input" : "nums = [4,2,3]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "No matter what we change, we cannot make the array non-decreasing.",
              "id" : "87855724-de51-4be1-add0-bb06722f4ebe",
              "input" : "nums = [4,2,1]"
            }
          ]
        },
        {
          "approach" : "Scan through the array and whenever we find a decrease, decide whether to change the current element or the previous one to maintain the non-decreasing order.",
          "code" : "func checkPossibility(_ nums: [Int]) -> Bool { var changed = false; for i in 1..<nums.count { if nums[i] < nums[i-1] { if i == 1 || nums[i] >= nums[i-2] { nums[i-1] = nums[i]; } else { nums[i] = nums[i-1]; } if changed { return false } changed = true } } return true }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No extra space is needed for the algorithm.",
            "time" : "O(n)",
            "timeExplanation" : "We only scan the array once."
          },
          "explanation" : "This optimized approach checks each pair of adjacent elements once and makes the necessary adjustment to ensure the array becomes non-decreasing if possible.",
          "id" : "6cef410c-bd69-47c2-9eed-304112ef8055",
          "intuition" : "Check for any decreasing subsequence and handle it by changing the smaller of the two elements involved in the subsequence.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Change the 5 to a 1 or less to make the array non-decreasing.",
              "id" : "005a47c6-958c-4d30-91a2-d49ca975f0b7",
              "input" : "nums = [5,7,1,8]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Change the 4 to a 2 or less to make the array [3,2,2,5].",
              "id" : "6f3e4ec2-c19a-4198-8a83-0eee85121388",
              "input" : "nums = [3,4,2,5]"
            }
          ]
        }
      ],
      "id" : "e14a2b80-b8ca-4fbb-aea6-27e0a018a801",
      "lastUpdated" : "2026-02-06T21:32:12Z",
      "problemSlug" : "non-decreasing-array",
      "relatedProblems" : [
        "wiggle-sort-ii",
        "increase-to-match"
      ],
      "summary" : "The problem requires determining whether it's possible to make an array non-decreasing by changing at most one element, and the key insight is to check for any decreasing subsequence and handle it accordingly."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Define a function to perform depth-first search. Step 2: Iterate over each cell in the grid. Step 3: For each land cell, perform depth-first search to mark all connected land cells.",
          "code" : "\n         class Solution {\n            func numEnclaves(_ grid: [[Int]]) -> Int {\n               let rows = grid.count\n               let cols = grid[0].count\n               var grid = grid\n               \n               \/\/ Mark connected land cells\n               for i in 0..<rows {\n                  dfs(&grid, i, 0)\n                  dfs(&grid, i, cols-1)\n               }\n               for j in 0..<cols {\n                  dfs(&grid, 0, j)\n                  dfs(&grid, rows-1, j)\n               }\n               \n               \/\/ Count enclaves\n               var count = 0\n               for i in 0..<rows {\n                  for j in 0..<cols {\n                     if grid[i][j] == 1 {\n                        count += 1\n                     }\n                  }\n               }\n               return count\n            }\n            \n            func dfs(_ grid: inout [[Int]], _ i: Int, _ j: Int) {\n               guard i >= 0, i < grid.count, j >= 0, j < grid[0].count, grid[i][j] == 1 else { return }\n               grid[i][j] = -1 \/\/ Mark as visited\n               dfs(&grid, i-1, j)\n               dfs(&grid, i+1, j)\n               dfs(&grid, i, j-1)\n               dfs(&grid, i, j+1)\n            }\n         }",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because in the worst case, the depth-first search call stack can go up to the number of cells in the grid.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because we iterate over the grid for each cell."
          },
          "explanation" : "This approach ensures that all land cells connected to the boundary are marked. Then, we can iterate over the grid again to count the number of remaining land cells, which are the enclaves.",
          "id" : "4b8fccef-ff03-471c-9c0f-cfa602961a5b",
          "intuition" : "This approach involves iterating over each cell in the grid and performing a depth-first search to find all connected land cells.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The enclaves are the two 1s in the second row and the 1 in the fourth row.",
              "id" : "70d66958-2f7d-4791-b688-85d451953878",
              "input" : "grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no enclaves because all the land cells are connected to the boundary.",
              "id" : "89332723-aa96-499c-8039-bb3a1de09707",
              "input" : "grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]"
            }
          ]
        },
        {
          "approach" : "Step 1: Create a set to store the visited cells. Step 2: Perform breadth-first search from the boundary to mark all connected land cells. Step 3: Iterate over the grid to count the remaining land cells.",
          "code" : "\n         class Solution {\n            func numEnclaves(_ grid: [[Int]]) -> Int {\n               let rows = grid.count\n               let cols = grid[0].count\n               var grid = grid\n               var queue = [(Int, Int)]()\n               var visited: Set<(Int, Int)> = []\n               \n               \/\/ Add boundary land cells to the queue\n               for i in 0..<rows {\n                  if grid[i][0] == 1 {\n                     queue.append((i, 0))\n                     visited.insert((i, 0))\n                  }\n                  if grid[i][cols-1] == 1 {\n                     queue.append((i, cols-1))\n                     visited.insert((i, cols-1))\n                  }\n               }\n               for j in 0..<cols {\n                  if grid[0][j] == 1 {\n                     queue.append((0, j))\n                     visited.insert((0, j))\n                  }\n                  if grid[rows-1][j] == 1 {\n                     queue.append((rows-1, j))\n                     visited.insert((rows-1, j))\n                  }\n               }\n               \n               \/\/ Perform breadth-first search\n               while !queue.isEmpty {\n                  let (x, y) = queue.removeFirst()\n                  if grid[x][y] == 1 {\n                     grid[x][y] = -1 \/\/ Mark as visited\n                     if x > 0 && grid[x-1][y] == 1 && !visited.contains((x-1, y)) {\n                        queue.append((x-1, y))\n                        visited.insert((x-1, y))\n                     }\n                     if x < rows-1 && grid[x+1][y] == 1 && !visited.contains((x+1, y)) {\n                        queue.append((x+1, y))\n                        visited.insert((x+1, y))\n                     }\n                     if y > 0 && grid[x][y-1] == 1 && !visited.contains((x, y-1)) {\n                        queue.append((x, y-1))\n                        visited.insert((x, y-1))\n                     }\n                     if y < cols-1 && grid[x][y+1] == 1 && !visited.contains((x, y+1)) {\n                        queue.append((x, y+1))\n                        visited.insert((x, y+1))\n                     }\n                  }\n               }\n               \n               \/\/ Count enclaves\n               var count = 0\n               for i in 0..<rows {\n                  for j in 0..<cols {\n                     if grid[i][j] == 1 {\n                        count += 1\n                     }\n                  }\n               }\n               return count\n            }\n         }",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because in the worst case, the breadth-first search queue can contain all the cells in the grid.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because we still need to iterate over the grid to count the enclaves."
          },
          "explanation" : "This approach still has a time complexity of O(R*C) but it avoids the recursion overhead of depth-first search.",
          "id" : "148096db-358d-4286-b837-de1bcaa80b7a",
          "intuition" : "This approach involves using a more efficient data structure, such as a set to keep track of visited cells, and using a breadth-first search instead of depth-first search.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "The enclaves are the two 1s in the second row and the 1 in the fourth row.",
              "id" : "858ae2ac-8f70-4acc-9e9a-49075a6c3a45",
              "input" : "grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]"
            },
            {
              "expectedOutput" : "0",
              "explanation" : "There are no enclaves because all the land cells are connected to the boundary.",
              "id" : "9632a155-bb07-41d6-9fab-513993657962",
              "input" : "grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]"
            }
          ]
        }
      ],
      "id" : "9defd0f2-ee52-4c56-addc-f8ac73ff820d",
      "lastUpdated" : "2026-02-06T21:56:10Z",
      "problemSlug" : "number-of-enclaves",
      "relatedProblems" : [
        "number-of-islands",
        "max-area-of-island"
      ],
      "summary" : "This problem involves counting the number of islands in a grid that are not connected to the boundary. The key insight is to first identify and mark all the land cells connected to the boundary."
    },
    {
      "approaches" : [
        {
          "approach" : "For each character in the string, calculate its width and add it to the current line width. If the current line width exceeds the given width, move to the next line.",
          "code" : "\n           func numberOfLines(_ widths: [Int], s: String) -> [Int] {\n               var lines = 1\n               var width = 0\n               for c in s {\n                   let w = widths[Int(c.asciiValue! - 97)]\n                   if width + w > 100 {\n                       lines += 1\n                       width = w\n                   } else {\n                       width += w\n                   }\n               }\n               return [lines, width]\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because only a fixed amount of space is used to store the variables.",
            "time" : "O(n)",
            "timeExplanation" : "The algorithm needs to iterate over each character in the string once."
          },
          "explanation" : "Start with the first character and keep adding characters to the line until the line width exceeds the given width. When it does, move to the next line and start over. Keep track of the number of lines needed.",
          "id" : "5e121245-5301-4f12-bfcd-017f32b79ec8",
          "intuition" : "This approach works by simulating the process of writing the string on a line of given width, counting the number of lines needed.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[3,60]",
              "explanation" : "Explanation: Now, lines are 3, last line width is 60.",
              "id" : "9a0284c4-6231-433c-a6ad-1b6ee41d92b8",
              "input" : "widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\""
            },
            {
              "expectedOutput" : "[2,4]",
              "explanation" : "Explanation: The characters in the string are b (4), c (10), c (10), d (10), d (10), a (10), a (10), a (10), a (10), a (10).",
              "id" : "2889d902-7ada-4972-b8d7-125e203586ca",
              "input" : "widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaaa\""
            }
          ]
        },
        {
          "approach" : "Instead of manually calculating each character's width, directly look up the width for each character in the widths array and accumulate the width. If the accumulated width exceeds 100, move to the next line.",
          "code" : "\n           func numberOfLines(_ widths: [Int], s: String) -> [Int] {\n               var lines = 1\n               var width = 0\n               let aAscii: UInt32 = 97\n               for c in s.utf8 {\n                   let w = widths[Int(c - aAscii)]\n                   if width + w > 100 {\n                       lines += 1\n                       width = w\n                   } else {\n                       width += w\n                   }\n               }\n               return [lines, width]\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity remains constant.",
            "time" : "O(n)",
            "timeExplanation" : "The algorithm still iterates over each character once but with the added efficiency of array lookup for width."
          },
          "explanation" : "The logic of this approach remains the same as the brute force approach but uses array indexing to find character widths efficiently.",
          "id" : "52a6a158-b490-4f19-94ee-d7f41f4f8961",
          "intuition" : "This approach takes advantage of the knowledge that all string characters will have widths defined in the given widths array.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2,4]",
              "explanation" : "Explanation: Same explanation as the brute force example.",
              "id" : "fc8aef44-db56-4714-8a9a-738b5bbad0c2",
              "input" : "widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaaa\""
            },
            {
              "expectedOutput" : "[3,60]",
              "explanation" : "Explanation: Same explanation as the brute force example.",
              "id" : "ca330146-3bba-464c-88a0-d55ea43913ff",
              "input" : "widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\""
            }
          ]
        }
      ],
      "id" : "71c8e180-f90c-4474-ad4c-277ecd782fa2",
      "lastUpdated" : "2026-02-06T21:40:51Z",
      "problemSlug" : "number-of-lines-to-write-string",
      "relatedProblems" : [
        "design-hashmap",
        "find-and-replace-pattern"
      ],
      "summary" : "The problem requires determining the number of lines required to write a string given an array of widths. The key insight here is to iterate through each character's width and decide when to move to the next line."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible next states from the current state by turning each wheel up or down. Perform DFS on each state.",
          "code" : "class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]) while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1); if c1 == \"10\" { let c1 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c1 == \"11\" { let c1 = \"1\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c1 = c1; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};}; let c2 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1); if c2 == \"-1\" { let c2 = \"9\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else if c2 == \"10\" { let c2 = \"0\"; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};} else { let c2 = c2; var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));};};};};}; return \"-1\";};}",
          "complexity" : {
            "space" : "O(4^N)",
            "spaceExplanation" : "We store all visited states.",
            "time" : "O(N * 4^N)",
            "timeExplanation" : "We generate all possible sequences of turns and check if the target code is reached."
          },
          "explanation" : "This solution works by trying every possible combination of turns and checking if the target code is reached.",
          "id" : "2c22fb74-915c-4950-a57b-9cf9a9be1715",
          "intuition" : "Check all possible sequences of turns and count the steps until we get the target code.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"6\"",
              "explanation" : "We start at \"0000\" and try to reach the target code \"0202\". After trying all possible combinations, we find the sequence of turns that reaches the target code in the minimum steps.",
              "id" : "45d8bea8-1abc-418a-b727-5ccd105807f8",
              "input" : "[\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"],\"0202\""
            },
            {
              "expectedOutput" : "\"-1\"",
              "explanation" : "All states are blocked by dead ends, so we cannot reach the target code.",
              "id" : "0475cee2-f32c-4a69-8c9d-b6a37e5ef8b5",
              "input" : "[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"],\"8888\""
            }
          ]
        },
        {
          "approach" : "Start with the initial state and generate all possible next states. Perform BFS to explore all states and count the steps until we get the target code.",
          "code" : "class Solution { func openLock(_ deadends: [String], _ target: String) -> String { let dead = Set(deadends); guard !dead.contains(\"0000\") else { return \"-1\" }; let queue: [(String, Int)] = [(\"0000\", 0)]; var visited = Set<String>([\"0000\"]); while !queue.isEmpty { let (cur, count) = queue.removeFirst(); if cur == target { return String(count) }; for i in 0...3 { let c = String(cur[cur.startIndex.advanced(by: i)]) let c1 = String(Int(String(cur[cur.startIndex.advanced(by: i)]))! + 1 % 10); var s = cur; s.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c1); if !visited.contains(s) && !dead.contains(s) { visited.insert(s); queue.append((s, count + 1));}; let c2 = String((Int(String(cur[cur.startIndex.advanced(by: i)]))! - 1 + 10) % 10); var s2 = cur; s2.replaceSubrange(cur.startIndex.advanced(by: i)...cur.startIndex.advanced(by: i + 1), with: c2); if !visited.contains(s2) && !dead.contains(s2) { visited.insert(s2); queue.append((s2, count + 1));};};}; return \"-1\";};}",
          "complexity" : {
            "space" : "O(4^N)",
            "spaceExplanation" : "We store all visited states.",
            "time" : "O(4^N)",
            "timeExplanation" : "We explore all possible states in the BFS."
          },
          "explanation" : "This solution works by exploring the most promising states first and avoiding states that are known to be dead ends.",
          "id" : "7973bed8-392e-4141-8688-88205dfc00fa",
          "intuition" : "Instead of generating all possible sequences, use a queue to perform BFS from the initial state and only explore the most promising states.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"6\"",
              "explanation" : "We start at \"0000\" and try to reach the target code \"0202\". After trying all possible combinations, we find the sequence of turns that reaches the target code in the minimum steps.",
              "id" : "62567e4f-1dc7-464c-8199-fcc3da274b00",
              "input" : "[\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"],\"0202\""
            },
            {
              "expectedOutput" : "\"1\"",
              "explanation" : "We start at \"0000\" and try to reach the target code \"0009\".",
              "id" : "590298f8-a521-4749-bc5c-892ec0669747",
              "input" : "[\"8888\"],\"0009\""
            }
          ]
        }
      ],
      "id" : "f2142427-0eb5-487f-8f60-1920ec8c3a37",
      "lastUpdated" : "2026-02-06T21:38:23Z",
      "problemSlug" : "open-the-lock",
      "relatedProblems" : [
        "number-of-atoms",
        "word-ladder"
      ],
      "summary" : "The problem Open the Lock involves finding the shortest sequence of turns to unlock a padlock with a given target code. The key insight is using a breadth-first search to explore all possible states."
    },
    {
      "approaches" : [
        {
          "approach" : "For each song, calculate its duration modulo 60 and check all other songs for a complementary duration.",
          "code" : "func numPairsDivisibleBy60(_ time: [Int]) -> Int { \n    var count = 0 \n    for i in 0..<time.count { \n        for j in (i+1)..<time.count { \n            if (time[i] + time[j]) % 60 == 0 { \n                count += 1 \n            } \n        } \n    } \n    return count \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we are only using a fixed amount of space to store the count.",
            "time" : "O(n^2)",
            "timeExplanation" : "We are using nested loops to compare each song with every other song."
          },
          "explanation" : "This approach has a time complexity of O(n^2), where n is the number of songs, because in the worst case, we're comparing each song with every other song.",
          "id" : "427371ce-2031-49c3-b970-2421c4c54870",
          "intuition" : "Iterate through each song, and for each song, iterate through the rest of the songs to check for a total duration divisible by 60.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Pairs are (30, 30), (20, 40), (150, 10) - wait, there is no 10, and also 100 + 20 = 120 which is also divisible by 60",
              "id" : "47d063ae-9e37-4419-8128-26382b4461e0",
              "input" : "time = [30,20,150,100,40]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Each song can be paired with every other song to produce a total duration divisible by 60.",
              "id" : "3fe125b4-686f-4afe-a17f-576b417aebb8",
              "input" : "time = [60,60,60]"
            }
          ]
        },
        {
          "approach" : "Calculate the remainder of each song's duration modulo 60 and use a hash map to count the occurrences of each remainder.",
          "code" : "func numPairsDivisibleBy60(_ time: [Int]) -> Int { \n    var count = 0 \n    var remainderCounts: [Int: Int] = [:] \n    for duration in time { \n        let remainder = duration % 60 \n        let complement = (60 - remainder) % 60 \n        if let complementCount = remainderCounts[complement] { \n            count += complementCount \n        } \n        remainderCounts[remainder, default: 0] += 1 \n    } \n    return count \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because the hash map will have at most 60 entries (one for each possible remainder).",
            "time" : "O(n)",
            "timeExplanation" : "We are only iterating through the songs once to calculate the remainder and update the hash map."
          },
          "explanation" : "This approach reduces the time complexity to O(n) because we only need to iterate through the songs once to calculate the remainder and update the hash map.",
          "id" : "10d51eab-235d-4abb-af40-17145f6b7177",
          "intuition" : "Use a hash map to store the frequency of each remainder when the duration is divided by 60, and then find pairs that sum up to a multiple of 60.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "3",
              "explanation" : "Pairs are (30, 30), (20, 40), (150, 10) - wait, there is no 10, and also 100 + 20 = 120 which is also divisible by 60",
              "id" : "90390a54-df93-44e8-bf4c-a43201121242",
              "input" : "time = [30,20,150,100,40]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "Each song can be paired with every other song to produce a total duration divisible by 60.",
              "id" : "7fe6d896-5acb-4259-8cb0-5eccd1be3cdc",
              "input" : "time = [60,60,60]"
            }
          ]
        }
      ],
      "id" : "00add1c4-1a01-4142-8347-d3eec2ce932f",
      "lastUpdated" : "2026-02-06T21:55:24Z",
      "problemSlug" : "pairs-of-songs-with-total-durations-divisible-by-60",
      "relatedProblems" : [
        "two-sum",
        "subarray-sum-equals-k"
      ],
      "summary" : "This problem requires finding pairs of songs with total durations divisible by 60, with a key insight being that a remainder of 0 indicates the total duration is divisible by 60."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Iterate over the array with a nested loop to generate all possible partitions. 2. For each partition, check if the maximum value in the current interval is less than or equal to the minimum value in the next interval.",
          "code" : "func partitionDisjoint(_ nums: [Int]) -> Int {\n    let n = nums.count\n    for i in 0..<n - 1 {\n        let leftMax = nums[0...i].max()!\n        let rightMin = nums[i + 1..<n].min()!\n        if leftMax = rightMin {\n            return i + 1\n        }\n    }\n    return -1\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No extra space is used.",
            "time" : "O(n^2)",
            "timeExplanation" : "The outer loop runs n times and the inner loop runs n times in the worst case."
          },
          "explanation" : "This approach generates all possible partitions of the array and checks each one to see if it satisfies the condition. However, it has a high time complexity due to the nested loop.",
          "id" : "a9e472be-cfcf-45cd-8b3f-73cab4f14513",
          "intuition" : "This approach works by trying all possible ways to partition the array into disjoint intervals and checking if the current interval satisfies the condition.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The optimal partition is [5,0] and [3,8,6] with a maximum value of 5 in the first interval and a minimum value of 3 in the second interval.",
              "id" : "46030c84-c20f-407e-85b8-089ebc4651e7",
              "input" : "nums = [5,0,3,8,6]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The optimal partition is [1,1,1,0] and [6,12] with a maximum value of 1 in the first interval and a minimum value of 6 in the second interval.",
              "id" : "36c1fbc2-1d5e-478c-9413-98bb73af436f",
              "input" : "nums = [1,1,1,0,6,12]"
            }
          ]
        },
        {
          "approach" : "1. Initialize two arrays, leftMax and rightMin, of size n, where leftMax[i] is the maximum value in the left interval ending at i and rightMin[i] is the minimum value in the right interval starting at i. 2. Iterate over the array from left to right to fill in leftMax and from right to left to fill in rightMin.",
          "code" : "func partitionDisjoint(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var leftMax = Array(repeating: 0, count: n)\n    var rightMin = Array(repeating: Int.max, count: n)\n    var maxSoFar = nums[0]\n    for i in 1..<n {\n        leftMax[i] = max(maxSoFar, nums[i])\n        maxSoFar = max(maxSoFar, nums[i])\n    }\n    var minSoFar = nums[n - 1]\n    for i in stride(from: n - 2, through: 0, by: -1) {\n        rightMin[i] = min(minSoFar, nums[i])\n        minSoFar = min(minSoFar, nums[i])\n    }\n    for i in 0..<n - 1 {\n        if leftMax[i] = rightMin[i + 1] {\n            return i + 1\n        }\n    }\n    return -1\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Extra space is used to store the leftMax and rightMin arrays.",
            "time" : "O(n)",
            "timeExplanation" : "The code makes two passes over the array: one to fill in leftMax and one to fill in rightMin."
          },
          "explanation" : "This approach has a time complexity of O(n) and space complexity of O(n) because it involves two passes over the array to fill in the leftMax and rightMin arrays.",
          "id" : "b74eaf32-f3c3-4586-b302-870cb9b0cee6",
          "intuition" : "This approach works by maintaining two arrays to keep track of the maximum value seen so far from the left and the minimum value seen so far from the right.",
          "name" : "Optimized Dynamic Programming",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The optimal partition is [5,0] and [3,8,6] with a maximum value of 5 in the first interval and a minimum value of 3 in the second interval.",
              "id" : "a87c05fb-becc-4d7a-8ce8-cd4dbf5ddbdb",
              "input" : "nums = [5,0,3,8,6]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "The optimal partition is [1,1,1,0] and [6,12] with a maximum value of 1 in the first interval and a minimum value of 6 in the second interval.",
              "id" : "11894f2e-e64a-4d13-b87a-9f20d885509c",
              "input" : "nums = [1,1,1,0,6,12]"
            }
          ]
        }
      ],
      "id" : "24d1153d-3fec-4782-9b8e-bdcae1d0d9eb",
      "lastUpdated" : "2026-02-06T21:48:08Z",
      "problemSlug" : "partition-array-into-disjoint-intervals",
      "relatedProblems" : [
        "best-time-to-buy-and-sell-stock",
        "minimum-size-subarray-sum"
      ],
      "summary" : "The problem requires partitioning an array into disjoint intervals such that the maximum value in each interval is less than or equal to the minimum value in the next interval. The key insight is to use a dynamic programming approach to keep track of the minimum value for each interval."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a new iterator class that stores the current element and the underlying iterator. Implement the peek and next methods to return the current element and update the current element using the underlying iterator.",
          "code" : "\nclass PeekingIterator {\n    let iterator: IndexingIterator<[Int]>\n    var current: Int?\n\n    init(_ arr: [Int]) {\n        iterator = arr.makeIterator()\n        current = iterator.next()\n    }\n\n    func peek() -> Int {\n        return current!\n    }\n\n    func next() -> Int {\n        let temp = current\n        current = iterator.next()\n        return temp!\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because the custom iterator stores a constant amount of data.",
            "time" : "O(1)",
            "timeExplanation" : "The time complexity is O(1) because the peek and next operations take constant time."
          },
          "explanation" : "The brute force approach works by storing the current element in the custom iterator. When the peek method is called, it returns the current element. When the next method is called, it updates the current element using the underlying iterator.",
          "id" : "cb12e87f-0d71-43c3-89bc-47e4926387ea",
          "intuition" : "This approach involves creating a brute force iterator that stores the current element and uses the underlying iterator to get the next element.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The custom iterator returns the first element '1' when the next method is called.",
              "id" : "31011661-4bd8-4293-9b9f-8bf7129d7b1d",
              "input" : "nums = [1, 2, 3], PeekingIterator(nums).next()"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The custom iterator returns the first element '1' when the peek method is called.",
              "id" : "532dcbb0-c402-4fce-82f0-82ab733a054d",
              "input" : "nums = [1, 2, 3], PeekingIterator(nums).peek()"
            }
          ]
        },
        {
          "approach" : "Create an optimized iterator class that stores the current element and the underlying iterator. Implement the peek and next methods to handle the operations more efficiently.",
          "code" : "\nclass PeekingIterator {\n    let iterator: IndexingIterator<[Int]>\n    var current: Int?\n\n    init(_ arr: [Int]) {\n        iterator = arr.makeIterator()\n    }\n\n    func peek() -> Int {\n        if current == nil {\n            current = iterator.next()\n        }\n        return current!\n    }\n\n    func next() -> Int {\n        if current == nil {\n            current = iterator.next()\n        }\n        let temp = current\n        current = nil\n        return temp!\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because the custom iterator stores a constant amount of data.",
            "time" : "O(1)",
            "timeExplanation" : "The time complexity is O(1) because the peek and next operations take constant time."
          },
          "explanation" : "The optimized approach works by handling the peek and next operations in a more efficient way. When the peek method is called, it returns the current element if it exists, or gets the next element from the underlying iterator if it does not exist. When the next method is called, it returns the current element if it exists, or gets the next element from the underlying iterator if it does not exist.",
          "id" : "fd35c7f5-ba6b-493c-8a83-407d12984438",
          "intuition" : "This approach involves optimizing the custom iterator by handling the peek and next operations in a more efficient way.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The custom iterator returns the first element '1' when the peek method is called.",
              "id" : "284579e4-00aa-4fb1-84d3-2d87df46d2a1",
              "input" : "nums = [1, 2, 3], PeekingIterator(nums).peek()"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The custom iterator returns the first element '1' when the next method is called.",
              "id" : "03c1943b-5dd8-4b2b-b18d-963519d9a79c",
              "input" : "nums = [1, 2, 3], PeekingIterator(nums).next()"
            }
          ]
        }
      ],
      "id" : "804d8035-1e6f-435e-ae57-fb08b1ec3c3a",
      "lastUpdated" : "2026-02-06T21:12:02Z",
      "problemSlug" : "peeking-iterator",
      "relatedProblems" : [
        "array-nesting",
        "find-all-duplicates-in-an-array"
      ],
      "summary" : "The Peeking Iterator problem involves implementing a custom iterator to peek and retrieve elements from an underlying iterator. The key insight is to create a wrapper class that stores the current element and handles peek and next operations."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Build result where result[i] is the product of all elements before i.\n2. Traverse from right, maintaining a suffix product and multiply into result[i].",
          "code" : "func productExceptSelf(_ nums: [Int]) -> [Int] {\n    var result = Array(repeating: 1, count: nums.count)\n    var prefix = 1\n    for i in 0..<nums.count {\n        result[i] = prefix\n        prefix *= nums[i]\n    }\n    var suffix = 1\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\n        result[i] *= suffix\n        suffix *= nums[i]\n    }\n    return result\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only constant extra space besides the output.",
            "time" : "O(n)",
            "timeExplanation" : "Two linear passes."
          },
          "explanation" : "This keeps O(1) extra space besides the output array and handles zeros correctly.",
          "id" : "cad14ea0-646e-49fd-bc22-69e4b5e08203",
          "intuition" : "The product for index i is (product of all elements before i) * (product of all elements after i).",
          "name" : "Prefix\/Suffix",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[24,12,8,6]",
              "explanation" : "Products excluding each index.",
              "id" : "ea2462d9-4c77-4f66-a78a-0882e8eeed6c",
              "input" : "nums = [1,2,3,4]"
            },
            {
              "expectedOutput" : "[0,0,9,0,0]",
              "explanation" : "Handles zeros correctly.",
              "id" : "c2ddebb8-39b4-494d-9b47-e5c6da74e2bc",
              "input" : "nums = [-1,1,0,-3,3]"
            }
          ]
        }
      ],
      "id" : "ce775cc2-53fd-4963-bb91-9c8f6b5dcb4c",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "product-of-array-except-self",
      "relatedProblems" : [
        "maximum-product-subarray",
        "subarray-product-less-than-k"
      ],
      "summary" : "Compute prefix products and suffix products to avoid division."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the individuals based on their height in descending order and then by the number of people in front of them in ascending order. Then, for each individual, iterate through the result array and insert the individual at the correct position based on the number of people in front of them.",
          "code" : "\nimport Foundation\n\nfunc reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n    var res = [[Int]]()\n    let sortedPeople = people.sorted { $0[0] == $1[0] ? $0[1] < $1[1] : $0[0] > $1[0] }\n    for person in sortedPeople {\n        res.insert(person, at: person[1])\n    }\n    return res\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the result in an array of size n.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are using a nested loop to try out all possible positions for each individual."
          },
          "explanation" : "The brute-force approach has an exponential time complexity due to the use of nested loops to try out all possible positions for each individual.",
          "id" : "7b6d3b95-84fb-42cf-8ba1-a902e32dac9c",
          "intuition" : "The brute-force approach works by trying out all possible positions for each individual and selecting the one that satisfies the given conditions.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[5,0],[7,0],[5,2],[6,1],[7,1],[4,4]]",
              "explanation" : "The expected output is the reconstructed queue based on the height of individuals.",
              "id" : "e238dd6b-0e0f-48d9-ac84-9d395fda1f92",
              "input" : "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]"
            },
            {
              "expectedOutput" : "[[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
              "explanation" : "The expected output is the reconstructed queue based on the height of individuals.",
              "id" : "1a399721-c332-473d-970b-d904893a9850",
              "input" : "people = [[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]"
            }
          ]
        },
        {
          "approach" : "First, sort the individuals based on their height in descending order and then by the number of people in front of them in ascending order. Then, use a sorted array to store the result and insert each individual at the correct position.",
          "code" : "\nimport Foundation\n\nfunc reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n    var res = [[Int]]()\n    let sortedPeople = people.sorted { $0[0] == $1[0] ? $0[1] < $1[1] : $0[0] > $1[0] }\n    for person in sortedPeople {\n        res.insert(person, at: person[1])\n    }\n    return res\n}\n",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the result in an array of size n.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) because we are using the sorted function to sort the individuals."
          },
          "explanation" : "The optimized approach has a linear time complexity due to the use of a sorted array to store the result and insert each individual at the correct position.",
          "id" : "45dafb6d-7c9f-4f51-8d03-ca9bd377064f",
          "intuition" : "The optimized approach works by maintaining a sorted array and inserting each individual at the correct position based on the number of people in front of them.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[5,0],[7,0],[5,2],[6,1],[7,1],[4,4]]",
              "explanation" : "The expected output is the reconstructed queue based on the height of individuals.",
              "id" : "a5d7400a-dd4d-4881-aa91-2eaf92475f20",
              "input" : "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]"
            },
            {
              "expectedOutput" : "[[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]",
              "explanation" : "The expected output is the reconstructed queue based on the height of individuals.",
              "id" : "b736ea1d-52d5-4422-bd0f-16f0765e55c2",
              "input" : "people = [[6,0],[5,0],[4,0],[3,0],[2,0],[1,0]]"
            }
          ]
        }
      ],
      "id" : "1bbdb5a4-525c-445d-9acf-16153686a672",
      "lastUpdated" : "2026-02-06T21:17:06Z",
      "problemSlug" : "queue-reconstruction-by-height",
      "relatedProblems" : [
        "insertion-sort-list",
        "sort-colors"
      ],
      "summary" : "Reconstruct a queue based on the height of individuals. The key insight is to sort the individuals by height in descending order and then by the number of people in front of them in ascending order."
    },
    {
      "approaches" : [
        {
          "approach" : "Initialize an array, for every update operation, update the corresponding element in the array, for every sum query, calculate the sum of the elements in the given range.",
          "code" : "__class RangeSumMutable { \n  var nums: [Int] \n  init(_ nums: [Int]) { \n    self.nums = nums \n  } \n  func update(_ i: Int, _ val: Int) { \n    nums[i] = val \n  } \n  func sumRange(_ i: Int, _ j: Int) -> Int { \n    return nums[i...j].reduce(0, +) \n  } \n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are not using any additional space that scales with the input size.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity of the update operation is O(1) and the time complexity of the sumRange operation is O(n)."
          },
          "explanation" : "This approach is straightforward but has a high time complexity due to the repeated calculations. It is not efficient for large arrays or frequent updates.",
          "id" : "d3e39a79-06ee-4fa3-83fa-36359211dd9c",
          "intuition" : "The brute force approach involves recalculating the sum of the entire range for every query, which is inefficient for large arrays.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "8",
              "explanation" : "The sum of the elements in the range [0, 2] after updating the value at index 1 to 2 is 1 + 2 + 5 = 8.",
              "id" : "82de314a-c683-4090-ae17-406c179afc9a",
              "input" : "nums = [1, 3, 5], update(1, 2), sumRange(0, 2)"
            },
            {
              "expectedOutput" : "5",
              "explanation" : "The sum of the elements in the range [0, 1] after updating the value at index 1 to 4 is 1 + 4 = 5.",
              "id" : "ddcf3f30-8b4f-433d-9637-7c1c10cb7999",
              "input" : "nums = [1, 3, 5], update(1, 4), sumRange(0, 1)"
            }
          ]
        },
        {
          "approach" : "Initialize a segment tree with the given array, for every update operation, update the corresponding node in the segment tree, for every sum query, calculate the sum of the elements in the given range using the segment tree.",
          "code" : "__class RangeSumMutable { \n  var tree: [Int] \n  var n: Int \n  init(_ nums: [Int]) { \n    n = nums.count \n    tree = [Int](repeating: 0, count: n * 4) \n    buildTree(nums, 0, n - 1, 0) \n  } \n  func buildTree(_ nums: [Int], _ left: Int, _ right: Int, _ node: Int) { \n    if left == right { \n      tree[node] = nums[left] \n    } else { \n      let mid = (left + right) \/ 2 \n      buildTree(nums, left, mid, 2 * node + 1) \n      buildTree(nums, mid + 1, right, 2 * node + 2) \n      tree[node] = tree[2 * node + 1] + tree[2 * node + 2] \n    } \n  } \n  func update(_ i: Int, _ val: Int) { \n    updateTree(i, val, 0, n - 1, 0) \n  } \n  func updateTree(_ i: Int, _ val: Int, _ left: Int, _ right: Int, _ node: Int) { \n    if left == right { \n      tree[node] = val \n    } else { \n      let mid = (left + right) \/ 2 \n      if i <= mid { \n        updateTree(i, val, left, mid, 2 * node + 1) \n      } else { \n        updateTree(i, val, mid + 1, right, 2 * node + 2) \n      } \n      tree[node] = tree[2 * node + 1] + tree[2 * node + 2] \n    } \n  } \n  func sumRange(_ i: Int, _ j: Int) -> Int { \n    return queryTree(i, j, 0, n - 1, 0) \n  } \n  func queryTree(_ i: Int, _ j: Int, _ left: Int, _ right: Int, _ node: Int) -> Int { \n    if i > right || j < left { \n      return 0 \n    } \n    if i <= left && j >= right { \n      return tree[node] \n    } \n    let mid = (left + right) \/ 2 \n    return queryTree(i, j, left, mid, 2 * node + 1) + queryTree(i, j, mid + 1, right, 2 * node + 2) \n  } \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are using a segment tree to store the sum of elements in each range.",
            "time" : "O(log n)",
            "timeExplanation" : "The time complexity of the update operation is O(log n) and the time complexity of the sumRange operation is O(log n)."
          },
          "explanation" : "This approach is more efficient than the brute force approach because it uses a balanced binary tree to store the sum of elements in each range, allowing for O(log n) time complexity for both update and sumRange operations.",
          "id" : "373ec3ca-2227-44c3-a2a7-e371820ff6cb",
          "intuition" : "The segment tree approach involves using a binary tree to store the sum of elements in each range, allowing for efficient updates and queries.",
          "name" : "Segment Tree",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "8",
              "explanation" : "The sum of the elements in the range [0, 2] after updating the value at index 1 to 2 is 1 + 2 + 5 = 8.",
              "id" : "d9927c27-50f9-4c99-b687-f2eaf5aac0ff",
              "input" : "nums = [1, 3, 5], update(1, 2), sumRange(0, 2)"
            },
            {
              "expectedOutput" : "5",
              "explanation" : "The sum of the elements in the range [0, 1] after updating the value at index 1 to 4 is 1 + 4 = 5.",
              "id" : "c13ba95a-f1ce-4a0d-a245-d0fd2b490d1e",
              "input" : "nums = [1, 3, 5], update(1, 4), sumRange(0, 1)"
            }
          ]
        }
      ],
      "id" : "4f22e217-32cd-452b-b0af-2fce55fd0790",
      "lastUpdated" : "2026-02-06T21:12:33Z",
      "problemSlug" : "range-sum-query-mutable",
      "relatedProblems" : [
        "range-sum-query-immutable",
        "subarray-sum-equals-k"
      ],
      "summary" : "The problem is to find the sum of elements in a given range of an array that can be modified. The key insight is to use a segment tree to efficiently calculate the sum and handle updates."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Count each character in magazine.\n2. For each character in ransomNote, decrement its count.\n3. If any count goes negative, return false. Otherwise return true.",
          "code" : "func canConstruct(_ ransomNote: String, _ magazine: String) -> Bool {\n    var counts: [Character: Int] = [:]\n    for ch in magazine { counts[ch, default: 0] += 1 }\n    for ch in ransomNote {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Character counts are bounded by alphabet size.",
            "time" : "O(m + n)",
            "timeExplanation" : "Scan magazine and ransom note once."
          },
          "explanation" : "This is a direct application of a frequency map: availability vs. demand.",
          "id" : "8d6b33ea-7830-4e29-a0d6-56d6ea03ab6b",
          "intuition" : "Each letter in the ransom note must be supplied by the magazine. If any count is insufficient, it fails.",
          "name" : "Frequency Map",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "Missing letter a.",
              "id" : "aa950b65-3fb0-478f-8048-cb5ddc162234",
              "input" : "ransomNote = \"a\", magazine = \"b\""
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Magazine has enough a's.",
              "id" : "07eea518-2a35-467d-adaf-87edaf1b9eb2",
              "input" : "ransomNote = \"aa\", magazine = \"aab\""
            }
          ]
        }
      ],
      "id" : "751df843-f7df-4040-a033-b2fd1cfc0050",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "ransom-note",
      "relatedProblems" : [
        "valid-anagram",
        "first-unique-character-in-a-string"
      ],
      "summary" : "Count available letters in the magazine and consume them for the ransom note."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a grid to represent the input square. 2. Iterate over each cell in the grid. 3. For each slash, check if it divides a region into two. 4. If it does, create a new region.",
          "code" : "class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); for i in 0..<n { for j in 0..<n { let val = grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)]; if val == '\/' { union(&g, i * 3, j * 3 + 2); union(&g, i * 3 + 2, j * 3); } else if val == '\\' { union(&g, i * 3, j * 3); union(&g, i * 3 + 2, j * 3 + 2); } } } func find(_ g: inout [[Int]], _ i: Int) -> Int { if g[i][i] != i { g[i][i] = find(&g, g[i][i]); } return g[i][i]; }; func union(_ g: inout [[Int]], _ i: Int, _ j: Int) { let fi = find(&g, i); let fj = find(&g, j); if fi != fj { g[fi][fi] = fj; res -= 1; } }; return res; } }",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The brute force approach takes O(n^2) space because it has to store the grid and the Union-Find data structure.",
            "time" : "O(n^2)",
            "timeExplanation" : "The brute force approach takes O(n^2) time because it has to iterate over each cell in the grid."
          },
          "explanation" : "This approach works but is inefficient because it has to manually check for connections between cells. It can be improved by using a Union-Find data structure to group the connected cells together.",
          "id" : "b2851b5b-ab0c-4375-95a3-052d6db50c18",
          "intuition" : "The brute force approach involves scanning the grid and grouping the regions manually, by checking which cells are connected.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "There are 4 regions: the top-left, top-right, bottom-left, and bottom-right sections.",
              "id" : "a1f6b22c-3cc4-42cb-8fd9-0a6a6ed7a2b1",
              "input" : "grid = [\" \/\",\"\/ \"]"
            },
            {
              "expectedOutput" : "8",
              "explanation" : "There are 8 regions: the top-left, top-right, middle-left, middle-right, bottom-left, bottom-right, and two additional regions created by the extra slashes.",
              "id" : "52c40000-1459-46e5-be6f-77c3489ec08b",
              "input" : "grid = [\" \/\",\"\/ \",\"\/ \",\"\/ \"]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There is 1 region: the entire grid.",
              "id" : "0c987746-7bc2-49d8-8f74-6ffaa47b78ab",
              "input" : "grid = [\" \"]"
            }
          ]
        },
        {
          "approach" : "1. Create a Union-Find data structure to group the connected cells together. 2. Iterate over each cell in the grid. 3. For each slash, check if it divides a region into two. 4. If it does, union the two regions together.",
          "code" : "class Solution { func regionsBySlashes(_ grid: [String]) -> Int { let n = grid.count; var res = n * n * 4; var g = Array(repeating: Array(repeating: 0, count: n * 3), count: n * 3); var parent = Array(repeating: -1, count: n * n * 4); func find(_ x: Int) -> Int { if parent[x] == -1 { return x; } parent[x] = find(parent[x]); return parent[x]; }; func union(_ x: Int, _ y: Int) -> Bool { let rootx = find(x); let rooty = find(y); if rootx == rooty { return false; } parent[rootx] = rooty; return true; }; var count = n * n * 4; for i in 0..<n { for j in 0..<n { if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\/' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 3) { count -= 1; } if union(i * n * 4 + j * 4 + 1, i * n * 4 + j * 4 + 2) { count -= 1; } } else if grid[i][grid[i].index(grid[i].startIndex, offsetBy: j)] == '\\' { if union(i * n * 4 + j * 4, i * n * 4 + j * 4 + 1) { count -= 1; } if union(i * n * 4 + j * 4 + 2, i * n * 4 + j * 4 + 3) { count -= 1; } } } } return count; } }",
          "complexity" : {
            "space" : "O(n^2)",
            "spaceExplanation" : "The optimized approach takes O(n^2) space because it has to store the Union-Find data structure.",
            "time" : "O(n)",
            "timeExplanation" : "The optimized approach takes O(n) time because it uses a Union-Find data structure to group the connected cells together."
          },
          "explanation" : "This approach works by using a Union-Find data structure to group the connected cells together, which reduces the time complexity from O(n^2) to O(n).",
          "id" : "95a0a198-b1fb-4008-a29f-6c892870b2b8",
          "intuition" : "The optimized approach involves using a Union-Find data structure to group the connected regions together.",
          "name" : "Optimized Union-Find",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "There are 4 regions: the top-left, top-right, bottom-left, and bottom-right sections.",
              "id" : "3896a930-7a74-4b62-813a-05022571cb68",
              "input" : "grid = [\" \/\",\"\/ \"]"
            },
            {
              "expectedOutput" : "8",
              "explanation" : "There are 8 regions: the top-left, top-right, middle-left, middle-right, bottom-left, bottom-right, and two additional regions created by the extra slashes.",
              "id" : "478d727c-dfd2-41e3-9aa6-04fa24465496",
              "input" : "grid = [\" \/\",\"\/ \",\"\/ \",\"\/ \"]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There is 1 region: the entire grid.",
              "id" : "c304bfd5-c570-44e4-8389-360ac5611df7",
              "input" : "grid = [\" \"]"
            }
          ]
        }
      ],
      "id" : "0aa87367-9c75-4585-9de4-7a4a19e3149c",
      "lastUpdated" : "2026-02-06T21:51:33Z",
      "problemSlug" : "regions-cut-by-slashes",
      "relatedProblems" : [
        "number-of-islands",
        "max-area-of-island"
      ],
      "summary" : "The problem requires counting the number of regions formed by cutting a square into smaller sections using slashes. The key insight is to use a Union-Find data structure to group the regions together."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Iterate over each character in the source code, checking for '\/\/' or '\/*' to identify comments. Step 2: Once a comment is identified, skip over its content until the end of the comment is found ('\/\/' until the end of the line or '*\/' for block comments). Step 3: For any non-comment parts, append those to the result string.",
          "code" : "let source = \"\/**\/\\[new String(\\\"\\\"\\+\\\"\\\")\\]; var s = \"\/**\/\\[new String(\\\"\\\"\\+\\\"\\\")\\];\"; print(removeComments([\"\/**\/\\[new String(\\\"\\\"\\+\\\"\\\")\\]; var s = \"\/**\/\\[new String(\\\"\\\"\\+\\\"\\\")\\];\"])",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) as we store the cleaned-up code, which in the worst case could be of the same length as the original code.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because for each of the 'n' lines, we might be checking up to 'm' characters to handle comments."
          },
          "explanation" : "This method is straightforward but inefficient because it checks every character and may result in multiple passes through the code to handle nested or complex comment structures.",
          "id" : "0d1640e4-026f-41a6-a7c4-bca2e3dcde99",
          "intuition" : "This approach works by manually checking each character in the source code to identify comments and then removing them. It iterates over all characters in the source code.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "source = [\"\", \"\", \"\", \"No comment here\"]",
              "explanation" : "The block comment that spans three lines gets completely removed, leaving only the last line, which doesn't contain any comments.",
              "id" : "d81649b9-9fbd-42ca-aae9-fd27ebf0735b",
              "input" : "source = [\"\/*Block\", \"   comments\", \" *\/\", \"No comment here\"]"
            },
            {
              "expectedOutput" : "source = [\"\", \"No comment here\"]",
              "explanation" : "The line comment on the first line gets removed, while the second line remains unchanged.",
              "id" : "2b19d5de-5af8-4b52-a30a-e76f24db0a63",
              "input" : "source = [\"\/\/Line comment\", \"No comment here\"]"
            }
          ]
        },
        {
          "approach" : "Step 1: Initialize a flag to track if we are inside a comment. Step 2: Iterate over the source code characters, toggling the flag when we encounter '\/\/' or '\/*' or '*\/'. Step 3: If we are not in a comment, append the character to the result string.",
          "code" : "func removeComments(_ source: [String]) -> String { var inBlockComment = false; var result = \"\"; for line in source { for (i, char) in line.enumerated() { if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '*' { inBlockComment = true; } else if inBlockComment && i + 1 < line.count && line[i] == '*' && line[i+1] == '\/' { inBlockComment = false; i += 1; } else if !inBlockComment && i + 1 < line.count && line[i] == '\/' && line[i+1] == '\/' { break; } else if !inBlockComment { result += String(char); } } if !inBlockComment && !result.isEmpty && result.last != \"\n\" { result += \"\n\"; } } return result.trimmingCharacters(in: .whitespacesAndNewlines); }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity remains O(n) for storing the cleaned-up code.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we make a single pass through the source code."
          },
          "explanation" : "This optimized method reduces the number of checks and passes through the source code, making it more efficient than the brute force approach.",
          "id" : "72119832-7bd4-4183-88bc-78787c7d2c1e",
          "intuition" : "This approach uses a state machine-like behavior to keep track of whether we are inside a comment or not, improving efficiency by minimizing unnecessary checks.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "No comment here",
              "explanation" : "After removing the block comment, only 'No comment here' remains.",
              "id" : "f21598b8-05fa-4fd5-8e70-12b04a027ba9",
              "input" : "source = [\"\/*Block\", \"   comments\", \" *\/\", \"No comment here\"]"
            },
            {
              "expectedOutput" : "No comment here",
              "explanation" : "The line comment is removed, leaving 'No comment here' as the output.",
              "id" : "37f57e15-78fc-45dd-9980-21d53646cfae",
              "input" : "source = [\"\/\/Line comment\", \"No comment here\"]"
            }
          ]
        }
      ],
      "id" : "1ed67fc1-9b4c-4182-bdd4-3a4a737d8456",
      "lastUpdated" : "2026-02-06T21:36:18Z",
      "problemSlug" : "remove-comments",
      "relatedProblems" : [
        "parse-lisp-expression",
        "min-remove-to-make-valid-parentheses"
      ],
      "summary" : "This problem involves removing comments from a given source code and returning the cleaned-up code. The key insight here is to identify and handle both line comments and block comments correctly."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize two empty arrays, one for letter-logs and one for digit-logs. Step 2: Iterate over each log and check whether it is a letter-log or a digit-log. Step 3: If it is a letter-log, add it to the letter-logs array. If it is a digit-log, add it to the digit-logs array. Step 4: Sort the letter-logs array lexicographically.",
          "code" : "func reorderLogFiles(_ logs: [String]) -> [String] { let letterLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isLetter } let digitLogs: [String] = logs.filter { log in Character(log.split(separator: \" \")[1]).isNumber } let sortedLetterLogs = letterLogs.sorted { $0.split(separator: \" \")[1] < $1.split(separator: \" \")[1] } return sortedLetterLogs + digitLogs }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing all the logs in two separate arrays.",
            "time" : "O(n*m*log(m))",
            "timeExplanation" : "The time complexity is O(n*m*log(m)) because we are sorting the letter-logs lexicographically."
          },
          "explanation" : "This approach works by first separating the logs into two categories, and then sorting the letter-logs. The time complexity of this approach is O(n*m*log(m)) due to the sorting, where n is the number of logs and m is the maximum length of a log.",
          "id" : "489e4cd3-3f74-4397-bc81-a92116f6869c",
          "intuition" : "The baseline approach works by iterating over each log and checking whether it is a letter-log or a digit-log, and then sorting the letter-logs lexicographically.",
          "name" : "Baseline Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"let1 art can\", \"let3 art zero\", \"let2 own kit dig\", \"dig1 8 1 5 1\", \"dig2 3 6\"]",
              "explanation" : "The output is correct because the letter-logs are sorted lexicographically and the digit-logs remain in their original order.",
              "id" : "419aa947-80d4-4cf0-89e0-c410fa8b6e17",
              "input" : "logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 own kit dig\", \"let3 art zero\"]"
            },
            {
              "expectedOutput" : "[\"g1 act car\", \"zo4 4 7\", \"a1 9 2 3 1\", \"g1 act car\", \"a10 t3 0\"]",
              "explanation" : "The output is incorrect because there is a duplicate letter-log. The correct output should be [\"g1 act car\", \"a1 9 2 3 1\", \"ze0 2 1 2 3\", \"zo4 4 7\", \"a10 t3 0\"]",
              "id" : "09200720-188f-46b7-93a0-c656f218dad5",
              "input" : "logs = [\"a1 9 2 3 1\", \"g1 act car\", \"zo4 4 7\", \"ze0 2 1 2 3\", \"a10 t3 0\"]"
            }
          ]
        },
        {
          "approach" : "Step 1: Define a custom sorting function that checks whether a log is a letter-log or a digit-log. Step 2: If both logs are letter-logs, compare them lexicographically. If one is a letter-log and the other is a digit-log, the letter-log comes first. If both are digit-logs, their original order is preserved.",
          "code" : "func reorderLogFiles(_ logs: [String]) -> [String] { return logs.sorted { log1, log2 in let identifier1 = String(log1.prefix(while: { $0 != \" \" })) let identifier2 = String(log2.prefix(while: { $0 != \" \" })) let content1 = String(log1.suffix(from: log1.firstIndex(of: \" \")!)) let content2 = String(log2.suffix(from: log2.firstIndex(of: \" \")!)) if Character(content1.first!).isLetter && Character(content2.first!).isLetter { return content1 < content2 } else if Character(content1.first!).isLetter { return true } else if Character(content2.first!).isLetter { return false } else { return false } } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing all the logs in the sorted array.",
            "time" : "O(n*m*log(n))",
            "timeExplanation" : "The time complexity is O(n*m*log(n)) because we are sorting the logs using a custom sorting function."
          },
          "explanation" : "This approach works by using a custom sorting function that separates logs into two categories and sorts letter-logs lexicographically. The time complexity of this approach is O(n*m*log(n)) due to the sorting, where n is the number of logs and m is the maximum length of a log.",
          "id" : "6c26ee32-42f6-4c36-b505-899bc43f6236",
          "intuition" : "The optimized approach works by using a custom sorting function that separates logs into two categories and sorts letter-logs lexicographically.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"let1 art can\", \"let3 art zero\", \"let2 own kit dig\", \"dig1 8 1 5 1\", \"dig2 3 6\"]",
              "explanation" : "The output is correct because the letter-logs are sorted lexicographically and the digit-logs remain in their original order.",
              "id" : "4586eb01-3ac9-49cd-8c66-e71cc508f67f",
              "input" : "logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 own kit dig\", \"let3 art zero\"]"
            },
            {
              "expectedOutput" : "[\"g1 act car\", \"a1 9 2 3 1\", \"ze0 2 1 2 3\", \"zo4 4 7\", \"a10 t3 0\"]",
              "explanation" : "The output is correct because the letter-logs are sorted lexicographically and the digit-logs remain in their original order.",
              "id" : "404e31fa-26c5-443a-8f67-21d7bd9635d4",
              "input" : "logs = [\"a1 9 2 3 1\", \"g1 act car\", \"zo4 4 7\", \"ze0 2 1 2 3\", \"a10 t3 0\"]"
            }
          ]
        }
      ],
      "id" : "8a44f932-161c-492a-950e-ce3369f5ae0d",
      "lastUpdated" : "2026-02-06T21:49:56Z",
      "problemSlug" : "reorder-data-in-log-files",
      "relatedProblems" : [
        "most-frequent-subtree-sum",
        "k-diff-pairs-in-an-array"
      ],
      "summary" : "Reorder Data in Log Files is a problem where logs are given and need to be reordered based on whether they are letter-logs or digit-logs, and the key insight is to separate logs into two categories and sort letter-logs lexicographically. The logs need to be sorted based on whether they are letter-logs or digit-logs."
    },
    {
      "approaches" : [
        {
          "approach" : "Step-by-step algorithm: First, we flatten the given matrix into a 1D array. Then we try to reshape the flattened array into a 2D array with 'r' rows and 'c' columns. If the total number of elements in the flattened array is not equal to 'r * c', we cannot reshape the matrix, so we return the original matrix.",
          "code" : "func matrixReshape(_ mat: [[Int]], _ r: Int, _ c: Int) -> [[Int]] { \n    let nums = mat.flatMap { $0 } \n    guard nums.count == r * c else { return mat } \n    return Array(0..<r).map { index in \n        Array(nums[(index*c)..<(index*c+c)]) \n    } \n}",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We need to store the flattened 1D array, which takes O(n*m) space.",
            "time" : "O(n*m)",
            "timeExplanation" : "We iterate over the entire matrix once to flatten it into a 1D array, and then we iterate over the 1D array to reshape it into a 2D array."
          },
          "explanation" : "The brute force solution first flattens the 2D matrix into a 1D array. Then it tries to reshape the 1D array into a new 2D array with 'r' rows and 'c' columns. It checks if the total number of elements in the 1D array is equal to 'r * c'. If not, it returns the original matrix.",
          "id" : "e5f518ec-83f9-40b5-8a38-a05180c57ef9",
          "intuition" : "The brute force solution works by flattening the given matrix into a 1D array, and then trying to reshape it into the new matrix with 'r' rows and 'c' columns.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,2,3,4]]",
              "explanation" : "The reshaped matrix has 1 row and 4 columns, so it can be formed by flattening the original matrix and reshaping it.",
              "id" : "73427333-a78f-459a-bf3b-4b19546d26cc",
              "input" : "nums = [[1,2],[3,4]], r = 1, c = 4"
            },
            {
              "expectedOutput" : "[[1,2],[3,4]]",
              "explanation" : "The reshaped matrix cannot be formed because the total number of elements in the flattened array is not equal to 'r * c', so we return the original matrix.",
              "id" : "b463e258-3ee6-499e-81b2-32de957559ee",
              "input" : "nums = [[1,2],[3,4]], r = 2, c = 4"
            }
          ]
        },
        {
          "approach" : "Step-by-step algorithm: First, we calculate the total number of elements in the given matrix. If the total number of elements is not equal to 'r * c', we return the original matrix. Otherwise, we flatten the given matrix into a 1D array and reshape the flattened array into a 2D array with 'r' rows and 'c' columns.",
          "code" : "func matrixReshape(_ mat: [[Int]], _ r: Int, _ c: Int) -> [[Int]] { \n    let numRows = mat.count \n    let numCols = mat[0].count \n    guard numRows * numCols == r * c else { return mat } \n    var flat: [Int] = [] \n    for i in 0..<numRows { \n        for j in 0..<numCols { \n            flat.append(mat[i][j]) \n        } \n    } \n    var result: [[Int]] = [] \n    for i in 0..<r { \n        result.append(Array(flat[(i*c)..<(i*c+c)])) \n    } \n    return result \n}",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We need to store the flattened 1D array, which takes O(n*m) space.",
            "time" : "O(n*m)",
            "timeExplanation" : "We iterate over the entire matrix once to flatten it into a 1D array, and then we iterate over the 1D array to reshape it into a 2D array."
          },
          "explanation" : "The optimized solution first checks if the total number of elements in the given matrix is equal to 'r * c'. If not, it returns the original matrix without flattening the entire matrix.",
          "id" : "06cc8146-4d6a-4abe-9c22-d69b800f6b39",
          "intuition" : "The optimized solution also works by flattening the given matrix into a 1D array, but it checks if the total number of elements in the flattened array is equal to 'r * c' before flattening the entire matrix.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,2,3,4]]",
              "explanation" : "The reshaped matrix has 1 row and 4 columns, so it can be formed by flattening the original matrix and reshaping it.",
              "id" : "40a7221d-369a-4a77-b81e-eb0c6139a988",
              "input" : "nums = [[1,2],[3,4]], r = 1, c = 4"
            },
            {
              "expectedOutput" : "[[1,2],[3,4]]",
              "explanation" : "The reshaped matrix cannot be formed because the total number of elements in the flattened array is not equal to 'r * c', so we return the original matrix.",
              "id" : "13bc7548-975e-40ec-b21b-f203a96dc2e8",
              "input" : "nums = [[1,2],[3,4]], r = 2, c = 4"
            }
          ]
        }
      ],
      "id" : "f03e6277-529c-4653-b8e7-f7f709cd34dc",
      "lastUpdated" : "2026-02-06T21:26:39Z",
      "problemSlug" : "reshape-the-matrix",
      "relatedProblems" : [
        "transpose-of-a-matrix",
        "set-matrix-zeroes"
      ],
      "summary" : "In the Reshape the Matrix problem, we're given a matrix with 'nums' rows and 'm' columns, and we want to reshape it into a new matrix with 'r' rows and 'c' columns without changing the values, while maintaining the original order. If the reshaped matrix cannot be formed, we should return the original matrix."
    },
    {
      "approaches" : [
        {
          "approach" : "Sort the input deck of cards. Then for each card in the sorted deck, reveal it and add it to the result array.",
          "code" : "\n       class Solution {\n           func deckRevealedIncreasing(_ deck: [Int]) -> [Int] {\n               let sortedDeck = deck.sorted()\n               var result = [Optional<Int>](repeating: nil, count: deck.count)\n               var index = 0\n               for card in sortedDeck {\n                   result[index] = card\n                   index += 2\n                   if index >= result.count {\n                       index = 1\n                   }\n               }\n               return result.compactMap { $0 }\n           }\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) as we need to store the result array of the same size as the input deck.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the sorting operation."
          },
          "explanation" : "The brute force solution is straightforward. We sort the deck first, then we iterate over the sorted deck, revealing each card and add it to the result array.",
          "id" : "d971dfb0-e9cc-43cc-8e3a-170a32090fe3",
          "intuition" : "This approach works by sorting the deck of cards and then revealing them in increasing order.",
          "name" : "Baseline\/Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[2,13,3,11,5,17,7]",
              "explanation" : "After sorting the deck, we get [2,3,5,7,11,13,17]. Reveal the cards according to the problem rules.",
              "id" : "d20b0943-26fc-42ca-bdac-2e32a50546d1",
              "input" : "deck = [17,13,11,2,3,5,7]"
            },
            {
              "expectedOutput" : "[2, 100, 10, 70, 30]",
              "explanation" : "After sorting the deck, we get [2,10,30,70,100]. Reveal the cards according to the problem rules.",
              "id" : "3bde627b-3410-4b28-8636-93ff956b95de",
              "input" : "deck = [100, 70, 30, 2, 10]"
            }
          ]
        },
        {
          "approach" : "Initialize a queue with the indices of the input deck. Then for each card in the sorted deck, pop the front index from the queue, reveal the card at that index, and add it to the result array. If the queue is not empty, push the next index to the back of the queue.",
          "code" : "\n       class Solution {\n           func deckRevealedIncreasing(_ deck: [Int]) -> [Int] {\n               let sortedDeck = deck.sorted()\n               var queue = Array(0..<deck.count)\n               var result = [Int](repeating: 0, count: deck.count)\n               var index = 0\n               for card in sortedDeck {\n                   let RevealedIndex = queue.removeFirst()\n                   result[RevealedIndex] = card\n                   if !queue.isEmpty {\n                       queue.append(queue.removeFirst())\n                   }\n               }\n               return result\n           }\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity remains O(n) for the queue and result array.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity remains O(n log n) due to the sorting operation."
          },
          "explanation" : "The optimized solution uses a queue to efficiently manage the indices of the cards. By always popping the front index, we ensure that the cards are revealed in increasing order.",
          "id" : "146299be-8171-4e00-9b5f-390010f08d36",
          "intuition" : "This approach works by using a queue data structure to efficiently manage the cards as they are revealed.",
          "name" : "Optimized\/Queue-Based",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[2,13,3,11,5,17,7]",
              "explanation" : "After sorting the deck, we get [2,3,5,7,11,13,17]. Reveal the cards according to the problem rules.",
              "id" : "3f780d3e-b84c-4907-bdbf-8aeda11cff28",
              "input" : "deck = [17,13,11,2,3,5,7]"
            },
            {
              "expectedOutput" : "[2, 100, 10, 70, 30]",
              "explanation" : "After sorting the deck, we get [2,10,30,70,100]. Reveal the cards according to the problem rules.",
              "id" : "a9c92729-386c-45ac-9126-0d8adef7ff28",
              "input" : "deck = [100, 70, 30, 2, 10]"
            }
          ]
        }
      ],
      "id" : "1124e563-7759-47cf-a4bd-3f4b71fc5a8c",
      "lastUpdated" : "2026-02-06T21:50:49Z",
      "problemSlug" : "reveal-cards-in-increasing-order",
      "relatedProblems" : [
        "next-permutation",
        "last-moment-before-all-ants-fall-out-of-a-plank"
      ],
      "summary" : "Reveal Cards In Increasing Order is a problem asking to reveal deck of cards in increasing order. Key insight is to sort the deck first then reveal the cards."
    },
    {
      "approaches" : [
        {
          "approach" : "Initialize a queue with the run-length encoded pairs and a variable to store the current element and its count. When next(n) is called, pop elements from the queue until we have enough elements to fulfill the request or the queue is empty.",
          "code" : "class RLEIterator { var queue: [(Int, Int)] = []; var idx: Int = 0; func next(_ n: Int) -> Int { while idx < queue.count { let (count, num) = queue[idx]; if count >= n { queue[idx].0 -= n; return num } else { idx += 1; n -= count } }; return -1 } func hasNext(_ n: Int) -> Bool { return true } init(_ encoding: [Int]) { for i in stride(from: 0, to: encoding.count, by: 2) { queue.append((encoding[i], encoding[i + 1])) } } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store the run-length encoded pairs in the queue.",
            "time" : "O(n)",
            "timeExplanation" : "We might need to traverse the entire queue in the worst case when next(n) is called."
          },
          "explanation" : "The brute-force approach uses a queue to keep track of the elements and their counts. When next(n) is called, we start popping elements from the queue until we have enough elements or the queue is empty. If we have enough elements, we remove the excess count from the current element and return the requested elements. Otherwise, we return as many elements as we can.",
          "id" : "d8e2ab0c-b40c-425e-9b54-e3b5dcbd10d7",
          "intuition" : "Use a queue to store the elements and their counts. Keep track of the remaining count for the current element.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[8, 8, 5, false, 0, true, 0, -1, false]",
              "explanation" : "The test cases cover different scenarios such as requesting more elements than available, requesting less elements than available, and checking if there are enough elements to return.",
              "id" : "882a48c1-a024-4f1c-8a7f-ae1ca9efda18",
              "input" : "RLEIterator([3,8,0,9,2,5]) next(2) next(1) next(1) hasNext(2) next(3) hasNext(1) next(1) next(2) hasNext(2)"
            },
            {
              "expectedOutput" : "[1, 1, -1]",
              "explanation" : "This test case checks when we request more elements than available.",
              "id" : "31ce5de7-b884-4311-9108-e61a917654f8",
              "input" : "RLEIterator([1,1,2,2]) next(1) next(1) next(1)"
            }
          ]
        },
        {
          "approach" : "Use the index to track the current position in the encoding array and update it when next(n) is called.",
          "code" : "class RLEIterator { var encoding: [Int]; var idx: Int = 0; init(_ encoding: [Int]) { self.encoding = encoding } func next(_ n: Int) -> Int { while idx < encoding.count { if encoding[idx] >= n { encoding[idx] -= n; return encoding[idx + 1] } else { idx += 2; n -= encoding[idx - 2] } }; return -1 } func hasNext(_ n: Int) -> Bool { return next(n) != -1 } }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the index and the current count.",
            "time" : "O(n)",
            "timeExplanation" : "In the worst case, we might need to traverse the entire encoding array when next(n) is called."
          },
          "explanation" : "The optimized approach keeps track of the current position in the encoding array using an index and updates it based on the next(n) requests. We subtract n from the current count and return the current number if we have enough elements. Otherwise, we move to the next pair and repeat the process.",
          "id" : "70b67e74-ecb8-4752-8727-eab471700fcb",
          "intuition" : "Initialize an index to keep track of the current position in the encoding array and update it based on the next(n) requests.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[8, 8, 5, false, 0, true, 0, -1, false]",
              "explanation" : "This test case checks different scenarios such as requesting more elements than available, requesting less elements than available, and checking if there are enough elements to return.",
              "id" : "715701ba-bff4-4e14-a917-860aa28888a0",
              "input" : "RLEIterator([3,8,0,9,2,5]) next(2) next(1) next(1) hasNext(2) next(3) hasNext(1) next(1) next(2) hasNext(2)"
            },
            {
              "expectedOutput" : "[1, 1, -1]",
              "explanation" : "This test case checks when we request more elements than available.",
              "id" : "c1df8e08-222c-4743-acbf-d2cf80b2437d",
              "input" : "RLEIterator([1,1,2,2]) next(1) next(1) next(1)"
            }
          ]
        }
      ],
      "id" : "98f1d910-cda1-48d3-a784-330e15664e79",
      "lastUpdated" : "2026-02-06T21:47:19Z",
      "problemSlug" : "rle-iterator",
      "relatedProblems" : [
        "design-tic-tac-toe",
        "number-of-burgers"
      ],
      "summary" : "Design an iterator to support a run-length encoded (RLE) list and provide next(n) to return the next n elements from the list, and hasNext() to check if there are enough elements to return."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Transpose the matrix: swap matrix[i][j] with matrix[j][i] for all i < j\n2. Reverse each row: swap elements from start and end moving inward\n3. The matrix is now rotated 90 clockwise",
          "code" : "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    \/\/ Step 1: Transpose\n    for i in 0..<n {\n        for j in i+1..<n {\n            let temp = matrix[i][j]\n            matrix[i][j] = matrix[j][i]\n            matrix[j][i] = temp\n        }\n    }\n    \n    \/\/ Step 2: Reverse each row\n    for i in 0..<n {\n        matrix[i].reverse()\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "In-place modification, only using temp variable for swaps",
            "time" : "O(n)",
            "timeExplanation" : "We visit each element twice: once for transpose, once for reverse"
          },
          "explanation" : "Consider element at position (i, j). After transpose, it moves to (j, i). After reversing the row, it moves to (j, n-1-i). This is exactly where it should be after a 90 clockwise rotation. The transpose swaps across the main diagonal, and reversing rows completes the rotation. Both operations are O(n) but simple to implement.",
          "id" : "933e672d-34b9-447e-a76c-09644d8f7918",
          "intuition" : "A 90 clockwise rotation can be decomposed into two simpler operations: first transpose the matrix (swap rows and columns), then reverse each row. This avoids complex index math.",
          "name" : "Transpose + Reverse",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[7,4,1],[8,5,2],[9,6,3]]",
              "explanation" : "After transpose: [[1,4,7],[2,5,8],[3,6,9]]. After reversing rows: [[7,4,1],[8,5,2],[9,6,3]]",
              "id" : "834ddbb1-2512-461c-8d69-89990cdb3ac4",
              "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput" : "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
              "explanation" : "4x4 matrix rotated 90 clockwise",
              "id" : "29336c48-3e1e-4719-9b3e-edc488e0bc5e",
              "input" : "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]"
            }
          ]
        },
        {
          "approach" : "1. Process layers from outside to inside (0 to n\/2)\n2. For each layer, rotate elements in groups of 4\n3. For position i in current layer: save top, move lefttop, bottomleft, rightbottom, savedright\n4. Continue until all layers processed",
          "code" : "func rotate(_ matrix: inout [[Int]]) {\n    let n = matrix.count\n    \n    for layer in 0..<n\/2 {\n        let first = layer\n        let last = n - 1 - layer\n        \n        for i in first..<last {\n            let offset = i - first\n            \n            \/\/ Save top\n            let top = matrix[first][i]\n            \n            \/\/ Left -> Top\n            matrix[first][i] = matrix[last - offset][first]\n            \n            \/\/ Bottom -> Left\n            matrix[last - offset][first] = matrix[last][last - offset]\n            \n            \/\/ Right -> Bottom\n            matrix[last][last - offset] = matrix[i][last]\n            \n            \/\/ Top -> Right\n            matrix[i][last] = top\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only one temp variable regardless of matrix size",
            "time" : "O(n)",
            "timeExplanation" : "Each element is moved exactly once"
          },
          "explanation" : "We process the matrix in concentric square layers. For each layer, we rotate 4 elements at a time that form a rotation cycle. Element at top goes to right, right goes to bottom, bottom goes to left, left goes to top. We use one temp variable to facilitate this 4-way swap. This directly implements the rotation without decomposing into simpler operations.",
          "id" : "77b504e7-773e-49d5-b46f-a0b83dd6a98e",
          "intuition" : "Rotate the matrix layer by layer, from the outermost layer inward. For each position in a layer, rotate four cells simultaneously in a cycle.",
          "name" : "Rotate Four Cells at a Time",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[3,1],[4,2]]",
              "explanation" : "2x2 has one layer. Rotate: 1right, 2bottom, 4left, 3top",
              "id" : "2a7b75f5-a5b4-47ee-ab9f-9dc915b99de3",
              "input" : "matrix = [[1,2],[3,4]]"
            },
            {
              "expectedOutput" : "[[1]]",
              "explanation" : "1x1 matrix has no layers to rotate (n\/2 = 0)",
              "id" : "b97b5b40-5421-465f-836a-767045b6c098",
              "input" : "matrix = [[1]]"
            }
          ]
        }
      ],
      "id" : "49fa1410-d23d-4411-a6a0-e931a35c7a76",
      "lastUpdated" : "2026-02-06T08:31:51Z",
      "problemSlug" : "rotate-image",
      "relatedProblems" : [
        "rotate-array",
        "determine-whether-matrix-can-be-obtained-by-rotation"
      ],
      "summary" : "Rotate an nn matrix 90 degrees clockwise in-place. The key insight is that rotation equals transpose + reverse each row, or you can rotate layer by layer from outside in."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible assignments of true and false to variables, then for each assignment, check if all equations are satisfied.",
          "code" : "func equationsPossible(_ equations: [String]) -> Bool { \n    let vars: [Character] = Array(Set(equations.flatMap { Array($0) }.filter { $0.isLetter })).sorted() \n    let n = vars.count \n    let assignments = (0..<1<<n) \n    for assignment in assignments { \n        var isSatisfied = true \n        for equation in equations { \n            if equation[1] == \"!\") { \n                let left = Int vars.firstIndex(of: equation[0])! \n                let right = Int vars.firstIndex(of: equation[3])! \n                if (assignment & (1 << left)) != 0 && (assignment & (1 << right)) != 0 { \n                    isSatisfied = false \n                    break \n                } \n            } else { \n                let left = Int vars.firstIndex(of: equation[0])! \n                let right = Int vars.firstIndex(of: equation[2])! \n                if (assignment & (1 << left)) == 0 && (assignment & (1 << right)) == 0 { \n                    isSatisfied = false \n                    break \n                } \n            } \n        } \n        if isSatisfied { return true } \n    } \n    return false \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Storing all unique variables and the current assignment.",
            "time" : "O(2^n * m)",
            "timeExplanation" : "Trying all possible assignments of true and false, and then checking each equation against these assignments."
          },
          "explanation" : "This approach works by trying all possible combinations of true and false for the variables, then checking each equation against these assignments. If all equations are satisfied for any given assignment, return true.",
          "id" : "795550d2-416e-4717-8f47-fc62ff8fd5ac",
          "intuition" : "Trying all possible assignments of true and false to variables and then evaluating each equation.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "Because one of the equations a==b and b!=a cannot be true at the same time.",
              "id" : "0faf45bd-976e-4bf0-8824-15c4678e4ba7",
              "input" : "equations = [\"a==b\",\"b!=a\"]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Because a==b and b==a are logically equivalent.",
              "id" : "bf98538c-d5d0-4e39-8066-f7fc3cf5e605",
              "input" : "equations = [\"b==a\",\"a==b\"]"
            }
          ]
        },
        {
          "approach" : "Using a Union Find data structure to group equal variables together, then checking if two variables that are not equal are in the same group.",
          "code" : "class UnionFind { \n    var parent: [Int] \n    init(_ n: Int) { \n        parent = Array(repeating: -1, count: n) \n    } \n    func find(_ x: Int) -> Int { \n        if parent[x] < 0 { return x } \n        parent[x] = find(parent[x]) \n        return parent[x] \n    } \n    func union(_ x: Int, _ y: Int) { \n        let rootx = find(x) \n        let rooty = find(y) \n        if rootx != rooty { \n            if parent[rootx] > parent[rooty] { \n                parent[rooty] += parent[rootx] \n                parent[rootx] = rooty \n            } else { \n                parent[rootx] += parent[rooty] \n                parent[rooty] = rootx \n            } \n        } \n    } \n} \nfunc equationsPossible(_ equations: [String]) -> Bool { \n    let uf = UnionFind(26) \n    var equationsWithoutNot: [String] = [] \n    for equation in equations { \n        if equation[1] == \"!\") { \n            continue \n        } \n        uf.union(Int(equation[0].asciiValue! - 97), Int(equation[3].asciiValue! - 97)) \n        equationsWithoutNot.append(equation) \n    } \n    for equation in equations { \n        if equation[1] != \"!\") { \n            continue \n        } \n        if uf.find(Int(equation[0].asciiValue! - 97)) == uf.find(Int(equation[3].asciiValue! - 97)) { \n            return false \n        } \n    } \n    return true \n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Storing the Union Find data structure.",
            "time" : "O(m * alpha(n))",
            "timeExplanation" : "Union and find operations are nearly constant time with path compression and union by rank."
          },
          "explanation" : "This approach works by first grouping equal variables together using a Union Find data structure, then checking each equation that asserts inequality. If two variables that are not equal are in the same group, return false.",
          "id" : "cf34cb8c-f973-475e-93a3-82d9c6c13dd1",
          "intuition" : "Grouping equal variables together and checking if two variables that are not equal are in the same group.",
          "name" : "Union Find",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "Because one of the equations a==b and b!=a cannot be true at the same time.",
              "id" : "0fb9cdd8-882e-49d8-94fd-ede124beaa1a",
              "input" : "equations = [\"a==b\",\"b!=a\"]"
            },
            {
              "expectedOutput" : "true",
              "explanation" : "Because a==b and b==a are logically equivalent.",
              "id" : "c0e5569b-359f-470a-90b1-1a80dcafa2a4",
              "input" : "equations = [\"b==a\",\"a==b\"]"
            }
          ]
        }
      ],
      "id" : "595c56b8-9b41-4f0b-b5ec-04b4de0e9bb9",
      "lastUpdated" : "2026-02-06T22:02:28Z",
      "problemSlug" : "satisfiability-of-equality-equations",
      "relatedProblems" : [
        "number-of-islands",
        "flood-fill"
      ],
      "summary" : "Given an array equations containing equations in the form of strings representing logical equalities, determine whether there exists a way to assign values (true or false) to variables such that all equations are satisfied. The key insight is to group equal variables together."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create sets to store row and column indices that have zeros\n2. Scan matrix, add row\/col indices to sets when we find a zero\n3. Scan matrix again, set cell to 0 if its row or column is in the sets",
          "code" : "func setZeroes(_ matrix: inout [[Int]]) {\n    let m = matrix.count\n    let n = matrix[0].count\n    var zeroRows = Set<Int>()\n    var zeroCols = Set<Int>()\n    \n    \/\/ Find zeros\n    for i in 0..<m {\n        for j in 0..<n {\n            if matrix[i][j] == 0 {\n                zeroRows.insert(i)\n                zeroCols.insert(j)\n            }\n        }\n    }\n    \n    \/\/ Set zeros\n    for i in 0..<m {\n        for j in 0..<n {\n            if zeroRows.contains(i) || zeroCols.contains(j) {\n                matrix[i][j] = 0\n            }\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(m + n)",
            "spaceExplanation" : "Sets can store at most m rows and n columns",
            "time" : "O(m  n)",
            "timeExplanation" : "Two passes through all mn elements"
          },
          "explanation" : "We separate the 'finding zeros' phase from the 'setting zeros' phase to avoid the cascade problem where newly set zeros would incorrectly trigger more zeros. The sets give us O(1) lookup to check if a row or column should be zeroed.",
          "id" : "d5d56952-c02a-469e-babc-30e33f5267d7",
          "intuition" : "First pass: record which rows and columns contain zeros. Second pass: set those rows and columns to zero. Simple but uses O(m+n) extra space.",
          "name" : "Extra Space with Sets",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,0,1],[0,0,0],[1,0,1]]",
              "explanation" : "Zero at (1,1)  row 1 and column 1 become zeros",
              "id" : "18a901d8-7ec7-4cd5-9012-133dfb29dc4b",
              "input" : "matrix = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput" : "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
              "explanation" : "Zeros at (0,0) and (0,3)  row 0, col 0, col 3 become zeros",
              "id" : "df4ce654-93b3-48e5-af64-3d9872b62da6",
              "input" : "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]"
            }
          ]
        },
        {
          "approach" : "1. Check if first row\/column originally have zeros (save this info)\n2. Use first row to mark which columns should be zero\n3. Use first column to mark which rows should be zero\n4. Zero out cells based on markers (skip first row\/col)\n5. Finally, zero out first row\/column if needed",
          "code" : "func setZeroes(_ matrix: inout [[Int]]) {\n    let m = matrix.count\n    let n = matrix[0].count\n    var firstColZero = false\n    \n    \/\/ Use first row and column as markers\n    for i in 0..<m {\n        if matrix[i][0] == 0 {\n            firstColZero = true\n        }\n        for j in 1..<n {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    \n    \/\/ Zero out cells based on markers (process from bottom-right)\n    for i in (1..<m).reversed() {\n        for j in (1..<n).reversed() {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    \n    \/\/ Zero out first row if needed\n    if matrix[0][0] == 0 {\n        for j in 0..<n {\n            matrix[0][j] = 0\n        }\n    }\n    \n    \/\/ Zero out first column if needed\n    if firstColZero {\n        for i in 0..<m {\n            matrix[i][0] = 0\n        }\n    }\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "Only using one boolean variable, markers stored in matrix itself",
            "time" : "O(m  n)",
            "timeExplanation" : "Two passes through the matrix"
          },
          "explanation" : "We repurpose matrix[0][j] to indicate 'column j should be zeroed' and matrix[i][0] to indicate 'row i should be zeroed'. Since these markers share cell (0,0), we use a separate variable for the first column. We process inner cells first, then handle the first row\/column last to preserve our markers until they're no longer needed.",
          "id" : "6f14e90d-231f-4292-ba06-31badbee9f10",
          "intuition" : "Use the first row and first column of the matrix itself as markers. This eliminates extra space, but we need special handling for the first row\/column themselves.",
          "name" : "O(1) Space - First Row\/Col as Markers",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,0,1],[0,0,0],[1,0,1]]",
              "explanation" : "matrix[1][0]=0 marks row 1, matrix[0][1]=0 marks col 1",
              "id" : "e34dbe64-1945-46ab-9e1b-a575842a39c8",
              "input" : "matrix = [[1,1,1],[1,0,1],[1,1,1]]"
            },
            {
              "expectedOutput" : "[[0,0],[0,0]]",
              "explanation" : "Both rows and columns get zeroed due to diagonal zeros",
              "id" : "79abf255-2aea-47e6-a66c-847d3965a42b",
              "input" : "matrix = [[1,0],[0,1]]"
            }
          ]
        }
      ],
      "id" : "c27abb9e-e150-414f-b57b-89af2ebfaea8",
      "lastUpdated" : "2026-02-06T08:31:51Z",
      "problemSlug" : "set-matrix-zeroes",
      "relatedProblems" : [
        "game-of-life"
      ],
      "summary" : "If an element is 0, set its entire row and column to 0. The challenge is doing this in-place without using extra space proportional to matrix size. Use the first row\/column as markers."
    },
    {
      "approaches" : [
        {
          "approach" : "We first create a prefix sum array to calculate the total shift for each character. Then we apply this total shift to each character to get the final result.",
          "code" : "import Foundation\nfunc shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n    var chars = Array(S)\n    var totalShifts = 0\n    for i in (0..<shifts.count).reversed() {\n        totalShifts += shifts[i]\n        chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + totalShifts) % 26 + 97)!)\n    }\n    return String(chars)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We don't need any additional space that scales with input size, so the space complexity is O(1).",
            "time" : "O(n^2)",
            "timeExplanation" : "We need to iterate through the shifts array twice for each character, which gives us a time complexity of O(n^2)."
          },
          "explanation" : "For example, for the string \"abc\" and shifts [3, 5, 9], we calculate the total shift for each character, and then apply this shift to get the final result.",
          "id" : "09bf0b4a-69e8-402d-90ec-25779f8a1684",
          "intuition" : "This approach calculates the total shift for each character by summing all the shifts to its right, and then shifts the character by this calculated amount.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "\"rpl\"",
              "explanation" : "Total shift for 'a' is 3 + 5 + 9 = 17, so 'a' becomes 'r'. Total shift for 'b' is 5 + 9 = 14, so 'b' becomes 'p'. Total shift for 'c' is 9, so 'c' becomes 'l'.",
              "id" : "5c585d43-3b06-421e-beed-4230491b58cf",
              "input" : "S = \"abc\", shifts = [3, 5, 9]"
            },
            {
              "expectedOutput" : "\"dpw\"",
              "explanation" : "Total shift for 'a' is 3 + 5 + 9 = 17, so 'a' becomes 'r', then shifted again to get 'd'. Total shift for 'b' is 5 + 9 = 14, so 'b' becomes 'p', then shifted again to get 'w'.",
              "id" : "dafead2c-863d-4e5e-9c3a-58474aa440ab",
              "input" : "S = \"aaa\", shifts = [3, 5, 9]"
            }
          ]
        },
        {
          "approach" : "We first create a prefix sum array to calculate the total shift for each character, and then use this prefix sum array to shift each character.",
          "code" : "import Foundation\nfunc shiftingLetters(_ S: String, _ shifts: [Int]) -> String {\n    var chars = Array(S)\n    var prefixSum = shifts\n    for i in (0..<shifts.count - 1).reversed() {\n        prefixSum[i] += prefixSum[i + 1]\n    }\n    for i in 0..<chars.count {\n        chars[i] = Character(UnicodeScalar((UInt32(chars[i].unicodeScalars.first!.value) - 97 + prefixSum[i]) % 26 + 97)!)    \n    }\n    return String(chars)\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We don't need any additional space that scales with input size, so the space complexity is O(1).",
            "time" : "O(n)",
            "timeExplanation" : "We need to iterate through the shifts array twice to calculate the prefix sum, which gives us a time complexity of O(n)."
          },
          "explanation" : "We calculate the prefix sum of the shifts array, which gives us the total shift for each character. We then use this prefix sum array to shift each character.",
          "id" : "f4c6324a-9d13-4dde-a389-5aa691a7f83e",
          "intuition" : "We can optimize the brute-force approach by calculating the total shift for each character using a prefix sum array.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "\"rpl\"",
              "explanation" : "Total shift for 'a' is 3 + 5 + 9 = 17, so 'a' becomes 'r'. Total shift for 'b' is 5 + 9 = 14, so 'b' becomes 'p'. Total shift for 'c' is 9, so 'c' becomes 'l'.",
              "id" : "53b47c3f-b1bc-4c6c-ac1e-9a27290d8060",
              "input" : "S = \"abc\", shifts = [3, 5, 9]"
            },
            {
              "expectedOutput" : "\"dpw\"",
              "explanation" : "Total shift for 'a' is 3 + 5 + 9 = 17, so 'a' becomes 'r', then shifted again to get 'd'. Total shift for 'b' is 5 + 9 = 14, so 'b' becomes 'p', then shifted again to get 'w'.",
              "id" : "86d36bb5-58a7-4e23-8cc2-e8ee2a4ee0bb",
              "input" : "S = \"aaa\", shifts = [3, 5, 9]"
            }
          ]
        }
      ],
      "id" : "f61a83d8-ccc0-48a1-b5ac-cfdee49f565f",
      "lastUpdated" : "2026-02-06T21:44:11Z",
      "problemSlug" : "shifting-letters",
      "relatedProblems" : [
        "cauliflower",
        "reverse-words-in-string-iii",
        "valid-palindrome-ii"
      ],
      "summary" : "The shifting letters problem requires us to shift characters in a string based on a given array of shifts. We can solve this problem by first calculating the total shift for each character and then applying this shift to get the final result."
    },
    {
      "approaches" : [
        {
          "approach" : "First, find all the land cells in the grid and group them into two islands. Then, for each island, perform a BFS traversal and at each step, check if the current cell is part of the other island. If it is, return the current distance as the shortest bridge length.",
          "code" : "func shortestBridge(_ A: [[Int]]) -> Int {\n    var dirs = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    var queue = [(Int, Int, Int)]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: A[0].count), count: A.count)\n    \n    func isValid(_ x: Int, _ y: Int) -> Bool {\n        return x >= 0 && x < A.count && y >= 0 && y < A[0].count\n    }\n    \n    func bfs() -> Int {\n        var res = 0\n        while !queue.isEmpty {\n            let (x, y, d) = queue.removeFirst()\n            \n            if A[x][y] == 1 && d > 0 {\n                return d\n            }\n            \n            for dir in dirs {\n                let nx = x + dir[0]\n                let ny = y + dir[1]\n                \n                if isValid(nx, ny) && !visited[nx][ny] {\n                    visited[nx][ny] = true\n                    \n                    if A[nx][ny] == 1 {\n                        queue.append((nx, ny, d + 1))\n                    } else {\n                        queue.append((nx, ny, d + 1))\n                    }\n                }\n            }\n        }\n        return res\n    }\n    \n    for i in 0...A.count-1 {\n        for j in 0...A[0].count-1 {\n            if A[i][j] == 1 {\n                visited[i][j] = true\n                queue.append((i, j, 0))\n                \n                for dir in dirs {\n                    let nx = i + dir[0]\n                    let ny = j + dir[1]\n                    \n                    if isValid(nx, ny) && !visited[nx][ny] {\n                        visited[nx][ny] = true\n                        queue.append((nx, ny, 1))\n                    }\n                }\n                return bfs()\n            }\n        }\n    }\n    return 0\n}",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is O(n * m) because we need to store the visited cells in the visited array, which takes O(n * m) space.",
            "time" : "O(n^2 * m^2)",
            "timeExplanation" : "The time complexity is O(n^2 * m^2) because in the worst case, we need to perform a BFS traversal from each island, which takes O(n * m) time. Also, we need to check every possible path from each island to every other island, which takes O(n * m) time."
          },
          "explanation" : "The brute-force approach has a high time complexity because it needs to perform BFS traversal from each island. Also, it needs to check every possible path from each island to every other island.",
          "id" : "8feaf99c-32b3-4edc-99ab-461fd0008e96",
          "intuition" : "This approach works by checking every possible path from each island to every other island and keeping track of the shortest path found.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The shortest bridge between the two islands has a length of 2.",
              "id" : "e7b5b1f6-3233-4ff0-b925-f28f70354550",
              "input" : "A = [[0,1,0],[0,0,0],[0,0,1]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The shortest bridge between the two islands has a length of 1.",
              "id" : "40858c2c-d066-4f60-bd8a-875fd7e926e0",
              "input" : "A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]"
            }
          ]
        },
        {
          "approach" : "First, find the first island and perform a BFS traversal to label all the cells in the island with a distance of 0. Then, perform another BFS traversal to find the shortest path to the second island.",
          "code" : "func shortestBridge(_ A: [[Int]]) -> Int {\n    var dirs = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n    var queue = [(Int, Int, Int)]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count: A[0].count), count: A.count)\n    \n    func isValid(_ x: Int, _ y: Int) -> Bool {\n        return x >= 0 && x < A.count && y >= 0 && y < A[0].count\n    }\n    \n    func bfs() -> Int {\n        var res = 0\n        while !queue.isEmpty {\n            let (x, y, d) = queue.removeFirst()\n            \n            if A[x][y] == 1 && d > 0 {\n                return d\n            }\n            \n            for dir in dirs {\n                let nx = x + dir[0]\n                let ny = y + dir[1]\n                \n                if isValid(nx, ny) && !visited[nx][ny] {\n                    visited[nx][ny] = true\n                    \n                    if A[nx][ny] == 1 {\n                        queue.append((nx, ny, d + 1))\n                    } else {\n                        queue.append((nx, ny, d + 1))\n                    }\n                }\n            }\n        }\n        return res\n    }\n    \n    func getFirstIsland() -> [(Int, Int)] {\n        var island = [(Int, Int)]()\n        for i in 0...A.count-1 {\n            for j in 0...A[0].count-1 {\n                if A[i][j] == 1 {\n                    island.append((i, j))\n                    visited[i][j] = true\n                    var stack = [(i, j)]\n                    while !stack.isEmpty {\n                        let (x, y) = stack.removeLast()\n                        for dir in dirs {\n                            let nx = x + dir[0]\n                            let ny = y + dir[1]\n                            \n                            if isValid(nx, ny) && !visited[nx][ny] && A[nx][ny] == 1 {\n                                island.append((nx, ny))\n                                visited[nx][ny] = true\n                                stack.append((nx, ny))\n                            }\n                        }\n                    }\n                    return island\n                }\n            }\n        }\n        return island\n    }\n    \n    var island = getFirstIsland()\n    for (x, y) in island {\n        queue.append((x, y, 0))\n    }\n    return bfs()\n}",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "The space complexity is O(n * m) because we need to store the visited cells in the visited array, which takes O(n * m) space.",
            "time" : "O(n * m)",
            "timeExplanation" : "The time complexity is O(n * m) because we need to perform two BFS traversals, one for each island, which takes O(n * m) time."
          },
          "explanation" : "The optimized approach has a lower time complexity than the brute-force approach because it only needs to perform two BFS traversals, one for each island.",
          "id" : "9fa45756-5b2c-449c-a9b7-8da8fb6b6ade",
          "intuition" : "This approach works by using a BFS traversal to find the shortest path between the two islands. It first identifies the two islands and then performs a BFS traversal from each island.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The shortest bridge between the two islands has a length of 2.",
              "id" : "729ff700-3a58-4304-8a20-a7811ca96c2d",
              "input" : "A = [[0,1,0],[0,0,0],[0,0,1]]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "The shortest bridge between the two islands has a length of 1.",
              "id" : "a2becf45-994a-4d63-9625-4dfdd7157854",
              "input" : "A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]"
            }
          ]
        }
      ],
      "id" : "ed8bb4ce-6789-48bc-908d-1144fec861dd",
      "lastUpdated" : "2026-02-06T21:49:38Z",
      "problemSlug" : "shortest-bridge",
      "relatedProblems" : [
        "number-of-islands",
        "max-area-of-island"
      ],
      "summary" : "The problem asks us to find the shortest bridge between two islands in a given 2D grid. The key insight is to use a breadth-first search (BFS) to traverse the grid and find the shortest path."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a dictionary to store the frequency of characters in the license plate. Then, iterate over each word and compare its character frequency with the license plate's frequency. If a word matches all characters in the license plate, update the result if the word is shorter.",
          "code" : "func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; for word in words { let wordCount: [Character: Int] = word.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are using a constant amount of space to store the frequency of characters in the license plate and the current word.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because we are iterating over each word and each character in the word."
          },
          "explanation" : "This approach involves a straightforward comparison of character frequencies. It iterates over each word, making it inefficient for large inputs.",
          "id" : "cac84085-a1a6-4f13-b976-d369d2c4233b",
          "intuition" : "This approach works by comparing the frequency of characters in the license plate with each word and finding the shortest match.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "steps",
              "explanation" : "The frequency of characters in the license plate is [s: 1, t: 1, p: 1]. The word 'steps' matches all characters in the license plate and is the shortest match.",
              "id" : "66c86c1d-9f47-47f2-b007-fd64c2fa69ce",
              "input" : "licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]"
            },
            {
              "expectedOutput" : "pest",
              "explanation" : "The frequency of characters in the license plate is [s: 1]. The word 'pest' matches all characters in the license plate and is the shortest match.",
              "id" : "09858553-30f9-4ee9-b4c8-46a08c00dd1e",
              "input" : "licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]"
            }
          ]
        },
        {
          "approach" : "Create a dictionary to store the frequency of characters in the license plate. Then, iterate over each word and compare its character frequency with the license plate's frequency. Use a hashmap to store the frequency of characters in each word to avoid redundant computation.",
          "code" : "func shortestCompletingWord(licensePlate: String, _ words: [String]) -> String { let licensePlateCount: [Character: Int] = licensePlate.lowercased().filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default: 0] += 1 }; var minLen = Int.max; var res = \"\"; var wordCount: [Character: Int] = [:]; for word in words { wordCount.removeAll(); for char in word.lowercased() { wordCount[char, default: 0] += 1 }; if licensePlateCount.allSatisfy { wordCount[$0.key, default: 0] >= $0.value } && word.count < minLen { minLen = word.count; res = word } } return res }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are using a constant amount of space to store the frequency of characters in the license plate and the current word.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) because we are iterating over each word and each character in the word."
          },
          "explanation" : "This approach involves using a hashmap to store the frequency of characters in each word. This allows for more efficient comparison and avoids redundant computation.",
          "id" : "022362b9-e931-40eb-9648-91d4fe14ea3b",
          "intuition" : "This approach works by using a hash table to store the frequency of characters in each word and then comparing these frequencies with the license plate's frequency.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "steps",
              "explanation" : "The frequency of characters in the license plate is [s: 1, t: 1, p: 1]. The word 'steps' matches all characters in the license plate and is the shortest match.",
              "id" : "d2740e08-58e9-41a3-a1b7-c82dda103473",
              "input" : "licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]"
            },
            {
              "expectedOutput" : "pest",
              "explanation" : "The frequency of characters in the license plate is [s: 1]. The word 'pest' matches all characters in the license plate and is the shortest match.",
              "id" : "cc32df22-81b3-4c60-abf4-5db465eede0d",
              "input" : "licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]"
            }
          ]
        }
      ],
      "id" : "104fa23d-a0b5-4c2b-84b0-5dd3ce26d3e9",
      "lastUpdated" : "2026-02-06T21:37:12Z",
      "problemSlug" : "shortest-completing-word",
      "relatedProblems" : [
        "find-and-replace-pattern",
        "minimum-window-substring"
      ],
      "summary" : "The problem requires finding the shortest completing word from a list of words. The key insight is to compare the frequency of characters in the license plate with each word and find the shortest match."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize top, bottom, left, right bounds.\n2. Traverse right, down, left, and up while bounds are valid.\n3. Shrink bounds after each side.",
          "code" : "func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n    guard !matrix.isEmpty else { return [] }\n    var top = 0\n    var bottom = matrix.count - 1\n    var left = 0\n    var right = matrix[0].count - 1\n    var result: [Int] = []\n\n    while top <= bottom && left <= right {\n        for col in left...right { result.append(matrix[top][col]) }\n        top += 1\n        if top > bottom { break }\n\n        for row in top...bottom { result.append(matrix[row][right]) }\n        right -= 1\n        if left > right { break }\n\n        for col in stride(from: right, through: left, by: -1) { result.append(matrix[bottom][col]) }\n        bottom -= 1\n        if top > bottom { break }\n\n        for row in stride(from: bottom, through: top, by: -1) { result.append(matrix[row][left]) }\n        left += 1\n    }\n\n    return result\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "No extra space besides the output array.",
            "time" : "O(m * n)",
            "timeExplanation" : "Each cell is visited exactly once."
          },
          "explanation" : "This orderly boundary scan avoids revisiting cells and handles non-square matrices.",
          "id" : "3cc9ef2e-fea5-401a-aa0a-595369e016c9",
          "intuition" : "Each spiral layer is a rectangle. After traversing its edges, we move the boundaries inward.",
          "name" : "Boundary Traversal",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[1,2,3,6,9,8,7,4,5]",
              "explanation" : "Classic 3x3 spiral.",
              "id" : "40d28244-749c-499c-8684-5141ef7ad57b",
              "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            },
            {
              "expectedOutput" : "[1,2,3,4,8,12,11,10,9,5,6,7]",
              "explanation" : "Spiral for rectangular matrix.",
              "id" : "1794fb06-b57a-4d9a-ae73-8323c7c50b14",
              "input" : "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]"
            }
          ]
        }
      ],
      "id" : "3d011264-1955-48cf-99a3-28cb75d173a0",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "spiral-matrix",
      "relatedProblems" : [
        "spiral-matrix-ii",
        "rotate-image"
      ],
      "summary" : "Walk the matrix in layers by shrinking the top, bottom, left, and right boundaries."
    },
    {
      "approaches" : [
        {
          "approach" : "Start with the number 1 and fill in the matrix in a spiral order by iterating over each cell in the matrix, keeping track of the current row and column.",
          "code" : "func generateMatrix(_ n: Int) -> [[Int]] {\n    var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    var counter = 1\n    var rowStart = 0\n    var rowEnd = n - 1\n    var colStart = 0\n    var colEnd = n - 1\n    while rowStart <= rowEnd && colStart <= colEnd {\n        for i in stride(from: colStart, through: colEnd, by: 1) {\n            matrix[rowStart][i] = counter\n            counter += 1\n        }\n        rowStart += 1\n        for i in stride(from: rowStart, through: rowEnd, by: 1) {\n            matrix[i][colEnd] = counter\n            counter += 1\n        }\n        colEnd -= 1\n        if rowStart <= rowEnd {\n            for i in stride(from: colEnd, through: colStart, by: -1) {\n                matrix[rowEnd][i] = counter\n                counter += 1\n            }\n            rowEnd -= 1\n        }\n        if colStart <= colEnd {\n            for i in stride(from: rowEnd, through: rowStart, by: -1) {\n                matrix[i][colStart] = counter\n                counter += 1\n            }\n            colStart += 1\n        }\n    }\n    return matrix\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are not using any additional space that scales with input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are filling in each cell in the matrix."
          },
          "explanation" : "This approach is not efficient because it requires checking each cell in the matrix to see if it has been filled, resulting in a lot of repeated work.",
          "id" : "2085cd09-67f0-4884-93c8-eb17b30e82ad",
          "intuition" : "The brute force approach works by iterating over each cell in the matrix and filling it with the correct number based on the current row and column.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
              "explanation" : "The matrix is filled in a spiral order starting from the top left corner.",
              "id" : "1c6b9bdc-7c8b-4674-a639-6fd36e2b580b",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]",
              "explanation" : "The matrix is filled in a spiral order starting from the top left corner.",
              "id" : "1d6f6cb6-0113-486d-acfb-fb5b1bc88c22",
              "input" : "n = 4"
            }
          ]
        },
        {
          "approach" : "Use four pointers to control the boundaries of the matrix and fill in the cells in a spiral order.",
          "code" : "func generateMatrix(_ n: Int) -> [[Int]] {\n    var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    var counter = 1\n    var directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    var directionIndex = 0\n    var row = 0\n    var col = 0\n    while counter <= n * n {\n        matrix[row][col] = counter\n        counter += 1\n        let nextRow = row + directions[directionIndex][0]\n        let nextCol = col + directions[directionIndex][1]\n        if nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0 {\n            directionIndex = (directionIndex + 1) % 4\n        }\n        row += directions[directionIndex][0]\n        col += directions[directionIndex][1]\n    }\n    return matrix\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are not using any additional space that scales with input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "The time complexity is O(n^2) because we are filling in each cell in the matrix."
          },
          "explanation" : "This approach is more efficient because it avoids checking each cell in the matrix to see if it has been filled, resulting in less repeated work.",
          "id" : "46bbc252-c494-4b22-948c-d36a7ad42a51",
          "intuition" : "The optimized approach works by using four pointers to control the boundaries of the matrix and filling in the cells in a spiral order.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]",
              "explanation" : "The matrix is filled in a spiral order starting from the top left corner.",
              "id" : "3705e6da-a361-4f01-a720-889ad86f64c2",
              "input" : "n = 3"
            },
            {
              "expectedOutput" : "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]",
              "explanation" : "The matrix is filled in a spiral order starting from the top left corner.",
              "id" : "6fc799cf-756b-478d-8dd1-47a767d477a2",
              "input" : "n = 4"
            }
          ]
        }
      ],
      "id" : "0a853ff3-7793-4744-b263-bf2e5ccabd94",
      "lastUpdated" : "2026-02-06T21:04:53Z",
      "problemSlug" : "spiral-matrix-ii",
      "relatedProblems" : [
        "spiral-matrix",
        "spiral-matrix-iii"
      ],
      "summary" : "Generate a matrix filled with numbers from 1 to n^2 in a spiral order, key insight is to use four pointers to control the boundaries of the matrix."
    },
    {
      "approaches" : [
        {
          "approach" : "Start at the given position, then move in a spiral order (right, down, left, up) until we have visited all cells.",
          "code" : "let R: Int = 5\nlet C: Int = 6\nvar res = [[Int]](repeating: [Int](repeating: 0, count: C), count: R)\nvar i = 0\nvar j = 0\nvar cnt = 1\nwhile cnt <= R * C {\n    res[i][j] = cnt\n    cnt += 1\n    var right = j, down = i, left = j, up = i\n    right += 1\n    if right < C && res[i][right] == 0 {\n        j = right\n    } else {\n        i += 1\n        down = i\n        if i < R && res[i][j] == 0 {\n            if down >= R { i = R - 1 }\n        } else {\n            j -= 1\n            left = j\n            if left >= 0 && res[i][left] == 0 {\n                if left < 0 { j = 0 }\n            } else {\n                i -= 1\n                up = i\n                if up >= 0 && res[i][j] == 0 {\n                    if up < 0 { i = 0 }\n                }\n            }\n        }\n    }\n}\n",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because we are storing the result in a matrix of size R x C.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because we are visiting each cell in the matrix once."
          },
          "explanation" : "In each step, we need to check if the current cell is within the bounds of the matrix and not visited before. If it is, we fill in the cell and move to the next cell.",
          "id" : "d2014fd4-9c68-4322-8011-b0a806cb45b8",
          "intuition" : "We can use a brute force approach to fill in the cells one by one, checking if the current cell is within the bounds of the matrix and not visited before.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
              "explanation" : "This test case starts at position (1,4) and fills in the cells in a spiral order.",
              "id" : "137b69fb-e899-4a5d-8fa7-1e03ca7ad2f2",
              "input" : "R = 5, C = 6, r0 = 1, c0 = 4"
            },
            {
              "expectedOutput" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
              "explanation" : "This test case starts at position (1,4) and fills in the cells in a spiral order.",
              "id" : "25c9e84d-44d7-4afd-b2ed-c8cc6f22173a",
              "input" : "R = 5, C = 6, r0 = 1, c0 = 4"
            }
          ]
        },
        {
          "approach" : "Start at the given position, then move in a spiral order (right, down, left, up) until we have visited all cells.",
          "code" : "func spiralMatrixIII(_ R: Int, _ C: Int, _ r0: Int, _ c0: Int) -> [[Int]] {\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    var res = [[Int]](repeating: [Int](repeating: 0, count: C), count: R)\n    var cnt = 1\n    var i = r0\n    var j = c0\n    var dir = 0\n    while cnt <= R * C {\n        res[i][j] = cnt\n        cnt += 1\n        var ii = i + directions[dir].0\n        var jj = j + directions[dir].1\n        if ii >= 0, ii < R, jj >= 0, jj < C, res[ii][jj] == 0 {\n            i = ii\n            j = jj\n        } else {\n            dir = (dir + 1) % 4\n            i += directions[dir].0\n            j += directions[dir].1\n        }\n    }\n    return res\n}",
          "complexity" : {
            "space" : "O(R*C)",
            "spaceExplanation" : "The space complexity is O(R*C) because we are storing the result in a matrix of size R x C.",
            "time" : "O(R*C)",
            "timeExplanation" : "The time complexity is O(R*C) because we are visiting each cell in the matrix once."
          },
          "explanation" : "In each step, we need to check if the current cell is within the bounds of the matrix and not visited before. If it is, we fill in the cell and move to the next cell.",
          "id" : "80a27be9-e6ed-490f-823d-47e6aba9c62e",
          "intuition" : "We can use an optimized approach to fill in the cells by moving in a spiral order (right, down, left, up) and keeping track of the current position and direction.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
              "explanation" : "This test case starts at position (1,4) and fills in the cells in a spiral order.",
              "id" : "b19b4f8b-a4f2-4d0c-b76b-182f8b0555af",
              "input" : "R = 5, C = 6, r0 = 1, c0 = 4"
            },
            {
              "expectedOutput" : "[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]",
              "explanation" : "This test case starts at position (1,4) and fills in the cells in a spiral order.",
              "id" : "9184baa6-ab74-4a1b-bab3-61bff3ea98ee",
              "input" : "R = 5, C = 6, r0 = 1, c0 = 4"
            }
          ]
        }
      ],
      "id" : "59c7eed7-3a23-4707-a477-22cc04bdfbf3",
      "lastUpdated" : "2026-02-06T21:46:23Z",
      "problemSlug" : "spiral-matrix-iii",
      "relatedProblems" : [
        "spiral-matrix",
        "spiral-matrix-ii"
      ],
      "summary" : "This problem asks us to generate a spiral matrix of size R x C starting from a given position. We need to traverse the matrix in a spiral order and fill in the cells."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Keep a dictionary of prefixSum -> count (start with 0 -> 1).\n2. Iterate nums, updating currentSum.\n3. Add counts of (currentSum - k) to the answer.\n4. Increment the count for currentSum.",
          "code" : "func subarraySum(_ nums: [Int], _ k: Int) -> Int {\n    var count = 0\n    var sum = 0\n    var freq: [Int: Int] = [0: 1]\n    for num in nums {\n        sum += num\n        if let c = freq[sum - k] { count += c }\n        freq[sum, default: 0] += 1\n    }\n    return count\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "Prefix sums stored in the map.",
            "time" : "O(n)",
            "timeExplanation" : "Single pass with O(1) hash operations."
          },
          "explanation" : "This avoids O(n^2) enumeration by using prefix sums and frequencies.",
          "id" : "8fdde843-fc09-448d-bf2e-00ec0b0885c5",
          "intuition" : "If currentSum - k has been seen before, each occurrence defines a subarray ending here with sum k.",
          "name" : "Prefix Sum + Map",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "Subarrays [1,1] at indices (0,1) and (1,2).",
              "id" : "36b9d5fd-4a58-46fb-ae4f-6fb5cfb8a641",
              "input" : "nums = [1,1,1], k = 2"
            },
            {
              "expectedOutput" : "2",
              "explanation" : "Subarrays [1,2] and [3].",
              "id" : "b9c9fbd2-7155-46a9-8270-792727582b7c",
              "input" : "nums = [1,2,3], k = 3"
            }
          ]
        }
      ],
      "id" : "09218b74-9f9a-490a-ae70-c1ac4dec5ca8",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "subarray-sum-equals-k",
      "relatedProblems" : [
        "minimum-size-subarray-sum",
        "continuous-subarray-sum"
      ],
      "summary" : "Count how often each prefix sum appears to find subarrays summing to k."
    },
    {
      "approaches" : [
        {
          "approach" : "Generate all possible subarrays from the given array, then calculate the sum of each subarray. Check if the sum of the subarray is divisible by k.",
          "code" : "func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { var count = 0; for i in 0..<nums.count { for j in i..<nums.count { let sum = nums[i...j].reduce(0, +); if sum % k == 0 { count += 1; } } }; return count; }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because the space used does not change with the size of the input array.",
            "time" : "O(n^3)",
            "timeExplanation" : "The time complexity is O(n^3) because there are two nested loops to generate subarrays, and the sum of the subarray is calculated for each subarray."
          },
          "explanation" : "This approach is not efficient for large arrays because it involves generating all possible subarrays and calculating their sums, resulting in a time complexity of O(n^3).",
          "id" : "a8c13e31-fbd0-475b-bc23-8fab9281c619",
          "intuition" : "This approach works by generating all possible subarrays and checking if their sum is divisible by k.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "There are 7 subarrays where the sum of the subarray elements is divisible by 5.",
              "id" : "7c61205a-d213-43e8-853e-87fa0041880a",
              "input" : "nums = [4,5,0,-2,-3,1], k = 5"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "There are 3 subarrays where the sum of the subarray elements is divisible by 10.",
              "id" : "12ba3275-961b-49d8-87a1-05ab50f9ed76",
              "input" : "nums = [4,5,0,-2,-3,1], k = 10"
            }
          ]
        },
        {
          "approach" : "Calculate the prefix sum for the given array and store the prefix sums modulo k in a hash map. Then, iterate through the array and for each prefix sum, calculate the number of subarrays where the sum of the subarray elements is divisible by k.",
          "code" : "func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int { let n = nums.count; var count = 0; var prefixSum = 0; var sumCount: [Int: Int] = [0: 1]; for num in nums { prefixSum = (prefixSum + num) % k; if prefixSum < 0 { prefixSum += k; } if let val = sumCount[prefixSum] { count += val; } sumCount[prefixSum, default: 0] += 1 }; return count; }",
          "complexity" : {
            "space" : "O(k)",
            "spaceExplanation" : "The space complexity is O(k) because the maximum number of entries in the hash map is k.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because the array is iterated through once."
          },
          "explanation" : "This approach is efficient because it uses a hash map to store the prefix sums modulo k, resulting in a time complexity of O(n).",
          "id" : "d37ba49c-55e7-4ba7-b890-6be71e0877fc",
          "intuition" : "This approach works by using a hash map to store the prefix sums modulo k.",
          "name" : "Prefix Sum with Hash Map",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "7",
              "explanation" : "There are 7 subarrays where the sum of the subarray elements is divisible by 5.",
              "id" : "348cda6a-2a46-45e4-a949-f7a10aa2f538",
              "input" : "nums = [4,5,0,-2,-3,1], k = 5"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "There are 3 subarrays where the sum of the subarray elements is divisible by 10.",
              "id" : "c70fc1d5-8b71-41b2-b176-3f30713eaef6",
              "input" : "nums = [4,5,0,-2,-3,1], k = 10"
            }
          ]
        }
      ],
      "id" : "d6c117b3-6da5-4a32-9d82-ec8894198b5f",
      "lastUpdated" : "2026-02-06T21:52:33Z",
      "problemSlug" : "subarray-sums-divisible-by-k",
      "relatedProblems" : [
        "subarray-sum-equals-k",
        "contiguous-array"
      ],
      "summary" : "Given an integer array nums and an integer k, return the number of subarrays where the sum of the subarray elements is divisible by k. The key insight is to use a hash map to store the prefix sums modulo k."
    },
    {
      "approaches" : [
        {
          "approach" : "Split each domain string by '.' to get subdomains, then use a hash map to count visits for each subdomain and its subdomains.",
          "code" : "class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var count: [String: Int] = [:]; for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr if var currCount = count[subdomainStr] { count[subdomainStr] = currCount + countVal } else { count[subdomainStr] = countVal } } } return count.map { \"\\(String($1)) \\(String($0))\" } } }",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "To store the visit count for each subdomain and its subdomains in the hash map.",
            "time" : "O(n * m)",
            "timeExplanation" : "Where n is the number of domain strings and m is the average number of subdomains."
          },
          "explanation" : "This approach iterates over each domain string, splits it into subdomains, and then updates the visit count for each subdomain and its subdomains in the hash map. Finally, it constructs the result string by concatenating each subdomain with its visit count and returns the result.",
          "id" : "dd5d9b78-4a82-4bde-b224-ffec318e49b7",
          "intuition" : "This approach works by parsing each domain string, splitting it into subdomains, and then counting the visits for each subdomain using a hash map.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"]",
              "explanation" : "Since discuss.leetcode.com has 9001 visits, and leetcode.com also has 9001 visits, the result is [\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"].",
              "id" : "f42215bb-93f6-4e68-9207-0aa95c75c2eb",
              "input" : "cpdomains = [\"9001 discuss.leetcode.com\"]"
            },
            {
              "expectedOutput" : "[\"900 google.mail.com\",\"50 yahoo.com\",\"10 intel.mail.com\",\"5 wiki.org\",\"5 org\",\"10 mail.com\",\"900 mail.com\"]",
              "explanation" : "The result includes the visit count for all subdomains and their parent domains.",
              "id" : "f820655f-e31f-4bc1-b32f-982b01d61ab4",
              "input" : "cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]"
            }
          ]
        },
        {
          "approach" : "Split each domain string by '.' to get subdomains, then maintain an array of subdomains for each domain string. Iterate over each subdomain and its subdomains to update the visit count.",
          "code" : "class Solution { func subdomainVisits(_ cpdomains: [String]) -> [String] { var visits: [String: Int] = [:] for domain in cpdomains { let parts = domain.components(separatedBy: \" \") let countVal = Int(parts[0])! let subdomains = parts[1].components(separatedBy: \".\") var subdomainStr = \"\" for i in stride(from: subdomains.count - 1, to: -1, by: -1) { subdomainStr = subdomains[i] + (subdomainStr.isEmpty ? \"\" : \".\") + subdomainStr visits[subdomainStr, default: 0] += countVal } } return visits.map { \"\\($1) \\($0)\" } } }",
          "complexity" : {
            "space" : "O(n * m)",
            "spaceExplanation" : "To store the visit count for each subdomain and its subdomains in the hash map.",
            "time" : "O(n * m)",
            "timeExplanation" : "Where n is the number of domain strings and m is the average number of subdomains."
          },
          "explanation" : "This approach first creates an array of subdomains for each domain string. Then, it iterates over each subdomain and its subdomains, updating the visit count for each one. Finally, it constructs the result string by concatenating each subdomain with its visit count and returns the result.",
          "id" : "e6d0efc4-8fac-44cd-8f58-e0a95a0f2380",
          "intuition" : "This approach works by maintaining an array of subdomains for each domain string, and then iterating over each subdomain to update the visit count.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"]",
              "explanation" : "Since discuss.leetcode.com has 9001 visits, and leetcode.com also has 9001 visits, the result is [\"9001 leetcode.com\",\"9001 discuss.leetcode.com\"].",
              "id" : "3d567b9b-8343-4b0c-a1c9-f28f4ca6c038",
              "input" : "cpdomains = [\"9001 discuss.leetcode.com\"]"
            },
            {
              "expectedOutput" : "[\"900 google.mail.com\",\"50 yahoo.com\",\"10 intel.mail.com\",\"5 wiki.org\",\"5 org\",\"10 mail.com\",\"900 mail.com\"]",
              "explanation" : "The result includes the visit count for all subdomains and their parent domains.",
              "id" : "f525a55a-a682-441b-8ee9-34e0b0cb6c2c",
              "input" : "cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]"
            }
          ]
        }
      ],
      "id" : "535bf2f7-2dc7-4d1f-a2cf-ccd6ca37a1b2",
      "lastUpdated" : "2026-02-06T21:41:20Z",
      "problemSlug" : "subdomain-visit-count",
      "relatedProblems" : [
        "subarray-sum-equals-k",
        "maximum-frequency-stack"
      ],
      "summary" : "The problem requires counting the visit count for each subdomain and returning the top-level domain with its visit count. The key insight is to parse each domain string to extract subdomains and maintain a hash map to count visits for each subdomain."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize a variable to store the sum of even numbers. 2. For each query, update the value at the specified index. 3. After each query, iterate through the entire array to find the sum of even numbers.",
          "code" : "func sumEvenAfterQueries(_ A: [Int], _ queries: [[Int]]) -> [Int] { var res: [Int] = [], sum = 0, a = A; for i in a { if i % 2 == 0 { sum += i } }; for query in queries { let val = query[0], index = query[1]; if a[index] % 2 == 0 { sum -= a[index] }; a[index] += val; if a[index] % 2 == 0 { sum += a[index] }; res.append(sum) }; return res }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store the updated array and the result array, which requires O(n) space.",
            "time" : "O(n*q)",
            "timeExplanation" : "We are iterating through the array for each query, where n is the number of elements in the array and q is the number of queries."
          },
          "explanation" : "This approach is straightforward but inefficient for large arrays because it requires iterating through the entire array after each query.",
          "id" : "b225e482-767e-43b2-bd36-2a72c47321b7",
          "intuition" : "The brute-force approach works by iterating through the array after each query and recalcuating the sum of even numbers from scratch.",
          "name" : "Brute-force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[8, 6, 2, 4]",
              "explanation" : "After the first query, the array becomes [2, 2, 3, 4] and the sum of even numbers is 2 + 2 + 4 = 8.",
              "id" : "3ba295a0-6a36-4aea-97eb-43b4bf6eb753",
              "input" : "A = [1, 2, 3, 4], queries = [[1, 0], [-3, 1], [-4, 0], [2, 3]]"
            },
            {
              "expectedOutput" : "[8, 6, 14]",
              "explanation" : "After the first query, the array becomes [0, 7, 11, 15] and the sum of even numbers is 0, which is the first element in the output array.",
              "id" : "5052f225-204e-45fb-b484-92dfab2228d2",
              "input" : "A = [2, 7, 11, 15], queries = [[-2, 0], [-4, 3], [7, 2]]"
            }
          ]
        },
        {
          "approach" : "1. Initialize a variable to store the sum of even numbers. 2. For each query, check if the value at the specified index is even. 3. If it is even, subtract it from the sum. 4. Update the value at the specified index. 5. Check if the new value is even and add it to the sum if it is.",
          "code" : "func sumEvenAfterQueries(_ A: [Int], _ queries: [[Int]]) -> [Int] { var res: [Int] = [], sum = 0, a = A; for i in a { if i % 2 == 0 { sum += i } }; for query in queries { let val = query[0], index = query[1]; if a[index] % 2 == 0 { sum -= a[index] }; a[index] += val; if a[index] % 2 == 0 { sum += a[index] }; res.append(sum) }; return res }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We need to store the updated array and the result array, which requires O(n) space.",
            "time" : "O(n + q)",
            "timeExplanation" : "We are iterating through the array once to calculate the initial sum, and then for each query, we are performing a constant amount of work."
          },
          "explanation" : "This approach is more efficient than the brute-force approach because it only updates the sum when necessary, avoiding the need to iterate through the entire array after each query.",
          "id" : "67042c0a-47e6-431b-866e-6ca80ce85b0b",
          "intuition" : "The optimized approach works by maintaining a running sum of even numbers and only updating it after each query if the query affects an even number.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[8, 6, 2, 4]",
              "explanation" : "After the first query, the array becomes [2, 2, 3, 4] and the sum of even numbers is 2 + 2 + 4 = 8.",
              "id" : "77781292-11a5-4e77-ac5d-a10134d3960e",
              "input" : "A = [1, 2, 3, 4], queries = [[1, 0], [-3, 1], [-4, 0], [2, 3]]"
            },
            {
              "expectedOutput" : "[8, 6, 14]",
              "explanation" : "After the first query, the array becomes [0, 7, 11, 15] and the sum of even numbers is 0, which is the first element in the output array.",
              "id" : "fc01264e-5978-43b1-857e-fabfaf7a3968",
              "input" : "A = [2, 7, 11, 15], queries = [[-2, 0], [-4, 3], [7, 2]]"
            }
          ]
        }
      ],
      "id" : "a106f81c-bdf9-49cb-aa69-717326e6e75e",
      "lastUpdated" : "2026-02-06T21:53:15Z",
      "problemSlug" : "sum-of-even-numbers-after-queries",
      "relatedProblems" : [
        "minimum-operations-to-make-array-equal",
        "max-consecutive-ones-iii"
      ],
      "summary" : "This problem requires us to find the sum of even numbers in an array after applying a series of queries, with the key insight being that we can maintain a running sum of even numbers and update it after each query. We can solve this problem using both a brute-force approach and an optimized approach."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Initialize an empty result list. Step 2: Iterate over the array and for each number, check if it's continuous with the previous number. Step 3: If it's not continuous, add the current range to the result and start a new range.",
          "code" : "class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for (index, num) in nums.enumerated() { if start == nil { start = num } else if num != start! + (index - (nums.firstIndex(of: start!) ?? 0)) { result.append(String(format: \"%d->%d\", start!, num - 1)); start = num } } if let start = start, let lastIndex = nums.lastIndex(of: start) { result.append(String(format: \"%d->%d\", start, nums[lastIndex])) } return result } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "In the worst case, we might need to store all the numbers in the result, so the space complexity is also linear.",
            "time" : "O(n)",
            "timeExplanation" : "We're doing a single pass over the array, so the time complexity is linear."
          },
          "explanation" : "We start by initializing an empty result list. Then, we iterate over the array. For each number, we check if it's continuous with the previous number by checking if the current number is equal to the previous number plus one. If it's not continuous, we add the current range to the result and start a new range.",
          "id" : "ced560e6-b378-4164-a03f-b5f153471d3b",
          "intuition" : "This approach works by iterating over the array and whenever we encounter a discontinuity, add the current range to the result and start a new range.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"0->2\",\"4->5\",\"7\"]",
              "explanation" : "The ranges are [0,1,2], [4,5], and [7].",
              "id" : "99cac7c4-3720-4217-bf2e-3e025ce698c5",
              "input" : "nums = [0,1,2,4,5,7]"
            },
            {
              "expectedOutput" : "[\"0\",\"2->4\",\"6\",\"8->9\"]",
              "explanation" : "The ranges are [0], [2,3,4], [6], and [8,9].",
              "id" : "5e1c84ef-98d1-450b-aa79-8a0000274479",
              "input" : "nums = [0,2,3,4,6,8,9]"
            }
          ]
        },
        {
          "approach" : "Step 1: Initialize an empty result list and a variable to keep track of the start of the current range. Step 2: Iterate over the array and for each number, check if it's continuous with the previous number. Step 3: If it's not continuous, add the current range to the result and update the start of the current range.",
          "code" : "class Solution { func summaryRanges(_ nums: [Int]) -> [String] { var result: [String] = []; var start: Int? = nil; for num in nums { if start == nil || num != start! + 1 { if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } start = num } } if let start = start { if start == start! + 1 { result.append(String(start)) } else { result.append(String(format: \"%d->%d\", start, start! + 1)) } } return result } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "In the worst case, we might need to store all the numbers in the result, so the space complexity is also linear.",
            "time" : "O(n)",
            "timeExplanation" : "We're doing a single pass over the array, so the time complexity is linear."
          },
          "explanation" : "We start by initializing an empty result list and a variable to keep track of the start of the current range. Then, we iterate over the array. For each number, we check if it's continuous with the previous number. If it's not continuous, we add the current range to the result and update the start of the current range.",
          "id" : "8b96830b-f54b-4ae1-befb-9db93163e831",
          "intuition" : "This approach works by using a similar idea as the brute force approach but with a more efficient way of checking for discontinuities and adding ranges to the result.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"0->2\",\"4->5\",\"7\"]",
              "explanation" : "The ranges are [0,1,2], [4,5], and [7].",
              "id" : "4b0f9412-46bc-4e1b-aff2-5833073c32de",
              "input" : "nums = [0,1,2,4,5,7]"
            },
            {
              "expectedOutput" : "[\"0\",\"2->4\",\"6\",\"8->9\"]",
              "explanation" : "The ranges are [0], [2,3,4], [6], and [8,9].",
              "id" : "b3eb8a17-fcd2-4d63-ac03-bd1702b9f362",
              "input" : "nums = [0,2,3,4,6,8,9]"
            }
          ]
        }
      ],
      "id" : "060c372c-efba-490e-a9f4-7ffc0c12dbcd",
      "lastUpdated" : "2026-02-06T21:11:00Z",
      "problemSlug" : "summary-ranges",
      "relatedProblems" : [
        "merge-intervals",
        "insert-interval"
      ],
      "summary" : "The problem is asking to summarize the ranges in a given array of numbers. The key insight is to iterate through the array and whenever we encounter a discontinuity, add the current range to the result and start a new range."
    },
    {
      "approaches" : [
        {
          "approach" : "Start from the first attack time and calculate the poisoning time until it's no longer poisoned. For each subsequent attack, start a new poisoning time. Compare all the poisoning times and return the maximum time.",
          "code" : "\nimport Foundation\n\nfunc findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n    if timeSeries.count == 0 {\n        return 0\n    }\n    var result = 0\n    for i in 0...timeSeries.count-2 {\n        if timeSeries[i+1]-timeSeries[i] >= duration {\n            result += duration\n        } else {\n            result += timeSeries[i+1] - timeSeries[i]\n        }\n    }\n    return result + duration\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use constant space to store the result and the current time.",
            "time" : "O(n)",
            "timeExplanation" : "We only need to iterate through the time series once."
          },
          "explanation" : "We keep track of the current time and the time when the poisoning effect ends. We iterate through all attacks and check if the current time is within the poisoning effect. If not, the poisoning effect ends. If it does, we update the end time of the poisoning effect.",
          "id" : "cc5d7e33-dc4a-4ca5-8dce-0d561c563be7",
          "intuition" : "To find the time of poisoning for each attack, iterate through all the possible attacks and check for the poisoning time.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "At time 1, Teemo starts attacking the first target and poisons it for 2 time units. At time 4, Teemo attacks the second target and poisons it for 2 time units. The total time that Teemo poisons the targets is 2 + 2 = 4.",
              "id" : "c5707aa0-da39-4716-a447-9f54a7e8cdb0",
              "input" : "timeSeries = [1,4], duration = 2"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "At time 1, Teemo starts attacking the first target and poisons it for 2 time units. At time 2, Teemo attacks the second target and poisons it for 2 time units. However, the first target's poisoning effect ends at time 3, so the total time that Teemo poisons the targets is 2 + 1 = 3.",
              "id" : "b3f4eb39-83c2-4458-aca2-a0d20c1f27f9",
              "input" : "timeSeries = [1,2], duration = 2"
            }
          ]
        },
        {
          "approach" : "Start from the first attack time and calculate the poisoning time until it's no longer poisoned. For each subsequent attack, check if the current time is within the poisoning effect. If it's not, add the duration of the poisoning effect to the total time. If it is, add the time between the two attacks to the total time.",
          "code" : "\nimport Foundation\n\nfunc findPoisonedDuration(_ timeSeries: [Int], _ duration: Int) -> Int {\n    if timeSeries.count == 0 {\n        return 0\n    }\n    var result = 0\n    for i in 0...timeSeries.count-2 {\n        if timeSeries[i+1]-timeSeries[i] >= duration {\n            result += duration\n        } else {\n            result += timeSeries[i+1] - timeSeries[i]\n        }\n    }\n    return result + duration\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We use constant space to store the result and the current time.",
            "time" : "O(n)",
            "timeExplanation" : "We only need to iterate through the time series once."
          },
          "explanation" : "We use the same approach as the brute force solution but we calculate the time between the two attacks and add it to the total time.",
          "id" : "b97ed179-9ad5-42a8-861e-776f723c369d",
          "intuition" : "We can optimize the brute force approach by using the fact that if two attacks are within the duration of each other, the total poisoning time will be the time between the two attacks plus the duration of the second attack.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "4",
              "explanation" : "At time 1, Teemo starts attacking the first target and poisons it for 2 time units. At time 4, Teemo attacks the second target and poisons it for 2 time units. The total time that Teemo poisons the targets is 2 + 2 = 4.",
              "id" : "665bb70f-8dcb-4dae-9488-34ee09da13d9",
              "input" : "timeSeries = [1,4], duration = 2"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "At time 1, Teemo starts attacking the first target and poisons it for 2 time units. At time 2, Teemo attacks the second target and poisons it for 2 time units. However, the first target's poisoning effect ends at time 3, so the total time that Teemo poisons the targets is 2 + 1 = 3.",
              "id" : "77a4341b-47f7-4bef-b485-c98d2c8d9418",
              "input" : "timeSeries = [1,2], duration = 2"
            }
          ]
        }
      ],
      "id" : "54e272ee-4ab8-4512-8d5c-598dbd7b836e",
      "lastUpdated" : "2026-02-06T21:22:04Z",
      "problemSlug" : "teemo-attacking",
      "relatedProblems" : [
        "find-poisoned-duration",
        "find-targets-within-attack-range"
      ],
      "summary" : "Teemo Attacking is a problem where we need to find the time of poisoning, we should find the maximum time by considering all the possible scenarios of attacks. We will approach this by first finding the time of poisoning using brute force method and then optimize it."
    },
    {
      "approaches" : [
        {
          "approach" : "First, sort the array in descending order. Then, remove duplicates by using a set. Finally, select the third maximum number from the set.",
          "code" : "\n       func thirdMax(_ nums: [Int]) -> Int {\n           let sortedNums = Array(Set(nums)).sorted(by: >)\n           if sortedNums.count >= 3 {\n               return sortedNums[2]\n           }\n           return sortedNums.first!\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we need to store the set of unique numbers and the sorted array.",
            "time" : "O(n log n)",
            "timeExplanation" : "The time complexity is O(n log n) due to the sorting operation."
          },
          "explanation" : "This approach first sorts the array and removes duplicates. It then returns the third maximum number if it exists. Otherwise, it returns the maximum number.",
          "id" : "9f83a4a9-94de-4453-bfcd-8c8c04eeaaa8",
          "intuition" : "This approach works by sorting the array first and then selecting the third maximum number",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The sorted set of unique numbers is [3,2,1]. The third maximum number is 1.",
              "id" : "f4de0832-e78a-4612-9f19-2cb845fcde24",
              "input" : "nums = [2,2,3,1]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There are less than 3 unique numbers. The function returns the maximum number, which is 1.",
              "id" : "478e4e5f-dd57-40db-a808-0c19ca6c6327",
              "input" : "nums = [1,2]"
            }
          ]
        },
        {
          "approach" : "Maintain three variables to store the maximum, second maximum, and third maximum numbers. Iterate through the array and update these variables accordingly.",
          "code" : "\n       func thirdMax(_ nums: [Int]) -> Int {\n           var max1 = Int.min\n           var max2 = Int.min\n           var max3 = Int.min\n           for num in nums {\n               if num > max1 {\n                   max3 = max2\n                   max2 = max1\n                   max1 = num\n               } else if num > max2 && num != max1 {\n                   max3 = max2\n                   max2 = num\n               } else if num > max3 && num != max1 && num != max2 {\n                   max3 = num\n               }\n           }\n           if max3 == Int.min {\n               return max1\n           }\n           return max3\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we use a constant amount of space to store the variables.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is O(n) because we make a single pass through the array."
          },
          "explanation" : "This approach uses three variables to keep track of the maximum, second maximum, and third maximum numbers. It iterates through the array, updating these variables. Finally, it returns the third maximum number if it exists. Otherwise, it returns the maximum number.",
          "id" : "92bd68f7-c673-41cf-baf1-85eeaa6e3cdc",
          "intuition" : "This approach works by keeping track of the three maximum numbers in a single pass through the array",
          "name" : "Single Pass",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "1",
              "explanation" : "The third maximum number is 1.",
              "id" : "67fd218e-b000-4822-9801-855ba3398b80",
              "input" : "nums = [3,2,1]"
            },
            {
              "expectedOutput" : "1",
              "explanation" : "There are less than 3 unique numbers. The function returns the maximum number, which is 1.",
              "id" : "bb8247c9-353f-48f6-8d5a-5475d12937bd",
              "input" : "nums = [1,2]"
            }
          ]
        }
      ],
      "id" : "bf7cc8cf-339b-44b0-bd01-2668e64c368b",
      "lastUpdated" : "2026-02-06T21:17:24Z",
      "problemSlug" : "third-maximum-number",
      "relatedProblems" : [
        "array-partition-i",
        "first-missing-positive"
      ],
      "summary" : "The problem involves finding the third maximum number in an array, and the key insight is to use a sorting approach or a single-pass solution to efficiently find the third maximum."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through each element in the matrix and compare it with the element diagonally up and to the left.",
          "code" : "\n       func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\n         for i in 1..<matrix.count {\n           for j in 1..<matrix[i].count {\n             if matrix[i][j] != matrix[i-1][j-1] {\n               return false\n             }\n           }\n         }\n         return true\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we are not using any additional space that scales with input size.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is O(m*n) because we are scanning the entire matrix once."
          },
          "explanation" : "Start from the second row and column (since the first row and column don't have elements above and to the left) and compare each element with the one above and to the left. If any pair of elements is not equal, return false. If the entire matrix is traversed without finding any unequal pairs, return true.",
          "id" : "60ae2906-0bf9-43db-be95-eef2a938c311",
          "intuition" : "Compare each element with the one above and to the left to check for equality.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "This matrix is a Toeplitz matrix because all descending diagonals from left to right are constant.",
              "id" : "ac32d11f-6d58-4bb7-8169-f0f66d9b09ff",
              "input" : "matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "This matrix is not a Toeplitz matrix because the second row and column do not have the same element as the one above and to the left.",
              "id" : "f6547482-495d-4da2-8b19-a2d8f7083613",
              "input" : "matrix = [[1,2],[2,2]]"
            }
          ]
        },
        {
          "approach" : "Use the same approach as the brute force but with some optimization to reduce the number of comparisons.",
          "code" : "\n       func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\n         let rows = matrix.count\n         let cols = matrix[0].count\n         for row in 1..<rows {\n           for col in 1..<cols {\n             if matrix[row][col] != matrix[row-1][col-1] {\n               return false\n             }\n           }\n         }\n         return true\n       }\n       ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is still O(1) as we are not using any additional space that scales with input size.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is still O(m*n) but with some minor optimization."
          },
          "explanation" : "Start from the second row and column and compare each element with the one above and to the left. If any pair of elements is not equal, return false. If the entire matrix is traversed without finding any unequal pairs, return true. To optimize, we only need to compare elements that are not on the first row or column.",
          "id" : "09e02c7f-cb36-4f5a-96b7-fcf742845952",
          "intuition" : "Use a similar approach but with a more optimized data structure.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "This matrix is a Toeplitz matrix because all descending diagonals from left to right are constant.",
              "id" : "11ea766e-efb0-42ac-980c-853dd07ab9bd",
              "input" : "matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "This matrix is not a Toeplitz matrix because the second row and column do not have the same element as the one above and to the left.",
              "id" : "9aff7246-e16e-40b1-a11e-7add34416804",
              "input" : "matrix = [[1,2],[2,2]]"
            }
          ]
        }
      ],
      "id" : "17e17456-e050-45a8-8fdb-2fbcf6deb660",
      "lastUpdated" : "2026-02-06T21:38:46Z",
      "problemSlug" : "toeplitz-matrix",
      "relatedProblems" : [
        "max-matrix-sum",
        "spiral-matrix-iii"
      ],
      "summary" : "A Toeplitz matrix is a matrix in which each descending diagonal from left to right is constant. The key insight is to compare each element with the one above and to the left to check for equality."
    },
    {
      "approaches" : [
        {
          "approach" : "Create a new matrix with the dimensions reversed, then iterate over the original matrix and copy each element to its corresponding position in the new matrix.",
          "code" : "\n           func transpose(_ matrix: [[Int]]) -> [[Int]] {\n               let rows = matrix.count\n               let cols = matrix[0].count\n               var transposed: [[Int]] = Array(repeating: Array(repeating: 0, count: rows), count: cols)\n               for i in 0..<rows {\n                   for j in 0..<cols {\n                       transposed[j][i] = matrix[i][j]\n                   }\n               }\n               return transposed\n           }\n           ",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "The space complexity is O(m*n) because we need to store the transposed matrix, which has the same number of elements as the original matrix.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is O(m*n) because we iterate over each element of the matrix once."
          },
          "explanation" : "This approach works by essentially flipping the matrix over its diagonal, but it requires extra space to store the transposed matrix.",
          "id" : "e938a073-eb94-4930-a88e-c155537cbe57",
          "intuition" : "Transposing a matrix involves swapping its rows with columns, so a brute force approach would involve iterating over each element of the matrix and copying it to its corresponding transposed position.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[[1,4],[2,5],[3,6]]",
              "explanation" : "The expected output is the transposed matrix, where the rows of the original matrix are now the columns.",
              "id" : "85e38e85-29de-4f51-ade9-0af56f1736a4",
              "input" : "matrix = [[1,2,3],[4,5,6]]"
            },
            {
              "expectedOutput" : "[[1,4,7],[2,5,8],[3,6,9]]",
              "explanation" : "The expected output is the transposed matrix, where the rows of the original matrix are now the columns.",
              "id" : "d0543e1c-f9bd-4f76-a2f4-ce97459c7ceb",
              "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            }
          ]
        },
        {
          "approach" : "Use the 'transpose' function or a library function to transpose the matrix.",
          "code" : "\n           func transpose(_ matrix: [[Int]]) -> [[Int]] {\n               return matrix[0].indices.map { index in\n                   matrix.map { $0[index] }\n               }\n           }\n           ",
          "complexity" : {
            "space" : "O(m*n)",
            "spaceExplanation" : "The space complexity is O(m*n) because we still need to store the transposed matrix, which has the same number of elements as the original matrix.",
            "time" : "O(m*n)",
            "timeExplanation" : "The time complexity is O(m*n) because we still need to iterate over each element of the matrix."
          },
          "explanation" : "This approach works by leveraging Swift's built-in functionality to transpose the matrix, making the code more concise and efficient.",
          "id" : "307db388-fb5c-4f04-a32c-adca72daec4e",
          "intuition" : "Instead of using a brute force approach, we can use a built-in Swift function to transpose the matrix more efficiently.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[[1,4],[2,5],[3,6]]",
              "explanation" : "The expected output is the transposed matrix, where the rows of the original matrix are now the columns.",
              "id" : "dde968e0-c2b7-47a6-b82a-498ee31e1449",
              "input" : "matrix = [[1,2,3],[4,5,6]]"
            },
            {
              "expectedOutput" : "[[1,4,7],[2,5,8],[3,6,9]]",
              "explanation" : "The expected output is the transposed matrix, where the rows of the original matrix are now the columns.",
              "id" : "f9229872-8343-48de-a491-62d4a45124fa",
              "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]"
            }
          ]
        }
      ],
      "id" : "b7e94c9c-187c-48ec-a49e-d642fb102b5c",
      "lastUpdated" : "2026-02-06T21:45:23Z",
      "problemSlug" : "transpose-matrix",
      "relatedProblems" : [
        "rotate-image",
        "spiral-matrix"
      ],
      "summary" : "The problem requires transposing a matrix, which involves swapping its rows with columns, and the key insight is to use a simple iterative approach or a more efficient transpose function."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create an empty dictionary valueToIndex.\n2. For each number in nums:\n   - Let complement = target - num.\n   - If complement exists in the dictionary, return [indexOfComplement, currentIndex].\n   - Otherwise store num -> currentIndex.\n3. If no pair found, return an empty array (not expected per constraints).",
          "code" : "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n    var valueToIndex: [Int: Int] = [:]\n    for (i, num) in nums.enumerated() {\n        let complement = target - num\n        if let j = valueToIndex[complement] {\n            return [j, i]\n        }\n        valueToIndex[num] = i\n    }\n    return []\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The hash map can store up to n elements.",
            "time" : "O(n)",
            "timeExplanation" : "Each number is processed once with O(1) hash lookups."
          },
          "explanation" : "The key is to decide in one pass whether the current number completes a previously seen pair.\nThis avoids the O(n^2) brute-force check and keeps time linear.",
          "id" : "5609529b-e80d-4064-b4df-b5cda6084880",
          "intuition" : "As we scan the array, if we already saw a value equal to (target - current), we can return that index immediately.\nStoring value -> index lets us find the complement in O(1) time.",
          "name" : "Hash Map",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[0,1]",
              "explanation" : "2 + 7 = 9, so indices 0 and 1.",
              "id" : "3d3717cb-c805-47a5-923f-5819a87a6b52",
              "input" : "nums = [2,7,11,15], target = 9"
            },
            {
              "expectedOutput" : "[1,2]",
              "explanation" : "2 + 4 = 6.",
              "id" : "6c706226-e832-445c-8206-154a288fe2d9",
              "input" : "nums = [3,2,4], target = 6"
            },
            {
              "expectedOutput" : "[0,1]",
              "explanation" : "Same value used twice at different indices.",
              "id" : "0c8fd92c-84f2-4eb9-84b3-1206d534bc08",
              "input" : "nums = [3,3], target = 6"
            }
          ]
        }
      ],
      "id" : "b6205791-50c7-4360-819a-607401b4f57a",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "two-sum",
      "relatedProblems" : [
        "two-sum-ii-input-array-is-sorted",
        "3sum"
      ],
      "summary" : "Find two indices whose values add up to the target by tracking seen numbers in a hash map."
    },
    {
      "approaches" : [
        {
          "approach" : "First, split the sentences into individual words. Then, iterate over each word and use a hash table to count the frequency of each word. Finally, filter out the words that appear more than once.",
          "code" : "\n       import Foundation\n\n       func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n           let words1 = sentence1.components(separatedBy: \" \")\n           let words2 = sentence2.components(separatedBy: \" \")\n           let allWords = words1 + words2\n           var count: [String: Int] = [:]\n\n           for word in allWords {\n               let lowerWord = word.lowercased()\n               if count[lowerWord] != nil {\n                   count[lowerWord]? += 1\n               } else {\n                   count[lowerWord] = 1\n               }\n           }\n\n           var result: [String] = []\n           for word in allWords {\n               let lowerWord = word.lowercased()\n               if count[lowerWord] == 1 {\n                   result.append(word)\n               }\n           }\n\n           return Array(Set(result))\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a hash table to store the frequency of each word, which in the worst-case scenario can store every word in the sentences.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over each word in both sentences once to count the frequency and once to filter out the words that appear more than once."
          },
          "explanation" : "The brute-force approach has a time complexity of O(n) because we need to iterate over each word in both sentences. The space complexity is also O(n) because in the worst-case scenario, we might need to store every word in the hash table.",
          "id" : "46da0f07-3fc5-41f6-afcf-c86f9cb434a6",
          "intuition" : "This approach works by iterating over each word in both sentences and counting the frequency of each word using a hash table.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"sweet\", \"sour\"]",
              "explanation" : "The words \"sweet\" and \"sour\" appear only once in both sentences combined.",
              "id" : "112014a7-5f7f-4689-99af-5c832b8873f0",
              "input" : "sentence1 = \"this apple is sweet\", sentence2 = \"this apple is sour\""
            },
            {
              "expectedOutput" : "[\"banana\"]",
              "explanation" : "The word \"banana\" appears only once in both sentences combined.",
              "id" : "6900b298-1716-49b1-ab57-4dd069debe24",
              "input" : "sentence1 = \"apple apple\", sentence2 = \"banana\" "
            }
          ]
        },
        {
          "approach" : "First, split the sentences into individual words. Then, use a hash table to count the frequency of each word in a single pass. Finally, filter out the words that appear more than once.",
          "code" : "\n       import Foundation\n\n       func findUncommonWords(_ sentence1: String, _ sentence2: String) -> [String] {\n           let words = (sentence1 + \" \" + sentence2).components(separatedBy: \" \")\n           var count: [String: Int] = [:]\n           var result: [String] = []\n\n           for word in words {\n               let lowerWord = word.lowercased()\n               if count[lowerWord] != nil {\n                   count[lowerWord]? += 1\n               } else {\n                   count[lowerWord] = 1\n               }\n           }\n\n           for word in words {\n               let lowerWord = word.lowercased()\n               if count[lowerWord] == 1 {\n                   result.append(word)\n               }\n           }\n\n           return Array(Set(result))\n       }\n       ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We use a hash table to store the frequency of each word, which in the worst-case scenario can store every word in the sentences.",
            "time" : "O(n)",
            "timeExplanation" : "We iterate over each word in both sentences once to count the frequency and filter out the words that appear more than once."
          },
          "explanation" : "The optimized approach has a time complexity of O(n) because we only need to iterate over each word in both sentences once. The space complexity is also O(n) because in the worst-case scenario, we might need to store every word in the hash table.",
          "id" : "8f2cf7fd-48c8-47b2-a641-934ad1030946",
          "intuition" : "This approach works by using a hash table to count the frequency of each word in a single pass.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"sweet\", \"sour\"]",
              "explanation" : "The words \"sweet\" and \"sour\" appear only once in both sentences combined.",
              "id" : "b0da14a0-422f-486d-9f09-52d189fc6993",
              "input" : "sentence1 = \"this apple is sweet\", sentence2 = \"this apple is sour\""
            },
            {
              "expectedOutput" : "[\"banana\"]",
              "explanation" : "The word \"banana\" appears only once in both sentences combined.",
              "id" : "80f011f6-c395-40ce-a8b8-67426710a90a",
              "input" : "sentence1 = \"apple apple\", sentence2 = \"banana\" "
            }
          ]
        }
      ],
      "id" : "e63b900c-4e10-46f0-b568-2821a0744131",
      "lastUpdated" : "2026-02-06T21:46:17Z",
      "problemSlug" : "uncommon-words-from-two-sentences",
      "relatedProblems" : [
        "find-all-numbers-disappeared-in-an-array",
        "single-number"
      ],
      "summary" : "Given two sentences, return all the words that appear only once in both sentences combined. The key insight here is to count the frequency of each word and filter out those that appear more than once."
    },
    {
      "approaches" : [
        {
          "approach" : "First, split each email address into local and domain parts. Then, remove everything after '+' and normalize the local part. Finally, count the unique normalized email addresses.",
          "code" : "func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { let parts = email.components(separatedBy: '@') let local = parts[0].replacingOccurrences(of: \".\", with: \"\", options: .regularExpression) let normalizedLocal = local.components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(__email__)\".replacingOccurrences(of: __email__, with: parts[1]) uniqueEmails.insert(normalizedEmail) } return uniqueEmails.count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the unique normalized email addresses in a set.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the number of email addresses and m is the average length of the email addresses, because we are iterating over each email address and each character in the email address."
          },
          "explanation" : "This approach involves iterating over each email address, splitting it into local and domain parts, removing everything after '+' in the local part, and removing '.'. Then, it counts the unique normalized email addresses.",
          "id" : "d634c933-ec80-4461-b261-14e4e5812cef",
          "intuition" : "This approach works by applying the normalization rules to each email address and then counting the unique ones.",
          "name" : "Brute-Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The unique normalized email addresses are 'testemail@leetcode.com' and 'testemail@lee.tcode.com'.",
              "id" : "8feb71ec-c1eb-4c7d-b8a5-5c36c9aa91c5",
              "input" : "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The email addresses are already unique, so the output is 3.",
              "id" : "038b8496-6e47-41ac-980b-1c28f97e2e92",
              "input" : "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]"
            }
          ]
        },
        {
          "approach" : "First, use regular expressions to split each email address into local and domain parts and to remove everything after '+' and '.'. Then, count the unique normalized email addresses.",
          "code" : "import Foundation func numUniqueEmails(_ emails: [String]) -> Int { var uniqueEmails: Set<String> = [] for email in emails { if let range = email.range(of: \"@\", options: .backwards) { let local = String(email[..<range.lowerBound]) let domain = String(email[range.upperBound...]) let normalizedLocal = local.replacingOccurrences(of: \".\", with: \"\", options: .regularExpression).components(separatedBy: \"+\")[0] let normalizedEmail = \"(normalizedLocal)@(domain)\" uniqueEmails.insert(normalizedEmail) } } return uniqueEmails.count }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is O(n) because we are storing the unique normalized email addresses in a set.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the number of email addresses and m is the average length of the email addresses, because we are iterating over each email address and each character in the email address."
          },
          "explanation" : "This approach involves using regular expressions to normalize the email addresses, which is more efficient than using string methods. Then, it counts the unique normalized email addresses.",
          "id" : "404a57d8-fec1-4a6d-bf9d-8b71882d749e",
          "intuition" : "This approach works by using a more efficient way to normalize the email addresses and then counting the unique ones.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The unique normalized email addresses are 'testemail@leetcode.com' and 'testemail@lee.tcode.com'.",
              "id" : "a3e7f483-b50b-4c11-81e1-4666811cc826",
              "input" : "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]"
            },
            {
              "expectedOutput" : "3",
              "explanation" : "The email addresses are already unique, so the output is 3.",
              "id" : "bcfdd061-e49f-46cc-917a-ba158e478e0d",
              "input" : "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]"
            }
          ]
        }
      ],
      "id" : "acd529be-cf56-4f59-b200-55ee7a1c2cec",
      "lastUpdated" : "2026-02-06T21:49:13Z",
      "problemSlug" : "unique-email-addresses",
      "relatedProblems" : [
        "reverse-words-in-a-string-iii",
        "valid-palindrome-ii"
      ],
      "summary" : "The problem requires counting the number of unique email addresses after applying certain rules, and the key insight is to normalize the email addresses before counting."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a dictionary to map English characters to Morse Code. 2. Iterate through each word, converting it to Morse Code. 3. Check if the Morse Code is already in a set of unique codes. 4. If not, add it to the set. 5. Return the size of the set.",
          "code" : "\nlet morseCodes: [Character: String] = [\n    \"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"\n]\n\nfunc uniqueMorseRepresentations(_ words: [String]) -> Int {\n    var uniqueCodes: Set<String> = []\n    \n    for word in words {\n        var code: String = \"\"\n        for char in word {\n            code += morseCodes[char] ?? \"\"\n        }\n        uniqueCodes.insert(code)\n    }\n    \n    return uniqueCodes.count\n}\n       ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We store unique Morse Codes in a set, which can hold up to n words with m characters each.",
            "time" : "O(n*m)",
            "timeExplanation" : "We iterate through n words with m characters each."
          },
          "explanation" : "This approach involves manually iterating through each word and character, making it inefficient for large lists.",
          "id" : "f67fb050-0c4c-48fc-9317-1e65e7f93e84",
          "intuition" : "The brute force approach works by manually converting each word to Morse Code and checking for uniqueness. This approach can be slow for large lists of words.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The Morse Code of \"gin\" is \"--...-.\", \"zen\" is \"--...-\", \"gig\" is \"--...--.\", and \"msg\" is \"--...--.\". Only \"gin\" and \"zen\" have unique Morse Codes.",
              "id" : "9de2611b-de54-4806-ba17-7ee37ec69e77",
              "input" : "words = [\"gin\", \"zen\", \"gig\", \"msg\"]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "Each word has a unique Morse Code.",
              "id" : "54f8bf9c-9a61-452d-9f6a-3121b47f01c0",
              "input" : "words = [\"a\", \"b\", \"c\", \"d\"]"
            }
          ]
        },
        {
          "approach" : "1. Create a dictionary to map English characters to Morse Code. 2. Iterate through each word, converting it to Morse Code and adding it to a set of unique codes. 3. Return the size of the set.",
          "code" : "\nlet morseCodes: [Character: String] = [\n    \"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"\n]\n\nfunc uniqueMorseRepresentations(_ words: [String]) -> Int {\n    var uniqueCodes: Set<String> = []\n    \n    for word in words {\n        let code = String(word.map { morseCodes[$0] ?? \"\" }.joined())\n        uniqueCodes.insert(code)\n    }\n    \n    return uniqueCodes.count\n}\n       ",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "We store unique Morse Codes in a set, which can hold up to n words with m characters each.",
            "time" : "O(n*m)",
            "timeExplanation" : "We iterate through n words with m characters each, converting them to Morse Code and adding to the set."
          },
          "explanation" : "This approach takes advantage of the set data structure to eliminate duplicates and uses a single pass to convert words to Morse Code.",
          "id" : "c6c163f8-f3ef-44b8-b799-3435360f9fd1",
          "intuition" : "The optimized approach works by using a set to automatically eliminate duplicate Morse Codes and converting words to Morse Code in a single pass.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "2",
              "explanation" : "The Morse Code of \"gin\" is \"--...-.\", \"zen\" is \"--...-\", \"gig\" is \"--...--.\", and \"msg\" is \"--...--.\". Only \"gin\" and \"zen\" have unique Morse Codes.",
              "id" : "fac0013e-b994-43f3-b645-ea875b91caea",
              "input" : "words = [\"gin\", \"zen\", \"gig\", \"msg\"]"
            },
            {
              "expectedOutput" : "4",
              "explanation" : "Each word has a unique Morse Code.",
              "id" : "93aece56-2270-4500-aa5b-2c4fa43ca825",
              "input" : "words = [\"a\", \"b\", \"c\", \"d\"]"
            }
          ]
        }
      ],
      "id" : "b34d56ab-c3c7-4878-9344-d05c2a98ce4a",
      "lastUpdated" : "2026-02-06T21:40:46Z",
      "problemSlug" : "unique-morse-code-words",
      "relatedProblems" : [
        "group-anagrams",
        "valid-anagram"
      ],
      "summary" : "This problem requires finding the number of unique Morse Code words in a given list of words. The key insight is to convert each word into Morse Code and store unique codes in a set."
    },
    {
      "approaches" : [
        {
          "approach" : "1. If lengths differ, return false.\n2. Count each character in s.\n3. Decrement for each character in t; if any count becomes negative, return false.\n4. If all counts are zero, return true.",
          "code" : "func isAnagram(_ s: String, _ t: String) -> Bool {\n    if s.count != t.count { return false }\n    var counts: [Character: Int] = [:]\n    for ch in s { counts[ch, default: 0] += 1 }\n    for ch in t {\n        let remaining = (counts[ch] ?? 0) - 1\n        if remaining < 0 { return false }\n        counts[ch] = remaining\n    }\n    return true\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The map stores counts for distinct characters.",
            "time" : "O(n)",
            "timeExplanation" : "Each string is scanned once."
          },
          "explanation" : "Using a dictionary keeps the solution clean and works for any character set.",
          "id" : "aa408334-2951-4317-85bb-dae695cb3ac7",
          "intuition" : "Two strings are anagrams if every character appears the same number of times in both.",
          "name" : "Frequency Map",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "All letters match counts.",
              "id" : "a82a4a86-78fe-4b64-ae62-2e098816859c",
              "input" : "s = \"anagram\", t = \"nagaram\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "Different letters.",
              "id" : "fce32cc3-1f00-4d32-b058-648e801addaf",
              "input" : "s = \"rat\", t = \"car\""
            }
          ]
        }
      ],
      "id" : "d9518775-be8b-4eee-a812-7c426fa80106",
      "lastUpdated" : "2026-02-06T00:00:00Z",
      "problemSlug" : "valid-anagram",
      "relatedProblems" : [
        "group-anagrams",
        "find-all-anagrams-in-a-string"
      ],
      "summary" : "Count characters in the first string and subtract counts using the second."
    },
    {
      "approaches" : [
        {
          "approach" : "For each element, we will check if elements to its left are increasing and elements to its right are decreasing. If we find such an element and verify these conditions, we return true, indicating the array is a valid mountain array.",
          "code" : "\n           func validMountainArray(_ arr: [Int]) -> Bool {\n               let n = arr.count\n               for i in 1..<(n-1) {\n                   var leftIncreasing = true\n                   var rightDecreasing = true\n                   for j in (0...i).reversed() {\n                       if arr[j] >= arr[j+1] {\n                           leftIncreasing = false\n                           break\n                       }\n                   }\n                   for j in (i..<(n-1)) {\n                       if arr[j] <= arr[j+1] {\n                           rightDecreasing = false\n                           break\n                       }\n                   }\n                   if leftIncreasing && rightDecreasing {\n                       return true\n                   }\n               }\n               return false\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store variables like indices and booleans, regardless of the input size.",
            "time" : "O(n^2)",
            "timeExplanation" : "The worst-case scenario involves traversing the array for each element, leading to quadratic time complexity."
          },
          "explanation" : "We iterate through each element in the array, for each element we check if it's a peak by verifying elements on its left are increasing and elements on its right are decreasing. We track these conditions by iterating from the current element to the start and end of the array.",
          "id" : "bc168fac-1bf7-43d9-b61c-c96979765a91",
          "intuition" : "This approach works by iterating through the array and checking for every element if it can be the peak of a valid mountain array.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "The array does not form a valid mountain because there's no peak",
              "id" : "58fefebf-7bf2-413d-b1ee-f5e351e20c99",
              "input" : "nums = [2,1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The array does not form a valid mountain because the left side is not strictly increasing",
              "id" : "3a94948d-e2f3-459e-b7c3-671ddede4060",
              "input" : "nums = [3,5,5]"
            }
          ]
        },
        {
          "approach" : "We start from the first element and move to the right until we find a peak (where the current element is greater than the previous one but not greater than the next one), then we continue moving right to verify the decreasing condition.",
          "code" : "\n           func validMountainArray(_ arr: [Int]) -> Bool {\n               let n = arr.count\n               if n < 3 {\n                   return false\n               }\n               var i = 0\n               while i < n-1 && arr[i] < arr[i+1] {\n                   i += 1\n               }\n               if i == 0 || i == n-1 {\n                   return false\n               }\n               while i < n-1 && arr[i] > arr[i+1] {\n                   i += 1\n               }\n               return i == n-1\n           }\n           ",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "We only use a constant amount of space to store the index and other variables, regardless of the input size.",
            "time" : "O(n)",
            "timeExplanation" : "We traverse the array at most once, leading to linear time complexity."
          },
          "explanation" : "We initialize two pointers, one at the start and move forward until we find a peak. After finding a peak, we then verify that elements to the right are decreasing. If at any point the conditions are not met, we return false.",
          "id" : "e1a2c8bf-d300-4f58-8a7b-dbdbfe634170",
          "intuition" : "This approach works by maintaining two pointers, one starting from the left and moving right until it finds a peak, then moving right to verify the decreasing condition.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The array forms a valid mountain with a peak at the second element",
              "id" : "9fe24507-f6eb-4b6e-8dc4-7216b6240134",
              "input" : "nums = [0,3,2,1]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The array does not form a valid mountain because the left side is not strictly increasing",
              "id" : "75e0b359-b741-44b7-b244-b55cc2a13e58",
              "input" : "nums = [3,5,5]"
            }
          ]
        }
      ],
      "id" : "f5a48e7e-283b-46d0-8aef-8295cfb79d09",
      "lastUpdated" : "2026-02-06T21:50:11Z",
      "problemSlug" : "valid-mountain-array",
      "relatedProblems" : [
        "array-partition-i",
        "maximum-subarray"
      ],
      "summary" : "A valid mountain array is an array where there is exactly one element that is the maximum, and elements to its left are strictly increasing and elements to its right are strictly decreasing. The key insight is to find this peak element and verify the increasing and decreasing conditions."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create 9 sets for rows, 9 for columns, 9 for boxes\n2. Iterate through each cell\n3. For non-empty cells, check if number exists in its row\/col\/box set\n4. If duplicate found, return false\n5. Otherwise, add number to all three sets",
          "code" : "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = Array(repeating: Set<Character>(), count: 9)\n    var cols = Array(repeating: Set<Character>(), count: 9)\n    var boxes = Array(repeating: Set<Character>(), count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let boxIndex = (i \/ 3) * 3 + (j \/ 3)\n            \n            if rows[i].contains(char) ||\n               cols[j].contains(char) ||\n               boxes[boxIndex].contains(char) {\n                return false\n            }\n            \n            rows[i].insert(char)\n            cols[j].insert(char)\n            boxes[boxIndex].insert(char)\n        }\n    }\n    \n    return true\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "27 sets with at most 9 elements each - constant space",
            "time" : "O(1)",
            "timeExplanation" : "Always 81 cells to check - constant for 99 board"
          },
          "explanation" : "Each cell belongs to exactly one row, one column, and one 33 box. The box index can be computed as (row\/3)*3 + (col\/3). We only need to check filled cells since empty cells don't violate constraints. Using sets gives O(1) lookup for duplicates.",
          "id" : "58b9d294-df9f-4d96-91b8-645874d585c0",
          "intuition" : "Use hash sets to track seen numbers for each row, column, and 33 box. If we encounter a duplicate in any unit, the board is invalid.",
          "name" : "Three Sets per Unit",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Valid Sudoku board - no duplicates in any row, column, or box",
              "id" : "e78eb467-73bd-47ac-ba04-86ee0c6d6ab2",
              "input" : "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "Two 8's in the first column (rows 0 and 3)",
              "id" : "76516396-63ad-47a5-a64e-293a1b37e327",
              "input" : "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]"
            }
          ]
        },
        {
          "approach" : "1. Use 9 integers for rows, 9 for cols, 9 for boxes (bits represent digits)\n2. For each cell, compute bit mask for the digit\n3. Check if bit is already set in row\/col\/box\n4. If set, return false; otherwise set the bit",
          "code" : "func isValidSudoku(_ board: [[Character]]) -> Bool {\n    var rows = [Int](repeating: 0, count: 9)\n    var cols = [Int](repeating: 0, count: 9)\n    var boxes = [Int](repeating: 0, count: 9)\n    \n    for i in 0..<9 {\n        for j in 0..<9 {\n            let char = board[i][j]\n            if char == \".\" { continue }\n            \n            let digit = Int(char.asciiValue! - Character(\"0\").asciiValue!)\n            let bit = 1 << digit\n            let boxIndex = (i \/ 3) * 3 + (j \/ 3)\n            \n            if (rows[i] & bit) != 0 ||\n               (cols[j] & bit) != 0 ||\n               (boxes[boxIndex] & bit) != 0 {\n                return false\n            }\n            \n            rows[i] |= bit\n            cols[j] |= bit\n            boxes[boxIndex] |= bit\n        }\n    }\n    \n    return true\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "27 integers - more efficient than sets",
            "time" : "O(1)",
            "timeExplanation" : "Fixed 81 cells, constant operations per cell"
          },
          "explanation" : "For digit d, we use bit (1 << d) as a marker. If (row[i] & bit) != 0, the digit was already seen in that row. Using bitwise operations is faster than hash set operations and uses less memory (just integers instead of set objects).",
          "id" : "4eae77bf-4c9e-4eed-93a6-c08647b6b6e3",
          "intuition" : "Use integers as bit sets instead of hash sets. Each bit represents whether a digit (1-9) has been seen. This is more memory-efficient.",
          "name" : "Bit Manipulation",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "Bit operations efficiently check for duplicates",
              "id" : "1631ed7a-06d3-42b2-ab74-b940bb35c787",
              "input" : "board with valid partial fill"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "boxes[boxIndex] & bit detects the duplicate",
              "id" : "bac657ff-962c-422f-ab04-4e7d4f8b4fe2",
              "input" : "board with duplicate in box"
            }
          ]
        }
      ],
      "id" : "5fbc2392-bb1a-4357-8ddf-87c26873abb0",
      "lastUpdated" : "2026-02-06T08:31:51Z",
      "problemSlug" : "valid-sudoku",
      "relatedProblems" : [
        "sudoku-solver"
      ],
      "summary" : "Validate a 99 Sudoku board. Check that each row, column, and 33 sub-box contains digits 1-9 without repetition. Empty cells (denoted by '.') are allowed."
    },
    {
      "approaches" : [
        {
          "approach" : "First, count the total number of 'X' and 'O' marks on the board. Then, manually check all possible winning combinations (rows, columns, and diagonals) to ensure that a winning combination is valid according to the game's rules.",
          "code" : "\n         func validTicTacToe(_ board: [String]) -> Bool {\n            let size = 3\n            var xCount = 0\n            var oCount = 0\n            var xWin = false\n            var oWin = false\n\n            \/\/ Count the marks\n            for i in 0..<size {\n               for j in 0..<size {\n                  if board[i].hasPrefix(String(repeating: \"X\", count: j+1)) {\n                     xCount += 1\n                  } else if board[i].hasPrefix(String(repeating: \"O\", count: j+1)) {\n                     oCount += 1\n                  }\n               }\n            }\n\n            \/\/ Check rows\n            for i in 0..<size {\n               if Set(Array(board[i])).count == 1 {\n                  if board[i].first == \"X\" {\n                     xWin = true\n                  } else if board[i].first == \"O\" {\n                     oWin = true\n                  }\n               }\n            }\n\n            \/\/ Check columns\n            for j in 0..<size {\n               var col = [Character]()\n               for i in 0..<size {\n                  col.append(board[i][j])\n               }\n               if Set(col).count == 1 {\n                  if col.first == \"X\" {\n                     xWin = true\n                  } else if col.first == \"O\" {\n                     oWin = true\n                  }\n               }\n            }\n\n            \/\/ Check diagonals\n            var diagonal1 = [Character]()\n            var diagonal2 = [Character]()\n            for i in 0..<size {\n               diagonal1.append(board[i][i])\n               diagonal2.append(board[i][size-i-1])\n            }\n            if Set(diagonal1).count == 1 {\n               if diagonal1.first == \"X\" {\n                  xWin = true\n               } else if diagonal1.first == \"O\" {\n                  oWin = true\n               }\n            }\n            if Set(diagonal2).count == 1 {\n               if diagonal2.first == \"X\" {\n                  xWin = true\n               } else if diagonal2.first == \"O\" {\n                  oWin = true\n               }\n            }\n\n            \/\/ Validate the game state\n            if xWin && oWin {\n               return false\n            }\n            if xWin {\n               return xCount == oCount + 1\n            }\n            if oWin {\n               return xCount == oCount\n            }\n            return xCount == oCount || xCount == oCount + 1\n         }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we use a constant amount of space to store the counters and the winning flags.",
            "time" : "O(1)",
            "timeExplanation" : "The time complexity is O(1) because the size of the Tic-Tac-Toe board is fixed (3x3)."
          },
          "explanation" : "We start by initializing counters for 'X' and 'O'. We then iterate over the board to count the marks. Next, we manually check all possible winning combinations. If a winning combination is found, we verify that the number of marks is consistent with a valid game state.",
          "id" : "b43700e1-1af6-469e-a1e4-4bf6187a7133",
          "intuition" : "This approach involves manually checking all possible winning combinations and verifying that the number of 'X' and 'O' marks is consistent with the game's rules.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "The board has three 'X' marks in a row, which is not a valid game state because it violates the alternating turns rule.",
              "id" : "5877de23-0a38-4236-9a6b-c510c80644d0",
              "input" : "board = [\"XOX\", \"OXO\", \"XOX\"]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The board has an invalid winning combination for 'X' and does not follow the rules of the game.",
              "id" : "380cfbe4-587b-4362-976d-1e1407aed392",
              "input" : "board = [\"XOX\", \" X \", \"   \"]"
            }
          ]
        },
        {
          "approach" : "First, initialize counters for 'X' and 'O'. Then, use a loop to count the marks and check for winning combinations. Finally, validate the game state based on the counters and the winning combinations found.",
          "code" : "\n         func validTicTacToe(_ board: [String]) -> Bool {\n            let size = 3\n            var xCount = 0\n            var oCount = 0\n            var xWin = 0\n            var oWin = 0\n\n            \/\/ Count the marks and check for winning combinations\n            for i in 0..<size {\n               var row = [Character]()\n               for j in 0..<size {\n                  let mark = board[i][j]\n                  row.append(mark)\n                  if mark == \"X\" {\n                     xCount += 1\n                  } else if mark == \"O\" {\n                     oCount += 1\n                  }\n               }\n               if Set(row).count == 1 && row.first == \"X\" {\n                  xWin += 1\n               } else if Set(row).count == 1 && row.first == \"O\" {\n                  oWin += 1\n               }\n            }\n\n            \/\/ Check columns\n            for j in 0..<size {\n               var col = [Character]()\n               for i in 0..<size {\n                  col.append(board[i][j])\n               }\n               if Set(col).count == 1 && col.first == \"X\" {\n                  xWin += 1\n               } else if Set(col).count == 1 && col.first == \"O\" {\n                  oWin += 1\n               }\n            }\n\n            \/\/ Check diagonals\n            var diagonal1 = [Character]()\n            var diagonal2 = [Character]()\n            for i in 0..<size {\n               diagonal1.append(board[i][i])\n               diagonal2.append(board[i][size-i-1])\n            }\n            if Set(diagonal1).count == 1 && diagonal1.first == \"X\" {\n               xWin += 1\n            } else if Set(diagonal1).count == 1 && diagonal1.first == \"O\" {\n               oWin += 1\n            }\n            if Set(diagonal2).count == 1 && diagonal2.first == \"X\" {\n               xWin += 1\n            } else if Set(diagonal2).count == 1 && diagonal2.first == \"O\" {\n               oWin += 1\n            }\n\n            \/\/ Validate the game state\n            if xWin > 0 && oWin > 0 {\n               return false\n            }\n            if xWin > 0 {\n               return xCount == oCount + 1\n            }\n            if oWin > 0 {\n               return xCount == oCount\n            }\n            return xCount == oCount || xCount == oCount + 1\n         }",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we use a constant amount of space to store the counters and the winning flags.",
            "time" : "O(1)",
            "timeExplanation" : "The time complexity is O(1) because the size of the Tic-Tac-Toe board is fixed (3x3)."
          },
          "explanation" : "We start by initializing counters for 'X' and 'O'. Then, we use a loop to iterate over the board and count the marks. We also check for winning combinations by examining rows, columns, and diagonals. After that, we validate the game state based on the counters and the winning combinations found.",
          "id" : "d874f1af-ed39-457d-ad51-1c473ac10b1b",
          "intuition" : "This approach involves using a more efficient algorithm to check for winning combinations and to verify the game state.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "false",
              "explanation" : "The board has three 'X' marks in a row, which is not a valid game state because it violates the alternating turns rule.",
              "id" : "b791459f-7fcd-4419-a95b-0fefb9b98887",
              "input" : "board = [\"XXO\", \"XOX\", \"OXO\"]"
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The board does not follow the rules of the game because there are not enough 'O' marks to fill the remaining spaces.",
              "id" : "3086dbd7-f1d3-44f7-bbc0-63b889e6cd7e",
              "input" : "board = [\"XOX\", \"OXO\", \"   \"]"
            }
          ]
        }
      ],
      "id" : "c519a7e4-da8f-4ad2-8957-415d7e94aa29",
      "lastUpdated" : "2026-02-06T21:40:08Z",
      "problemSlug" : "valid-tic-tac-toe-state",
      "relatedProblems" : [
        "determine_if_string_halves_are_alike",
        "find_all_lucky_numbers_in_a_matrix"
      ],
      "summary" : "The problem requires determining whether a given Tic-Tac-Toe board state is valid, considering the number of 'X' and 'O' marks and the winning conditions. The key insight is to track the number of 'X' and 'O' and verify the validity of winning combinations."
    },
    {
      "approaches" : [
        {
          "approach" : "Step 1: Create a dictionary to store the mapping of alien characters to their order. Step 2: Compare each pair of adjacent words in the list. Step 3: For each pair, iterate over the characters and compare their order based on the dictionary. Step 4: If a word is out of order, return false. Step 5: If all pairs are in order, return true.",
          "code" : "\nimport Foundation\n\nfunc isAlienSorted(_ words: [String], _ order: String) -> Bool {\n    let orderMap: [Character: Int] = Dictionary(uniqueKeysWithValues: order.enumerated().map { ($0.element, $0.offset) })\n    \n    for (index, word) in words.enumerated() {\n        if index == words.count - 1 {\n            break\n        }\n        \n        let nextWord = words[index + 1]\n        \n        for (char1, char2) in zip(word, nextWord) {\n            if orderMap[char1] ?? Int.max < orderMap[char2] ?? Int.max {\n                break\n            } else if orderMap[char1] ?? Int.max > orderMap[char2] ?? Int.max {\n                return false\n            }\n        }\n        \n        if nextWord.count < word.count && nextWord == String(word.prefix(nextWord.count)) {\n            return false\n        }\n    }\n    \n    return true\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we use a constant amount of space to store the order map.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the number of words and m is the average length of a word. This is because we compare each pair of words in the list, and for each pair, we iterate over the characters in the words."
          },
          "explanation" : "This approach works by manually checking each pair of adjacent words in the list. It has a high time complexity because it involves comparing all pairs of words and iterating over the characters in each word.",
          "id" : "1bfd122b-ac2a-41d2-8e96-f0cfd61746b2",
          "intuition" : "Compare all pairs of adjacent words in the list. If a word is out of order with respect to the alien dictionary, return false. Otherwise, return true.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The given list of words is sorted according to the given alien dictionary.",
              "id" : "27b92607-5852-46c8-b33a-56f2c0e9dd4e",
              "input" : "words = [\"kuvbz\",\"q\"] , order =\"ngxlkthsjuoqcpavbfdermiywz\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The given list of words is not sorted according to the given alien dictionary.",
              "id" : "3d798954-2138-425b-a5ed-167bf1aa029f",
              "input" : "words = [\"word\",\"world\",\"row\"] , order = \"worldabcefghijkmnpqstuvxyz\""
            }
          ]
        },
        {
          "approach" : "Step 1: Create a dictionary to store the mapping of alien characters to their order. Step 2: Compare each pair of adjacent words in the list. Step 3: For each pair, iterate over the characters and compare their order based on the dictionary. Step 4: If a word is out of order, return false. Step 5: If all pairs are in order, return true.",
          "code" : "\nimport Foundation\n\nfunc isAlienSorted(_ words: [String], _ order: String) -> Bool {\n    let orderMap: [Character: Int] = Dictionary(uniqueKeysWithValues: order.enumerated().map { ($0.element, $0.offset) })\n    \n    for index in 0..<words.count - 1 {\n        let word1 = words[index]\n        let word2 = words[index + 1]\n        \n        var i = 0\n        var j = 0\n        \n        while i < word1.count && j < word2.count {\n            if orderMap[word1[word1.index(word1.startIndex, offsetBy: i)]] ?? Int.max < orderMap[word2[word2.index(word2.startIndex, offsetBy: j)]] ?? Int.max {\n                break\n            } else if orderMap[word1[word1.index(word1.startIndex, offsetBy: i)]] ?? Int.max > orderMap[word2[word2.index(word2.startIndex, offsetBy: j)]] ?? Int.max {\n                return false\n            }\n            \n            i += 1\n            j += 1\n        }\n        \n        if j == word2.count && i < word1.count {\n            return false\n        }\n    }\n    \n    return true\n}\n",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is O(1) because we use a constant amount of space to store the order map.",
            "time" : "O(n*m)",
            "timeExplanation" : "The time complexity is O(n*m) where n is the number of words and m is the average length of a word. This is because we compare each pair of words in the list, and for each pair, we iterate over the characters in the words."
          },
          "explanation" : "This approach works by using a dictionary to store the mapping of alien characters to their order. This allows us to compare the order of words in O(m) time where m is the length of the words.",
          "id" : "f742d928-fb6f-4908-962d-2ae31f770c55",
          "intuition" : "Create a dictionary that maps each alien character to its order. Then, compare each pair of adjacent words in the list based on this dictionary.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The given list of words is sorted according to the given alien dictionary.",
              "id" : "a49a379d-a568-45c7-925b-0f5c9f9b30be",
              "input" : "words = [\"hello\",\"leetcode\"] , order = \"hlabcdefgijkmnopqrstuvwxyz\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The given list of words is not sorted according to the given alien dictionary.",
              "id" : "5e33b635-ebf1-4414-84e1-dc7404f43fea",
              "input" : "words = [\"word\",\"world\",\"row\"] , order = \"worldabcefghijkmnpqstuvxyz\""
            }
          ]
        }
      ],
      "id" : "6beeabf4-fbe4-407a-ab0d-fe2431a9b45f",
      "lastUpdated" : "2026-02-06T21:50:59Z",
      "problemSlug" : "verifying-an-alien-dictionary",
      "relatedProblems" : [
        "string-comparison",
        "dictionary-lookup"
      ],
      "summary" : "Verifying an Alien Dictionary problem involves checking if a given list of words is sorted according to a specific alien dictionary. The key insight is to compare adjacent words in the list and check their order based on the given dictionary."
    },
    {
      "approaches" : [
        {
          "approach" : "For each query word, iterate over each word in the word list. If the word matches the query exactly, add it to the result. If not, check for vowel match and close match.",
          "code" : "class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { var wordSet = Set<String>(), lowerCaseMap = [String: [String]](), vowelMap = [String: [String]](); for word in wordlist { let lower = word.lowercased(); let vowelWord = lower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with \"\"); wordSet.insert(word); if lowerCaseMap[lower] == nil { lowerCaseMap[lower] = [word] } else { lowerCaseMap[lower]!.append(word) }; if vowelMap[vowelWord] == nil { vowelMap[vowelWord] = [word] } else { vowelMap[vowelWord]!.append(word) } }; var result = [String](); for query in queries { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if wordSet.contains(query) { result.append(query) } else if lowerCaseMap[queryLower] != nil { result.append(lowerCaseMap[queryLower]!.first!) } else if vowelMap[queryVowel] != nil { result.append(vowelMap[queryVowel]!.first!) }; }; return result; } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We store all the words in a set, as well as in two maps, resulting in a linear space complexity with respect to the number of words.",
            "time" : "O(n * m)",
            "timeExplanation" : "For each query word, we potentially check every word in the word list, resulting in a linear time complexity with respect to the number of words and queries."
          },
          "explanation" : "Start by creating a set of words for fast lookup. Then, iterate over each query word, checking for each type of match against the words in the word list.",
          "id" : "1dca4549-b7ba-4e12-8ecb-fd58aff1d926",
          "intuition" : "This approach works by checking each word in the word list against each query word, applying the given rules and returning all matches.",
          "name" : "Brute Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"apple\"]",
              "explanation" : "The word \"apple\" matches itself exactly.",
              "id" : "6f9255de-64e6-4ace-830b-1a05865d31a9",
              "input" : "wordlist = [\"apple\"], queries = [\"apple\"]"
            },
            {
              "expectedOutput" : "[\"apple\"]",
              "explanation" : "The word \"appel\" matches \"apple\" closely (with one character difference).",
              "id" : "b71dedf3-2d77-49a5-9ef7-027bb93690c1",
              "input" : "wordlist = [\"apple\"], queries = [\"appel\"]"
            }
          ]
        },
        {
          "approach" : "Build a trie with the words and their corresponding lower case and vowel-replaced versions, then traverse the trie for each query to find matches.",
          "code" : "class TrieNode { var children: [TrieNode?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil]; var word: String? = nil; }; class Trie { var root = TrieNode(); func insert(_ word: String) { var node = root; for char in word.utf8 { node.children[Int(char) - 97] = node.children[Int(char) - 97] ?? TrieNode(); node = node.children[Int(char) - 97]! }; node.word = word; }; func search(_ word: String) -> String? { var node = root; for char in word.utf8 { node = node.children[Int(char) - 97] ?? return nil; }; return node.word; }; }; class Solution { func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] { let trie = Trie(); for word in wordlist { trie.insert(word); trie.insert(word.lowercased()); let vowelWord = word.lowercased().replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); trie.insert(vowelWord); }; var result = [String](); for query in queries { if let word = trie.search(query) { result.append(word); } else if let word = trie.search(query.lowercased()) { result.append(word); } else { let queryLower = query.lowercased(); let queryVowel = queryLower.replacingOccurrences(of: \"e\", with: \"\").replacingOccurrences(of: \"a\", with: \"\").replacingOccurrences(of: \"i\", with: \"\").replacingOccurrences(of: \"o\", with: \"\").replacingOccurrences(of: \"u\", with: \"\"); if let word = trie.search(queryVowel) { result.append(word); } }; }; return result; } }",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "We store all the words in a trie, resulting in a linear space complexity with respect to the number of words.",
            "time" : "O(n + m)",
            "timeExplanation" : "We only need to traverse the trie for each query word, resulting in a linear time complexity with respect to the number of words and queries."
          },
          "explanation" : "Create a trie node class and a trie class, then build the trie by inserting all the words into it. After that, for each query word, traverse the trie to find matches according to the given rules.",
          "id" : "655c0592-36ae-4906-b95e-de6f964de618",
          "intuition" : "This approach works similarly to the brute force approach but uses a more optimized data structure, such as a trie, for storing the word list and a more efficient algorithm for checking matches.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"apple\"]",
              "explanation" : "The word \"apple\" matches itself exactly.",
              "id" : "f5ab0e3a-e118-4844-8896-b558ef7b2127",
              "input" : "wordlist = [\"apple\"], queries = [\"apple\"]"
            },
            {
              "expectedOutput" : "[\"apple\"]",
              "explanation" : "The word \"appel\" matches \"apple\" closely (with one character difference).",
              "id" : "43fc44f9-07e1-465f-968f-c7c309f12eef",
              "input" : "wordlist = [\"apple\"], queries = [\"appel\"]"
            }
          ]
        }
      ],
      "id" : "3a3b15de-6fdc-44bb-80fd-1ba1a70311eb",
      "lastUpdated" : "2026-02-06T21:52:08Z",
      "problemSlug" : "vowel-spellchecker",
      "relatedProblems" : [
        "word-ladder",
        "implement-trie-prefix-tree"
      ],
      "summary" : "The problem is to find words in a given list of words that match the given words with one of the following rules: exact match, vowel match (ignoring case and allowing different vowels to be the same), and close match (with one character difference and ignoring case). The key insight is to use hashing for faster lookups."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Initialize the robot's position and direction. 2. Iterate over each command. 3. Update the robot's position based on the command.",
          "code" : "func robotSim(commands: [Int]) -> [Int] {\n    var x = 0\n    var y = 0\n    var dx = 0\n    var dy = 1\n    for command in commands {\n        if command == -1 {\n            x += dx\n            y += dy\n        } else if command == -2 {\n            x -= dx\n            y -= dy\n        } else {\n            if command % 2 == 1 {\n                dy += command\n            } else {\n                dx += command\n            }\n        }\n    }\n    return [x, y]\n}",
          "complexity" : {
            "space" : "O(1)",
            "spaceExplanation" : "The space complexity is constant because we use a fixed amount of space to store the robot's position and direction.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we iterate over each command once."
          },
          "explanation" : "The brute-force approach works by simulating the robot's movements step by step. It uses a hash table to store the commands and iterates over each command to update the robot's position.",
          "id" : "9609f5fb-b4cd-4c74-bd3f-4280d71f8cc7",
          "intuition" : "This approach involves iterating over each command and updating the robot's position accordingly. It is a straightforward solution that works for small inputs but may be inefficient for large inputs.",
          "name" : "Brute-Force Approach",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[-1,4]",
              "explanation" : "The robot starts at (0,0) and faces north. It moves forward 4 steps to (0,4), then turns right to face east. It moves forward 1 step to (1,4), then turns left to face north. It moves forward 3 steps to (-1,4).",
              "id" : "314b54d1-0c97-4ba9-8953-ecbd4a47c65b",
              "input" : "commands = [4,-1,3]"
            },
            {
              "expectedOutput" : "[-1,8]",
              "explanation" : "The robot starts at (0,0) and faces north. It moves forward 4 steps to (0,4), then turns right to face east. It moves forward 1 step to (1,4), then turns left to face north. It moves forward 4 steps to (1,8), then turns right to face east. It moves forward 2 steps to (3,8), then turns left to face north. It moves forward 4 steps to (-1,8).",
              "id" : "a13281c3-2f84-4de4-a99c-08e93c8c723d",
              "input" : "commands = [4,-1,4,-2,4]"
            }
          ]
        },
        {
          "approach" : "1. Initialize the robot's position and direction. 2. Create a hash table to store the commands and their effects. 3. Iterate over each command and update the hash table. 4. Calculate the final position using the hash table.",
          "code" : "func robotSim(commands: [Int]) -> [Int] {\n    var x = 0\n    var y = 0\n    var dx = 0\n    var dy = 1\n    var hashTable: [Int: (Int, Int)] = [:]\n    for (i, command) in commands.enumerated() {\n        if command == -1 {\n            x += dx\n            y += dy\n        } else if command == -2 {\n            x -= dx\n            y -= dy\n        } else {\n            if command % 2 == 1 {\n                dy += command\n            } else {\n                dx += command\n            }\n        }\n        hashTable[i] = (x, y)\n    }\n    return [x, y]\n}",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we use a hash table to store the commands and their effects.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we iterate over each command once."
          },
          "explanation" : "The optimized approach works by utilizing a hash table to store the commands and their effects on the robot's position. It iterates over each command and updates the hash table, then calculates the final position using the hash table.",
          "id" : "b888870d-1e6d-4c2e-8f6b-881d731e7d50",
          "intuition" : "This approach involves utilizing a hash table to store the commands and their effects on the robot's position. It is an efficient solution that works for large inputs.",
          "name" : "Optimized Approach",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[1,4]",
              "explanation" : "The robot starts at (0,0) and faces north. It moves forward 4 steps to (0,4), then turns right to face east. It moves forward 1 step to (1,4), then turns left to face north. It moves forward 3 steps to (1,7).",
              "id" : "a7fc2a12-ea8a-4a70-8ac1-4f61f40dc610",
              "input" : "commands = [4,-1,3]"
            },
            {
              "expectedOutput" : "[3,8]",
              "explanation" : "The robot starts at (0,0) and faces north. It moves forward 4 steps to (0,4), then turns right to face east. It moves forward 1 step to (1,4), then turns left to face north. It moves forward 4 steps to (1,8), then turns right to face east. It moves forward 2 steps to (3,8), then turns left to face north. It moves forward 4 steps to (3,12).",
              "id" : "14b05308-5b40-43e7-a4ae-de4179c9c8dd",
              "input" : "commands = [4,-1,4,-2,4]"
            }
          ]
        }
      ],
      "id" : "a87956ef-26b3-4cc6-863e-84d6b89e3d39",
      "lastUpdated" : "2026-02-06T21:45:53Z",
      "problemSlug" : "walking-robot-simulation",
      "relatedProblems" : [
        "final-price-with-special-discount",
        "minimum-number-of-operations-to-make-array-equal"
      ],
      "summary" : "The problem involves simulating a robot that follows a series of commands and returns the robot's final position. A key insight is to utilize a hash table to store the commands and simulate the robot's movements."
    },
    {
      "approaches" : [
        {
          "approach" : "1. Create a set of words and a set of pattern characters. 2. For each pattern character, iterate over each word. 3. If a word has not been used and matches the character, store the mapping and move to the next character.",
          "code" : "\n         import Foundation\n\n         func wordPattern(_ pattern: String, _ s: String) -> Bool {\n             let words = s.components(separatedBy: \" \")\n             if words.count != pattern.count { return false }\n             var charToWord: [Character: String] = [:]\n             var wordToChar: [String: Character] = [:]\n\n             for (char, word) in zip(pattern, words) {\n                 if charToWord[char] == nil && wordToChar[word] == nil {\n                     charToWord[char] = word\n                     wordToChar[word] = char\n                 } else if charToWord[char] != word || wordToChar[word] != char {\n                     return false\n                 }\n             }\n\n             return true\n         }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we need to store every word and every character in our hash tables.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are scanning the input array once."
          },
          "explanation" : "This approach checks every possible mapping but results in high time complexity due to nested loops.",
          "id" : "e36f46b6-f7a9-4804-a686-7fc9df01ad4c",
          "intuition" : "The brute force approach involves checking every possible mapping of pattern characters to words.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The pattern 'abba' matches the given string because 'a' maps to 'dog' and 'b' maps to 'cat'.",
              "id" : "69dbbb9e-0744-4b04-9f05-100527ff6c4d",
              "input" : "pattern = \"abba\", s = \"dog cat cat dog\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The pattern 'abba' does not match the given string because 'a' maps to both 'dog' and 'fish'.",
              "id" : "337428d2-7503-48eb-8aa2-ed98b8c885e0",
              "input" : "pattern = \"abba\", s = \"dog cat cat fish\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The pattern 'aaaa' does not match the given string because 'a' maps to multiple different words.",
              "id" : "9a5d7d0e-90e8-4d02-902b-5743ad4e8b9e",
              "input" : "pattern = \"aaaa\", s = \"dog cat cat dog\""
            }
          ]
        },
        {
          "approach" : "1. Create a set of words and a set of pattern characters. 2. Use two hash tables to store the mapping of pattern characters to words and vice versa. 3. Iterate over the input array once, checking for any inconsistencies in the mapping.",
          "code" : "\n         import Foundation\n\n         func wordPattern(_ pattern: String, _ s: String) -> Bool {\n             let words = s.components(separatedBy: \" \")\n             if words.count != pattern.count { return false }\n             var charToWord: [Character: String] = [:]\n             var wordToChar: [String: Character] = [:]\n\n             for (char, word) in zip(pattern, words) {\n                 if (charToWord[char] != word) || (wordToChar[word] != char) {\n                     return false\n                 }\n                 charToWord[char] = word\n                 wordToChar[word] = char\n             }\n\n             return true\n         }\n         ",
          "complexity" : {
            "space" : "O(n)",
            "spaceExplanation" : "The space complexity is linear because we need to store every word and every character in our hash tables.",
            "time" : "O(n)",
            "timeExplanation" : "The time complexity is linear because we are scanning the input array once."
          },
          "explanation" : "This approach significantly reduces time complexity by only scanning the input array once.",
          "id" : "eea62af5-45fb-4f68-acde-279364568bd2",
          "intuition" : "The optimized approach uses two hash tables to map pattern characters to words and vice versa, but it only iterates over the input array once.",
          "name" : "Optimized Hash Table",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "true",
              "explanation" : "The pattern 'abba' matches the given string because 'a' maps to 'dog' and 'b' maps to 'cat'.",
              "id" : "c7a9ec11-1caf-4945-8986-9bd7a7c1c74b",
              "input" : "pattern = \"abba\", s = \"dog cat cat dog\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The pattern 'abba' does not match the given string because 'a' maps to both 'dog' and 'fish'.",
              "id" : "e81c7535-bfb7-41b0-8d74-85a2f818a166",
              "input" : "pattern = \"abba\", s = \"dog cat cat fish\""
            },
            {
              "expectedOutput" : "false",
              "explanation" : "The pattern 'aaaa' does not match the given string because 'a' maps to multiple different words.",
              "id" : "c310ad81-6dfd-4a98-b0d7-38265327caef",
              "input" : "pattern = \"aaaa\", s = \"dog cat cat dog\""
            }
          ]
        }
      ],
      "id" : "284eb039-3538-4785-9386-5b95aa626bb8",
      "lastUpdated" : "2026-02-06T21:12:07Z",
      "problemSlug" : "word-pattern",
      "relatedProblems" : [
        "isomorphic-strings",
        "is-graph-bipartite"
      ],
      "summary" : "The Word Pattern problem involves determining if a given pattern string matches the words in a given string array. The key insight is to use hash tables to map pattern characters to words and vice versa."
    },
    {
      "approaches" : [
        {
          "approach" : "Iterate through each word in the first list and compare its character count with each word in the second list.",
          "code" : "func wordSubsets(_ A: [String], _ B: [String]) -> [String] {\n    var ans: [String] = []\n    let bmax = B.map { Array($0).reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 } }\n    for a in A {\n        let acount = Array(a).reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n        var isSuperset = true\n        for bcount in bmax {\n            for (char, count) in bcount {\n                if acount[char] ?? 0 < count {\n                    isSuperset = false\n                    break\n                }\n            }\n            if !isSuperset {\n                break\n            }\n        }\n        if isSuperset {\n            ans.append(a)\n        }\n    }\n    return ans\n}",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "Space is used for storing character counts of each word.",
            "time" : "O(n*m*k)",
            "timeExplanation" : "n is the length of A, m is the length of B, and k is the maximum length of a word in B."
          },
          "explanation" : "This involves creating a character count hash table for each word and then comparing these tables.",
          "id" : "ab986950-9dda-4fc0-94a8-776c042d1b7e",
          "intuition" : "Compare every word in the list with every word in the other list to find supersets.",
          "name" : "Brute Force",
          "order" : 1,
          "testCases" : [
            {
              "expectedOutput" : "[\"facebook\",\"google\",\"leetcode\"]",
              "explanation" : "All words in the output are supersets of at least one word in B.",
              "id" : "8d833b6f-0da8-4c1f-b7e7-3c3c43c37df1",
              "input" : "A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"o\"]"
            },
            {
              "expectedOutput" : "[\"apple\",\"google\",\"leetcode\"]",
              "explanation" : "All words in the output are supersets of at least one word in B.",
              "id" : "9c83c36d-58da-4810-84a0-ab4b249b8fbb",
              "input" : "A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"l\",\"e\"]"
            }
          ]
        },
        {
          "approach" : "First, find the maximum character count from the second list. Then, compare this maximum count with the character count of each word in the first list.",
          "code" : "func wordSubsets(_ A: [String], _ B: [String]) -> [String] {\n    var bmax = [Character: Int]()\n    for b in B {\n        var bcount = Array(b).reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n        for (char, count) in bcount {\n            bmax[char] = max(bmax[char] ?? 0, count)\n        }\n    }\n    var ans: [String] = []\n    for a in A {\n        var acount = Array(a).reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n        var isSuperset = true\n        for (char, count) in bmax {\n            if acount[char] ?? 0 < count {\n                isSuperset = false\n                break\n            }\n        }\n        if isSuperset {\n            ans.append(a)\n        }\n    }\n    return ans\n}",
          "complexity" : {
            "space" : "O(n*m)",
            "spaceExplanation" : "Space is used for storing character counts of each word and the maximum count from B.",
            "time" : "O(n*m + k)",
            "timeExplanation" : "n is the length of A, m is the length of B, and k is the total number of characters in all words of B."
          },
          "explanation" : "This approach reduces the number of comparisons needed by finding the maximum character count first.",
          "id" : "3b0a9966-eec2-4a60-ba72-e57ab9d0a35a",
          "intuition" : "Find the maximum character count from the second list and compare it with the character count of each word in the first list.",
          "name" : "Optimized",
          "order" : 2,
          "testCases" : [
            {
              "expectedOutput" : "[\"facebook\",\"google\",\"leetcode\"]",
              "explanation" : "All words in the output are supersets of at least one word in B.",
              "id" : "8967d552-5400-4547-be5f-334653d5689c",
              "input" : "A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"o\"]"
            },
            {
              "expectedOutput" : "[\"apple\",\"google\",\"leetcode\"]",
              "explanation" : "All words in the output are supersets of at least one word in B.",
              "id" : "4acdfc36-f2a6-4aad-9145-0df68619a41b",
              "input" : "A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"l\",\"e\"]"
            }
          ]
        }
      ],
      "id" : "a03696c0-347b-4860-a763-c970ed0cd9e4",
      "lastUpdated" : "2026-02-06T21:48:13Z",
      "problemSlug" : "word-subsets",
      "relatedProblems" : [
        "maximum-length-of-subarray",
        "longest-substring-without-repeating-characters"
      ],
      "summary" : "Word Subsets involves finding the words in a list that are superset of another given list, key insight being the use of hash tables to efficiently compare characters."
    }
  ],
  "topic" : "arrays-hashing",
  "version" : "2.0.0"
}