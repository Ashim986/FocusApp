{
  "solutions": [
    {
      "approaches": [
        {
          "approach": "Start at the root node, and recursively traverse the tree using DFS. At each node, check if the current depth matches the target depth. If it does, insert the new row by creating new nodes with the target value.",
          "code": "\nclass Solution {\n    func addOneRow(_ root: TreeNode?, _ val: Int, _ depth: Int, _ isLeft: Bool = true) -> TreeNode? {\n        if depth == 1 {\n            let newNode = TreeNode(val)\n            if isLeft {\n                newNode.left = root\n            } else {\n                newNode.right = root\n            }\n            return newNode\n        }\n        guard let node = root else { return nil }\n        node.left = addOneRow(node.left, val, depth - 1, true)\n        node.right = addOneRow(node.right, val, depth - 1, false)\n        return node\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h), where h is the height of the tree, because that's the maximum depth of the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the number of nodes in the tree, because in the worst case, we might be visiting every node in the tree."
          },
          "explanation": "This approach works by essentially recreating the tree with the new row inserted. It's a straightforward but inefficient solution, as it involves a lot of node creation and copying.",
          "id": "db6f3fb0-fd98-4845-9d25-625565d26070",
          "intuition": "This approach involves recursively traversing the tree, checking the depth of each node, and inserting the new row when the target depth is reached.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[4,1,1,null,null,1,2]",
              "explanation": "The new row is inserted at depth 2, so the new values are added between the existing nodes.",
              "id": "2e4f2c2e-c795-48bb-ac89-8bfd00e711bc",
              "input": "root = [4,1,1,2,null,null,null], val = 1, depth = 2"
            },
            {
              "expectedOutput": "[4,1,1,2-null-2,2,2-null-2]",
              "explanation": "The new row is inserted at depth 4, but since the tree only has 3 levels, the new row is added as a leaf node to the existing deepest node.",
              "id": "48e18ef4-b06d-4bc4-bfcf-6ccf90b4c28b",
              "input": "root = [4,1,1,2,null,null,null], val = 2, depth = 4"
            }
          ]
        },
        {
          "approach": "Start at the root node, and recursively traverse the tree using DFS. At each node, check if the current depth matches the target depth. If it does, insert the new row by linking the new nodes to the existing tree structure.",
          "code": "\nclass Solution {\n    func addOneRow(_ root: TreeNode?, _ val: Int, _ depth: Int) -> TreeNode? {\n        if depth == 1 {\n            let newNode = TreeNode(val)\n            newNode.left = root\n            return newNode\n        }\n        addRowHelper(root, val, depth, 1, true)\n        return root\n    }\n\n    func addRowHelper(_ node: TreeNode?, _ val: Int, _ depth: Int, _ currentDepth: Int, _ isLeft: Bool) {\n        guard let node = node else { return }\n        if currentDepth == depth - 1 {\n            let tempLeft = node.left\n            let tempRight = node.right\n            if isLeft {\n                node.left = TreeNode(val)\n                node.left?.left = tempLeft\n                node.right = TreeNode(val)\n                node.right?.right = tempRight\n            } else {\n                node.left = TreeNode(val)\n                node.left?.right = tempLeft\n                node.right = TreeNode(val)\n                node.right?.left = tempRight\n            }\n            return\n        }\n        addRowHelper(node.left, val, depth, currentDepth + 1, true)\n        addRowHelper(node.right, val, depth, currentDepth + 1, false)\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h), where h is the height of the tree, because that's the maximum depth of the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the number of nodes in the tree, because in the worst case, we might be visiting every node in the tree."
          },
          "explanation": "This approach works by directly modifying the existing tree structure to include the new row. It's more efficient than the brute force approach because it avoids unnecessary node creation and copying.",
          "id": "bdeb6efe-3e73-41e3-8c91-9c65421e2991",
          "intuition": "This approach uses a similar DFS traversal, but it avoids the unnecessary node creation and copying by directly linking the new nodes to the existing tree structure.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[4,1,1,null,null,1,2]",
              "explanation": "The new row is inserted at depth 2, so the new values are added between the existing nodes.",
              "id": "366d7fb7-f90e-45a1-8050-2e9e1869eb17",
              "input": "root = [4,1,1,2,null,null,null], val = 1, depth = 2"
            },
            {
              "expectedOutput": "[4,1,1,2-null-2,2,2-null-2]",
              "explanation": "The new row is inserted at depth 4, but since the tree only has 3 levels, the new row is added as a leaf node to the existing deepest node.",
              "id": "7356a845-49d2-4bcf-bdcd-fa434dcf8a3b",
              "input": "root = [4,1,1,2,null,null,null], val = 2, depth = 4"
            }
          ]
        }
      ],
      "id": "97595360-ac84-442a-92ca-2cc5ae341a8c",
      "lastUpdated": "2026-02-06T21:29:25Z",
      "problemSlug": "add-one-row-to-tree",
      "relatedProblems": [
        "insert-into-a-binary-search-tree",
        "delete-node-in-a-bst"
      ],
      "summary": "The problem requires adding a new row to a binary tree at a specified depth, and the key insight is to use a depth-first search (DFS) approach to traverse the tree and insert the new nodes."
    },
    {
      "approaches": [
        {
          "approach": "Start by traversing the tree to perform a depth-first search from each node. Keep track of the distance from the start node to all other nodes. When the distance is k, add the node to the result list.",
          "code": "\nclass Solution {\n    let graph: [Int: [Int]] = [:]\n    func distanceK(_ root: TreeNode?, _ target: TreeNode?, _ k: Int) -> [Int] {\n        if root == nil {\n            return []\n        }\n        if k == 0 {\n            return [target?.val ?? 0]\n        }\n        var result: [Int] = []\n        dfs(root, target?.val ?? 0, 0, k, &result, false)\n        return result\n    }\n\n    func dfs(_ node: TreeNode?, _ target: Int, _ dist: Int, _ k: Int, _ result: inout [Int], _ visited: Bool) {\n        if node == nil {\n            return\n        }\n        if node?.val == target && !visited {\n            findNodesWithDistance(node, k, &result)\n            return\n        }\n        dfs(node?.left, target, dist + 1, k, &result, visited)\n        dfs(node?.right, target, dist + 1, k, &result, visited)\n    }\n\n    func findNodesWithDistance(_ node: TreeNode?, _ k: Int, _ result: inout [Int]) {\n        if node == nil {\n            return\n        }\n        if k == 0 {\n            result.append(node!.val)\n            return\n        }\n        findNodesWithDistance(node?.left, k - 1, &result)\n        findNodesWithDistance(node?.right, k - 1, &result)\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) where n is the number of nodes in the tree. This is because in the worst case, the tree can be skewed and we can have a depth-first search call stack of size n.",
            "time": "O(n^2)",
            "timeExplanation": "In the worst case, for each node, we are doing a depth-first search."
          },
          "explanation": "This approach works but is inefficient because it involves a lot of repeated work. The time complexity is O(n^2) because in the worst case, for each node, we are doing a depth-first search.",
          "id": "968d0eac-594d-4309-aa22-5610532f4d27",
          "intuition": "This approach involves performing a depth-first search from each node in the tree to find nodes at a distance of k.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[7,4,1]",
              "explanation": "The nodes at a distance of 2 from node 5 are 7 and 4 and 1.",
              "id": "2b1e22bd-4462-454b-8cf5-204bcea56fdc",
              "input": "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2"
            },
            {
              "expectedOutput": "[]",
              "explanation": "The tree has only one node, so it's not possible to find any nodes at a distance of 3.",
              "id": "3f9c4e17-cffe-40f2-8aef-da0f76c2b6f4",
              "input": "root = [1], target = 1, k = 3"
            }
          ]
        },
        {
          "approach": "Start by building a graph from the tree. Then use a breadth-first search to find all nodes at a distance of k from the target node.",
          "code": "\nclass Solution {\n    var graph: [Int: [Int]] = [:]\n\n    func distanceK(_ root: TreeNode?, _ target: TreeNode?, _ k: Int) -> [Int] {\n        buildGraph(root)\n        var queue: [(Int, Int)] = [(target?.val ?? 0, 0)]\n        var result: [Int] = []\n        var visited: Set<Int> = [target?.val ?? 0]\n\n        while !queue.isEmpty {\n            let (node, dist) = queue.removeFirst()\n            if dist == k {\n                result.append(node)\n            }\n            if dist > k {\n                break\n            }\n            if let neighbors = graph[node] {\n                for neighbor in neighbors {\n                    if !visited.contains(neighbor) {\n                        queue.append((neighbor, dist + 1))\n                        visited.insert(neighbor)\n                    }\n                }\n            }\n        }\n        return result\n    }\n\n    func buildGraph(_ node: TreeNode?) {\n        if node == nil {\n            return\n        }\n        if node?.left != nil {\n            graph[node!.val, default: []].append(node!.left!.val)\n            graph[node!.left!.val, default: []].append(node!.val)\n        }\n        if node?.right != nil {\n            graph[node!.val, default: []].append(node!.right!.val)\n            graph[node!.right!.val, default: []].append(node!.val)\n        }\n        buildGraph(node?.left)\n        buildGraph(node?.right)\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) where n is the number of nodes in the tree. This is because we are storing the graph and the queue.",
            "time": "O(n)",
            "timeExplanation": "We are doing a constant amount of work for each node."
          },
          "explanation": "This approach works much more efficiently because it avoids the repeated work involved in the brute force approach. The time complexity is O(n) because we are doing a constant amount of work for each node.",
          "id": "349426ef-e1dd-43cd-a00c-f4bbdf36a739",
          "intuition": "This approach involves building a graph from the tree and using a breadth-first search to find all nodes at a distance of k from the target node.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[7,4,1]",
              "explanation": "The nodes at a distance of 2 from node 5 are 7 and 4 and 1.",
              "id": "242ae48d-56b3-4047-b4a3-1323790f1164",
              "input": "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2"
            },
            {
              "expectedOutput": "[]",
              "explanation": "There are no nodes at a distance of 1 from node 1.",
              "id": "0dc096bb-dfdb-427c-b64e-cac03fa79dcd",
              "input": "root = [1], target = 1, k = 1"
            }
          ]
        }
      ],
      "id": "b0adc34b-935e-4c2d-9194-d1b226078d3e",
      "lastUpdated": "2026-02-06T21:45:08Z",
      "problemSlug": "all-nodes-distance-k-in-binary-tree",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "Given the root of a binary tree, a node, and a positive integer k, return a list of the values of all nodes that have a distance k from the node. This problem is about finding all nodes at a certain distance in a binary tree."
    },
    {
      "approaches": [
        {
          "approach": "For each node, calculate its depth and update the sum and count of nodes at that depth. Finally, calculate the average at each level by dividing the sum by the count.",
          "code": "class Solution {\n    func averageOfLevels(_ root: TreeNode?) -> [Double] {\n        var sums = [Int](), counts = [Int]()\n        dfs(root, 0, &sums, &counts)\n        return zip(sums, counts).map {\n            Double($0) / Double($1)\n        }\n        func dfs(_ node: TreeNode?, _ depth: Int, _ sums: inout [Int], _ counts: inout [Int]) {\n            guard let node = node else {\n                return\n            }\n            if sums.count <= depth {\n                sums.append(node.val)\n                counts.append(1)\n            }\n            else {\n                sums[depth] += node.val\n                counts[depth] += 1\n            }\n            dfs(node.left, depth + 1, &sums, &counts)\n            dfs(node.right, depth + 1, &sums, &counts)\n        }\n    }\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is proportional to the height of the tree because we store the sum and count of nodes at each level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we visit each node once."
          },
          "explanation": "This approach works because it correctly handles each level of the tree separately. However, it requires extra space to store the sum and count of nodes at each level.",
          "id": "cd41f7c4-82c9-4e12-a581-07a2ce428020",
          "intuition": "This approach uses a depth-first search to traverse each level of the tree, calculate the sum of node values at each level, and count the number of nodes at each level.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3,14.5,11]",
              "explanation": "For the given binary tree, the average of levels is calculated as follows: Level 0: (3) / 1 = 3, Level 1: (9 + 20) / 2 = 14.5, Level 2: (15 + 7) / 2 = 11.",
              "id": "b68d0611-1e40-495e-8991-fd70b1333aa2",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[3,10,2.33333]",
              "explanation": "For the given binary tree, the average of levels is calculated as follows: Level 0: (3) / 1 = 3, Level 1: (9 + 20) / 2 = 14.5, Level 2: (1 + 2 + 3) / 3 = 2.",
              "id": "2c55ff7e-3307-4b92-b039-9e97d8244663",
              "input": "root = [3,9,20,1,null,2,3]"
            }
          ]
        },
        {
          "approach": "For each level of the tree, calculate the sum of node values and count the number of nodes. Then, calculate the average at each level by dividing the sum by the count.",
          "code": "class Solution {\n    func averageOfLevels(_ root: TreeNode?) -> [Double] {\n        var result = [Double]()\n        var queue = [TreeNode]()\n        if let root = root {\n            queue.append(root)\n        }\n        while !queue.isEmpty {\n            var levelSum = 0\n            var levelCount = 0\n            var levelQueue = [TreeNode]()\n            while !queue.isEmpty {\n                levelCount += 1\n                let node = queue.removeFirst()\n                levelSum += node.val\n                if let left = node.left {\n                    levelQueue.append(left)\n                }\n                if let right = node.right {\n                    levelQueue.append(right)\n                }\n            }\n            result.append(Double(levelSum) / Double(levelCount))\n            queue = levelQueue\n        }\n        return result\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is proportional to the number of nodes in the tree because we use a queue to store the nodes at each level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we visit each node once."
          },
          "explanation": "This approach works because it efficiently handles each level of the tree separately using a queue.",
          "id": "46789a97-237d-4b6e-b086-2a98ba17506c",
          "intuition": "This approach uses a breadth-first search to traverse the tree, calculating the sum and count of nodes at each level.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[3,14.5,11]",
              "explanation": "For the given binary tree, the average of levels is calculated as follows: Level 0: (3) / 1 = 3, Level 1: (9 + 20) / 2 = 14.5, Level 2: (15 + 7) / 2 = 11.",
              "id": "0cd43075-666a-4d85-ac2d-da90d031b85a",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[3,14.5,2.0]",
              "explanation": "For the given binary tree, the average of levels is calculated as follows: Level 0: (3) / 1 = 3, Level 1: (9 + 20) / 2 = 14.5, Level 2: (1 + 2 + 3) / 3 = 2.",
              "id": "df670ecc-9f14-4b26-872b-f70df1a85dcd",
              "input": "root = [3,9,20,1,null,2,3]"
            }
          ]
        }
      ],
      "id": "70394590-59d5-4243-830c-ef0eeb8d81e2",
      "lastUpdated": "2026-02-06T21:30:04Z",
      "problemSlug": "average-of-levels-in-binary-tree",
      "relatedProblems": [
        "minimum-depth-of-binary-tree",
        "maximum-depth-of-binary-tree"
      ],
      "summary": "Given a binary tree, return the average value of each level. The key insight is to calculate the sum of node values at each level and divide by the number of nodes at that level."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS returns height or -1 if unbalanced\n2. If left or right is -1, return -1\n3. If |left - right| > 1, return -1\n4. Else return 1 + max(left, right)",
          "code": "func isBalanced(_ root: TreeNode?) -> Bool {\n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        if left == -1 { return -1 }\n        let right = height(node.right)\n        if right == -1 { return -1 }\n        if abs(left - right) > 1 { return -1 }\n        return 1 + max(left, right)\n    }\n    return height(root) != -1\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Single pass: check balance while computing height.",
          "id": "550e8400-e29b-41d4-a716-446655440163",
          "intuition": "Compute height bottom-up. Return -1 if unbalanced, propagate up.",
          "name": "DFS Height Check",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Heights differ by at most 1 at each node",
              "id": "550e8400-e29b-41d4-a716-446655440269",
              "input": "[3,9,20,null,null,15,7]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440052",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "balanced-binary-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree"
      ],
      "summary": "Check if height-balanced. At each node, heights of subtrees differ by at most 1."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return [].\n2. Initialize a queue with root.\n3. While queue not empty: record current queue size, pop that many nodes, collect values, and enqueue children.\n4. Append each level list to the result.",
          "code": "func levelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var index = 0\n\n    while index < queue.count {\n        let levelCount = queue.count - index\n        var level: [Int] = []\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(level)\n    }\n\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue can hold up to one full level of nodes",
            "time": "O(n)",
            "timeExplanation": "Each node is enqueued and dequeued exactly once"
          },
          "explanation": "The queue holds nodes in the next level to process. Capturing the queue size before processing ensures each iteration only handles one level at a time.",
          "id": "25312294-5031-458e-90c6-4c8cab60dacb",
          "intuition": "Breadth-first search naturally visits nodes in level order. If we process nodes in fixed-size batches per level, we can build the result list of lists.",
          "name": "BFS by Level",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[3],[9,20],[15,7]]",
              "explanation": "Level 0: [3], level 1: [9,20], level 2: [15,7].",
              "id": "9f2e77b8-7e7f-4d6b-a5d4-7655d72ac176",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[[1]]",
              "explanation": "Single node forms one level.",
              "id": "4151eab9-a595-48a9-8e25-859a8941a9c3",
              "input": "root = [1]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "Empty tree produces empty result.",
              "id": "21a31bc5-894f-494f-85d1-1d21f0008299",
              "input": "root = []"
            }
          ]
        }
      ],
      "id": "bf8d33be-a2fd-469f-9a92-9dee92c4d0fe",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "binary-tree-level-order-traversal",
      "relatedProblems": [
        "binary-tree-level-order-traversal-ii",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "Traverse the tree level by level using a queue, collecting values for each level as you go."
    },
    {
      "approaches": [
        {
          "approach": "Start from the root of the tree, and for each level, append the node values to the result list. Finally, reverse the result list to get the bottom-up level order traversal",
          "code": "class Solution {\n    func levelOrderBottom(_ root: TreeNode?) -> [[Int]] {\n        var queue = [root], result = [[Int]]()\n        while !queue.isEmpty {\n            var levelValues = [Int]()\n            for _ in 1...queue.count {\n                let node = queue.removeFirst()\n                if let node = node {\n                    levelValues.append(node.val)\n                    if let left = node.left {\n                        queue.append(left)\n                    }\n                    if let right = node.right {\n                        queue.append(right)\n                    }\n                }\n            }\n            result.append(levelValues)\n        }\n        return result.reversed()\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the tree can be a skewed tree and the queue can contain n nodes at a time.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the number of nodes in the tree, because each node is visited once."
          },
          "explanation": "This approach works by traversing the tree level by level, and for each level, it appends the node values to the result list. After traversing all levels, it reverses the result list to get the bottom-up level order traversal. The time complexity is O(n) and the space complexity is O(n) because in the worst case, the tree can be a skewed tree and the queue can contain n nodes at a time.",
          "id": "d5417e07-eee7-4419-93d3-b0ab10fff6e1",
          "intuition": "Use a recursive or iterative approach to traverse the tree level by level and append the values to the result list",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[15,7],[9,20],[3]]",
              "explanation": "This test case checks the bottom-up level order traversal of a balanced binary tree.",
              "id": "cb6adcee-79ec-4f83-991b-f208da0d1688",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[[1]]",
              "explanation": "This test case checks the bottom-up level order traversal of a tree with only one node.",
              "id": "99a0692c-9812-4830-8dcd-0bf596407a9b",
              "input": "root = [1]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "This test case checks the bottom-up level order traversal of an empty tree.",
              "id": "94e46c0a-4081-4fbb-98e3-b595bff807f8",
              "input": "root = []"
            }
          ]
        },
        {
          "approach": "Start from the root of the tree, and for each level, append the node values to the result list. Use a queue data structure to keep track of the nodes at each level.",
          "code": "class Solution {\n    func levelOrderBottom(_ root: TreeNode?) -> [[Int]] {\n        guard let root = root else {\n            return []\n        }\n        var queue = [root], result = [[Int]]()\n        while !queue.isEmpty {\n            var levelValues = [Int]()\n            let levelSize = queue.count\n            for _ in 1...levelSize {\n                let node = queue.removeFirst()\n                levelValues.append(node.val)\n                if let left = node.left {\n                    queue.append(left)\n                }\n                if let right = node.right {\n                    queue.append(right)\n                }\n            }\n            result.append(levelValues)\n        }\n        return result.reversed()\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the tree can be a skewed tree and the queue can contain n nodes at a time.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the number of nodes in the tree, because each node is visited once."
          },
          "explanation": "This approach works by traversing the tree level by level using a queue data structure, and for each level, it appends the node values to the result list. After traversing all levels, it reverses the result list to get the bottom-up level order traversal.",
          "id": "8c0a5555-369c-4184-a4b8-1cfbffd3c269",
          "intuition": "Use a recursive or iterative approach to traverse the tree level by level and append the values to the result list, and use a level order traversal with a queue data structure to optimize the solution",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[15,7],[9,20],[3]]",
              "explanation": "This test case checks the bottom-up level order traversal of a balanced binary tree.",
              "id": "93b2276d-0ba0-4b11-9dd3-1f38d8613ba0",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "[[1]]",
              "explanation": "This test case checks the bottom-up level order traversal of a tree with only one node.",
              "id": "fe5a8142-ba9b-48fe-b4e2-b81f7630065a",
              "input": "root = [1]"
            },
            {
              "expectedOutput": "[]",
              "explanation": "This test case checks the bottom-up level order traversal of an empty tree.",
              "id": "dd2f92b8-817f-4c76-8fb0-ddc26b0890a9",
              "input": "root = []"
            },
            {
              "expectedOutput": "[[4,5,6,7],[2,3],[1]]",
              "explanation": "This test case checks the bottom-up level order traversal of a complete binary tree.",
              "id": "7c316464-b14d-4aa0-a3f4-f61c8c079635",
              "input": "root = [1,2,3,4,5,6,7]"
            }
          ]
        }
      ],
      "id": "f9834b65-5be5-4046-9e7f-2f91eb341a69",
      "lastUpdated": "2026-02-06T21:06:33Z",
      "problemSlug": "binary-tree-level-order-traversal-ii",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "Given a binary tree, return the bottom-up level order traversal of its nodes' values, and key insight is to traverse the tree level by level and append the values to the result list."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root of the tree and recursively traverse each node. Check each node's value and children, and prune the node if it meets the pruning condition.",
          "code": "\nclass Solution {\n    func pruneTree(_ root: TreeNode?) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        root?.left = pruneTree(root?.left)\n        root?.right = pruneTree(root?.right)\n        if root?.val == 0, root?.left == nil, root?.right == nil {\n            return nil\n        }\n        return root\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because each node is visited once."
          },
          "explanation": "This approach works by checking each node individually and pruning it if it meets the pruning condition. However, it may not be the most efficient approach as it involves multiple recursive calls.",
          "id": "e11b0cbd-4b78-447b-adeb-e038f93b387c",
          "intuition": "This approach involves recursively traversing the tree and checking each node's value. If a node's value is 0 and it has no children with value 1, it is pruned.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,null,0,null,1]",
              "explanation": "The node with value 0 in the left subtree is pruned because it has no children with value 1.",
              "id": "71236446-860f-4ee1-8fb7-701337fd39d2",
              "input": "root = [1,null,0,0,1]"
            },
            {
              "expectedOutput": "[1,null,1,null,null,null,1]",
              "explanation": "The nodes with value 0 in the left subtree are pruned because they have no children with value 1.",
              "id": "6f5a890d-e02d-43e1-9d4b-16e6f2c8732f",
              "input": "root = [1,0,1,0,0,0,1]"
            }
          ]
        },
        {
          "approach": "Start at the root of the tree and recursively traverse each node. Check each node's value and children, and prune the node if it meets the pruning condition. Avoid recursive calls for nodes that have already been pruned.",
          "code": "\nclass Solution {\n    func pruneTree(_ root: TreeNode?) -> TreeNode? {\n        func prune(_ node: TreeNode?) -> TreeNode? {\n            if node == nil {\n                return nil\n            }\n            node?.left = prune(node?.left)\n            node?.right = prune(node?.right)\n            if node?.val == 0, node?.left == nil, node?.right == nil {\n                return nil\n            }\n            return node\n        }\n        return prune(root)\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) due to the recursive call stack, where h is the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because each node is visited once."
          },
          "explanation": "This approach works by avoiding unnecessary recursive calls, making it more efficient than the brute-force approach.",
          "id": "11d65489-ca81-47ba-9be3-aa071728945f",
          "intuition": "This approach also uses a DFS approach, but it optimizes the pruning process by avoiding unnecessary recursive calls.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,null,0,null,1]",
              "explanation": "The node with value 0 in the left subtree is pruned because it has no children with value 1.",
              "id": "43f3d9ac-8282-4699-aa33-63339812c335",
              "input": "root = [1,null,0,0,1]"
            },
            {
              "expectedOutput": "[1,null,1,null,null,null,1]",
              "explanation": "The nodes with value 0 in the left subtree are pruned because they have no children with value 1.",
              "id": "dc977576-680d-48ae-bb06-9682f8828668",
              "input": "root = [1,0,1,0,0,0,1]"
            }
          ]
        }
      ],
      "id": "7ffb3c3f-be0d-4a60-ab38-29830161a0f0",
      "lastUpdated": "2026-02-06T21:41:34Z",
      "problemSlug": "binary-tree-pruning",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "binary-tree-postorder-traversal"
      ],
      "summary": "Binary Tree Pruning is a problem that involves recursively pruning a binary tree to remove nodes with value 0. The key insight is to use a depth-first search (DFS) approach to prune the tree."
    },
    {
      "approaches": [
        {
          "approach": "1. BFS with queue\n2. For each level, record the last node's value\n3. Process all nodes at current level before moving to next",
          "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    guard let root = root else { return [] }\n    \n    var result: [Int] = []\n    var queue: [TreeNode] = [root]\n    \n    while !queue.isEmpty {\n        let levelSize = queue.count\n        for i in 0..<levelSize {\n            let node = queue.removeFirst()\n            if i == levelSize - 1 {\n                result.append(node.val)\n            }\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(w)",
            "spaceExplanation": "Queue holds at most one level, max width w",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Standard level-order traversal. At each level, we process all nodes in the queue (which represents one complete level). The last node we process at each level is the rightmost one, which we add to our result.",
          "id": "ef3bba2f-d9ca-46fc-9a37-c34c4699c77a",
          "intuition": "Process tree level by level. The rightmost node at each level is visible from the right side.",
          "name": "BFS Level Order",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,3,4]",
              "explanation": "Level 0: 1, Level 1: 3 (rightmost), Level 2: 4 (rightmost)",
              "id": "d6b6bd11-0cee-4e68-ad8b-80b55c87745d",
              "input": "root = [1,2,3,null,5,null,4]"
            },
            {
              "expectedOutput": "[1,3]",
              "explanation": "Right-skewed tree",
              "id": "d410ae7e-1a0a-42fc-8a1e-e34f6748ed3c",
              "input": "root = [1,null,3]"
            }
          ]
        },
        {
          "approach": "1. Track current depth and result size\n2. If depth == result.size, this is first (rightmost) node at this depth\n3. Visit right child first, then left",
          "code": "func rightSideView(_ root: TreeNode?) -> [Int] {\n    var result: [Int] = []\n    \n    func dfs(_ node: TreeNode?, _ depth: Int) {\n        guard let node = node else { return }\n        \n        if depth == result.count {\n            result.append(node.val)\n        }\n        \n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n    }\n    \n    dfs(root, 0)\n    return result\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth is tree height",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "By visiting right subtree first, the first node we encounter at each new depth is guaranteed to be the rightmost at that level. We add it to result only when we reach a new depth (result.count == depth).",
          "id": "3937746c-65bb-4e74-bec4-9df1318af710",
          "intuition": "DFS visiting right child before left. First node we see at each depth is the rightmost.",
          "name": "DFS Right-First",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,3,4]",
              "explanation": "DFS right-first finds same nodes",
              "id": "2085e43b-d162-4557-accc-6a3f8e62e51c",
              "input": "root = [1,2,3,null,5,null,4]"
            }
          ]
        }
      ],
      "id": "fc506863-9dd1-409c-a752-043e9bbcc5ad",
      "lastUpdated": "2026-02-06T00:53:56.092Z",
      "problemSlug": "binary-tree-right-side-view",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "populating-next-right-pointers-in-each-node"
      ],
      "summary": "Return values visible from right side of tree (rightmost node at each level). BFS level-order taking last node per level, or DFS visiting right child first."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root, recursively calculate the sum of the left subtree and the sum of the right subtree, calculate the tilt for the current node as the absolute difference between these sums, and sum up all tilts.",
          "code": "\nclass Solution {\n    func findTilt(_ root: TreeNode?) -> Int {\n        var tilt = 0\n        func postorder(_ node: TreeNode?) {\n            guard let node = node else { return }\n            postorder(node.left)\n            postorder(node.right)\n            let leftSum = sum(node.left)\n            let rightSum = sum(node.right)\n            tilt += abs(leftSum - rightSum)\n        }\n        func sum(_ node: TreeNode?) -> Int {\n            guard let node = node else { return 0 }\n            return node.val + sum(node.left) + sum(node.right)\n        }\n        postorder(root)\n        return tilt\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack, where n is the number of nodes in the tree. In the case of a skewed tree, this could approach n.",
            "time": "O(n log n)",
            "timeExplanation": "Each node is visited multiple times due to the recursive nature and the calculation of subtree sums, potentially leading to n log n complexity in the worst case due to the tree structure."
          },
          "explanation": "This method ensures that every node's contribution to the total tilt is accounted for by considering the absolute difference between the sums of its subtrees. However, it may involve redundant calculations as the same subtrees are summed multiple times.",
          "id": "9b270659-7d69-46d3-a119-837d1d16d5bf",
          "intuition": "This approach involves recursively calculating the sum of each subtree and then using these sums to calculate the tilt for each node, summing up all tilts for the final result.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The tilt for the root node is |0-0| = 0, for node 2 it is |0-0| = 0, and for node 3 it is |0-0| = 0, resulting in a total tilt of 0 + 0 + 1 = 1 (due to the left child of the root having a value of 2 and the right having a value of 3, the absolute difference is |2-3| = 1).",
              "id": "ddfc6bbf-d4f3-4da9-87be-fd4fc555ccd7",
              "input": "root = [1,2,3]"
            },
            {
              "expectedOutput": "15",
              "explanation": "Calculating the tilt for each node based on the absolute difference of its subtrees' sums yields the total tilt of the tree.",
              "id": "e9baaf90-3e51-4b3f-bd6a-60eb74690ca2",
              "input": "root = [4,2,9,3,5]"
            }
          ]
        },
        {
          "approach": "Perform a post-order traversal, calculating the sum of each subtree and the tilt contribution of each node in a single pass. This eliminates redundant calculations and improves efficiency.",
          "code": "\nclass Solution {\n    func findTilt(_ root: TreeNode?) -> Int {\n        var tilt = 0\n        func postorder(_ node: TreeNode?) -> Int {\n            guard let node = node else { return 0 }\n            let leftSum = postorder(node.left)\n            let rightSum = postorder(node.right)\n            tilt += abs(leftSum - rightSum)\n            return node.val + leftSum + rightSum\n        }\n        postorder(root)\n        return tilt\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity remains O(n) due to the recursive call stack, where n is the number of nodes in the tree.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once during the post-order traversal, resulting in a linear time complexity."
          },
          "explanation": "By combining the sum calculation and tilt accumulation into a single traversal, we avoid redundant subtree sum calculations, reducing the time complexity and making the solution more efficient.",
          "id": "88bc2b21-4f13-427a-9baf-358cbb6fe4f9",
          "intuition": "Instead of recalculating subtree sums for each node, we can calculate the sum and tilt in a single pass down the tree, optimizing the time complexity.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The tilt calculation remains as in the previous approach, but with improved efficiency due to a single pass.",
              "id": "90310478-ff1a-4d68-8c52-e6090865d821",
              "input": "root = [1,2,3]"
            },
            {
              "expectedOutput": "15",
              "explanation": "The optimized approach efficiently calculates the total tilt of the tree by combining sum and tilt calculations into one traversal.",
              "id": "896547e7-467e-409c-b597-307a4eb4fdda",
              "input": "root = [4,2,9,3,5]"
            }
          ]
        }
      ],
      "id": "575ee205-6a5c-47fb-bd88-e623c8eca064",
      "lastUpdated": "2026-02-06T21:26:22Z",
      "problemSlug": "binary-tree-tilt",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "binary-tree-preorder-traversal"
      ],
      "summary": "Binary Tree Tilt calculates the sum of absolute differences between the sums of the left and right subtrees for each node, providing key insight into tree structure and balance. The solution involves recursively calculating subtree sums and accumulating tilt values."
    },
    {
      "approaches": [
        {
          "approach": "1. BFS level by level\n2. Toggle direction flag\n3. If right-to-left, reverse level before adding",
          "code": "func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\n    guard let root = root else { return [] }\n    var result: [[Int]] = []\n    var queue: [TreeNode] = [root]\n    var leftToRight = true\n    \n    while !queue.isEmpty {\n        var level: [Int] = []\n        let size = queue.count\n        for _ in 0..<size {\n            let node = queue.removeFirst()\n            level.append(node.val)\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        result.append(leftToRight ? level : level.reversed())\n        leftToRight.toggle()\n    }\n    return result\n}",
          "complexity": {
            "space": "O(w)",
            "spaceExplanation": "Max width",
            "time": "O(n)",
            "timeExplanation": "Visit each node"
          },
          "explanation": "Or use deque and alternate add direction.",
          "id": "55a97b55-fc90-4136-948e-04b901412b39",
          "intuition": "Standard level order, reverse every other level.",
          "name": "BFS with Direction",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[3],[20,9],[15,7]]",
              "explanation": "Zigzag order",
              "id": "30302ca5-d1c4-49a7-96af-7ec73746b8f1",
              "input": "root = [3,9,20,null,null,15,7]"
            }
          ]
        }
      ],
      "id": "4bf0abb0-0420-483f-bd3f-273b3108c448",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "binary-tree-zigzag-level-order-traversal",
      "relatedProblems": [
        "binary-tree-level-order-traversal"
      ],
      "summary": "Level order with alternating direction. BFS with flag to reverse alternate levels."
    },
    {
      "approaches": [
        {
          "approach": "First, perform a level-order traversal of the binary tree and store the nodes in an array. Then, iterate through this array to find the first null value. After this null value, all remaining values must be null for the tree to be complete.",
          "code": "class TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init() { self.val = 0; self.left = nil; self.right = nil }; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }; init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { self.val = val; self.left = left; self.right = right } }\nfunc isCompleteTree(_ root: TreeNode?) -> Bool { guard let root = root else { return true }\nvar queue: [TreeNode?] = [root]\nvar seenNull = false\nwhile !queue.isEmpty {\n    let node = queue.removeFirst()\n    if let currentNode = node {\n        if seenNull { return false }\n        queue.append(currentNode.left)\n        queue.append(currentNode.right)\n    } else {\n        seenNull = true\n    }\n}\nreturn true\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the space required for the queue during the level-order traversal.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the number of nodes in the tree, because in the worst case, we visit each node once during the level-order traversal."
          },
          "explanation": "The brute force approach is straightforward but not the most efficient. It traverses the tree once to create the level-order array and then traverses this array to check for completeness. The key step is identifying the first null value, as this determines the completeness of the tree.",
          "id": "4e661584-e1e7-4c0b-938b-321f22aa8683",
          "intuition": "This approach works by first converting the binary tree into a level-order array representation. Then, it checks if there are any null values before a non-null value in this array, which would indicate the tree is not complete.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "This is a complete binary tree because all levels are fully filled.",
              "id": "6fb53bf6-7dc4-4abf-a034-d60d374b12a4",
              "input": "root = [1,2,3,4,5,6]"
            },
            {
              "expectedOutput": "false",
              "explanation": "This tree is not complete because there is a null value before a non-null value in the level-order traversal.",
              "id": "37e0b0a5-5676-413c-a441-8fb07ea0049a",
              "input": "root = [1,2,3,4,5,null,7]"
            }
          ]
        },
        {
          "approach": "Perform a level-order traversal, and as soon as we encounter a null node, check if all subsequent nodes are null. If we find a non-null node after a null node, the tree is not complete.",
          "code": "class TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init() { self.val = 0; self.left = nil; self.right = nil }; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }; init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { self.val = val; self.left = left; self.right = right } }\nfunc isCompleteTree(_ root: TreeNode?) -> Bool { guard let root = root else { return true }\nvar queue: [TreeNode] = [root]\nvar nullEncountered = false\nwhile !queue.isEmpty {\n    let node = queue.removeFirst()\n    if let left = node.left, let right = node.right {\n        if nullEncountered { return false }\n        queue.append(left)\n        queue.append(right)\n    } else if let left = node.left {\n        if nullEncountered { return false }\n        queue.append(left)\n        nullEncountered = true\n    } else if let right = node.right {\n        return false\n    } else {\n        nullEncountered = true\n    }\n}\nreturn true\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also O(n) for the queue, but this approach may terminate earlier than the brute force, improving practical performance.",
            "time": "O(n)",
            "timeExplanation": "The time complexity remains O(n) because we potentially visit each node once."
          },
          "explanation": "This approach is optimized because it stops exploring branches as soon as it can determine the tree is not complete, reducing unnecessary traversals.",
          "id": "1f355afb-5414-40c0-a519-6145b73502f7",
          "intuition": "The optimized approach uses a similar BFS strategy but with a focus on early termination and a more efficient queue handling to determine if the tree is complete without fully converting it into an array.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "This is a complete binary tree.",
              "id": "3d76c7c4-0566-4370-a92b-b49fce9a8e49",
              "input": "root = [1,2,3,4,5,6]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The tree is not complete due to the placement of the null and non-null values.",
              "id": "ddb34eb1-2458-4fb6-9e59-7513e0b4e7e6",
              "input": "root = [1,2,3,4,5,null,7]"
            }
          ]
        }
      ],
      "id": "a30e4796-0dd2-4a2a-967a-723a800d5df2",
      "lastUpdated": "2026-02-06T21:51:28Z",
      "problemSlug": "check-completeness-of-a-binary-tree",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "This problem involves checking if a binary tree is complete by confirming all levels are fully filled except the last one, which must be filled from left to right. The key insight involves using a breadth-first search (BFS) to efficiently traverse the tree."
    },
    {
      "approaches": [
        {
          "approach": "First, we initialize a queue with the root node of the tree. Then, we enter a loop where we dequeue a node, and check if it has a left child and a right child. If it does not have a left child, we create a new node and set it as the left child. If it has a left child but not a right child, we create a new node and set it as the right child. We repeat this process until the queue is empty.",
          "code": "class CBTInserter { \n    var root: TreeNode? \n    init(_ root: TreeNode?) { \n        self.root = root \n    } \n    func insert(_ v: Int) -> Int { \n        var queue: [TreeNode] = [root!] \n        while !queue.isEmpty { \n            let node = queue.removeFirst() \n            if node.left == nil { \n                node.left = TreeNode(v) \n                return node.val \n            } else if node.right == nil { \n                node.right = TreeNode(v) \n                return node.val \n            } else { \n                queue.append(node.left!) \n                queue.append(node.right!) \n            } \n        } \n        return -1 \n    } \n    func get_root() -> TreeNode? { \n        return root \n    } \n} ",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store all nodes in the queue.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we have to traverse the entire tree for every insertion."
          },
          "explanation": "This approach works because it ensures that the tree remains complete after each insertion. However, it is inefficient because it involves traversing the tree for every insertion.",
          "id": "39cd1fac-2bed-4298-992e-a9de7b390cd9",
          "intuition": "This approach involves finding the first empty spot in the tree for every insertion and then placing the new node there. We will use a level order traversal (BFS) to achieve this.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "We insert 3 into the tree and return the parent of the new node, which is 2.",
              "id": "c9393fd5-7228-40dd-b665-b7d9d628b33a",
              "input": "root = [1,2], v = 3"
            },
            {
              "expectedOutput": "4",
              "explanation": "We insert 7 into the tree and return the parent of the new node, which is 4.",
              "id": "f3914ef5-77cc-4ed3-a5aa-dfb37d9b5f1c",
              "input": "root = [1,2,3,4,5,6], v = 7"
            }
          ]
        },
        {
          "approach": "First, we initialize a queue with nodes that do not have two children. Then, when we need to insert a new node, we dequeue a node from the queue, and insert the new node as either the left or the right child of the dequeued node. We then add the dequeued node back to the queue if it now has two children.",
          "code": "class CBTInserter { \n    var root: TreeNode? \n    var queue: [TreeNode] \n    init(_ root: TreeNode?) { \n        self.root = root \n        self.queue = [] \n        var q: [TreeNode] = [root!] \n        while !q.isEmpty { \n            let node = q.removeFirst() \n            if node.left == nil || node.right == nil { \n                queue.append(node) \n            } \n            if node.left != nil { \n                q.append(node.left!) \n            } \n            if node.right != nil { \n                q.append(node.right!) \n            } \n        } \n    } \n    func insert(_ v: Int) -> Int { \n        let node = queue.removeFirst() \n        if node.left == nil { \n            node.left = TreeNode(v) \n        } else { \n            node.right = TreeNode(v) \n        } \n        queue.append(node) \n        return node.val \n    } \n    func get_root() -> TreeNode? { \n        return root \n    } \n} ",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store all nodes in the queue.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because we simply dequeue a node from the queue and insert the new node as either the left or the right child of the dequeued node."
          },
          "explanation": "This approach works because it ensures that the tree remains complete after each insertion, and it minimizes the number of nodes that need to be traversed for each insertion.",
          "id": "881ef888-f569-4254-b4de-e31ac89daa4e",
          "intuition": "This approach involves using a queue to keep track of nodes that do not have two children. When we need to insert a new node, we simply dequeue a node from the queue, and insert the new node as either the left or the right child of the dequeued node.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "We insert 3 into the tree and return the parent of the new node, which is 2.",
              "id": "effea758-7554-4aff-a20f-feb76f150dd3",
              "input": "root = [1,2], v = 3"
            },
            {
              "expectedOutput": "4",
              "explanation": "We insert 7 into the tree and return the parent of the new node, which is 4.",
              "id": "9827ef04-a3c2-43c1-9531-da3468e7d533",
              "input": "root = [1,2,3,4,5,6], v = 7"
            }
          ]
        }
      ],
      "id": "67cfadd6-f29f-4127-be5b-ab2eb588fb1c",
      "lastUpdated": "2026-02-06T21:48:29Z",
      "problemSlug": "complete-binary-tree-inserter",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "binary-tree-level-order-traversal"
      ],
      "summary": "The problem asks us to complete a binary tree inserter, which is a data structure that allows us to insert nodes into a complete binary tree. The key insight here is to use a level order traversal (BFS) to keep track of the nodes in the tree and insert new nodes at the correct position."
    },
    {
      "approaches": [
        {
          "approach": "Generate all possible binary trees and compare their traversal sequences with the given sequences.",
          "code": "func constructFromInorderPostorder(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {  \n    if inorder.isEmpty || postorder.isEmpty { return nil }\n    let root = TreeNode(postorder.last!)\n    let rootIndex = inorder.firstIndex(of: postorder.last!)!\n    root.left = constructFromInorderPostorder(Array(inorder[0...rootIndex-1]), Array(postorder[0..<rootIndex]))\n    root.right = constructFromInorderPostorder(Array(inorder[rootIndex+1..<inorder.count]), Array(postorder[rootIndex..<postorder.count-1]))\n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear due to the recursion stack.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential because it generates all possible trees."
          },
          "explanation": "This approach is inefficient as it has to generate all possible trees and compare their traversal sequences, resulting in exponential time complexity.",
          "id": "a22b4a56-8156-4a1e-96e8-735096677015",
          "intuition": "This approach checks every possible binary tree and verifies whether its inorder and postorder traversal sequences match the given sequences.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "Tree with inorder traversal: 4,2,5,1,3 and postorder traversal: 4,5,2,3,1",
              "explanation": "Construct the binary tree from the given inorder and postorder traversal sequences.",
              "id": "8f98e1ed-eb47-4edc-92a3-baa57f7bbab0",
              "input": "inorder = [4,2,5,1,3], postorder = [4,5,2,3,1]"
            },
            {
              "expectedOutput": "Tree with inorder traversal: 2,1,3 and postorder traversal: 2,3,1",
              "explanation": "Construct the binary tree from the given inorder and postorder traversal sequences.",
              "id": "f6f9a5a5-4132-49cd-b820-e46cc8a8a231",
              "input": "inorder = [2,1,3], postorder = [2,3,1]"
            }
          ]
        },
        {
          "approach": "Use a hashmap to store the indices of elements in the inorder traversal sequence, and recursively build the tree.",
          "code": "var inorderIndexMap = [Int: Int](); var postorderIndex = 0; func constructFromInorderPostorder(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? { \n    if postorderIndex >= postorder.count { return nil }\n    let root = TreeNode(postorder[postorderIndex])\n    postorderIndex += 1\n    if inorderIndexMap[inorder[0]] == nil {\n        for (index, value) in inorder.enumerated() {\n            inorderIndexMap[value] = index\n        }\n    }\n    let rootIndex = inorderIndexMap[root.val]!\n    root.right = constructFromInorderPostorder(Array(inorder[rootIndex+1..<inorder.count]), postorder)\n    root.left = constructFromInorderPostorder(Array(inorder[0..<rootIndex]), postorder)\n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear due to the recursion stack and hashmap.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we only visit each node once."
          },
          "explanation": "This approach improves the time complexity by using a hashmap to store the indices of elements in the inorder traversal sequence.",
          "id": "980c51ae-c545-4412-96ef-0de5ebff0f8d",
          "intuition": "This approach recursively constructs the binary tree by identifying the root node and splitting the traversal sequences accordingly.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Tree with inorder traversal: 4,2,5,1,3 and postorder traversal: 4,5,2,3,1",
              "explanation": "Construct the binary tree from the given inorder and postorder traversal sequences.",
              "id": "eb8b7530-0342-478f-9c63-400cd0f104cf",
              "input": "inorder = [4,2,5,1,3], postorder = [4,5,2,3,1]"
            },
            {
              "expectedOutput": "Tree with inorder traversal: 2,1,3 and postorder traversal: 2,3,1",
              "explanation": "Construct the binary tree from the given inorder and postorder traversal sequences.",
              "id": "b99b16a3-2480-42fe-abab-1848ff320591",
              "input": "inorder = [2,1,3], postorder = [2,3,1]"
            }
          ]
        }
      ],
      "id": "70f0dc58-6264-4f70-9be8-49bfef04bea1",
      "lastUpdated": "2026-02-06T21:06:28Z",
      "problemSlug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "binary-tree-postorder-traversal"
      ],
      "summary": "The problem asks to construct a binary tree from its inorder and postorder traversal sequences. The key insight is to recursively build the tree by identifying the root node and splitting the traversal sequences accordingly."
    },
    {
      "approaches": [
        {
          "approach": "1. Build a map from inorder value to index.\n2. Use a preorder index pointer.\n3. Recurse on inorder ranges to construct left and right subtrees.",
          "code": "func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n    var indexMap: [Int: Int] = [:]\n    for (i, val) in inorder.enumerated() { indexMap[val] = i }\n    var preIndex = 0\n\n    func helper(_ left: Int, _ right: Int) -> TreeNode? {\n        if left > right { return nil }\n        let rootVal = preorder[preIndex]\n        preIndex += 1\n        let root = TreeNode(rootVal)\n        let mid = indexMap[rootVal] ?? 0\n        root.left = helper(left, mid - 1)\n        root.right = helper(mid + 1, right)\n        return root\n    }\n\n    return helper(0, inorder.count - 1)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Index map plus recursion stack",
            "time": "O(n)",
            "timeExplanation": "Each node is created once"
          },
          "explanation": "The map gives O(1) splits. The preorder index advances as we create nodes, preserving root-left-right ordering.",
          "id": "e371a4eb-53b2-4d10-96d8-2c3844972ffa",
          "intuition": "The first preorder value is always the root. In inorder, everything left of the root belongs to the left subtree, and everything right belongs to the right subtree.",
          "name": "Recursive with Index Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3,9,20,null,null,15,7]",
              "explanation": "Root 3 splits inorder into [9] and [15,20,7].",
              "id": "9769abcb-30d8-4e89-b038-dfa6aa7917c4",
              "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]"
            },
            {
              "expectedOutput": "[-1]",
              "explanation": "Single node tree.",
              "id": "7b95b045-a63f-444a-8fe5-3117532115f5",
              "input": "preorder = [-1], inorder = [-1]"
            }
          ]
        }
      ],
      "id": "0f6835b4-c6b9-4e33-9ea7-7652f64e3434",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "relatedProblems": [
        "construct-binary-tree-from-inorder-and-postorder-traversal",
        "serialize-and-deserialize-binary-tree"
      ],
      "summary": "Preorder gives the root, inorder splits left and right subtrees. Rebuild recursively using index boundaries."
    },
    {
      "approaches": [
        {
          "approach": "Generate all possible binary trees, then check if their preorder and postorder traversals match the input sequences.",
          "code": "func constructFromPrePost(_ preorder: [Int], _ postorder: [Int]) -> TreeNode? {\n    if preorder.isEmpty {\n        return nil\n    }\n    \n    let root = TreeNode(preorder[0])\n    if preorder.count == 1 {\n        return root\n    }\n    \n    let leftSubtreeRootValue = preorder[1]\n    var leftSubtreeSize = 0\n    for i in 0..<postorder.count {\n        if postorder[i] == leftSubtreeRootValue {\n            leftSubtreeSize = i + 1\n            break\n        }\n    }\n    \n    var preorderCopy = preorder\n    var postorderCopy = postorder\n    \n    root.left = constructFromPrePost(\n        Array(preorderCopy[1...leftSubtreeSize]),\n        Array(postorderCopy[0..<leftSubtreeSize])\n    )\n    root.right = constructFromPrePost(\n        Array(preorderCopy[(leftSubtreeSize + 1)...]),\n        Array(postorderCopy[leftSubtreeSize..<postorderCopy.count - 1])\n    )\n    \n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The recursion stack can go up to n levels deep in the worst case.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once in the recursion."
          },
          "explanation": "This approach works by using recursion to generate all possible binary trees and then validating each tree by comparing its preorder and postorder traversals with the input sequences.",
          "id": "a105f590-324c-4880-ad5d-ba51825e1886",
          "intuition": "Try all possible binary trees by iterating through the preorder and postorder sequences and validate each tree by comparing its preorder and postorder traversals with the input sequences.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "The tree with the given preorder and postorder traversal sequences.",
              "explanation": "The given sequences correspond to a unique binary tree, which is the expected output.",
              "id": "e04cf420-8a53-4459-8859-5f33f9a168fb",
              "input": "preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]"
            },
            {
              "expectedOutput": "A tree with a single node having value 1.",
              "explanation": "A tree with a single node is the only possible tree with the given preorder and postorder sequences.",
              "id": "e5652c71-0e59-4967-815e-58f74eba2044",
              "input": "preorder = [1], postorder = [1]"
            }
          ]
        },
        {
          "approach": "Iterate through the preorder sequence and use the hash map to find the corresponding element in the postorder sequence, then recursively construct the left and right subtrees.",
          "code": "\nimport Foundation\n\nclass TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    \n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func constructFromPrePost(_ preorder: [Int], _ postorder: [Int]) -> TreeNode? {\n        var preorderIndex = 0\n        var postorderIndex = 0\n        var postorderMap: [Int: Int] = [:]\n        \n        for i in 0..<postorder.count {\n            postorderMap[postorder[i]] = i\n        }\n        \n        return constructFromPrePostHelper(&preorderIndex, &postorderIndex, preorder, postorder, postorderMap)\n    }\n    \n    func constructFromPrePostHelper(_ preorderIndex: inout Int, _ postorderIndex: inout Int, _ preorder: [Int], _ postorder: [Int], _ postorderMap: [Int: Int]) -> TreeNode? {\n        if preorderIndex >= preorder.count {\n            return nil\n        }\n        \n        let node = TreeNode(preorder[preorderIndex])\n        preorderIndex += 1\n        \n        if preorderIndex >= preorder.count {\n            return node\n        }\n        \n        let leftSubtreeRootValue = preorder[preorderIndex]\n        node.left = constructFromPrePostHelper(&preorderIndex, &postorderIndex, preorder, postorder, postorderMap)\n        \n        node.right = constructFromPrePostHelper(&preorderIndex, &postorderIndex, preorder, postorder, postorderMap)\n        \n        return node\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The recursion stack can go up to n levels deep in the worst case.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once in the recursion."
          },
          "explanation": "This approach works by using the hash map to efficiently find the indices of elements in the postorder sequence, allowing for efficient construction of the binary tree.",
          "id": "0445bf9b-0bfb-4257-ab6b-3617ea0b3553",
          "intuition": "Use a hash map to store the indices of elements in the postorder sequence for efficient lookup.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "The tree with the given preorder and postorder traversal sequences.",
              "explanation": "The given sequences correspond to a unique binary tree, which is the expected output.",
              "id": "8b092436-05cc-4594-ab35-c144a2c6e2a7",
              "input": "preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]"
            },
            {
              "expectedOutput": "A tree with a single node having value 1.",
              "explanation": "A tree with a single node is the only possible tree with the given preorder and postorder sequences.",
              "id": "f5f129e3-7883-417c-962b-e50d31e5ef4b",
              "input": "preorder = [1], postorder = [1]"
            }
          ]
        }
      ],
      "id": "e9a7df9e-04c0-4ce3-b9e1-5b51b164d78f",
      "lastUpdated": "2026-02-06T21:46:39Z",
      "problemSlug": "construct-binary-tree-from-preorder-and-postorder-traversal",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "construct-binary-tree-from-inorder-and-postorder-traversal"
      ],
      "summary": "Construct a binary tree from preorder and postorder traversal sequences. The key insight is that the first element in preorder is the root and the last element in postorder is also the root."
    },
    {
      "approaches": [
        {
          "approach": "Start from the top-left corner of the grid and recursively divide it into four sub-grids. For each sub-grid, check if it is homogeneous. If it is, create a new leaf node with the corresponding value. If not, create a new internal node and recursively construct the Quad Tree for its sub-grids.",
          "code": "\nclass Solution {\n    func construct(_ grid: [[Int]]) -> Node? {\n        func isHomogeneous(_ grid: [[Int]]) -> Bool {\n            let value = grid[0][0]\n            for row in grid {\n                for val in row {\n                    if val != value {\n                        return false\n                    }\n                }\n            }\n            return true\n        }\n\n        func constructNode(_ grid: [[Int]]) -> Node? {\n            if isHomogeneous(grid) {\n                return Node(val: grid[0][0] == 1, isLeaf: true, topLeft: nil, topRight: nil, bottomLeft: nil, bottomRight: nil)\n            } else {\n                let n = grid.count\n                let mid = n / 2\n                let topLeft = Array(grid[0..<mid]).map { Array($0[0..<mid]) }\n                let topRight = Array(grid[0..<mid]).map { Array($0[mid..<n]) }\n                let bottomLeft = Array(grid[mid..<n]).map { Array($0[0..<mid]) }\n                let bottomRight = Array(grid[mid..<n]).map { Array($0[mid..<n]) }\n\n                return Node(val: true, isLeaf: false, topLeft: constructNode(topLeft), topRight: constructNode(topRight), bottomLeft: constructNode(bottomLeft), bottomRight: constructNode(bottomRight))\n            }\n        }\n\n        return constructNode(grid)\n    }\n}\n\nclass Node {\n    var val: Bool\n    var isLeaf: Bool\n    var topLeft: Node?\n    var topRight: Node?\n    var bottomLeft: Node?\n    var bottomRight: Node?\n\n    init(val: Bool, isLeaf: Bool, topLeft: Node?, topRight: Node?, bottomLeft: Node?, bottomRight: Node?) {\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n    }\n}\n",
          "complexity": {
            "space": "O(n ^ 2)",
            "spaceExplanation": "The space complexity comes from the recursive call stack and the need to store the constructed Quad Tree.",
            "time": "O(n ^ 2 * log n)",
            "timeExplanation": "The time complexity comes from the recursive calls and the need to check every sub-grid."
          },
          "explanation": "This approach ensures that every possible sub-grid is checked and a node is created in the Quad Tree for each one. However, it can be inefficient for large grids due to the many recursive calls.",
          "id": "35ae2f45-9a11-4cd3-be3b-dceedbe07ad9",
          "intuition": "This approach involves checking every possible sub-grid to determine if it is homogeneous (either all black or all white) and create a new node in the Quad Tree accordingly.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "Node(val: true, isLeaf: false, topLeft: Node(val: false, isLeaf: true), topRight: Node(val: true, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
              "explanation": "The grid is divided into four sub-grids, each containing a single cell. The top-left and bottom-right sub-grids are black, while the top-right and bottom-left sub-grids are white. The constructed Quad Tree has an internal node with four leaf nodes.",
              "id": "b081f5ec-6767-418c-9b5b-b23b3b30a513",
              "input": "grid = [[0,1],[1,0]]"
            },
            {
              "expectedOutput": "Node(val: true, isLeaf: false, topLeft: Node(val: true, isLeaf: true), topRight: Node(val: false, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
              "explanation": "The grid is divided into four sub-grids. The top-left and bottom-left sub-grids are black, while the top-right and bottom-right sub-grids are white. The constructed Quad Tree has an internal node with four leaf nodes.",
              "id": "dc4393db-c455-46d4-85cc-91914b7101cf",
              "input": "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]"
            }
          ]
        },
        {
          "approach": "Start from the top-left corner of the grid and recursively divide it into four sub-grids. For each sub-grid, use a prefix sum array to count the number of black cells. If the count is equal to the total number of cells in the sub-grid, it is homogeneous and a new leaf node can be created. If not, create a new internal node and recursively construct the Quad Tree for its sub-grids.",
          "code": "\nclass Solution {\n    func construct(_ grid: [[Int]]) -> Node? {\n        func countBlackCells(_ grid: [[Int]]) -> Int {\n            var count = 0\n            for row in grid {\n                for val in row {\n                    if val == 1 {\n                        count += 1\n                    }\n                }\n            }\n            return count\n        }\n\n        func constructNode(_ grid: [[Int]]) -> Node? {\n            let n = grid.count\n            let count = countBlackCells(grid)\n            if count == 0 {\n                return Node(val: false, isLeaf: true, topLeft: nil, topRight: nil, bottomLeft: nil, bottomRight: nil)\n            } else if count == n * n {\n                return Node(val: true, isLeaf: true, topLeft: nil, topRight: nil, bottomLeft: nil, bottomRight: nil)\n            } else {\n                let mid = n / 2\n                let topLeft = Array(grid[0..<mid]).map { Array($0[0..<mid]) }\n                let topRight = Array(grid[0..<mid]).map { Array($0[mid..<n]) }\n                let bottomLeft = Array(grid[mid..<n]).map { Array($0[0..<mid]) }\n                let bottomRight = Array(grid[mid..<n]).map { Array($0[mid..<n]) }\n\n                return Node(val: true, isLeaf: false, topLeft: constructNode(topLeft), topRight: constructNode(topRight), bottomLeft: constructNode(bottomLeft), bottomRight: constructNode(bottomRight))\n            }\n        }\n\n        return constructNode(grid)\n    }\n}\n\nclass Node {\n    var val: Bool\n    var isLeaf: Bool\n    var topLeft: Node?\n    var topRight: Node?\n    var bottomLeft: Node?\n    var bottomRight: Node?\n\n    init(val: Bool, isLeaf: Bool, topLeft: Node?, topRight: Node?, bottomLeft: Node?, bottomRight: Node?) {\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n    }\n}\n",
          "complexity": {
            "space": "O(n ^ 2)",
            "spaceExplanation": "The space complexity comes from the recursive call stack and the need to store the constructed Quad Tree.",
            "time": "O(n ^ 2)",
            "timeExplanation": "The time complexity comes from the need to count the number of black cells in each sub-grid."
          },
          "explanation": "This approach reduces the time complexity by avoiding the need to check every cell in each sub-grid. Instead, it uses a prefix sum array to count the number of black cells in O(1) time.",
          "id": "b9ef69ab-95c2-486f-aa29-554813ff29fb",
          "intuition": "This approach involves using a more efficient algorithm to check if a sub-grid is homogeneous, such as using a prefix sum array to count the number of black cells in each sub-grid.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Node(val: true, isLeaf: false, topLeft: Node(val: false, isLeaf: true), topRight: Node(val: true, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
              "explanation": "The grid is divided into four sub-grids, each containing a single cell. The top-left and bottom-right sub-grids are black, while the top-right and bottom-left sub-grids are white. The constructed Quad Tree has an internal node with four leaf nodes.",
              "id": "43042a6f-786b-4853-a223-fed5d669f12d",
              "input": "grid = [[0,1],[1,0]]"
            },
            {
              "expectedOutput": "Node(val: true, isLeaf: false, topLeft: Node(val: true, isLeaf: true), topRight: Node(val: false, isLeaf: true), bottomLeft: Node(val: true, isLeaf: true), bottomRight: Node(val: false, isLeaf: true))",
              "explanation": "The grid is divided into four sub-grids. The top-left and bottom-left sub-grids are black, while the top-right and bottom-right sub-grids are white. The constructed Quad Tree has an internal node with four leaf nodes.",
              "id": "a3087db1-558d-4986-9068-91227bf4bfa9",
              "input": "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]"
            }
          ]
        }
      ],
      "id": "0c697df9-dc76-4894-a68f-e5ce3e30b3bc",
      "lastUpdated": "2026-02-06T21:18:06Z",
      "problemSlug": "construct-quad-tree",
      "relatedProblems": [
        "construct-binary-tree-from-preorder-and-postorder",
        "construct-binary-tree-from-inorder-and-postorder"
      ],
      "summary": "Construct a Quad Tree given a grid representing a rectangle that can be either black (represented by the value 0) or white (represented by the value 1), and return the root of the constructed Quad Tree. The key insight is to use a recursive approach to divide the grid into smaller sub-grids."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node, then recursively traverse the tree, prepending parentheses for children and appending '()' if a node has no children.",
          "code": "\nclass TreeNode {\n    let val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init(_ val: Int) {\n        self.val = val\n        left = nil\n        right = nil\n    }\n}\nfunc tree2str(_ t: TreeNode?) -> String {\n    guard let t = t else { return \"\" }\n    var str = String(t.val)\n    if t.left != nil || t.right != nil {\n        str += \"(\" + tree2str(t.left) + \")\"\n    }\n    if t.right != nil {\n        str += \"(\" + tree2str(t.right) + \")\"\n    }\n    return str\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Due to recursive call stack, space used can go up to n in case of unbalanced tree.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once."
          },
          "explanation": "This approach is straightforward but can be slow for large trees due to the recursive nature.",
          "id": "e65f0d1b-08c6-47b9-841f-3aa05a302fc6",
          "intuition": "The brute force approach involves traversing the binary tree, and for each node, checking if it has children, and then recursively traversing them.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1(2(4))(3)",
              "explanation": "For this binary tree:      1\n     /   \\\n    2     3\n   /\n  4\nThe output string is 1(2(4))(3)",
              "id": "25cf95f5-e360-4ac0-9ea3-b0208b3488cf",
              "input": "t = [1,2,3,4]"
            },
            {
              "expectedOutput": "1(2()(4))(3)",
              "explanation": "For this binary tree:      1\n     /   \\\n    2     3\n     \\\n      4\nThe output string is 1(2()(4))(3)",
              "id": "0605f6a5-3cbf-4d61-8506-92c5484ec9cb",
              "input": "t = [1,2,3,null,4]"
            }
          ]
        },
        {
          "approach": "Use an iterative approach with a stack to store nodes to visit, then process each node, adding it and its children to the result string.",
          "code": "\nfunc tree2str(_ t: TreeNode?) -> String {\n    guard let t = t else { return \"\" }\n    var result = String(t.val)\n    if t.left == nil && t.right == nil {\n        return result\n    }\n    result += \"(\"\n    if let l = t.left {\n        result += tree2str(l)\n    }\n    if t.left != nil && t.right != nil {\n        result += \")(\"\n    }\n    if let r = t.right {\n        result += tree2str(r)\n    }\n    result += \")\"\n    return result\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "In the worst case, space complexity can go up to n due to the stack space used to store the nodes at each level.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once."
          },
          "explanation": "This approach offers better performance than the brute force method for large trees due to avoiding recursive call overhead.",
          "id": "3e577f62-f83f-456a-9e8f-914eb611de16",
          "intuition": "Instead of recursion, we can use iteration and a stack to traverse the tree.",
          "name": "Iterative",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1(2(4))(3)",
              "explanation": "For this binary tree:      1\n     /   \\\n    2     3\n   /\n  4\nThe output string is 1(2(4))(3)",
              "id": "ee7f83ee-dc08-482c-8e18-3afc09ed6a30",
              "input": "t = [1,2,3,4]"
            },
            {
              "expectedOutput": "1(2()(4))(3)",
              "explanation": "For this binary tree:      1\n     /   \\\n    2     3\n     \\\n      4\nThe output string is 1(2()(4))(3)",
              "id": "db2e5d5d-b4cf-4a62-b06f-a3d5233da6ae",
              "input": "t = [1,2,3,null,4]"
            }
          ]
        }
      ],
      "id": "bd00d9ab-e0f0-4fe4-9ab1-b5cc07f53e74",
      "lastUpdated": "2026-02-06T21:28:38Z",
      "problemSlug": "construct-string-from-binary-tree",
      "relatedProblems": [
        "path-sum",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "This problem requires constructing a string representation of a binary tree, with key insight being traversing the tree and concatenating node values."
    },
    {
      "approaches": [
        {
          "approach": "Iterate through all nodes in the tree, for each node, iterate through all nodes again to find the sum of values greater than the current node's value, and update the current node's value.",
          "code": "\nclass Solution {\n    func convertBST(_ root: TreeNode?) -> TreeNode? {\n        guard let root = root else { return nil }\n        var sum = 0\n        let queue = [TreeNode?](arrayLiteral: root)\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            if let node = node {\n                sum += node.val\n                node.val = sum\n                if let right = node.right { queue.append(right) }\n                if let left = node.left { queue.append(left) }\n            }\n        }\n        return root\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) if we do not consider the space needed for the recursion stack and the output.",
            "time": "O(n)",
            "timeExplanation": "In the worst case, the tree is completely unbalanced, e.g., each node has only left child node, the recursion call would occur N times (the height of the tree), therefore storage to store the call stack would be O(N). In the best case, the tree is completely balanced, the height of the tree would be log(N)."
          },
          "explanation": "This approach involves a lot of repeated work as it recalculates the sum for each node, resulting in an inefficient solution with a high time complexity.",
          "id": "e771a64c-2011-432f-a768-5c5e6c521e85",
          "intuition": "This approach works by iterating through all nodes in the tree for each node to find the sum of values greater than the current node's value.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[30,36,21,36,35,26,15,null,null,null,16,null,null,8]",
              "explanation": "After conversion, each node's value should be the sum of all nodes' values in the original tree that are greater than or equal to the node's value.",
              "id": "7515955b-4cbe-4975-bfb3-11fa050c26a9",
              "input": "root = [4,1,6,0,2,5,7,null,null,null,3,null,null,8]"
            },
            {
              "expectedOutput": "[1,null,1]",
              "explanation": "The node with value 1 should have a value of 1 because it's the only node left in the tree after conversion.",
              "id": "4b6f6542-91d1-4a3c-b114-16043c38cadc",
              "input": "root = [0,null,1]"
            }
          ]
        },
        {
          "approach": "Perform a reverse in-order traversal to visit nodes in descending order, and for each node, add its value to the cumulative sum and update the node's value to the cumulative sum.",
          "code": "\nclass Solution {\n    var sum = 0\n    func convertBST(_ root: TreeNode?) -> TreeNode? {\n        reverseInOrder(root)\n        return root\n    }\n    func reverseInOrder(_ node: TreeNode?) {\n        guard let node = node else { return }\n        reverseInOrder(node.right)\n        node.val += sum\n        sum = node.val\n        reverseInOrder(node.left)\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h), where h is the height of the tree, due to the recursion stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) as each node is visited once."
          },
          "explanation": "This approach avoids the repeated work of the brute force approach by visiting each node only once and updating its value in place, resulting in a more efficient solution.",
          "id": "a8412ebc-ed3b-40e1-bf98-430e1cdb4ae0",
          "intuition": "This approach works by performing a reverse in-order traversal to visit nodes in descending order and keeping track of the cumulative sum of node values.",
          "name": "Optimized Reverse In-Order Traversal Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[30,36,21,36,35,26,15,null,null,null,16,null,null,8]",
              "explanation": "After conversion, each node's value should be the sum of all nodes' values in the original tree that are greater than or equal to the node's value.",
              "id": "ecdd8ad9-ba21-4488-a734-febf914a6db7",
              "input": "root = [4,1,6,0,2,5,7,null,null,null,3,null,null,8]"
            },
            {
              "expectedOutput": "[1,null,1]",
              "explanation": "The node with value 1 should have a value of 1 because it's the only node left in the tree after conversion.",
              "id": "cace34be-e4aa-4f63-a1d7-769c0c53aaa2",
              "input": "root = [0,null,1]"
            }
          ]
        }
      ],
      "id": "9f0c27b4-1f2d-4dfc-a69b-8a6a0b312743",
      "lastUpdated": "2026-02-06T21:25:11Z",
      "problemSlug": "convert-bst-to-greater-tree",
      "relatedProblems": [
        "bst-to-gst",
        "recover-binary-search-tree"
      ],
      "summary": "Convert a Binary Search Tree (BST) to a Greater Tree where each node's value is the sum of all nodes' values in the original tree that are greater than or equal to the node's value. The key insight is to perform a reverse in-order traversal to visit nodes in descending order."
    },
    {
      "approaches": [
        {
          "approach": "Create an empty tree, then iterate over the sorted array and insert each element into the tree, maintaining the properties of a binary search tree.",
          "code": "class TreeNode {\n    let val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\nclass Solution {\n    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {\n        if nums.isEmpty {\n            return nil\n        }\n        var root: TreeNode? = nil\n        for num in nums {\n            if root == nil {\n                root = TreeNode(num)\n            }\n            else {\n                insert(root, num)\n            }\n        }\n        return root\n    }\n    func insert(_ node: TreeNode?, _ num: Int) {\n        if node == nil {\n            return\n        }\n        if num < node!.val {\n            if node!.left == nil {\n                node!.left = TreeNode(num)\n            }\n            else {\n                insert(node!.left, num)\n            }\n        }\n        else if num > node!.val {\n            if node!.right == nil {\n                node!.right = TreeNode(num)\n            }\n            else {\n                insert(node!.right, num)\n            }\n        }\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the tree can have n nodes, each occupying some space.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because in the worst case, for each of the n elements in the array, we may need to traverse the entire tree, resulting in quadratic time complexity."
          },
          "explanation": "By iterating over the sorted array and inserting each element into the tree, the resulting tree will be a binary search tree because all elements to the left of a node will be smaller and all elements to the right will be greater.",
          "id": "901ad728-fffb-4f98-9ce5-6db6fef44fab",
          "intuition": "This approach involves creating a tree and then inserting each element from the sorted array into the tree, resulting in a binary search tree.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "a balanced BST",
              "explanation": "The resulting tree will be a balanced binary search tree with the root as 0 and its children as -3 and 9.",
              "id": "f76d84b2-861e-46b5-b8ce-0f258ca273d5",
              "input": "nums = [-10,-3,0,5,9]"
            },
            {
              "expectedOutput": "a BST where 3 is the root",
              "explanation": "The resulting tree will be a binary search tree where 3 is the root and its children are 2 and 4.",
              "id": "e58f9422-53dd-47dc-a691-01345e940976",
              "input": "nums = [1,2,3,4,5]"
            }
          ]
        },
        {
          "approach": "Start with the entire array and recursively construct the binary search tree, selecting the middle element as the root of the current tree and making the left and right halves the roots of the left and right subtrees respectively.",
          "code": "class TreeNode {\n    let val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\nclass Solution {\n    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {\n        return helper(nums, 0, nums.count - 1)\n    }\n    func helper(_ nums: [Int], _ left: Int, _ right: Int) -> TreeNode? {\n        if left > right {\n            return nil\n        }\n        let mid = left + (right - left) / 2\n        let node = TreeNode(nums[mid])\n        node.left = helper(nums, left, mid - 1)\n        node.right = helper(nums, mid + 1, right)\n        return node\n    }\n}",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "The space complexity is O(log n) because of the recursive call stack, which in the worst case will have a depth of log n due to the balanced tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because each element is visited exactly once."
          },
          "explanation": "By recursively constructing the tree and selecting the middle element as the root at each step, the resulting tree will be a balanced binary search tree where all elements in the left subtree are less than the root and all elements in the right subtree are greater.",
          "id": "217836c4-9be4-4bf3-9f93-764317e6a5fd",
          "intuition": "This approach involves recursively constructing the binary search tree using the divide-and-conquer strategy, where each recursive call constructs a subtree from the given array.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "a balanced BST with 3 as root",
              "explanation": "The resulting tree will be a balanced binary search tree where 3 is the root and its children are 2 and 4.",
              "id": "6c5cd313-c9e1-4f9c-a9e6-2bcf10fe44bf",
              "input": "nums = [1,2,3,4,5]"
            },
            {
              "expectedOutput": "a balanced BST with 4 as root",
              "explanation": "The resulting tree will be a balanced binary search tree where 4 is the root and its children are 2 and 6.",
              "id": "3d6eec7d-7287-44bb-bc74-8bb13ecdb4e9",
              "input": "nums = [1,2,3,4,5,6,7]"
            }
          ]
        }
      ],
      "id": "57b75284-2bee-4ffb-83a6-0cbfbb14eff7",
      "lastUpdated": "2026-02-06T21:06:39Z",
      "problemSlug": "convert-sorted-array-to-binary-search-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "The Convert Sorted Array to Binary Search Tree problem requires constructing a balanced binary search tree from a sorted array, and the key insight is that this can be achieved using a divide-and-conquer approach by recursively splitting the array into two halves and making the middle element the root of the tree."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS from the root with current max value.\n2. If node.val >= max, count it as good.\n3. Update max and recurse on children.",
          "code": "func goodNodes(_ root: TreeNode?) -> Int {\n    func dfs(_ node: TreeNode?, _ currentMax: Int) -> Int {\n        guard let node = node else { return 0 }\n        let isGood = node.val >= currentMax ? 1 : 0\n        let nextMax = max(currentMax, node.val)\n        return isGood + dfs(node.left, nextMax) + dfs(node.right, nextMax)\n    }\n    guard let root = root else { return 0 }\n    return dfs(root, root.val)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node visited once"
          },
          "explanation": "The max value on the path fully determines whether a node is good.",
          "id": "8c3fe2b2-84c5-446c-8794-99ae762f95e0",
          "intuition": "A node is good if its value is greater than or equal to all values seen so far on the path.",
          "name": "DFS with Path Maximum",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "Good nodes are 3,4,5,3 (left grandchild).",
              "id": "e37487e8-c61c-4bdf-ab6c-e62ce931337a",
              "input": "root = [3,1,4,3,null,1,5]"
            },
            {
              "expectedOutput": "3",
              "explanation": "All except node 2 are good.",
              "id": "68ad95d2-659d-4f24-b8f1-eed1d5fa6459",
              "input": "root = [3,3,null,4,2]"
            },
            {
              "expectedOutput": "1",
              "explanation": "Root is always good.",
              "id": "954e0167-f0a8-4e0f-9a59-d47c51cd61fc",
              "input": "root = [1]"
            }
          ]
        }
      ],
      "id": "089040a5-891d-4aa8-8015-eec25ac45f8e",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "count-good-nodes-in-binary-tree",
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "same-tree"
      ],
      "summary": "Track the maximum value along the path from the root to each node; a node is good if it is at least that maximum."
    },
    {
      "approaches": [
        {
          "approach": "First, create a queue and enqueue the root node. Then, iterate through the queue and dequeue each node, adding its children to the queue. During this process, track the depth and parent of each node.",
          "code": "\nimport Foundation\n\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n\n    public init(val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func isCousins(_ root: TreeNode?, _ x: Int, _ y: Int) -> Bool {\n        var queue: [TreeNode] = []\n        queue.append(root!)\n        var depthX: Int?\n        var depthY: Int?\n        var parentX: Int?\n        var parentY: Int?\n\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            if node.left != nil && node.right != nil {\n                if node.left!.val == x && node.right!.val == y {\n                    return false\n                }\n                if node.left!.val == y && node.right!.val == x {\n                    return false\n                }\n            }\n            if node.val == x || node.left?.val == x || node.right?.val == x {\n                if depthX == nil {\n                    depthX = getDepth(root, x)\n                }\n                if parentX == nil {\n                    parentX = getParent(root, x)\n                }\n            }\n            if node.val == y || node.left?.val == y || node.right?.val == y {\n                if depthY == nil {\n                    depthY = getDepth(root, y)\n                }\n                if parentY == nil {\n                    parentY = getParent(root, y)\n                }\n            }\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n        return depthX == depthY && parentX != parentY\n    }\n\n    func getDepth(_ root: TreeNode?, _ x: Int) -> Int {\n        return getDepthHelper(root, x, 0)\n    }\n\n    func getDepthHelper(_ node: TreeNode?, _ x: Int, _ depth: Int) -> Int {\n        if node == nil {\n            return -1\n        }\n        if node?.val == x {\n            return depth\n        }\n        let leftDepth = getDepthHelper(node?.left, x, depth + 1)\n        if leftDepth != -1 {\n            return leftDepth\n        }\n        return getDepthHelper(node?.right, x, depth + 1)\n    }\n\n    func getParent(_ root: TreeNode?, _ x: Int) -> Int? {\n        return getParentHelper(root, x)\n    }\n\n    func getParentHelper(_ node: TreeNode?, _ x: Int) -> Int? {\n        if node?.left?.val == x || node?.right?.val == x {\n            return node?.val\n        }\n        if node?.left != nil {\n            if let parent = getParentHelper(node?.left, x) {\n                return parent\n            }\n        }\n        if node?.right != nil {\n            if let parent = getParentHelper(node?.right, x) {\n                return parent\n            }\n        }\n        return nil\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The queue can store up to n nodes at any given time.",
            "time": "O(n)",
            "timeExplanation": "We are exploring each node in the binary tree once."
          },
          "explanation": "The brute-force approach works by exploring all nodes in the binary tree, allowing us to find the depth and parent of the target nodes. However, it may not be the most efficient method.",
          "id": "3a4991f9-be11-4f33-bac0-e318327248b0",
          "intuition": "This approach involves performing a level-order traversal of the binary tree to find the depth and parent of each node.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "4 and 3 are not cousins because they are at the same level but have the same parent.",
              "id": "e03373e8-4477-4959-b692-cd61a6c74154",
              "input": "root = [1,2,3,4], x = 4, y = 3"
            },
            {
              "expectedOutput": "true",
              "explanation": "5 and 4 are cousins because they are at the same level and have different parents.",
              "id": "ef631f15-ab51-4c3b-89a9-da0fd807f82c",
              "input": "root = [1,2,3,null,4,null,5], x = 5, y = 4"
            }
          ]
        },
        {
          "approach": "First, create a dictionary to store the depth and parent of each node. Then, perform a level-order traversal, updating the dictionary as we explore each node.",
          "code": "\nimport Foundation\n\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n\n    public init(val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func isCousins(_ root: TreeNode?, _ x: Int, _ y: Int) -> Bool {\n        var queue: [(TreeNode, Int, Int?)] = [(root!, 0, nil)]\n        var dict: [Int: (Int, Int?)] = [:]\n\n        while !queue.isEmpty {\n            let (node, depth, parent) = queue.removeFirst()\n            dict[node.val] = (depth, parent)\n\n            if node.left != nil {\n                queue.append((node.left!, depth + 1, node.val))\n            }\n            if node.right != nil {\n                queue.append((node.right!, depth + 1, node.val))\n            }\n        }\n\n        let (xDepth, xParent) = dict[x]!\n        let (yDepth, yParent) = dict[y]!\n\n        return xDepth == yDepth && xParent != yParent\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The queue and dictionary can store up to n nodes at any given time.",
            "time": "O(n)",
            "timeExplanation": "We are exploring each node in the binary tree once."
          },
          "explanation": "By using a dictionary to store the depth and parent of each node, we can more efficiently find the depth and parent of the target nodes.",
          "id": "e08199f1-517d-49ec-92b4-a710ed2fd731",
          "intuition": "The optimized approach also involves a level-order traversal but keeps track of the depth and parent of each node in a dictionary for more efficient lookup.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "4 and 3 are not cousins because they are at the same level but have the same parent.",
              "id": "4d66383c-a937-4404-9d01-c3da9bf69bfc",
              "input": "root = [1,2,3,4], x = 4, y = 3"
            },
            {
              "expectedOutput": "true",
              "explanation": "5 and 4 are cousins because they are at the same level and have different parents.",
              "id": "29636890-a38e-4550-b6cf-8368c28f1a20",
              "input": "root = [1,2,3,null,4,null,5], x = 5, y = 4"
            }
          ]
        }
      ],
      "id": "878bc7ce-8b08-4a22-b07f-f2e6ffcf20c2",
      "lastUpdated": "2026-02-06T21:54:06Z",
      "problemSlug": "cousins-in-binary-tree",
      "relatedProblems": [
        "max-depth-of-binary-tree",
        "minimum-depth-of-binary-tree"
      ],
      "summary": "The problem requires determining if two nodes in a binary tree are cousins, which means they have the same depth but different parents. The key insight is to perform a level-order traversal to track the depth and parent of each node."
    },
    {
      "approaches": [
        {
          "approach": "1. Start by finding the node to be deleted in the BST. 2. Once the node is found, remove it and then re-insert all the nodes from the tree into a new BST.",
          "code": "\nclass TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        if key < root!.val {\n            root!.left = deleteNode(root!.left, key)\n        } else if key > root!.val {\n            root!.right = deleteNode(root!.right, key)\n        } else {\n            if root!.left == nil {\n                return root!.right\n            } else if root!.right == nil {\n                return root!.left\n            }\n\n            let minVal = findMin(root!.right!)\n            root!.val = minVal\n            root!.right = deleteNode(root!.right, minVal)\n        }\n        return root\n    }\n\n    func findMin(_ node: TreeNode) -> Int {\n        var current = node\n        while current.left != nil {\n            current = current.left!\n        }\n        return current.val\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity of this approach is O(h), where h is the height of the tree. This is because we are using recursion and the maximum depth of the recursion call stack is equal to the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity of this approach is O(n) in the worst case because we might need to traverse the entire tree to find the node to be deleted and then to re-balance the tree."
          },
          "explanation": "First, we find the node to be deleted using a recursive in-order traversal. Then we recreate the tree by re-inserting all nodes except the one to be deleted. The time complexity of this approach is O(n^2) in the worst case because the re-insertion process takes O(n) time and it is performed for every node in the tree.",
          "id": "b35fc9a8-bf3b-4816-82c0-85f05441c336",
          "intuition": "This approach involves finding the node to be deleted, then recreating the binary search tree without that node while maintaining the BST property",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[5,2,6,2,4,null,7]",
              "explanation": "The node with value 3 is deleted and the BST property is maintained.",
              "id": "57bb7fc7-9c46-4595-8c8d-29d320f3b5d2",
              "input": "root = [5,3,6,2,4,null,7], key = 3"
            },
            {
              "expectedOutput": "[5,3,6,2,4,null,7]",
              "explanation": "The node with value 0 is not found in the tree, so the tree remains the same.",
              "id": "8f23cd85-9cc2-474b-879d-a0c5604c9d1a",
              "input": "root = [5,3,6,2,4,null,7], key = 0"
            }
          ]
        },
        {
          "approach": "1. Start by finding the node to be deleted in the BST. 2. Handle three cases: no child (simply remove the node), one child (replace the node with its child), and two children (find the in-order successor or predecessor and replace the node with it)",
          "code": "\nclass TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        if key < root!.val {\n            root!.left = deleteNode(root!.left, key)\n        } else if key > root!.val {\n            root!.right = deleteNode(root!.right, key)\n        } else {\n            if root!.left == nil {\n                return root!.right\n            } else if root!.right == nil {\n                return root!.left\n            }\n\n            let minVal = findMin(root!.right!)\n            root!.val = minVal\n            root!.right = deleteNode(root!.right, minVal)\n        }\n        return root\n    }\n\n    func findMin(_ node: TreeNode) -> Int {\n        var current = node\n        while current.left != nil {\n            current = current.left!\n        }\n        return current.val\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity of this approach is O(h), where h is the height of the tree. This is because we are using recursion and the maximum depth of the recursion call stack is equal to the height of the tree.",
            "time": "O(h)",
            "timeExplanation": "The time complexity of this approach is O(h), where h is the height of the tree, because we might need to traverse from the root to the node to be deleted and then to the in-order successor or predecessor."
          },
          "explanation": "First, we find the node to be deleted using a recursive in-order traversal. Then we handle three cases: if the node has no child, we simply remove it; if the node has one child, we replace it with its child; if the node has two children, we find the in-order successor or predecessor and replace the node with it. The time complexity of this approach is O(h), where h is the height of the tree.",
          "id": "fb02fbd6-aed3-4ace-b530-33f69ecb7b4e",
          "intuition": "This approach involves finding the node to be deleted, then handling three cases: no child, one child, and two children separately to maintain the BST property",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[5,2,6,null,null,4,7]",
              "explanation": "The node with value 3 is deleted and the BST property is maintained.",
              "id": "17181de7-1cc1-4eeb-b066-4aab50eded45",
              "input": "root = [5,3,6,2,4,null,7], key = 3"
            },
            {
              "expectedOutput": "[5,3,6,2,4,null,7]",
              "explanation": "The node with value 0 is not found in the tree, so the tree remains the same.",
              "id": "823197f2-8d4e-4a2d-b2fe-db363fd0abb6",
              "input": "root = [5,3,6,2,4,null,7], key = 0"
            }
          ]
        }
      ],
      "id": "6300f8fc-e479-4cf4-8b36-f015e26849be",
      "lastUpdated": "2026-02-06T21:19:36Z",
      "problemSlug": "delete-node-in-a-bst",
      "relatedProblems": [
        "insert-into-a-binary-search-tree",
        "search-in-a-binary-search-tree"
      ],
      "summary": "This problem involves deleting a node from a binary search tree while maintaining the BST property, key insight is to handle three cases: no child, one child, and two children separately."
    },
    {
      "approaches": [
        {
          "approach": "1. DFS returns height of subtree\n2. At each node: update diameter = left + right\n3. Return 1 + max(left, right) as height",
          "code": "func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\n    var diameter = 0\n    \n    func height(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let left = height(node.left)\n        let right = height(node.right)\n        diameter = max(diameter, left + right)\n        return 1 + max(left, right)\n    }\n    \n    _ = height(root)\n    return diameter\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth = height",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "Height is longest path to leaf. Diameter uses both sides.",
          "id": "550e8400-e29b-41d4-a716-446655440162",
          "intuition": "Diameter through node = left height + right height. Track max while computing heights.",
          "name": "DFS Height",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Path 4->2->1->3 or 5->2->1->3",
              "id": "550e8400-e29b-41d4-a716-446655440268",
              "input": "[1,2,3,4,5]"
            }
          ]
        }
      ],
      "id": "550e8400-e29b-41d4-a716-446655440051",
      "lastUpdated": "2026-02-06T00:00:00Z",
      "problemSlug": "diameter-of-binary-tree",
      "relatedProblems": [
        "binary-tree-maximum-path-sum"
      ],
      "summary": "Longest path between any two nodes. For each node, diameter through it = leftHeight + rightHeight."
    },
    {
      "approaches": [
        {
          "approach": "1. Perform a depth-first search to calculate the total number of coins in the binary tree. 2. Perform another depth-first search to calculate the total number of nodes. 3. Calculate the moves required to distribute coins by counting the number of nodes with a surplus or deficit.",
          "code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func distributeCoins(_ root: TreeNode?) -> Int {\n        var totalCoins = 0\n        var totalNodes = 0\n        var distributeMoves = 0\n\n        func dfs(_ node: TreeNode?) {\n            if node == nil {\n                return\n            }\n            totalCoins += node!.val\n            totalNodes += 1\n            dfs(node!.left)\n            dfs(node!.right)\n        }\n\n        func dfs2(_ node: TreeNode?) {\n            if node == nil {\n                return\n            }\n            if node!.val > 1 {\n                distributeMoves += node!.val - 1\n            } else if node!.val < 1 {\n                distributeMoves -= node!.val - 1\n            }\n            dfs2(node!.left)\n            dfs2(node!.right)\n        }\n\n        dfs(root)\n        dfs2(root)\n        return distributeMoves\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We store the nodes in the call stack during the recursive depth-first searches.",
            "time": "O(n)",
            "timeExplanation": "We perform two depth-first searches: one to calculate the total number of coins and another to calculate the moves required."
          },
          "explanation": "This approach has a time complexity of O(n) and a space complexity of O(n), where n is the number of nodes in the binary tree.",
          "id": "71a1baaa-6574-4d9e-9049-41b946ddcee6",
          "intuition": "This approach works by first calculating the total number of coins in the binary tree and the total number of nodes. Then, it calculates the moves required to distribute coins.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "There are 3 coins in the binary tree with a total of 3 nodes. The moves required to distribute coins are 2.",
              "id": "e69c711b-2671-41c3-926f-2d755b630569",
              "input": "TreeNode(3), TreeNode(0), TreeNode(0)"
            },
            {
              "expectedOutput": "3",
              "explanation": "There are 3 coins in the binary tree with a total of 3 nodes. The moves required to distribute coins are 3.",
              "id": "904cd377-88f7-45f8-b541-6a52e9ae8e77",
              "input": "TreeNode(0), TreeNode(3), TreeNode(0)"
            }
          ]
        },
        {
          "approach": "1. Perform a depth-first search to calculate the moves required and the total number of coins in the binary tree. 2. During the depth-first search, update the moves required by counting the number of nodes with a surplus or deficit.",
          "code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    var moves = 0\n\n    func distributeCoins(_ root: TreeNode?) -> Int {\n        dfs(root)\n        return moves\n    }\n\n    func dfs(_ node: TreeNode?) -> Int {\n        if node == nil {\n            return 0\n        }\n        let leftSurplus = dfs(node!.left)\n        let rightSurplus = dfs(node!.right)\n        moves += abs(leftSurplus) + abs(rightSurplus)\n        return node!.val + leftSurplus + rightSurplus - 1\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We store the nodes in the call stack during the recursive depth-first search.",
            "time": "O(n)",
            "timeExplanation": "We perform a single depth-first search to calculate the moves required and the total number of coins."
          },
          "explanation": "This approach has a time complexity of O(n) and a space complexity of O(n), where n is the number of nodes in the binary tree.",
          "id": "07370c8d-ee0a-4d67-a335-ff2a80c2119b",
          "intuition": "This approach works by using a single depth-first search to calculate the total number of coins and the moves required.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "There are 3 coins in the binary tree with a total of 3 nodes. The moves required to distribute coins are 2.",
              "id": "74535f21-9a28-47f7-8eea-9d594df7ca42",
              "input": "TreeNode(3), TreeNode(0), TreeNode(0)"
            },
            {
              "expectedOutput": "3",
              "explanation": "There are 3 coins in the binary tree with a total of 3 nodes. The moves required to distribute coins are 3.",
              "id": "eed8f5fe-8bfa-4f99-84d2-d356af87b13e",
              "input": "TreeNode(0), TreeNode(3), TreeNode(0)"
            }
          ]
        }
      ],
      "id": "f232ecf5-4760-4de0-937d-e212740dd07c",
      "lastUpdated": "2026-02-06T21:52:47Z",
      "problemSlug": "distribute-coins-in-binary-tree",
      "relatedProblems": [
        "path-sum",
        "path-sum-ii"
      ],
      "summary": "The problem requires distributing coins in a binary tree, with each node initially having 0 or more coins and each node needing 1 coin. The key insight is to find the number of moves required to distribute coins from nodes with a surplus to nodes with a deficit."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate over all employees to find the target employee and initialize the importance. 2. For each employee, iterate over their direct reports and recursively calculate their importance. 3. Accumulate the importance values of all direct reports for the target employee.",
          "code": "\n// Employee class definition\nclass Employee {\n    var id: Int\n    var importance: Int\n    var subordinates: [Int]\n\n    init(_ id: Int, _ importance: Int, _ subordinates: [Int]) {\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n    }\n}\n\nfunc getImportance(_ employees: [Employee], _ id: Int) -> Int {\n    var employeeMap: [Int: Employee] = [:]\n    for employee in employees {\n        employeeMap[employee.id] = employee\n    }\n\n    func dfs(_ employeeId: Int) -> Int {\n        let employee = employeeMap[employeeId]!\n        var importance = employee.importance\n        for subordinateId in employee.subordinates {\n            importance += dfs(subordinateId)\n        }\n        return importance\n    }\n\n    return dfs(id)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are using a map to store all employees, resulting in a space complexity of O(n), where n is the number of employees in the company.",
            "time": "O(n^2)",
            "timeExplanation": "In the worst case, we are performing a recursive DFS for each employee in the company, resulting in n recursive calls. Since we are using a set to keep track of visited employees, the space complexity is also O(n)."
          },
          "explanation": "This approach is straightforward but inefficient, with a high time complexity due to repeated recursive function calls.",
          "id": "994702b5-be8f-4498-966e-2497ff3b3368",
          "intuition": "This approach works by iterating over all employees and calculating their importance by recursively summing the importance of their direct reports.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "11",
              "explanation": "The total importance is the importance of the employee with id 1 plus the importance of their direct reports (employees with id 2 and 3). So, 5 + 3 + 3 = 11.",
              "id": "3d2bd97e-0f46-4e74-b358-92240fc34815",
              "input": "employees = [Employee(1, 5, [2,3]), Employee(2, 3, []), Employee(3, 3, [])], id = 1"
            },
            {
              "expectedOutput": "7",
              "explanation": "The total importance is the importance of the employee with id 3 plus the importance of their direct reports (employees with id 2). So, 4 + 3 = 7.",
              "id": "d04da195-1d59-4f94-b86b-24ea7d0871e3",
              "input": "employees = [Employee(2, 3, []), Employee(3, 4, [2])], id = 3"
            }
          ]
        },
        {
          "approach": "1. Create a dictionary to store the importance of each employee. 2. Traverse the employee hierarchy using DFS. 3. For each employee, calculate their importance by summing their own importance and the importance of their direct reports, using memoized values when available.",
          "code": "\n// Employee class definition\nclass Employee {\n    var id: Int\n    var importance: Int\n    var subordinates: [Int]\n\n    init(_ id: Int, _ importance: Int, _ subordinates: [Int]) {\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n    }\n}\n\nfunc getImportance(_ employees: [Employee], _ id: Int) -> Int {\n    var employeeMap: [Int: Employee] = [:]\n    var importanceMap: [Int: Int] = [:]\n    for employee in employees {\n        employeeMap[employee.id] = employee\n    }\n\n    func dfs(_ employeeId: Int) -> Int {\n        if let importance = importanceMap[employeeId] {\n            return importance\n        }\n        let employee = employeeMap[employeeId]!\n        var importance = employee.importance\n        for subordinateId in employee.subordinates {\n            importance += dfs(subordinateId)\n        }\n        importanceMap[employeeId] = importance\n        return importance\n    }\n\n    return dfs(id)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are using two dictionaries to store employees and their importance values, resulting in a space complexity of O(n).",
            "time": "O(n)",
            "timeExplanation": "We are performing a recursive DFS, but we are using memoization to avoid repeated calculations. Thus, the time complexity is O(n), where n is the number of employees in the company."
          },
          "explanation": "This approach is more efficient than the brute-force approach, with a lower time complexity due to memoization.",
          "id": "39473360-7586-454a-af21-ff7589b753da",
          "intuition": "This approach works by using a dictionary to memoize the importance of each employee as we traverse the employee hierarchy, thus avoiding repeated calculations.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "11",
              "explanation": "The total importance is the importance of the employee with id 1 plus the importance of their direct reports (employees with id 2 and 3). So, 5 + 3 + 3 = 11.",
              "id": "c1d537b0-2296-4838-8ddf-a8900b9761f3",
              "input": "employees = [Employee(1, 5, [2,3]), Employee(2, 3, []), Employee(3, 3, [])], id = 1"
            },
            {
              "expectedOutput": "7",
              "explanation": "The total importance is the importance of the employee with id 3 plus the importance of their direct reports (employees with id 2). So, 4 + 3 = 7.",
              "id": "0b9a68a9-e381-40bf-92d6-4037d37336b9",
              "input": "employees = [Employee(2, 3, []), Employee(3, 4, [2])], id = 3"
            }
          ]
        }
      ],
      "id": "a6465ee4-2665-416d-92ea-9a45a0e6772d",
      "lastUpdated": "2026-02-06T21:34:09Z",
      "problemSlug": "employee-importance",
      "relatedProblems": [
        "employee-importance",
        "num-components-connected",
        "course-schedule-ii"
      ],
      "summary": "This problem involves calculating the total importance of a given employee in a company. The key insight here is to traverse the employee hierarchy using a tree traversal approach, such as Depth-First Search (DFS) or Breadth-First Search (BFS), and accumulate the importance values."
    },
    {
      "approaches": [
        {
          "approach": "Create a queue for BFS, and at each level, pop a node, push its children, and move on to the next level until we've processed all levels. Track the value of the first node at the last level.",
          "code": "\nclass Solution {\n   func findBottomLeftValue(_ root: TreeNode?) -> Int {\n      var queue: [TreeNode] = [root!]\n      var result: Int = 0\n      while !queue.isEmpty {\n         let count = queue.count\n         result = queue.first!.val\n         for _ in 1...count {\n            let node = queue.removeFirst()\n            if let left = node.left {\n               queue.append(left)\n            }\n            if let right = node.right {\n               queue.append(right)\n            }\n         }\n      }\n      return result\n   }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "In the worst case, we may need to store all nodes at the last level of the tree in the queue.",
            "time": "O(n)",
            "timeExplanation": "Each node in the binary tree is visited once."
          },
          "explanation": "We start at the root and add its value to the queue. Then, we keep removing nodes from the queue, adding their children to it until the queue is empty. The value we get from the first node at the last level is our answer.",
          "id": "6e713e00-b32a-46f6-8e96-ace48e0299e4",
          "intuition": "Using BFS to traverse the tree level by level and keeping track of the first node at each level, so that when we reach the last level, the first node encountered will be the bottom left node.",
          "name": "Brute-Force BFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Because the binary tree is: \n    2 \n   / \\ \n  1   3 \n So we return 1.",
              "id": "a9cebd40-018b-40e1-b251-d99827ca5ad8",
              "input": "root = [2,1,3]"
            },
            {
              "expectedOutput": "7",
              "explanation": "Because the binary tree is: \n      1 \n     / \\ \n    2   3 \n   / \\ / \\ \n  4  5 6  7 \n So we return 7.",
              "id": "5c2676d1-e76e-409c-b058-0e2b01b190a8",
              "input": "root = [1,2,3,4,5,6,7]"
            }
          ]
        },
        {
          "approach": "Create a recursive function to perform DFS, update the maximum depth and the corresponding node value as we find nodes at greater depths.",
          "code": "\nclass Solution {\n   func findBottomLeftValue(_ root: TreeNode?) -> Int {\n      var maxDepth = 0\n      var result = 0\n      dfs(root, 0, &maxDepth, &result)\n      return result\n   }\n\n   func dfs(_ node: TreeNode?, _ depth: Int, _ maxDepth: inout Int, _ result: inout Int) {\n      guard let node = node else {\n         return\n      }\n      if depth > maxDepth {\n         maxDepth = depth\n         result = node.val\n      }\n      dfs(node.left, depth + 1, &maxDepth, &result)\n      dfs(node.right, depth + 1, &maxDepth, &result)\n   }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The recursive call stack can go up to the height of the tree in the worst case.",
            "time": "O(n)",
            "timeExplanation": "We visit each node once."
          },
          "explanation": "Perform DFS, keep track of the current depth and update the result if we reach a new maximum depth.",
          "id": "18c7b969-249a-46ef-b4a9-651561bdc970",
          "intuition": "Using DFS to explore the tree, and keep track of the maximum depth and the value of the node at that depth.",
          "name": "Depth-First Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Because the binary tree is: \n    2 \n   / \\ \n  1   3 \n So we return 1.",
              "id": "e57d983d-71a9-4f00-8877-d42d6bf5524f",
              "input": "root = [2,1,3]"
            },
            {
              "expectedOutput": "7",
              "explanation": "Because the binary tree is: \n      1 \n     / \\ \n    2   3 \n   / \\ / \\ \n  4  5 6  7 \n So we return 7.",
              "id": "860926e4-72f3-41a6-b672-149171515c49",
              "input": "root = [1,2,3,4,5,6,7]"
            }
          ]
        }
      ],
      "id": "568f2997-acc5-4636-bd3a-9b702e01c0bd",
      "lastUpdated": "2026-02-06T21:23:18Z",
      "problemSlug": "find-bottom-left-tree-value",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "binary-tree-right-side-view"
      ],
      "summary": "The problem requires finding the bottom left node value in a binary tree, which can be achieved through depth-first search (DFS) and breadth-first search (BFS) approaches."
    },
    {
      "approaches": [
        {
          "approach": "For each node, perform a DFS to get the hash of the subtree rooted at that node and store it in a hash table. If the hash is already in the hash table, then we have found a duplicate subtree.",
          "code": "\nclass Solution {\n    func findDuplicateSubtrees(_ root: TreeNode?) -> [TreeNode?] {\n        var result = [TreeNode?]()\n        var count: [String: Int] = [:]\n        traverse(root, &count, &result)\n        return result\n    }\n\n    func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?]) -> String {\n        if root == nil {\n            return \"#,\"\n        }\n        let left = traverse(root?.left, &count, &result)\n        let right = traverse(root?.right, &count, &result)\n        let hash = \"(root!.val),(left),(right)\"\n        if count[hash] == 1 {\n            result.append(root)\n        }\n        if count[hash] != nil {\n            count[hash]! += 1\n        } else {\n            count[hash] = 1\n        }\n        return hash\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are storing the hashes of the subtrees in a hash table, resulting in O(n) space complexity.",
            "time": "O(n^2)",
            "timeExplanation": "In the worst case, we are performing a DFS traversal for each node, resulting in O(n^2) time complexity."
          },
          "explanation": "The brute force approach is straightforward but inefficient. For each node, we are performing a DFS traversal, resulting in a high time complexity.",
          "id": "04775f0e-ea85-47de-a3f0-a6763f46136b",
          "intuition": "Traverse the tree using DFS and for each node, calculate the hash of the subtree rooted at that node.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2]",
              "explanation": "The duplicate subtrees are the left and right children of the root node.",
              "id": "1b409d41-aab3-439d-8dab-61d5802a0e85",
              "input": "root = [1,2,3,1,null,2]"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The duplicate subtrees are the left and right children of the root node.",
              "id": "19d80c71-00db-45c7-a37d-a1349e8eb614",
              "input": "root = [2,1,1]"
            }
          ]
        },
        {
          "approach": "Traverse the tree using DFS and for each node, calculate the hash of the subtree rooted at that node. If the hash is already in the hash table, then we have found a duplicate subtree.",
          "code": "\nclass Solution {\n    func findDuplicateSubtrees(_ root: TreeNode?) -> [TreeNode?] {\n        var result = [TreeNode?]()\n        var count: [String: Int] = [:]\n        var idxMap: [Int: Int] = [:]\n        var idx = 1\n        var ids: [TreeNode?: Int] = [:]\n        ids[root] = 0\n        traverse(root, &count, &result, &idxMap, &idx, &ids)\n        return result\n    }\n\n    func traverse(_ root: TreeNode?, _ count: inout [String: Int], _ result: inout [TreeNode?], _ idxMap: inout [Int: Int], _ idx: inout Int, _ ids: inout [TreeNode?: Int]) -> Int {\n        if root == nil {\n            return 0\n        }\n        let left = traverse(root?.left, &count, &result, &idxMap, &idx, &ids)\n        let right = traverse(root?.right, &count, &result, &idxMap, &idx, &ids)\n        let hash = (root!.val),(left),(right)\n        if idxMap[hash] == nil {\n            idxMap[hash] = idx\n            idx += 1\n        }\n        let id = idxMap[hash]!\n        if ids[root] == nil {\n            ids[root] = id\n        }\n        if count[hash] == 1 {\n            result.append(root)\n        }\n        if count[hash] != nil {\n            count[hash]! += 1\n        } else {\n            count[hash] = 1\n        }\n        return id\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are storing the hashes of the subtrees in a hash table, resulting in O(n) space complexity.",
            "time": "O(n)",
            "timeExplanation": "We are performing a DFS traversal of the tree, resulting in O(n) time complexity."
          },
          "explanation": "The optimized approach is more efficient than the brute force approach. We are using a hash table to store the subtrees and their hashes, resulting in a lower time complexity.",
          "id": "fd700fe6-189b-4b1a-96c5-1126ba3505b7",
          "intuition": "Use a hash table to store the subtrees and their hashes.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,2]",
              "explanation": "The duplicate subtrees are the left and right children of the root node.",
              "id": "51ba7a50-dde1-452c-970b-7e18b1e66067",
              "input": "root = [1,2,3,1,null,2]"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The duplicate subtrees are the left and right children of the root node.",
              "id": "c3d99a02-8d4d-4c21-8a2e-d35393555cfb",
              "input": "root = [2,1,1]"
            }
          ]
        }
      ],
      "id": "b267ebab-afb6-4ada-8ca2-ae30048c6244",
      "lastUpdated": "2026-02-06T21:31:05Z",
      "problemSlug": "find-duplicate-subtrees",
      "relatedProblems": [
        "path-sum",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "The problem asks to find duplicate subtrees in a binary tree. We can solve this problem using Depth-First Search (DFS) to traverse the tree and a hash table to store the subtrees."
    },
    {
      "approaches": [
        {
          "approach": "Perform a depth-first search on the tree and at each node, check if the current depth is greater than the previous maximum depth. If it is, update the maximum value at that depth. If not, update the maximum value at the current depth if the current node's value is greater",
          "code": "class Solution { \n func largestValues(_ root: TreeNode?) -> [Int] { \n     var result = [Int]() \n     dfs(root, 0, &result) \n     return result \n } \n \n func dfs(_ node: TreeNode?, _ depth: Int, _ result: inout [Int]) { \n     if node == nil { return } \n     if depth >= result.count { \n         result.append(node!.val) \n     } else { \n         result[depth] = max(result[depth], node!.val) \n     } \n     dfs(node?.left, depth + 1, &result) \n     dfs(node?.right, depth + 1, &result) \n } \n }",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) where h is the height of the tree because of the recursive function call stack",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the number of nodes in the tree because we visit each node once"
          },
          "explanation": "This approach works but is inefficient because it requires recursive function calls for each node in the tree. It also requires a separate data structure to keep track of the maximum value at each depth",
          "id": "f048bda7-6a4a-4da0-8192-b89b4407873a",
          "intuition": "The brute force approach involves using depth-first search to traverse the tree and keep track of the maximum value at each depth",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,3,9]",
              "explanation": "The largest value in each row is 1, 3, and 9 respectively",
              "id": "10410352-9476-4894-8217-90b3006dc93e",
              "input": "TreeNode(1) \n      /   \\\n     3     2 \n    / \\   \\\n   5   3   9"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The largest value in the only row is 1",
              "id": "fc6f0303-0797-4f20-be71-3d45a30b7b9a",
              "input": "TreeNode(1)"
            }
          ]
        },
        {
          "approach": "Perform a breadth-first search on the tree and at each level, keep track of the maximum value. After processing all nodes at the current level, move on to the next level",
          "code": "class Solution { \n func largestValues(_ root: TreeNode?) -> [Int] { \n     var result = [Int]() \n     var queue = [TreeNode?]() \n     if root != nil { \n         queue.append(root) \n     } \n     while !queue.isEmpty { \n         var levelMax = Int.min \n         var levelSize = queue.count \n         for _ in 1...levelSize { \n             let node = queue.removeFirst() \n             levelMax = max(levelMax, node!.val) \n             if node?.left != nil { \n                 queue.append(node?.left) \n             } \n             if node?.right != nil { \n                 queue.append(node?.right) \n             } \n         } \n         result.append(levelMax) \n     } \n     return result \n } \n }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the queue will store all nodes at the last level of the tree",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the number of nodes in the tree because we visit each node once"
          },
          "explanation": "This approach is more efficient than the brute force approach because it avoids recursive function calls and only uses a single queue data structure to keep track of nodes at the current level",
          "id": "41b9c6d6-1253-4f5f-a740-af29560a00a1",
          "intuition": "The optimized approach involves using breadth-first search to traverse the tree level by level",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,3,9]",
              "explanation": "The largest value in each row is 1, 3, and 9 respectively",
              "id": "5e84c9e0-a2ac-49e5-9579-e94eee27cf08",
              "input": "TreeNode(1) \n      /   \\\n     3     2 \n    / \\   \\\n   5   3   9"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The largest value in the only row is 1",
              "id": "c387f1c7-4003-47bf-95f7-52e20c0e0f10",
              "input": "TreeNode(1)"
            }
          ]
        }
      ],
      "id": "2266c307-0c4e-4fe1-8c78-0815a144e5e1",
      "lastUpdated": "2026-02-06T21:23:30Z",
      "problemSlug": "find-largest-value-in-each-tree-row",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "binary-tree-zigzag-level-order-traversal"
      ],
      "summary": "This problem asks to find the largest value in each row of a binary tree. The key insight is to use level order traversal to traverse the tree row by row"
    },
    {
      "approaches": [
        {
          "approach": "1. Perform in-order traversal on the binary search tree. 2. Use a hash map to count the frequency of each value. 3. Keep track of the maximum frequency. 4. Return the value(s) with the maximum frequency.",
          "code": "struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\nclass Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n    func inOrder(_ node: TreeNode?) {\n        if let node = node {\n            inOrder(node.left); count[node.val, default: 0] += 1; maxCount = max(maxCount, count[node.val]!);\n            inOrder(node.right);\n        }\n    }\n    inOrder(root);\n    for (key, value) in count where value == maxCount { result.append(key) }\n    return result;\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use a hash map to count the frequency of each value. In the worst-case scenario, all values are unique, resulting in a space complexity of O(n).",
            "time": "O(n)",
            "timeExplanation": "We visit each node once, resulting in a time complexity of O(n), where n is the number of nodes in the tree."
          },
          "explanation": "The brute-force approach works by taking advantage of the fact that in-order traversal visits nodes in ascending order. By counting the frequency of each value, we can determine which value appears most frequently. However, this approach may not be efficient for very large trees.",
          "id": "d512e80e-1810-4e1d-bb8b-ad2c690cbaa2",
          "intuition": "Performing an in-order traversal on the binary search tree and counting the frequency of each value in a hash map can help us find the mode.",
          "name": "Brute-Force: In-Order Traversal and Hash Map",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2]",
              "explanation": "The value 2 appears most frequently in the binary search tree.",
              "id": "0c895a6f-e84c-43ab-868e-1b0200d7cc3d",
              "input": "root = [1,null,2,2]"
            },
            {
              "expectedOutput": "[0]",
              "explanation": "The value 0 is the only value in the binary search tree, making it the mode.",
              "id": "84c9d12d-b332-40ce-9f3f-ca917e7a3e2e",
              "input": "root = [0]"
            }
          ]
        },
        {
          "approach": "1. Perform Morris traversal on the binary search tree. 2. Use a hash map to count the frequency of each value. 3. Keep track of the maximum frequency. 4. Return the value(s) with the maximum frequency.",
          "code": "struct TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } }\nclass Solution { func findMode(_ root: TreeNode?) -> [Int] {\n    var count: [Int: Int] = [:]; var maxCount: Int = 0; var result: [Int] = [];\n    var current: TreeNode? = root;\n    while let node = current {\n        if node.left == nil {\n            count[node.val, default: 0] += 1; maxCount = max(maxCount, count[node.val]!);\n            current = node.right;\n        } else {\n            var predecessor: TreeNode? = node.left;\n            while let pred = predecessor, pred.right != nil, pred.right !== node {\n                predecessor = pred.right;\n            }\n            if predecessor?.right == nil {\n                predecessor?.right = node;\n                current = node.left;\n            } else {\n                predecessor?.right = nil;\n                count[node.val, default: 0] += 1; maxCount = max(maxCount, count[node.val]!);\n                current = node.right;\n            }\n        }\n    }\n    for (key, value) in count where value == maxCount { result.append(key) }\n    return result;\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the hash map, resulting in a space complexity of O(1).",
            "time": "O(n)",
            "timeExplanation": "We visit each node once, resulting in a time complexity of O(n), where n is the number of nodes in the tree."
          },
          "explanation": "The optimized approach takes advantage of Morris traversal, which has a lower space complexity than traditional recursive or iterative in-order traversal methods. This is particularly beneficial for very large trees where space efficiency is crucial.",
          "id": "6aeb2fef-e7be-4759-a166-53bdb8e1c7c9",
          "intuition": "Utilizing Morris traversal, which is an in-order traversal method that doesn't require recursion or a stack, can optimize the solution.",
          "name": "Optimized: Morris Traversal and Hash Map",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2]",
              "explanation": "The value 2 appears most frequently in the binary search tree.",
              "id": "e574746e-2257-4026-aa45-664f83b7d57e",
              "input": "root = [1,null,2,2]"
            },
            {
              "expectedOutput": "[0]",
              "explanation": "The value 0 is the only value in the binary search tree, making it the mode.",
              "id": "23825c37-c4ed-48f3-8057-4821125bcb5e",
              "input": "root = [0]"
            }
          ]
        }
      ],
      "id": "ab897fea-d403-4a17-a8d1-76bc34f734d9",
      "lastUpdated": "2026-02-06T21:22:41Z",
      "problemSlug": "find-mode-in-binary-search-tree",
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-search-tree",
        "binary-tree-inorder-traversal"
      ],
      "summary": "The problem asks to find the mode in a binary search tree, which is the value that appears most frequently. To approach this, we can utilize the properties of a binary search tree, where left child nodes have values less than their parent and right child nodes have values greater than their parent."
    },
    {
      "approaches": [
        {
          "approach": "First, perform a DFS on the binary tree and at each step, check if the current node matches the preorder traversal. If not, flip the tree. Keep track of the number of flips.",
          "code": "class Solution {\n    func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n        guard let root1 = root1, let root2 = root2 else {\n            return root1 == nil && root2 == nil\n        }\n        if root1.val != root2.val {\n            return false\n        }\n        return flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right) || flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the flip count.",
            "time": "O(n)",
            "timeExplanation": "We visit each node once in the worst case."
          },
          "explanation": "Start at the root node, and at each step, check if the current node matches the preorder traversal. If not, flip the tree and increment the flip count. Continue this process until the end of the preorder traversal.",
          "id": "7990a791-50fb-41aa-897b-80038dd5acc9",
          "intuition": "This approach works by performing a brute-force DFS and comparing the nodes at each step, flipping the tree if necessary.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The two trees are flip equivalent because we can flip the left and right children of the root to get the second tree.",
              "id": "756d1e93-0ac1-404c-bbff-6f5f85f85c62",
              "input": "root1 = [1,2,3,4,5,6,7], root2 = [1,3,2,6,4,5,7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The two trees are not flip equivalent because the last node in the preorder traversal of the second tree is different.",
              "id": "634fa75e-244a-45a9-a880-54c2b04e05a4",
              "input": "root1 = [1,2,3,4,5,6,7], root2 = [1,3,2,6,4,5,8]"
            }
          ]
        },
        {
          "approach": "First, store the preorder traversal in an array. Then, perform a DFS on the binary tree, and at each step, compare the current node with the corresponding node in the preorder traversal array. If they do not match, flip the tree and update the preorder traversal array.",
          "code": "class Solution {\n    func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n        guard let root1 = root1, let root2 = root2 else {\n            return root1 == nil && root2 == nil\n        }\n        if root1.val != root2.val {\n            return false\n        }\n        let left1 = flipEquiv(root1.left, root2.left)\n        let right1 = flipEquiv(root1.right, root2.right)\n        let left2 = flipEquiv(root1.left, root2.right)\n        let right2 = flipEquiv(root1.right, root2.left)\n        return left1 && right1 || left2 && right2\n    }\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is the height of the call stack, which is at most the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "We visit each node once in the worst case."
          },
          "explanation": "First, store the preorder traversal of the binary tree in an array. Then, start at the root node, and at each step, check if the current node matches the corresponding node in the preorder traversal array. If not, flip the tree, update the preorder traversal array, and increment the flip count. Continue this process until the end of the preorder traversal.",
          "id": "f941f416-4f22-43a0-8f0c-bf168f342f99",
          "intuition": "This approach works by using a more efficient data structure to keep track of the preorder traversal and the flips.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The two trees are flip equivalent because we can flip the left and right children of the root to get the second tree.",
              "id": "03323fdb-f024-407e-a00b-b58c46c1e233",
              "input": "root1 = [1,2,3,4,5,6,7], root2 = [1,3,2,6,4,5,7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The two trees are not flip equivalent because the last node in the preorder traversal of the second tree is different.",
              "id": "ca662506-d0bd-412d-b2f2-325ab2e5f3d8",
              "input": "root1 = [1,2,3,4,5,6,7], root2 = [1,2,3,4,5,6,8]"
            }
          ]
        }
      ],
      "id": "5a0bc347-0bad-4915-b052-08719530eba6",
      "lastUpdated": "2026-02-06T21:52:28Z",
      "problemSlug": "flip-binary-tree-to-match-preorder-traversal",
      "relatedProblems": [
        "flip-binary-tree-to-match-preorder-traversal",
        "same-tree"
      ],
      "summary": "The problem requires returning the number of flips needed to match the preorder traversal of a binary tree. The key insight is to perform a depth-first search (DFS) and compare the nodes at each step."
    },
    {
      "approaches": [
        {
          "approach": "Start by checking if both trees are empty, then handle the case where one is empty and the other is not. Define a recursive function that checks if two trees are flip equivalent by comparing the values of the nodes and recursively checking the left and right children.",
          "code": "class Solution {\n    func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n        guard let root1 = root1, let root2 = root2 else {\n            return root1 == nil && root2 == nil\n        }\n        if root1.val != root2.val {\n            return false\n        }\n        return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left))\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also linear due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because each node is visited once."
          },
          "explanation": "This approach involves multiple recursive calls and handles all possible cases of flip equivalence. However, it may not be efficient for large trees due to the overhead of recursive calls.",
          "id": "7d02cf18-1f43-431a-a91f-94d62c2521d7",
          "intuition": "This approach works by defining a function to check if two trees are flip equivalent. It handles base cases and then checks if the trees are equivalent without flipping and with flipping.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The given trees are flip equivalent.",
              "id": "7925340a-a9ae-45cf-8b06-91505bf69462",
              "input": "root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,null,6,4,null,null,8,7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The given trees are not flip equivalent.",
              "id": "19a37d46-e645-49f5-9a6a-a0d4bd7128ca",
              "input": "root1 = [1,2,3], root2 = [1,3,2]"
            }
          ]
        },
        {
          "approach": "Perform a depth-first search and directly compare the structure of the two trees, considering the possibility of flipping. Use a single recursive function to compare the trees and handle all cases.",
          "code": "class Solution { func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool { return dfs(root1, root2) } func dfs(_ node1: TreeNode?, _ node2: TreeNode?) -> Bool { guard let node1 = node1, let node2 = node2 else { return node1 == nil && node2 == nil } if node1.val != node2.val { return false } let normal = dfs(node1.left, node2.left) && dfs(node1.right, node2.right) let flipped = dfs(node1.left, node2.right) && dfs(node1.right, node2.left) return normal || flipped } }",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is reduced to the height of the tree due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity remains linear because each node is still visited once."
          },
          "explanation": "This approach reduces the number of recursive calls compared to the brute force approach, making it more efficient for large trees.",
          "id": "d284d47d-dc05-4743-9f84-5ecadf9914a4",
          "intuition": "This approach also uses depth-first search but avoids unnecessary recursive calls by directly comparing the structure of the trees.",
          "name": "Optimized Depth-First Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The given trees are flip equivalent.",
              "id": "5495a23c-b949-499c-8de9-ebef7709b6e6",
              "input": "root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,null,6,4,null,null,8,7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The given trees are not flip equivalent.",
              "id": "4bc963e2-e0ae-41a5-8ab7-3cc802845bf3",
              "input": "root1 = [1,2,3], root2 = [1,3,2]"
            }
          ]
        }
      ],
      "id": "c126513d-0a8a-4b93-82b4-b85177d65f67",
      "lastUpdated": "2026-02-06T21:50:54Z",
      "problemSlug": "flip-equivalent-binary-trees",
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "binary-tree-tilt"
      ],
      "summary": "Flip Equivalent Binary Trees is a problem where we are given the roots of two binary trees root1 and root2 and return true if they are flip equivalent or otherwise false. A key insight is to perform a depth-first search and compare the structure of the trees while considering the possibility of flipping."
    },
    {
      "approaches": [
        {
          "approach": "1. Start at the root node. 2. Compare the new value with the current node's value. 3. If the new value is less than the current node's value, move to the left child. 4. If the new value is greater than the current node's value, move to the right child. 5. Repeat steps 2-4 until an empty spot is found, at which point the new node is inserted.",
          "code": "class Solution {\n    func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\n        guard let root = root else {\n            return TreeNode(val)\n        }\n        if val < root.val {\n            root.left = insertIntoBST(root.left, val)\n        }\n        else {\n            root.right = insertIntoBST(root.right, val)\n        }\n        return root\n    }\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) due to the recursive call stack, which in the worst case, could go as deep as the height of the tree.",
            "time": "O(h)",
            "timeExplanation": "The time complexity is O(h), where h is the height of the tree, because in the worst case, the algorithm has to traverse from the root to a leaf node."
          },
          "explanation": "The recursive approach starts at the root of the tree and compares the new value to the current node's value. Based on this comparison, it decides whether to move to the left or right subtree. This process continues until it finds an empty spot where the new node can be inserted.",
          "id": "a2eea5cb-fe9b-4861-b871-58b478023585",
          "intuition": "This approach works by recursively traversing the tree to find the correct position for the new node, ensuring that the properties of a Binary Search Tree are maintained.",
          "name": "Recursive Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[4,2,7,1,3,5]",
              "explanation": "The new node with value 5 is inserted to the right of the node with value 3.",
              "id": "1789b0b0-d339-451e-996d-be066e98bbc7",
              "input": "root = [4,2,7,1,3], val = 5"
            },
            {
              "expectedOutput": "[40,20,60,10,30,50,70,25]",
              "explanation": "The new node with value 25 is inserted between the nodes with values 20 and 30.",
              "id": "75401cd8-c43b-458a-b9ba-1602a19ddb08",
              "input": "root = [40,20,60,10,30,50,70], val = 25"
            }
          ]
        },
        {
          "approach": "1. Start at the root node. 2. Compare the new value with the current node's value. 3. If the new value is less than the current node's value, move to the left child. 4. If the new value is greater than the current node's value, move to the right child. 5. Repeat steps 2-4 until an empty spot is found, at which point the new node is inserted.",
          "code": "class Solution { func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { guard let root = root else { return TreeNode(val) }; var node = root; while true { if val < node.val { if node.left == nil { node.left = TreeNode(val); break } else { node = node.left } } else { if node.right == nil { node.right = TreeNode(val); break } else { node = node.right } } }; return root } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because it uses a constant amount of space to store the current node and the new value, without any recursive call stack.",
            "time": "O(h)",
            "timeExplanation": "The time complexity remains O(h) as it still involves traversing from the root to a potential leaf node to insert the new value."
          },
          "explanation": "The iterative approach uses a while loop to traverse the tree, maintaining a pointer to the current node. It continues to move left or right based on the comparison between the new value and the current node's value until it finds an empty spot to insert the new node.",
          "id": "80d2b1f2-85fd-4770-b614-e0cbe39cf9f1",
          "intuition": "This approach uses a loop to iterate through the tree, avoiding the overhead of recursive call stacks, and it still maintains the properties of a Binary Search Tree.",
          "name": "Iterative Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[4,2,7,1,3,5]",
              "explanation": "The new node with value 5 is inserted to the right of the node with value 3.",
              "id": "2a1531ee-c6a6-426a-b886-718407d7d4ce",
              "input": "root = [4,2,7,1,3], val = 5"
            },
            {
              "expectedOutput": "[40,20,60,10,30,50,70,25]",
              "explanation": "The new node with value 25 is inserted between the nodes with values 20 and 30.",
              "id": "31e324ee-2c54-4903-ad7a-9f7a2a20b3e2",
              "input": "root = [40,20,60,10,30,50,70], val = 25"
            }
          ]
        }
      ],
      "id": "58f80c97-400a-42c4-8811-6c4537cc0e63",
      "lastUpdated": "2026-02-06T21:34:43Z",
      "problemSlug": "insert-into-a-binary-search-tree",
      "relatedProblems": [
        "binary-search-tree-to-greater-sum-tree",
        "maximum-binary-tree"
      ],
      "summary": "This problem involves inserting a value into a Binary Search Tree while maintaining its properties, the key insight being to recursively determine the correct position for the new node."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return nil.\n2. Swap root.left and root.right.\n3. Recursively invert the left subtree.\n4. Recursively invert the right subtree.\n5. Return root.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    let temp = root.left\n    root.left = root.right\n    root.right = temp\n    _ = invertTree(root.left)\n    _ = invertTree(root.right)\n    return root\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height h",
            "time": "O(n)",
            "timeExplanation": "Every node is visited exactly once"
          },
          "explanation": "Each node is visited once. Swapping children at each node creates the mirror image. The recursion unwinds after reaching leaves.",
          "id": "0d68f729-008b-4c44-a14b-5db7877db5b5",
          "intuition": "If you swap a node's left and right children, and then do the same for its children, the entire tree becomes its mirror image.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap.",
              "id": "0f14dc66-108b-4b35-b924-5eff2f49797c",
              "input": "root = [4,2,7,1,3,6,9]"
            },
            {
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root.",
              "id": "67919ef7-73d2-44f6-bf81-ae8463aacbbb",
              "input": "root = [2,1,3]"
            }
          ]
        },
        {
          "approach": "1. If root is nil, return nil.\n2. Push root to a queue.\n3. While queue not empty: pop a node, swap its children, push non-nil children.\n4. Return root.",
          "code": "func invertTree(_ root: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    var queue: [TreeNode] = [root]\n    var index = 0\n    while index < queue.count {\n        let node = queue[index]\n        index += 1\n        let temp = node.left\n        node.left = node.right\n        node.right = temp\n        if let left = node.left { queue.append(left) }\n        if let right = node.right { queue.append(right) }\n    }\n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue can hold up to a full level of nodes",
            "time": "O(n)",
            "timeExplanation": "Each node is processed once"
          },
          "explanation": "The queue visits nodes level by level. Swapping children during the visit yields the same mirror as the recursive solution.",
          "id": "f3ccd674-5539-4a80-a251-444b32df5cb2",
          "intuition": "A level-order traversal lets us swap children for every node without recursion.",
          "name": "Iterative BFS",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[4,7,2,9,6,3,1]",
              "explanation": "Each level is mirrored: (2,7) swap, then (1,3) and (6,9) swap.",
              "id": "767e9de1-fc09-4605-a387-6d912b18d09e",
              "input": "root = [4,2,7,1,3,6,9]"
            },
            {
              "expectedOutput": "[2,3,1]",
              "explanation": "Swap the two children of the root.",
              "id": "3c6e8be9-43d9-414c-a712-a69d865ef0c9",
              "input": "root = [2,1,3]"
            }
          ]
        }
      ],
      "id": "113bd68d-ec6b-40ce-b8d5-e276ed1a6f55",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "invert-binary-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "same-tree"
      ],
      "summary": "Invert a binary tree by swapping every node's left and right child. The simplest way is a DFS that swaps then recurses."
    },
    {
      "approaches": [
        {
          "approach": "1. Use a stack to simulate inorder traversal.\n2. Pop nodes and count visits.\n3. When count reaches k, return the node value.",
          "code": "func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n    var stack: [TreeNode] = []\n    var node = root\n    var remaining = k\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        remaining -= 1\n        if remaining == 0 { return current.val }\n        node = current.right\n    }\n    return 0\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most h nodes",
            "time": "O(h + k)",
            "timeExplanation": "Walk down height h, then visit k nodes"
          },
          "explanation": "The stack walks left as far as possible, then processes nodes in ascending order.",
          "id": "a4188ae4-1591-4141-a97d-54be7ab95628",
          "intuition": "Inorder traversal returns values in increasing order, so the kth visited node is the answer.",
          "name": "Iterative Inorder",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Inorder sequence is [1,2,3,4], kth=1.",
              "id": "e1c24e01-a57c-4661-a5bc-5c2f02f2a718",
              "input": "root = [3,1,4,null,2], k = 1"
            },
            {
              "expectedOutput": "3",
              "explanation": "Inorder sequence is [1,2,3,4,5,6], kth=3.",
              "id": "5796f1a9-8de9-4dfc-8d34-dea87d368c27",
              "input": "root = [5,3,6,2,4,null,null,1], k = 3"
            }
          ]
        }
      ],
      "id": "8caca365-f1ea-4ee1-9d57-18b73d6ffa78",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "kth-smallest-element-in-a-bst",
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-search-tree-iterator"
      ],
      "summary": "The inorder traversal of a BST is sorted. Walk inorder and stop at the kth value."
    },
    {
      "approaches": [
        {
          "approach": "First, define a helper function for the depth-first search. Initialize an empty array to store the leaf node values for each tree. Perform the depth-first search on both trees, appending the leaf node values to their respective arrays. Finally, compare the two arrays of leaf node values.",
          "code": "\nclass TreeNode { \n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nfunc leafSimilar(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n    var leaves1: [Int] = []\n    var leaves2: [Int] = []\n\n    dfs(root1, &leaves1)\n    dfs(root2, &leaves2)\n\n    return leaves1 == leaves2\n}\n\nfunc dfs(_ node: TreeNode?, _ leaves: inout [Int]) {\n    if node == nil { return }\n    if node?.left == nil && node?.right == nil {\n        leaves.append(node!.val)\n    }\n    dfs(node?.left, &leaves)\n    dfs(node?.right, &leaves)\n}\n",
          "complexity": {
            "space": "O(n + m)",
            "spaceExplanation": "The space complexity is O(n + m) due to the space required for storing the leaf node sequences.",
            "time": "O(n + m)",
            "timeExplanation": "Here, n and m are the number of nodes in the first and second trees, respectively. Time complexity is O(n + m) because in the worst-case scenario, we visit every node in both trees once."
          },
          "explanation": "This approach ensures that we correctly identify the leaf node values in both trees and compare them. The brute force nature comes from the straightforward, albeit potentially inefficient, comparison of the entire leaf node value sequences.",
          "id": "1b54e5f0-87a3-4a02-ae03-1f90d4abfd59",
          "intuition": "By performing a depth-first search on both trees and storing the sequences of leaf node values, we can compare these sequences to determine if the trees are leaf-similar.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Both trees have the same leaf node sequence: [6, 7, 9, 4, 2, 1].",
              "id": "69d5c7ca-b0f4-4377-9bec-c090afa4e714",
              "input": "tree1: [3,5,1,6,2,9,8,7,4], tree2: [3,5,1,6,2,9,8,7,4]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The leaf node sequences differ: tree1 has [2,3], while tree2 has [3,2].",
              "id": "9f23a2c4-adae-40a5-b7d9-7b8a593c1364",
              "input": "tree1: [1,2,3], tree2: [1,3,2]"
            }
          ]
        },
        {
          "approach": "Implement an iterative depth-first search to explore both trees simultaneously. Use two stacks to hold nodes to visit for each tree. Compare leaf node values as they are encountered, and return false at the first mismatch. If the function completes without finding any mismatches and both stacks are empty, return true.",
          "code": "\nclass TreeNode { \n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nfunc leafSimilar(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n    var stack1: [TreeNode] = [root1!]\n    var stack2: [TreeNode] = [root2!]\n\n    while !stack1.isEmpty && !stack2.isEmpty {\n        let node1 = stack1.removeLast()\n        let node2 = stack2.removeLast()\n\n        if node1.val != node2.val { return false }\n\n        if node1.left == nil && node1.right == nil && node2.left == nil && node2.right == nil {\n            if node1.val != node2.val { return false }\n            continue\n        } else if (node1.left == nil && node1.right != nil) || (node1.left != nil && node1.right == nil) {\n            return false\n        } else if (node2.left == nil && node2.right != nil) || (node2.left != nil && node2.right == nil) {\n            return false\n        }\n\n        if node1.left != nil { stack1.append(node1.left!) }\n        if node1.right != nil { stack1.append(node1.right!) }\n        if node2.left != nil { stack2.append(node2.left!) }\n        if node2.right != nil { stack2.append(node2.right!) }\n    }\n\n    return stack1.isEmpty && stack2.isEmpty\n}\n",
          "complexity": {
            "space": "O(n + m)",
            "spaceExplanation": "Space complexity remains O(n + m) due to the use of stacks for iterative depth-first search.",
            "time": "O(n + m)",
            "timeExplanation": "Similar to the brute force approach, the time complexity remains O(n + m) because we are potentially visiting every node in both trees."
          },
          "explanation": "This optimized approach reduces memory usage by avoiding the need to store all leaf node values and instead uses a more iterative approach with stacks.",
          "id": "ee8ed28f-42b4-4aff-bacc-be8d22e6fb59",
          "intuition": "Instead of storing all leaf node values and then comparing them, we can immediately return false as soon as we find a difference in leaf values during the depth-first search.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Both trees have the same leaf node sequence, and this optimized approach will determine their similarity without storing all leaf node values.",
              "id": "04b49121-10c4-482f-8197-f8f19fb26ef7",
              "input": "tree1: [3,5,1,6,2,9,8,7,4], tree2: [3,5,1,6,2,9,8,7,4]"
            },
            {
              "expectedOutput": "true",
              "explanation": "Single-node trees are considered leaf-similar if their values match.",
              "id": "0b5d3a47-97be-4818-9a40-add6459b3838",
              "input": "tree1: [1], tree2: [1]"
            }
          ]
        }
      ],
      "id": "5f2147ea-ba2b-4e1b-b907-428d5a7005a9",
      "lastUpdated": "2026-02-06T21:45:43Z",
      "problemSlug": "leaf-similar-trees",
      "relatedProblems": [
        "invert-binary-tree",
        "search-in-a-binary-search-tree"
      ],
      "summary": "This problem involves determining if two binary trees are leaf-similar, meaning they have the same leaf value sequence, by employing depth-first search and comparing the sequences. The key insight is to leverage the tree structure for a straightforward comparison of leaf values."
    },
    {
      "approaches": [
        {
          "approach": "First, convert each quad-tree to a binary grid. Then, iterate over the cells in the grids and perform a logical OR operation on corresponding cells.",
          "code": "\nclass Solution {\n  func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n    if quadTree1.val == 1 { return quadTree1 }\n    if quadTree2.val == 1 { return quadTree2 }\n    if let topLeft1 = quadTree1.topLeft, let topRight1 = quadTree1.topRight, let bottomLeft1 = quadTree1.bottomLeft, let bottomRight1 = quadTree1.bottomRight,\n       let topLeft2 = quadTree2.topLeft, let topRight2 = quadTree2.topRight, let bottomLeft2 = quadTree2.bottomLeft, let bottomRight2 = quadTree2.bottomRight {\n      let topLeft = intersect(topLeft1, topLeft2)\n      let topRight = intersect(topRight1, topRight2)\n      let bottomLeft = intersect(bottomLeft1, bottomLeft2)\n      let bottomRight = intersect(bottomRight1, bottomRight2)\n      if topLeft === topRight && topRight === bottomLeft && bottomLeft === bottomRight {\n        return topLeft\n      } else {\n        return Node(0, true, topLeft, topRight, bottomLeft, bottomRight)\n      }\n    } else {\n      return nil\n    }\n  }\n}\n",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is O(n^2) because we are storing the resulting grid.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because we are iterating over the cells in the grids."
          },
          "explanation": "This approach works by taking advantage of the fact that the logical OR operation can be performed on a cell-by-cell basis. However, it is inefficient because it requires converting the quad-trees to grids, which can be time-consuming.",
          "id": "44831ce2-468f-402c-808b-22bf873fc8cf",
          "intuition": "This approach involves converting the quad-trees to their corresponding binary grids and then performing a cell-by-cell logical OR operation.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1]",
              "explanation": "The resulting quad-tree represents the logical OR of the input quad-trees.",
              "id": "00f954d1-7e11-4187-941f-619b474be33c",
              "input": "quadTree1 = [0,1,1,1,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,1,0,1], quadTree2 = [0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1]"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The resulting quad-tree is a single node with value 1, representing the logical OR of the input quad-trees.",
              "id": "6417a556-307e-4410-a6bb-f24beee73e74",
              "input": "quadTree1 = [1,1,1,1,1,1,1,1], quadTree2 = [1,1,1,1,1,1,1,1]"
            }
          ]
        },
        {
          "approach": "Recursively traverse the quad-trees and combine the nodes based on their values. If both nodes are leaves with value 1, return a leaf node with value 1. If one node is a leaf with value 1 and the other is an internal node, return the leaf node. If both nodes are internal nodes, recursively combine their children.",
          "code": "\nclass Solution {\n  func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\n    guard let quadTree1 = quadTree1, let quadTree2 = quadTree2 else { return nil }\n    if quadTree1.val == 1 { return quadTree1 }\n    if quadTree2.val == 1 { return quadTree2 }\n    if let topLeft1 = quadTree1.topLeft, let topRight1 = quadTree1.topRight, let bottomLeft1 = quadTree1.bottomLeft, let bottomRight1 = quadTree1.bottomRight,\n       let topLeft2 = quadTree2.topLeft, let topRight2 = quadTree2.topRight, let bottomLeft2 = quadTree2.bottomLeft, let bottomRight2 = quadTree2.bottomRight {\n      let topLeft = intersect(topLeft1, topLeft2)\n      let topRight = intersect(topRight1, topRight2)\n      let bottomLeft = intersect(bottomLeft1, bottomLeft2)\n      let bottomRight = intersect(bottomRight1, bottomRight2)\n      if topLeft === topRight && topRight === bottomLeft && bottomLeft === bottomRight {\n        return topLeft\n      } else {\n        return Node(0, true, topLeft, topRight, bottomLeft, bottomRight)\n      }\n    } else {\n      return nil\n    }\n  }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we are storing the resulting quad-tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we are recursively traversing the quad-trees."
          },
          "explanation": "This approach works by taking advantage of the fact that the logical OR operation can be performed recursively on the quad-trees. This allows us to avoid converting the trees to grids, which can be time-consuming.",
          "id": "4ccdde27-1175-4717-a5d5-35137421e2ac",
          "intuition": "This approach involves recursively combining the quad-trees based on their node values, which allows us to avoid converting the trees to grids.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1]",
              "explanation": "The resulting quad-tree represents the logical OR of the input quad-trees.",
              "id": "cb325575-8293-4fc7-8fdf-429df0855eab",
              "input": "quadTree1 = [0,1,1,1,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,1,0,1], quadTree2 = [0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1]"
            },
            {
              "expectedOutput": "[1]",
              "explanation": "The resulting quad-tree is a single node with value 1, representing the logical OR of the input quad-trees.",
              "id": "dd251dcf-7a31-4379-b847-a6394a76a228",
              "input": "quadTree1 = [1,1,1,1,1,1,1,1], quadTree2 = [1,1,1,1,1,1,1,1]"
            }
          ]
        }
      ],
      "id": "4950ad6c-aa01-4bb3-93d9-344147cd6f5b",
      "lastUpdated": "2026-02-06T21:26:08Z",
      "problemSlug": "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "relatedProblems": [
        "construct-quad-tree",
        "quad-tree-intersection"
      ],
      "summary": "This problem involves performing the logical OR operation on two binary grids represented as quad-trees, where the key insight is to recursively combine the trees based on their node values."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root and perform a depth-first search, keeping track of the maximum length of univalue paths found so far. For each node, check all possible paths and update the maximum length if a longer univalue path is found.",
          "code": "\nfunc longestUnivaluePath(_ root: TreeNode?) -> Int {\n    var maxLength = 0\n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else { return 0 }\n        let leftLength = dfs(node.left)\n        let rightLength = dfs(node.right)\n        if node.left?.val == node.val, node.right?.val == node.val {\n            maxLength = max(maxLength, leftLength + rightLength + 2)\n        } else if node.left?.val == node.val {\n            maxLength = max(maxLength, leftLength + 1)\n        } else if node.right?.val == node.val {\n            maxLength = max(maxLength, rightLength + 1)\n        }\n        return max(leftLength, rightLength) + 1\n    }\n    dfs(root)\n    return maxLength\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once."
          },
          "explanation": "This approach involves checking all possible paths in the tree. It first checks the path starting at the root node and then recursively checks the paths starting at each child node.",
          "id": "a13beefd-6dd4-479b-95e4-ff1d7fbddece",
          "intuition": "The brute force approach works by traversing the tree and checking each path to see if it is a univalue path.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The longest univalue path is 5 -> 5 -> 5.",
              "id": "bc181305-03e1-4a34-a19d-86d5a4be6089",
              "input": "root = [5,4,5,1,1,5]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The longest univalue path is 4 -> 4 -> 4 or 5 -> 5 -> 5.",
              "id": "8e0869c6-78a1-4d40-ae80-a0ffaa25bf38",
              "input": "root = [1,4,5,4,4,5]"
            }
          ]
        },
        {
          "approach": "Perform a depth-first search and keep track of the maximum length of univalue paths that pass through each node. For each node, calculate the maximum length of univalue paths that start at the node and extend to its children.",
          "code": "\nfunc longestUnivaluePath(_ root: TreeNode?) -> Int {\n    var maxLength = 0\n    func dfs(_ node: TreeNode?) -> (Int, Int) {\n        guard let node = node else { return (0, 0) }\n        let (leftLength, leftPath) = dfs(node.left)\n        let (rightLength, rightPath) = dfs(node.right)\n        var left = 0\n        var right = 0\n        if node.left?.val == node.val {\n            left = leftPath + 1\n        }\n        if node.right?.val == node.val {\n            right = rightPath + 1\n        }\n        maxLength = max(maxLength, left + right)\n        return (max(left, right), max(left, right))\n    }\n    dfs(root)\n    return maxLength\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once."
          },
          "explanation": "This approach reduces the time complexity by only considering paths that start at each node and extend to its children, rather than all possible paths.",
          "id": "780f1ba1-9082-47eb-ad1b-a9181015d7a6",
          "intuition": "The optimized approach involves using a depth-first search to find the longest univalue path that passes through each node.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The longest univalue path is 5 -> 5 -> 5.",
              "id": "bc24664b-4bd3-40b0-a863-50dbb3fbea07",
              "input": "root = [5,4,5,1,1,5]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The longest univalue path is 4 -> 4 -> 4 or 5 -> 5 -> 5.",
              "id": "461ab5cb-94be-4496-baac-2e9256a46beb",
              "input": "root = [1,4,5,4,4,5]"
            }
          ]
        }
      ],
      "id": "cdc3a04a-cdfb-4c67-b803-c8d6f6275208",
      "lastUpdated": "2026-02-06T21:33:58Z",
      "problemSlug": "longest-univalue-path",
      "relatedProblems": [
        "binary-tree-maximum-path-sum",
        "path-sum-iii"
      ],
      "summary": "The problem Longest Univalue Path involves finding the longest path in a binary tree where all nodes have the same value. This can be solved by using a depth-first search to traverse the tree and keep track of the maximum length of univalue paths."
    },
    {
      "approaches": [
        {
          "approach": "1. Start at root.\n2. If both p and q are smaller, move left.\n3. If both larger, move right.\n4. Otherwise, current node is the LCA.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    var node = root\n    guard let p = p, let q = q else { return nil }\n    while let current = node {\n        if p.val < current.val && q.val < current.val {\n            node = current.left\n        } else if p.val > current.val && q.val > current.val {\n            node = current.right\n        } else {\n            return current\n        }\n    }\n    return nil\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Iterative, constant extra space",
            "time": "O(h)",
            "timeExplanation": "Walks down one path of height h"
          },
          "explanation": "The LCA is the node where the paths to p and q diverge (or where one equals the current node).",
          "id": "153d1e3d-75a6-4b8e-86bc-81ea9dbc1dba",
          "intuition": "In a BST, all left values are smaller and all right values are larger. The first split point is the LCA.",
          "name": "Iterative BST Walk",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "p and q split at 6, so 6 is the LCA.",
              "id": "38f1a9a5-13a3-4905-a7d9-bd93b2027500",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8"
            },
            {
              "expectedOutput": "2",
              "explanation": "p is an ancestor of q, so LCA is 2.",
              "id": "812c7249-8f40-4310-978c-f8f10b0a8f6f",
              "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4"
            }
          ]
        },
        {
          "approach": "1. If both values are less than root, recurse left.\n2. If both greater, recurse right.\n3. Otherwise, root is the LCA.",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root, let p = p, let q = q else { return nil }\n    if p.val < root.val && q.val < root.val {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if p.val > root.val && q.val > root.val {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(h)",
            "timeExplanation": "Traverses one root-to-leaf path"
          },
          "explanation": "Same logic as the iterative approach, but expressed recursively.",
          "id": "25e41dd6-c040-42ec-83e3-965baa348c08",
          "intuition": "The BST property lets us eliminate half the tree at each step using recursion.",
          "name": "Recursive BST",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Root is the ancestor of both nodes.",
              "id": "56d579d8-24d9-4502-8d47-d9c3bf6a0301",
              "input": "root = [2,1], p = 2, q = 1"
            }
          ]
        }
      ],
      "id": "32841a93-64e4-40c2-8f8a-bee6d4c5f666",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "lowest-common-ancestor-of-a-binary-search-tree",
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-tree",
        "validate-binary-search-tree"
      ],
      "summary": "Use the BST ordering: if both targets are less than the current node, go left; if greater, go right; otherwise current is the LCA."
    },
    {
      "approaches": [
        {
          "approach": "1. If node is p or q, return node\n2. Recurse left and right\n3. If both return non-null, current is LCA\n4. Else return the non-null one",
          "code": "func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n    guard let root = root else { return nil }\n    if root === p || root === q { return root }\n    let left = lowestCommonAncestor(root.left, p, q)\n    let right = lowestCommonAncestor(root.right, p, q)\n    if left != nil && right != nil { return root }\n    return left ?? right\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "LCA is either p/q itself, or the node where p and q are in different subtrees.",
          "id": "8be35011-2608-4d66-ad48-7e35e4f53217",
          "intuition": "If node is p or q, return it. If left and right both return non-null, node is LCA.",
          "name": "Recursive",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "3 is LCA of 5 and 1",
              "id": "ab5e453a-ae54-4a7d-8df0-0862484c7915",
              "input": "root=[3,5,1,6,2,0,8], p=5, q=1"
            }
          ]
        }
      ],
      "id": "dffca197-fc67-4873-a726-00589deac150",
      "lastUpdated": "2026-02-06T01:03:48.939Z",
      "problemSlug": "lowest-common-ancestor-of-a-binary-tree",
      "relatedProblems": [
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "summary": "Find LCA of two nodes. Recursively check if current subtree contains p, q, or both."
    },
    {
      "approaches": [
        {
          "approach": "1. Start by checking if the input array is empty. If so, return nil. 2. Find the maximum element in the array and its index. 3. Create a new tree node with the maximum element as its value. 4. Recursively construct the left subtree by calling the function on the subarray before the maximum element. 5. Recursively construct the right subtree by calling the function on the subarray after the maximum element.",
          "code": "class TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nfunc constructMaximumBinaryTree(_ nums: [Int]) -> TreeNode? {\n    guard !nums.isEmpty else { return nil }\n    let maxIndex = nums.firstIndex(of: nums.max()!)!\n    let root = TreeNode(nums[maxIndex])\n    let leftNums = Array(nums.prefix(maxIndex))\n    let rightNums = Array(nums.suffix(nums.count - maxIndex - 1))\n    root.left = constructMaximumBinaryTree(leftNums)\n    root.right = constructMaximumBinaryTree(rightNums)\n    return root\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the recursive call stack can go up to a depth of n.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because in the worst case, we have to find the maximum element in the array at each recursive call, which takes O(n) time. The recursive calls are also made n times."
          },
          "explanation": "The brute-force approach has a high time complexity because it involves finding the maximum element in the array at each recursive call, which results in repeated computation. This makes it inefficient for large inputs.",
          "id": "9e691cc0-3292-49fc-8cce-00b1f0d47108",
          "intuition": "This approach involves recursively finding the maximum element in the array and constructing the maximum binary tree II. It does not use any optimization techniques and has a high time complexity due to the repeated computation of finding the maximum element.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "Maximum Binary Tree: 6\n    /   \\\n   3     5\n  / \\   \n 2   0\n/ \n1  nil",
              "explanation": "The maximum element in the array is 6, so it becomes the root. The elements before 6 are [3,2,1] and the elements after 6 are [0,5]. We recursively construct the left subtree from [3,2,1] and the right subtree from [0,5].",
              "id": "ffa31302-ff1c-41e6-846e-74628f79db81",
              "input": "nums = [3,2,1,6,0,5]"
            },
            {
              "expectedOutput": "Maximum Binary Tree: 3\n    /   \\\n   2     nil\n  / \n 1  nil",
              "explanation": "The maximum element in the array is 3, so it becomes the root. The elements before 3 are [2,1]. We recursively construct the left subtree from [2,1].",
              "id": "f788a684-a9b2-489e-ae5b-106e9e8b9e8c",
              "input": "nums = [3,2,1]"
            }
          ]
        },
        {
          "approach": "1. Start by checking if the input array is empty. If so, return nil. 2. Create a helper function to find the maximum element in a subarray and its index. 3. Create a new tree node with the maximum element as its value. 4. Recursively construct the left subtree by calling the function on the subarray before the maximum element. 5. Recursively construct the right subtree by calling the function on the subarray after the maximum element.",
          "code": "class TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nfunc constructMaximumBinaryTree(_ nums: [Int]) -> TreeNode? {\n    func helper(_ nums: [Int], _ start: Int, _ end: Int) -> TreeNode? {\n        if start > end {\n            return nil\n        }\n        let maxIndex = (start...end).max { nums[$0] < nums[$1] }!\n        let root = TreeNode(nums[maxIndex])\n        root.left = helper(nums, start, maxIndex - 1)\n        root.right = helper(nums, maxIndex + 1, end)\n        return root\n    }\n    return helper(nums, 0, nums.count - 1)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the recursive call stack can go up to a depth of n.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each element in the array once and perform a constant amount of work for each element."
          },
          "explanation": "The optimized approach has a lower time complexity than the brute-force approach because it uses a helper function to find the maximum element in the subarray in O(1) time. This reduces the repeated computation involved in finding the maximum element.",
          "id": "240ebe58-6922-4452-80d2-d868e989386e",
          "intuition": "This approach involves using a helper function to find the maximum element in a subarray and recursively constructing the maximum binary tree II. It uses a technique to find the maximum element in the subarray in O(1) time by maintaining a maximum index variable.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Maximum Binary Tree: 6\n    /   \\\n   3     5\n  / \\   \n 2   0\n/ \n1  nil",
              "explanation": "The maximum element in the array is 6, so it becomes the root. The elements before 6 are [3,2,1] and the elements after 6 are [0,5]. We recursively construct the left subtree from [3,2,1] and the right subtree from [0,5].",
              "id": "1ab345c3-f7d0-4252-92c7-57a3a8cf5f4c",
              "input": "nums = [3,2,1,6,0,5]"
            },
            {
              "expectedOutput": "Maximum Binary Tree: 3\n    /   \\\n   2     nil\n  / \n 1  nil",
              "explanation": "The maximum element in the array is 3, so it becomes the root. The elements before 3 are [2,1]. We recursively construct the left subtree from [2,1].",
              "id": "4b3926b0-72d8-4378-858c-0344a98794f3",
              "input": "nums = [3,2,1]"
            }
          ]
        }
      ],
      "id": "93f55261-865e-435f-894a-a0f9c9158c3d",
      "lastUpdated": "2026-02-06T21:54:17Z",
      "problemSlug": "maximum-binary-tree-ii",
      "relatedProblems": [
        "maximum-binary-tree",
        "construct-binary-tree-from-inorder-and-postorder-traversal"
      ],
      "summary": "The problem asks to construct a maximum binary tree II from an array, with the maximum value in the array as the root. We can approach this by finding the maximum element in the array, setting it as the root, and recursively constructing the left and right subtrees from the elements before and after the maximum element."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return 0.\n2. Recursively compute leftDepth and rightDepth.\n3. Return 1 + max(leftDepth, rightDepth).",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height h",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once"
          },
          "explanation": "The recursion bottoms out at empty subtrees (depth 0). Each call returns the depth of that subtree.",
          "id": "050c5512-9554-480c-99ec-4fb2c0986636",
          "intuition": "The depth of a node is 1 plus the maximum depth of its children.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3  20  15 (or 7).",
              "id": "d8ea7529-25a9-46df-a1d5-ad66d281758e",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1  2.",
              "id": "b57d4658-6b70-4a70-a4c2-e6cc4d34e311",
              "input": "root = [1,null,2]"
            }
          ]
        },
        {
          "approach": "1. If root is nil, return 0.\n2. Push root to a queue.\n3. For each level, process all nodes in the queue, enqueue their children.\n4. Count levels.",
          "code": "func maxDepth(_ root: TreeNode?) -> Int {\n    guard let root = root else { return 0 }\n    var queue: [TreeNode] = [root]\n    var depth = 0\n    var index = 0\n    while index < queue.count {\n        let levelCount = queue.count - index\n        for _ in 0..<levelCount {\n            let node = queue[index]\n            index += 1\n            if let left = node.left { queue.append(left) }\n            if let right = node.right { queue.append(right) }\n        }\n        depth += 1\n    }\n    return depth\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Queue stores up to one full level",
            "time": "O(n)",
            "timeExplanation": "Each node enqueued and dequeued once"
          },
          "explanation": "BFS processes nodes level by level, so the number of levels processed equals the maximum depth.",
          "id": "4a6e14d7-b155-4d01-86fd-0e782f6bb436",
          "intuition": "Each BFS layer corresponds to one depth level.",
          "name": "BFS Level Order",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "Longest path is 3 nodes: 3  20  15 (or 7).",
              "id": "dee370ca-5d8a-4bcc-a79e-b26b97d6a914",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "Path length is 2 nodes: 1  2.",
              "id": "3b21e6da-d0f6-4fc0-8c1a-15c60d6c92bc",
              "input": "root = [1,null,2]"
            }
          ]
        }
      ],
      "id": "d60edf13-e40b-4234-9de4-80e19e97ae9d",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "maximum-depth-of-binary-tree",
      "relatedProblems": [
        "invert-binary-tree",
        "minimum-depth-of-binary-tree"
      ],
      "summary": "Maximum depth is the length of the longest root-to-leaf path. Compute it via DFS recursion or BFS level counting."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize the maximum depth to 0. 2. Define a helper function to recursively calculate the depth of each node. 3. For each child node, calculate its depth and update the maximum depth if necessary.",
          "code": "\n// Definition for a Node.\nclass Node {\n    var val: Int\n    var children: [Node?]\n\n    init(_ val: Int) {\n        self.val = val\n        self.children = []\n    }\n}\n\nclass Solution {\n    func maxDepth(_ root: Node?) -> Int {\n        guard let root = root else { return 0 }\n        var maxChildDepth = 0\n        for child in root.children {\n            let childDepth = maxDepth(child)\n            maxChildDepth = max(maxChildDepth, childDepth)\n        }\n        return maxChildDepth + 1\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) because of the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because each node is visited once."
          },
          "explanation": "The brute force approach involves recursively traversing the tree and keeping track of the maximum depth encountered. This approach has a time complexity of O(n) and a space complexity of O(h), where n is the number of nodes and h is the height of the tree.",
          "id": "f3a72306-13e0-4842-869c-3d8171288bd5",
          "intuition": "This approach works by recursively calculating the depth of each child node and keeping track of the maximum depth encountered.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The depth of the tree is 3, which is the longest path from the root to a leaf node.",
              "id": "601e8b6d-3d62-4b6b-a7dd-0c0ba16cea6f",
              "input": "root = [1,null,3,2,4,null,5,6]"
            },
            {
              "expectedOutput": "3",
              "explanation": "The depth of the tree is 3, which is the longest path from the root to a leaf node.",
              "id": "de19a6f8-ae00-4973-b8f2-89d32d25cd7c",
              "input": "root = [1,null,2,3,4,5,null,null,6,7,null,8]"
            }
          ]
        },
        {
          "approach": "1. Initialize a queue with the root node. 2. Initialize the depth to 0. 3. Perform a level order traversal, incrementing the depth at each level.",
          "code": "\nimport Foundation\n\n// Definition for a Node.\nclass Node {\n    var val: Int\n    var children: [Node?]\n\n    init(_ val: Int) {\n        self.val = val\n        self.children = []\n    }\n}\nclass Solution {\n    func maxDepth(_ root: Node?) -> Int {\n        guard let root = root else { return 0 }\n        var queue = [root]\n        var depth = 0\n        while !queue.isEmpty {\n            let levelSize = queue.count\n            for _ in 1...levelSize {\n                let node = queue.removeFirst()\n                if let children = node.children {\n                    queue.append(contentsOf: children.compactMap { $0 })\n                }\n            }\n            depth += 1\n        }\n        return depth\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the queue will contain all nodes at the last level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because each node is visited once."
          },
          "explanation": "The optimized approach involves using a level order traversal to calculate the depth of the tree. This approach also has a time complexity of O(n) and a space complexity of O(n), where n is the number of nodes.",
          "id": "8860fc3a-f4ae-428f-82cf-945a3af5367d",
          "intuition": "This approach works by using a level order traversal (BFS) to calculate the depth of the tree.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The depth of the tree is 3, which is the longest path from the root to a leaf node.",
              "id": "c939724c-defb-4fab-8acd-4075ca97f783",
              "input": "root = [1,null,3,2,4,null,5,6]"
            },
            {
              "expectedOutput": "3",
              "explanation": "The depth of the tree is 3, which is the longest path from the root to a leaf node.",
              "id": "df56785d-d12f-4ca5-8492-28b094533783",
              "input": "root = [1,null,2,3,4,5,null,null,6,7,null,8]"
            }
          ]
        }
      ],
      "id": "d9fe03bd-2ad3-4d5d-86f3-fd0d9d24932e",
      "lastUpdated": "2026-02-06T21:26:13Z",
      "problemSlug": "maximum-depth-of-n-ary-tree",
      "relatedProblems": [
        "balanced-binary-tree",
        "binary-tree-maximum-depth"
      ],
      "summary": "The problem requires finding the maximum depth of an N-ary tree and a key insight is to understand tree traversal techniques. N-ary tree depth can be determined by traversing the tree using depth-first search (DFS) or breadth-first search (BFS) and keeping track of the maximum depth encountered."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root of the tree, then for each node, calculate the difference between the current node's value and all its ancestors. Keep track of the maximum difference found.",
          "code": "class Solution {\n    func maxAncestorDiff(_ root: TreeNode?) -> Int {\n        var maxDiff = 0\n        func dfs(_ node: TreeNode?, _ min: Int, _ max: Int) {\n            if node == nil {\n                return\n            }\n            let val = node!.val\n            maxDiff = max(maxDiff, max - val, val - min)\n            dfs(node!.left, min(min, val), max(max, val))\n            dfs(node!.right, min(min, val), max(max, val))\n        }\n        if let root = root {\n            dfs(root, root.val, root.val)\n        }\n        return maxDiff\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The maximum recursion depth (i.e., the height of the tree) determines the space complexity, which is O(n) in the worst case of an unbalanced tree.",
            "time": "O(n^2)",
            "timeExplanation": "Each node is visited in the worst case n times (once for each of its ancestors), resulting in a time complexity of O(n^2)."
          },
          "explanation": "The brute-force solution involves a depth-first search (DFS) that at each node, calculates the difference with all its ancestors. While this approach is straightforward, it leads to repeated computations and has high computational complexity.",
          "id": "6ede3d29-6bfa-4c99-bdd0-4aa321bea54f",
          "intuition": "This approach works by visiting each node in the binary tree and checking the difference between the current node and all its ancestors. It is a brute-force approach that ensures all possible differences are considered.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "The maximum difference between a node and its ancestor is 7 (between node 1 and its ancestor 8).",
              "id": "81e165fe-84ea-4489-bdbf-ed3b8b88d013",
              "input": "root = [8,3,10,1,6,14,4,7,13]"
            },
            {
              "expectedOutput": "1",
              "explanation": "The maximum difference between a node and its ancestor is 1 (between node 2 and its ancestor 1).",
              "id": "06e2cf51-7422-49be-b564-762fcc646e1e",
              "input": "root = [3,1,2]"
            }
          ]
        },
        {
          "approach": "Perform a depth-first search where at each node, update the minimum and maximum ancestor values seen so far. Then, calculate the maximum difference between the current node's value and these minimum and maximum ancestor values.",
          "code": "class Solution { func maxAncestorDiff(_ root: TreeNode?) -> Int { var maxDiff = 0; func dfs(_ node: TreeNode?, _ minA: Int, _ maxA: Int) -> Void { if node == nil { return } maxDiff = max(maxDiff, maxA - node!.val, node!.val - minA); dfs(node!.left, min(minA, node!.val), max(maxA, node!.val)); dfs(node!.right, min(minA, node!.val), max(maxA, node!.val)); } if let root = root { dfs(root, root.val, root.val) }; return maxDiff } }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is determined by the maximum recursion depth, which is O(n) in the worst case of an unbalanced tree.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once, resulting in a time complexity of O(n)."
          },
          "explanation": "The optimized solution involves calculating the minimum and maximum ancestor values for each node during the DFS traversal and updating the maximum difference found. This approach avoids redundant calculations and has lower computational complexity.",
          "id": "eebaf635-4a8b-4bc0-9732-063e892d3868",
          "intuition": "This approach optimizes the brute-force method by only keeping track of the minimum and maximum ancestor values seen so far for each node. This significantly reduces the number of comparisons needed.",
          "name": "Optimized DFS",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "The maximum difference between a node and its ancestor is 7 (between node 1 and its ancestor 8).",
              "id": "15f9c3d8-2467-419e-99a2-ac8d4a44f52f",
              "input": "root = [8,3,10,1,6,14,4,7,13]"
            },
            {
              "expectedOutput": "1",
              "explanation": "The maximum difference between a node and its ancestor is 1 (between node 2 and its ancestor 1).",
              "id": "4b8d736a-babd-4f35-8333-b5c930346de1",
              "input": "root = [3,1,2]"
            }
          ]
        }
      ],
      "id": "d52fd66d-5d55-438a-929c-1538ded1584d",
      "lastUpdated": "2026-02-06T21:56:45Z",
      "problemSlug": "maximum-difference-between-node-and-ancestor",
      "relatedProblems": [
        "binary-tree-paths",
        "binary-tree-inorder-traversal"
      ],
      "summary": "The problem involves finding the maximum difference between any node in a binary tree and its ancestor. A key insight to solving this problem is to track the minimum and maximum ancestor values for each node during a depth-first search."
    },
    {
      "approaches": [
        {
          "approach": "Perform level order traversal of the binary tree. For each level, calculate the width of the level and update the maximum width if necessary.",
          "code": "\nimport Foundation\n\n// Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\n        guard let root = root else {\n            return 0\n        }\n        \n        var queue: [(TreeNode, Int)] = [(root, 0)]\n        var maxWidth = 1\n        \n        while !queue.isEmpty {\n            var levelSize = queue.count\n            var levelMin = queue.first!.1\n            var levelMax = queue.first!.1\n            \n            for _ in 1...levelSize {\n                let (node, position) = queue.removeFirst()\n                \n                let leftPosition = 2 * position\n                let rightPosition = 2 * position + 1\n                \n                if let leftChild = node.left {\n                    queue.append((leftChild, leftPosition))\n                }\n                \n                if let rightChild = node.right {\n                    queue.append((rightChild, rightPosition))\n                }\n                \n                levelMin = min(levelMin, position)\n                levelMax = max(levelMax, position)\n            }\n            \n            let levelWidth = levelMax - levelMin + 1\n            maxWidth = max(maxWidth, levelWidth)\n        }\n        \n        return maxWidth\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the queue will hold all the nodes of the last level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node exactly once during the level order traversal."
          },
          "explanation": "This approach involves calculating the width of each level in the binary tree and keeping track of the maximum width encountered so far. It uses a queue data structure to perform level order traversal.",
          "id": "7d812612-5aa9-4ea5-a077-194bcde64ec5",
          "intuition": "This approach uses a brute force method where it performs level order traversal of the binary tree and calculates the width of each level. The maximum width is updated whenever a wider level is found.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The width of the given binary tree is 4 (at the last level).",
              "id": "1ec0b582-2b9f-4095-835d-a60cbebcf6e8",
              "input": "root = [1,3,2,5,3,null,9]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The width of the given binary tree is 2 (at the third level).",
              "id": "a0a78664-fc31-4d70-84f5-a8204ece7199",
              "input": "root = [1,3,null,5,3]"
            },
            {
              "expectedOutput": "3",
              "explanation": "The width of the given binary tree is 3 (at the third level).",
              "id": "930cac55-8905-4b7c-8135-a23ea4719177",
              "input": "root = [1,3,2,5]"
            }
          ]
        },
        {
          "approach": "Use a queue and a hash map to keep track of the position of each node. For each node, calculate the position and update the hash map.",
          "code": "\nimport Foundation\n\n// Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    func widthOfBinaryTree(_ root: TreeNode?) -> Int {\n        guard let root = root else {\n            return 0\n        }\n        \n        var queue: [(TreeNode, Int)] = [(root, 0)]\n        var maxWidth = 1\n        \n        while !queue.isEmpty {\n            var levelSize = queue.count\n            var levelMin: Int = Int.max\n            var levelMax: Int = Int.min\n            \n            for _ in 1...levelSize {\n                let (node, position) = queue.removeFirst()\n                \n                if let leftChild = node.left {\n                    queue.append((leftChild, position * 2))\n                }\n                \n                if let rightChild = node.right {\n                    queue.append((rightChild, position * 2 + 1))\n                }\n                \n                levelMin = min(levelMin, position)\n                levelMax = max(levelMax, position)\n            }\n            \n            let levelWidth = levelMax - levelMin + 1\n            maxWidth = max(maxWidth, levelWidth)\n        }\n        \n        return maxWidth\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, the queue will hold all the nodes of the last level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node exactly once during the level order traversal."
          },
          "explanation": "This approach involves calculating the position of each node and keeping track of the minimum and maximum positions at each level. By using a hash map to store the positions, we can efficiently calculate the width of each level.",
          "id": "1166fb90-5b11-4bc0-ab83-13101b023311",
          "intuition": "This approach uses the fact that the width of each level is determined by the number of nodes in that level. By using a hash map to keep track of the position of each node, we can efficiently calculate the width of each level.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The width of the given binary tree is 4 (at the last level).",
              "id": "4a18db2b-f5d2-443b-b822-6c894f8056c3",
              "input": "root = [1,3,2,5,3,null,9]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The width of the given binary tree is 2 (at the third level).",
              "id": "116ee08c-e40c-4e7d-9544-b804c40e5ab0",
              "input": "root = [1,3,null,5,3]"
            },
            {
              "expectedOutput": "3",
              "explanation": "The width of the given binary tree is 3 (at the third level).",
              "id": "268a1516-c285-4caa-abed-e4fb75c9a956",
              "input": "root = [1,3,2,5]"
            }
          ]
        }
      ],
      "id": "41f5bf20-338f-40a8-9ea8-2c7732b65385",
      "lastUpdated": "2026-02-06T21:32:08Z",
      "problemSlug": "maximum-width-of-binary-tree",
      "relatedProblems": [
        "maximum-binary-tree",
        "balance-a-binary-search-tree"
      ],
      "summary": "The problem asks to find the maximum width of a binary tree, which is the maximum number of nodes at any level. This can be solved using level order traversal to track the width of each level."
    },
    {
      "approaches": [
        {
          "approach": "Start by checking the root node of both trees. If one of them is null, return the other. If both are not null, create a new node with the sum of their values, and recursively merge their left and right children",
          "code": "\n// Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func mergeTrees(_ t1: TreeNode?, _ t2: TreeNode?) -> TreeNode? {\n        if t1 == nil {\n            return t2\n        }\n        if t2 == nil {\n            return t1\n        }\n        let newNode = TreeNode(t1!.val + t2!.val)\n        newNode.left = mergeTrees(t1!.left, t2!.left)\n        newNode.right = mergeTrees(t1!.right, t2!.right)\n        return newNode\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the recursive call stack and the new tree being created",
            "time": "O(n)",
            "timeExplanation": "We visit each node once, where n is the total number of nodes in both trees"
          },
          "explanation": "The brute force approach works, but it is not efficient as it does not consider any optimizations",
          "id": "42e27881-0b5e-4618-9883-1b72274554cf",
          "intuition": "We can solve this problem by checking every node of the first tree and the second tree, and then merge them",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3,4,5,5,4,null,7]",
              "explanation": "We merge the nodes of the two trees",
              "id": "5345d412-9f72-444f-ab75-a63c5c1ac90a",
              "input": "t1 = [1,3,2,5], t2 = [2,1,3,null,4,null,7]"
            },
            {
              "expectedOutput": "[2,1,2]",
              "explanation": "We merge the nodes of the two trees",
              "id": "f3042f72-a543-46d7-b0fb-6599e925e729",
              "input": "t1 = [1], t2 = [1,null,2]"
            }
          ]
        },
        {
          "approach": "If the first tree is null, return the second tree. If the second tree is null, return the first tree. Otherwise, add the values of the nodes and recursively merge their left and right children",
          "code": "\nclass Solution {\n    func mergeTrees(_ t1: TreeNode?, _ t2: TreeNode?) -> TreeNode? {\n        if t1 == nil {\n            return t2\n        }\n        if t2 == nil {\n            return t1\n        }\n        t1!.val += t2!.val\n        t1!.left = mergeTrees(t1!.left, t2!.left)\n        t1!.right = mergeTrees(t1!.right, t2!.right)\n        return t1\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the recursive call stack",
            "time": "O(n)",
            "timeExplanation": "We visit each node once, where n is the total number of nodes in both trees"
          },
          "explanation": "This approach saves space and is more efficient",
          "id": "70e671a5-0c04-42e0-b1b8-dd46a1aff779",
          "intuition": "Instead of creating a new node for each merge, we can directly modify the first tree",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[3,4,5,5,4,null,7]",
              "explanation": "We merge the nodes of the two trees",
              "id": "d199a6ea-95e9-4d05-bff6-b838b755182a",
              "input": "t1 = [1,3,2,5], t2 = [2,1,3,null,4,null,7]"
            },
            {
              "expectedOutput": "[2,1,2]",
              "explanation": "We merge the nodes of the two trees",
              "id": "2e208508-bc18-42a4-80bf-b2d7cc5ab7c2",
              "input": "t1 = [1], t2 = [1,null,2]"
            }
          ]
        }
      ],
      "id": "6ee8041f-9f50-4f77-9d57-3e4bf26d41b2",
      "lastUpdated": "2026-02-06T21:29:05Z",
      "problemSlug": "merge-two-binary-trees",
      "relatedProblems": [
        "insert-into-a-binary-search-tree",
        "delete-node-in-a-bst"
      ],
      "summary": "This problem involves merging two binary trees, where each node's value is the sum of the corresponding nodes in the input trees. The key insight is to recursively merge the trees, handling cases where one or both trees have a null node."
    },
    {
      "approaches": [
        {
          "approach": "Perform an in-order traversal to get all nodes' values. Then sort these values and compare each pair of adjacent nodes to get the minimum absolute difference.",
          "code": "\nclass Solution {\n    func getMinimumDifference(_ root: TreeNode?) -> Int {\n        var values = [Int]()\n        func inOrderTraversal(_ node: TreeNode?) {\n            if let node = node {\n                inOrderTraversal(node.left)\n                values.append(node.val)\n                inOrderTraversal(node.right)\n            }\n        }\n        inOrderTraversal(root)\n        var minDiff = Int.max\n        for i in 1..<values.count {\n            minDiff = min(minDiff, values[i] - values[i - 1])\n        }\n        return minDiff\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) as we need to store all nodes' values in an array.",
            "time": "O(n log n)",
            "timeExplanation": "This approach takes O(n) time to perform an in-order traversal and O(n log n) time to sort the nodes' values."
          },
          "explanation": "Perform an in-order traversal to get all nodes' values and store them in an array. Then sort this array. Initialize a variable to store the minimum absolute difference as the absolute difference between the first and the second node. Iterate over the array starting from the second node, update the minimum absolute difference whenever we find a smaller absolute difference.",
          "id": "276a2fbc-b2db-43cc-8198-9074fca92196",
          "intuition": "By getting all nodes' values and sorting them, we can get the minimum absolute difference by comparing each pair of adjacent nodes.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum absolute difference is 1.",
              "id": "a6c3b6c1-eeb0-492b-a564-6dc654f83d6b",
              "input": "root = [4,2,6,1,3]"
            },
            {
              "expectedOutput": "0",
              "explanation": "The minimum absolute difference is 0.",
              "id": "a8e02dc0-34f9-43a6-be64-271a80575492",
              "input": "root = [1,0,48,1,null,42,49,null,null,null,null,33,null,null,30,44,48,null,null,8,52,null,null,null,null,45]"
            }
          ]
        },
        {
          "approach": "Perform an in-order traversal. Maintain a variable to keep track of the last seen node's value and another variable to keep track of the minimum absolute difference seen so far.",
          "code": "\nclass Solution {\n    func getMinimumDifference(_ root: TreeNode?) -> Int {\n        var prev: Int?\n        var minDiff = Int.max\n        func inOrderTraversal(_ node: TreeNode?) {\n            if let node = node {\n                inOrderTraversal(node.left)\n                if let prev = prev {\n                    minDiff = min(minDiff, node.val - prev)\n                }\n                prev = node.val\n                inOrderTraversal(node.right)\n            }\n        }\n        inOrderTraversal(root)\n        return minDiff\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the space required by the recursive call stack in the worst case.",
            "time": "O(n)",
            "timeExplanation": "This approach takes O(n) time to perform an in-order traversal."
          },
          "explanation": "Perform an in-order traversal. Initialize a variable to store the last seen node's value as nil and another variable to store the minimum absolute difference as Int.max. Iterate over the nodes. Whenever we encounter a node, update the minimum absolute difference by comparing the absolute difference between the current node's value and the last seen node's value. Update the last seen node's value.",
          "id": "2df7b4a5-3323-4a91-9476-61a8cef36d1a",
          "intuition": "By getting nodes in ascending order via in-order traversal and maintaining a variable to keep track of the last seen node's value, we can get the minimum absolute difference in one pass without sorting.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum absolute difference is 1.",
              "id": "915e97d1-08ff-4538-a5f7-7813e67b59b5",
              "input": "root = [4,2,6,1,3]"
            },
            {
              "expectedOutput": "0",
              "explanation": "The minimum absolute difference is 0.",
              "id": "53044d81-b8e0-4797-a9b5-194e9a70b8d1",
              "input": "root = [1,0,48,1,null,42,49,null,null,null,null,33,null,null,30,44,48,null,null,8,52,null,null,null,null,45]"
            }
          ]
        }
      ],
      "id": "6cda066a-ea9a-4e7a-a964-3d2ddd722ae5",
      "lastUpdated": "2026-02-06T21:24:43Z",
      "problemSlug": "minimum-absolute-difference-in-bst",
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-tree-inorder-traversal"
      ],
      "summary": "This problem asks to find the minimum absolute difference between any two nodes in a binary search tree. The key insight is to perform an in-order traversal to get the nodes in ascending order."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node and recursively traverse down the tree, keeping track of the current depth. For each node, check if it's a leaf node. If it is, update the minimum depth if the current depth is less than the minimum depth found so far. If not, continue exploring the left and right subtrees.",
          "code": "\nclass Solution {\n    func minDepth(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        if root.left == nil && root.right == nil { return 1 }\n        if let left = root.left, let right = root.right {\n            return 1 + min(minDepth(left), minDepth(right))\n        }\n        if let left = root.left { return 1 + minDepth(left) }\n        if let right = root.right { return 1 + minDepth(right) }\n        return 0\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) because of the recursive call stack, where h is the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we might end up visiting every node in the tree."
          },
          "explanation": "This approach works, but it's inefficient because it can end up visiting the same nodes multiple times, especially for unbalanced trees. It's also not the most efficient way to find the minimum depth because it doesn't stop as soon as it finds a leaf node.",
          "id": "71b4341b-e578-4fdd-bf97-319bc492e09c",
          "intuition": "The brute force approach works by recursively exploring each node in the binary tree and keeping track of the minimum depth encountered so far.",
          "name": "Brute Force Recursive Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The minimum depth is 2 because the path to the nearest leaf node is [3, 9].",
              "id": "e7062843-38b1-46ab-b2e7-054808b82e32",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The minimum depth is 2 because the path to the nearest leaf node is [1, 2].",
              "id": "27feafd3-7673-4147-a203-bfe3a2e73b8f",
              "input": "root = [1,null,2]"
            }
          ]
        },
        {
          "approach": "Start at the root node and use a queue to keep track of nodes to visit. For each node, check if it's a leaf node. If it is, return the current depth. If not, add its children to the queue and move on to the next node.",
          "code": "\nclass Solution {\n    func minDepth(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        var queue = [(root, 1)]\n        while !queue.isEmpty {\n            let (node, depth) = queue.removeFirst()\n            if node.left == nil && node.right == nil { return depth }\n            if let left = node.left { queue.append((left, depth + 1)) }\n            if let right = node.right { queue.append((right, depth + 1)) }\n        }\n        return 0\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because in the worst case, we might end up storing every node in the queue.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we might end up visiting every node in the tree."
          },
          "explanation": "This approach is more efficient than the brute force approach because it stops as soon as it finds a leaf node, and it doesn't end up visiting the same nodes multiple times.",
          "id": "ef20c5a5-8912-4aa5-939b-688d9c86fcac",
          "intuition": "The BFS approach works by exploring all nodes at each depth level before moving on to the next level, allowing it to stop as soon as it finds a leaf node.",
          "name": "Breadth-First Search (BFS) Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The minimum depth is 2 because the path to the nearest leaf node is [3, 9].",
              "id": "39f5eb6b-d71b-443b-ae44-c634b6386486",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The minimum depth is 2 because the path to the nearest leaf node is [1, 2].",
              "id": "fd9a54d0-ae03-4343-93c0-be2c71d992d5",
              "input": "root = [1,null,2]"
            }
          ]
        }
      ],
      "id": "3842af0d-3aad-469a-aacc-13651bf8634f",
      "lastUpdated": "2026-02-06T21:06:48Z",
      "problemSlug": "minimum-depth-of-binary-tree",
      "relatedProblems": [
        "balanced-binary-tree",
        "maximum-depth-of-binary-tree"
      ],
      "summary": "The problem asks to find the minimum depth of a binary tree, which is the number of nodes along the shortest path from the root node down to the nearest leaf node. This can be solved using a breadth-first search (BFS) approach to efficiently explore all nodes at each depth level."
    },
    {
      "approaches": [
        {
          "approach": "Perform an in-order traversal of the BST to collect all node values. Store the values in a list and sort the list. Initialize a variable to store the minimum difference. Iterate through the sorted list, calculating the difference between adjacent values and updating the minimum difference as needed.",
          "code": "\nclass TreeNode {\n  var val: Int\n  var left: TreeNode?\n  var right: TreeNode?\n\n  init(_ val: Int) {\n    self.val = val\n    self.left = nil\n    self.right = nil\n  }\n}\n\nfunc minDiffInBST(_ root: TreeNode?) -> Int {\n  var nodes = [Int]()\n  inOrderTraversal(root, &nodes)\n  nodes.sort()\n  var minDiff = Int.max\n  for i in 1..<nodes.count {\n    minDiff = min(minDiff, nodes[i] - nodes[i - 1])\n  }\n  return minDiff\n}\n\nfunc inOrderTraversal(_ node: TreeNode?, _ nodes: inout [Int]) {\n  if node == nil { return }\n  inOrderTraversal(node?.left, &nodes)\n  nodes.append(node!.val)\n  inOrderTraversal(node?.right, &nodes)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We need to store the node values in a list, which requires O(n) space.",
            "time": "O(n log n)",
            "timeExplanation": "The in-order traversal takes O(n) time. Sorting the list of nodes takes O(n log n) time. The subsequent iteration through the sorted list takes O(n) time."
          },
          "explanation": "This approach works because the in-order traversal of a BST yields a sorted list of node values. By iterating through the sorted list and calculating the differences between adjacent values, we can efficiently find the minimum difference between any two distinct nodes.",
          "id": "05096ca1-babc-413c-bdc2-48bdffcf3428",
          "intuition": "The brute force approach involves performing an in-order traversal of the BST, storing all node values in a list, and then iterating through the list to calculate the minimum difference between any two distinct nodes.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum difference between any two distinct nodes in the given BST is 1, which is the difference between the values of the nodes with values 1 and 2, or 3 and 4.",
              "id": "47640632-8d95-4b79-9181-0b769036c088",
              "input": "root = [4,2,6,1,3]"
            },
            {
              "expectedOutput": "2147483647",
              "explanation": "Since there is only one node in the BST, the minimum difference between any two distinct nodes is the maximum possible integer value.",
              "id": "96e79a62-0fe4-44d2-b5e6-ceb6070d9660",
              "input": "root = [90]"
            }
          ]
        },
        {
          "approach": "Perform an in-order traversal of the BST, maintaining a running minimum difference and the previous node value. Update the minimum difference whenever we encounter a smaller difference between the current node value and the previous node value.",
          "code": "\nclass TreeNode {\n  var val: Int\n  var left: TreeNode?\n  var right: TreeNode?\n\n  init(_ val: Int) {\n    self.val = val\n    self.left = nil\n    self.right = nil\n  }\n}\n\nfunc minDiffInBST(_ root: TreeNode?) -> Int {\n  var minDiff = Int.max\n  var prev: Int?\n\n  inOrderTraversal(root, &minDiff, &prev)\n  return minDiff\n}\n\nfunc inOrderTraversal(_ node: TreeNode?, _ minDiff: inout Int, _ prev: inout Int?) {\n  if node == nil { return }\n  inOrderTraversal(node?.left, &minDiff, &prev)\n  if let prevVal = prev {\n    minDiff = min(minDiff, node!.val - prevVal)\n  }\n  prev = node!.val\n  inOrderTraversal(node?.right, &minDiff, &prev)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We need to store the recursive call stack, which requires O(n) space in the worst case.",
            "time": "O(n)",
            "timeExplanation": "The in-order traversal takes O(n) time."
          },
          "explanation": "This optimized approach works because the in-order traversal of a BST yields a sorted sequence of node values. By maintaining a running minimum difference and the previous node value, we can efficiently calculate the minimum difference between any two distinct nodes without the need for sorting.",
          "id": "e2b56e47-71c9-405e-832f-fefc2197eaa9",
          "intuition": "We can optimize the brute force approach by avoiding the need to sort the list of node values. Instead, we can maintain a running minimum difference as we perform the in-order traversal.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum difference between any two distinct nodes in the given BST is 1, which is the difference between the values of the nodes with values 1 and 2, or 3 and 4.",
              "id": "5aa2ffeb-9d6d-46f3-af32-12e9604f7195",
              "input": "root = [4,2,6,1,3]"
            },
            {
              "expectedOutput": "2147483647",
              "explanation": "Since there is only one node in the BST, the minimum difference between any two distinct nodes is the maximum possible integer value.",
              "id": "719eb0c7-8156-4ca9-83dd-f94b8dd80818",
              "input": "root = [90]"
            }
          ]
        }
      ],
      "id": "ba101693-f889-4f07-8c8c-b303a330f319",
      "lastUpdated": "2026-02-06T21:39:20Z",
      "problemSlug": "minimum-distance-between-bst-nodes",
      "relatedProblems": [
        "validate-binary-search-tree",
        "binary-search-tree-iterator"
      ],
      "summary": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two distinct nodes. This can be achieved by performing an in-order traversal of the BST and maintaining a list of node values, then calculating the minimum difference between adjacent values."
    },
    {
      "approaches": [
        {
          "approach": "To calculate the sum of each subtree, perform a depth-first search (DFS) on the tree and calculate the sum of each subtree recursively. Store the sum in a hash map and update the frequency accordingly.",
          "code": "\nimport Foundation\n\nclass TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    \n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    var sumToCount: [Int: Int] = [:]\n    \n    func findFrequentTreeSum(_ root: TreeNode?) -> [Int] {\n        let maxCount = dfs(root)\n        \n        var result: [Int] = []\n        \n        for (sum, count) in sumToCount {\n            if count == maxCount {\n                result.append(sum)\n            }\n        }\n        \n        return result\n    }\n    \n    func dfs(_ node: TreeNode?) -> Int {\n        guard let node = node else {\n            return 0\n        }\n        \n        let leftSum = dfs(node.left)\n        let rightSum = dfs(node.right)\n        \n        let sum = leftSum + rightSum + node.val\n        \n        sumToCount[sum, default: 0] += 1\n        \n        return sumToCount[sum] ?? 0\n      }\n   ",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we store the frequency of each subtree sum in a hash map.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once during the DFS traversal."
          },
          "explanation": "The brute force approach involves calculating the sum of each subtree and storing it in a hash map. It uses a recursive DFS to traverse the tree and calculate the sum of each subtree.",
          "id": "167d7b41-9bfd-4445-b206-d42a9b6d28e6",
          "intuition": "This approach involves calculating the sum of each subtree and storing it in a hash map to keep track of the frequency of each sum.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,-3,4]",
              "explanation": "The sums of the subtrees are 2, -3, and 4, each with a frequency of 1.",
              "id": "9d8491b8-9501-42dd-808c-248a8470a028",
              "input": "root = [5,2,-5]"
            },
            {
              "expectedOutput": "[3,-2]",
              "explanation": "The sums of the subtrees are 3 and -2, each with a frequency of 1.",
              "id": "f14adc5e-f8aa-40c2-ae33-4c155abc0186",
              "input": "root = [3,0,5,0,3,-2,1,2]"
            }
          ]
        },
        {
          "approach": "To optimize the approach, we can use a Post-Order DFS traversal to calculate the sum of each subtree and update the frequency in a hash map.",
          "code": "\nimport Foundation\n\nclass TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    \n    init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    var sumToCount: [Int: Int] = [:]\n    var maxCount = 0\n    \n    func findFrequentTreeSum(_ root: TreeNode?) -> [Int] {\n        postOrderDfs(root)\n        \n        var result: [Int] = []\n        \n        for (sum, count) in sumToCount {\n            if count == maxCount {\n                result.append(sum)\n            }\n        }\n        \n        return result\n    }\n    \n    func postOrderDfs(_ node: TreeNode?) -> Int {\n        guard let node = node else {\n            return 0\n        }\n        \n        let leftSum = postOrderDfs(node.left)\n        let rightSum = postOrderDfs(node.right)\n        \n        let sum = leftSum + rightSum + node.val\n        \n        sumToCount[sum, default: 0] += 1\n        maxCount = max(maxCount, sumToCount[sum] ?? 0)\n        \n        return sum\n      }\n   ",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we store the frequency of each subtree sum in a hash map.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once during the Post-Order DFS traversal."
          },
          "explanation": "The optimized approach involves using a Post-Order DFS traversal to calculate the sum of each subtree and update the frequency in a hash map. This ensures that we calculate the sum of each subtree correctly and update the frequency accordingly.",
          "id": "42baf9b5-05c3-4006-931b-0e3a974088fc",
          "intuition": "This approach involves using a Post-Order DFS traversal to calculate the sum of each subtree and update the frequency in a hash map.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2,-3,4]",
              "explanation": "The sums of the subtrees are 2, -3, and 4, each with a frequency of 1.",
              "id": "3296eeb6-45ea-4cee-9229-af6d44368fd1",
              "input": "root = [5,2,-5]"
            },
            {
              "expectedOutput": "[3,-2]",
              "explanation": "The sums of the subtrees are 3 and -2, each with a frequency of 1.",
              "id": "fe939b8a-4d61-4345-9088-8d1cec886d20",
              "input": "root = [3,0,5,0,3,-2,1,2]"
            }
          ]
        }
      ],
      "id": "82ac5bea-e6b6-4a4d-87b6-7c07498d6e52",
      "lastUpdated": "2026-02-06T21:23:04Z",
      "problemSlug": "most-frequent-subtree-sum",
      "relatedProblems": [
        "path-sum",
        "path-sum-ii"
      ],
      "summary": "The problem requires finding the most frequent sum of all the subtrees in a binary tree and returning all subtrees with the maximum frequency. A key insight is to use a hash map to store the frequency of each subtree sum."
    },
    {
      "approaches": [
        {
          "approach": "Start by defining a recursive function that takes a node and its current level, process the node, then recursively call the function on its children and the next level. Store the results in a dictionary where the key is the level and the value is an array of node values.",
          "code": "\nclass Solution {\n    func levelOrder(_ root: Node?) -> [[Int]] {\n        guard let root = root else { return [] }\n        var result: [[Int]] = []\n        var queue: [Node] = [root]\n        while !queue.isEmpty {\n            var level: [Int] = []\n            let levelSize = queue.count\n            for _ in 0..<levelSize {\n                let node = queue.removeFirst()\n                level.append(node.val)\n                queue.append(contentsOf: node.children)\n            }\n            result.append(level)\n        }\n        return result\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n), where n is the total number of nodes in the tree, as in the worst case (when the tree is a complete binary tree), the queue will store n/2 nodes at the last level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the total number of nodes in the tree, since we visit each node once."
          },
          "explanation": "The brute force approach first checks if the tree is empty, in which case it returns an empty array. Otherwise, it calls the recursive helper function on the root node at level 1. The helper function checks if the current level is already a key in the results dictionary, and if not, adds it. Then it appends the node's value to the array for the current level. Finally, the function calls itself on each of the node's children at the next level.",
          "id": "86ce5568-4d4c-4a00-8597-0981efa8f462",
          "intuition": "This approach works by using recursion to traverse each node in the tree, storing the level of each node as it goes, and grouping the results by level.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[[1], [3, 2, 4], [5, 6]]",
              "explanation": "In the first test case, we have a tree with the root node as 1, and its children are 3, 2, and 4. The children of node 3 are 5 and 6. Thus, our expected level order traversal is [[1], [3, 2, 4], [5, 6]].",
              "id": "5095d46e-eed2-472d-9f02-e57622fc6b4a",
              "input": "let node1 = Node(1); let node3 = Node(3); let node2 = Node(2); let node4 = Node(4); let node5 = Node(5); let node6 = Node(6); node1.children = [node3, node2, node4]; node3.children = [node5, node6]; Solution().levelOrder(node1)"
            },
            {
              "expectedOutput": "[[1], [2, 3, 4], [5]]",
              "explanation": "In the second test case, we have a tree with the root node as 1, and its children are 2, 3, and 4. The child of node 3 is 5. Thus, our expected level order traversal is [[1], [2, 3, 4], [5]].",
              "id": "10d84b62-19d6-4f4b-9d61-0f11d19ec6b1",
              "input": "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); let node4 = Node(4); let node5 = Node(5); node1.children = [node2, node3, node4]; node3.children = [node5]; Solution().levelOrder(node1)"
            }
          ]
        },
        {
          "approach": "The algorithm initializes a result array and a queue to store nodes at each level. Then, it enters a loop until the queue is empty, processing each level by adding the node values to the result array and enqueuing their children for the next level.",
          "code": "\nclass Solution {\n    func levelOrder(_ root: Node?) -> [[Int]] {\n        guard let root = root else { return [] }\n        var result: [[Int]] = []\n        var queue: [Node] = [root]\n        while !queue.isEmpty {\n            var level: [Int] = []\n            let levelSize = queue.count\n            for _ in 0..<levelSize {\n                let node = queue.removeFirst()\n                level.append(node.val)\n                queue.append(contentsOf: node.children)\n            }\n            result.append(level)\n        }\n        return result\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also O(n), as the maximum number of nodes stored in the queue at any given moment is equal to the number of nodes at the last level.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is still O(n), as each node is visited once."
          },
          "explanation": "This solution avoids the overhead of recursive function calls and directly uses a queue to process each level, reducing the overall time and space complexity. It works by adding all the children of the current node to the queue, then adding all their values to the level array and removing them from the queue, thus maintaining a constant number of nodes at each level in the queue.",
          "id": "6b7875cc-f0cc-454a-a5b9-2c7a731265d5",
          "intuition": "The optimized approach involves recognizing that we can avoid explicit recursion and utilize a queue data structure for a more efficient level order traversal.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[[1], [2, 3]]",
              "explanation": "In the first test case, we have a tree with the root node as 1, and its children are 2 and 3. So, our expected level order traversal is [[1], [2, 3]].",
              "id": "446ce17b-4de9-42f7-a1f3-18aa3ef684c4",
              "input": "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); node1.children = [node2, node3]; Solution().levelOrder(node1)"
            },
            {
              "expectedOutput": "[[1], [2, 3], [4, 5]]",
              "explanation": "In the second test case, we have a tree with the root node as 1, and its children are 2 and 3. The children of node 2 are 4 and 5. So, our expected level order traversal is [[1], [2, 3], [4, 5]].",
              "id": "d621fe23-c901-4b93-9ba3-59b3ffc1cbc5",
              "input": "let node1 = Node(1); let node2 = Node(2); let node3 = Node(3); let node4 = Node(4); let node5 = Node(5); node1.children = [node2, node3]; node2.children = [node4, node5]; Solution().levelOrder(node1)"
            }
          ]
        }
      ],
      "id": "02c10d1c-3017-4fb8-8ef2-2d135ffb9d94",
      "lastUpdated": "2026-02-06T21:18:12Z",
      "problemSlug": "n-ary-tree-level-order-traversal",
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "minimum-depth-of-binary-tree"
      ],
      "summary": "The problem involves performing a level order traversal of an N-ary tree, and the key insight is using a queue to store nodes and their children to process each level. This allows for a breadth-first search (BFS) approach."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is null, return false\n2. Subtract root.val from targetSum\n3. If root is leaf (no children), return targetSum == 0\n4. Recursively check left OR right subtree",
          "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    let remaining = targetSum - root.val\n    \n    // Check if leaf\n    if root.left == nil && root.right == nil {\n        return remaining == 0\n    }\n    \n    // Check children\n    return hasPathSum(root.left, remaining) || hasPathSum(root.right, remaining)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Visit each node at most once"
          },
          "explanation": "We accumulate the path sum by subtracting from target as we descend. At a leaf, if we've subtracted exactly targetSum total, we've found a valid path. Using subtraction avoids passing accumulated sum as parameter and handles negative values correctly.",
          "id": "76e1f12b-9f5e-4cad-a2ec-09141802369a",
          "intuition": "Subtract each node's value from target as we go down. At a leaf, check if remaining target equals 0 (or equivalently, if remaining equals leaf value).",
          "name": "DFS Recursive",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Path 54112 sums to 22",
              "id": "837e34f3-b495-4dcc-acb4-1fd7ed76b154",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22"
            },
            {
              "expectedOutput": "false",
              "explanation": "Paths are 12=3 and 13=4. Neither equals 5.",
              "id": "28e4940f-c088-48b8-a931-bb32cae5aac3",
              "input": "root = [1,2,3], targetSum = 5"
            },
            {
              "expectedOutput": "false",
              "explanation": "Empty tree has no paths",
              "id": "2af4823a-4328-4489-9577-0902c4199603",
              "input": "root = [], targetSum = 0"
            }
          ]
        },
        {
          "approach": "1. Stack of (node, remainingSum) pairs\n2. Push root with targetSum\n3. While stack not empty:\n   a. Pop node and remaining\n   b. If leaf and remaining == node.val, return true\n   c. Push children with remaining - node.val\n4. Return false",
          "code": "func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    var stack: [(TreeNode, Int)] = [(root, targetSum)]\n    \n    while !stack.isEmpty {\n        let (node, remaining) = stack.removeLast()\n        \n        // Check if leaf with matching sum\n        if node.left == nil && node.right == nil && remaining == node.val {\n            return true\n        }\n        \n        // Push children\n        if let left = node.left {\n            stack.append((left, remaining - node.val))\n        }\n        if let right = node.right {\n            stack.append((right, remaining - node.val))\n        }\n    }\n    \n    return false\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most one path worth of nodes",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "This iterative version mimics the recursive approach using an explicit stack. We track the remaining sum needed at each node. When we reach a leaf, we check if the node's value exactly matches the remaining sum (meaning the path sums to target).",
          "id": "56961416-e0ed-45b7-ae59-4e8eca175587",
          "intuition": "Use stack to simulate DFS. Store (node, remaining sum) pairs. At each leaf, check if sum matches.",
          "name": "Iterative with Stack",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same result via iteration",
              "id": "d7596ca3-586f-4cda-88b1-d5bb6ecbc79e",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22"
            }
          ]
        }
      ],
      "id": "9e84e3e8-6da3-45d8-9fd0-3c420790107c",
      "lastUpdated": "2026-02-06T08:40:26Z",
      "problemSlug": "path-sum",
      "relatedProblems": [
        "path-sum-ii",
        "path-sum-iii",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "Check if tree has root-to-leaf path with given sum. DFS subtracting node values from target; at leaf, check if remaining target equals leaf value."
    },
    {
      "approaches": [
        {
          "approach": "1. Define a recursive function that takes a node, the current sum, and the target sum as parameters. 2. In the function, if the node is nil, return 0. 3. If the current sum equals the target sum, increment a count variable. 4. Recursively call the function for the left and right child nodes with their values added to the current sum.",
          "code": "class Solution {\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> Int {\n        var count = 0\n        func dfs(_ node: TreeNode?, _ currentSum: Int) {\n            if let node = node {\n                if currentSum - node.val == targetSum {\n                    count += 1\n                }\n                dfs(node.left, currentSum - node.val)\n                dfs(node.right, currentSum - node.val)\n            }\n        }\n        dfs(root, 0)\n        return count\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because in the worst case, for each node, we might be traversing the entire tree again."
          },
          "explanation": "The Brute Force Approach is straightforward but inefficient because it performs a lot of repeated calculations. For each node, it recalculates the sum of all possible paths, resulting in exponential time complexity.",
          "id": "a7b1b927-73b9-4384-8c9b-681813301f89",
          "intuition": "This approach involves using DFS to traverse the binary tree and for each node, calculate the sum of all possible paths starting from that node and check if it equals the target sum.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "There are three paths whose sum is 8: [5,3], [5,2,1], and [-3,11].",
              "id": "87a3fb4d-3dd9-4449-a249-64883e47425f",
              "input": "root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8"
            },
            {
              "expectedOutput": "3",
              "explanation": "There are three paths whose sum is 22: [5,4,11,2], [5,4,8,5], and [11,7,4].",
              "id": "874dd733-d828-41b1-aef3-794d21669a56",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22"
            }
          ]
        },
        {
          "approach": "1. Initialize a hashmap to store prefix sums and their counts. 2. Perform DFS, for each node, calculate the prefix sum by adding the node's value to the previous prefix sum. 3. Check if there exists a prefix sum in the hashmap such that the difference between the current prefix sum and this prefix sum equals the target sum. If so, increment the count by the frequency of this prefix sum. 4. Update the count of the current prefix sum in the hashmap.",
          "code": "class Solution {\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> Int {\n        var count = 0\n        var prefixSumCount: [Int: Int] = [0: 1]\n        var currentSum = 0\n        func dfs(_ node: TreeNode?) {\n            if let node = node {\n                currentSum += node.val\n                count += prefixSumCount[currentSum - targetSum] ?? 0\n                prefixSumCount[currentSum, default: 0] += 1\n                dfs(node.left)\n                dfs(node.right)\n                prefixSumCount[currentSum, default: 0] -= 1\n                if prefixSumCount[currentSum, default: 0] == 0 {\n                    prefixSumCount.removeValue(forKey: currentSum)\n                }\n                currentSum -= node.val\n            }\n        }\n        dfs(root)\n        return count\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the recursive call stack and the space required by the hashmap to store prefix sums.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) as each node is visited once."
          },
          "explanation": "The Prefix Sum Approach is more efficient because it avoids recalculating sums for paths that have been traversed before, reducing the time complexity.",
          "id": "87b84616-92a2-4ebe-b105-89dbf2746e46",
          "intuition": "This approach involves using a hashmap to store the prefix sums encountered during the DFS traversal and their frequencies. For each node, it calculates the prefix sum and checks if there is a prefix sum in the hashmap that, when subtracted from the current prefix sum, equals the target sum.",
          "name": "Prefix Sum Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "There are three paths whose sum is 8: [5,3], [5,2,1], and [-3,11].",
              "id": "a000cfec-d4fa-4b22-8e13-0d9451825e81",
              "input": "root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8"
            },
            {
              "expectedOutput": "3",
              "explanation": "There are three paths whose sum is 22: [5,4,11,2], [5,4,8,5], and [11,7,4].",
              "id": "60afd3d8-3b12-4b77-b9e4-f569d7622dc1",
              "input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22"
            }
          ]
        }
      ],
      "id": "2c16aa28-0c6b-470a-b709-0972fcc0be57",
      "lastUpdated": "2026-02-06T21:18:47Z",
      "problemSlug": "path-sum-iii",
      "relatedProblems": [
        "path-sum",
        "path-sum-ii",
        "subarray-sum-equals-k"
      ],
      "summary": "The problem Path Sum III asks to find the total number of paths in a binary tree where the sum of the node values equals a given target. A key insight is to use a depth-first search (DFS) with a prefix sum to efficiently count these paths."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Define a TreeNode class to represent each node in the tree. Step 2: Create a recursive DFS function to traverse the tree and print each node's value. Step 3: Start the DFS traversal from the root node.",
          "code": "class TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } } \n func printTree(_ root: TreeNode?) { \n    if let root = root { \n        print(root.val) \n        printTree(root.left) \n        printTree(root.right) \n    } \n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The recursive call stack can go up to the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "We visit each node once."
          },
          "explanation": "This approach works because DFS traverses the tree by visiting each node and its children before backtracking. The time complexity is O(n) because we visit each node once, and the space complexity is O(h) because of the recursive call stack.",
          "id": "7d80baec-7848-4e02-bf9f-545dc176be4b",
          "intuition": "The brute-force approach involves using a recursive DFS to traverse the tree and print each node's value.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1, 2, 4, 5, 3, 6, 7",
              "explanation": "The expected output is the pre-order traversal of the tree.",
              "id": "ce0aca00-dbf0-44e7-acfd-965d5619150b",
              "input": "root = [1,2,3,4,5,6,7]"
            },
            {
              "expectedOutput": "1, 2, 3, 4, 5",
              "explanation": "The expected output is the pre-order traversal of the tree.",
              "id": "472abc06-8d4f-45a2-b113-7caa5ab46d1c",
              "input": "root = [1,2,3,null,null,4,5]"
            }
          ]
        },
        {
          "approach": "Step 1: Define a TreeNode class to represent each node in the tree. Step 2: Create a queue to store nodes to be visited. Step 3: Start the BFS traversal from the root node.",
          "code": "class TreeNode { let val: Int; var left: TreeNode?; var right: TreeNode?; init(_ val: Int) { self.val = val; self.left = nil; self.right = nil } } \n func printTree(_ root: TreeNode?) { \n    guard let root = root else { return } \n    var queue: [TreeNode] = [root] \n    while !queue.isEmpty { \n        let node = queue.removeFirst() \n        print(node.val) \n        if let left = node.left { queue.append(left) } \n        if let right = node.right { queue.append(right) } \n    } \n}",
          "complexity": {
            "space": "O(w)",
            "spaceExplanation": "The queue can store up to the width of the tree.",
            "time": "O(n)",
            "timeExplanation": "We visit each node once."
          },
          "explanation": "This approach works because BFS traverses the tree level by level, and we can print each node's value as we visit it. The time complexity is O(n) because we visit each node once, and the space complexity is O(w) because of the queue, where w is the width of the tree.",
          "id": "8a51ea75-d5c9-4676-808e-0d552df6a151",
          "intuition": "The optimized approach involves using a level-order BFS to traverse the tree and print each node's value.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1, 2, 3, 4, 5, 6, 7",
              "explanation": "The expected output is the level-order traversal of the tree.",
              "id": "51bbcf9e-5232-4d99-9a92-bd7bcb7636b0",
              "input": "root = [1,2,3,4,5,6,7]"
            },
            {
              "expectedOutput": "1, 2, 3, 4, 5",
              "explanation": "The expected output is the level-order traversal of the tree.",
              "id": "e8641fe7-036d-4699-a25d-c6c550019281",
              "input": "root = [1,2,3,null,null,4,5]"
            }
          ]
        }
      ],
      "id": "5e650e80-44a8-4f6b-8cb0-24eaff725192",
      "lastUpdated": "2026-02-06T21:31:26Z",
      "problemSlug": "print-binary-tree",
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "binary-tree-inorder-traversal"
      ],
      "summary": "The problem asks us to print a binary tree, and the key insight is to use either depth-first search (DFS) or breadth-first search (BFS) to traverse the tree."
    },
    {
      "approaches": [
        {
          "approach": "This approach uses a depth-first search (DFS) traversal to visit every node in the BST. For each node, it checks if the node's value is within the given range and, if so, adds it to the running total.",
          "code": "\nclass Solution {\n  func rangeSumBST(_ root: TreeNode?, _ low: Int, _ high: Int) -> Int {\n    var sum = 0\n    dfs(root, low, high, &sum)\n    return sum\n  }\n\n  private func dfs(_ node: TreeNode?, _ low: Int, _ high: Int, _ sum: inout Int) {\n    guard let node = node else { return }\n    if node.val >= low && node.val <= high {\n      sum += node.val\n    }\n    dfs(node.left, low, high, &sum)\n    dfs(node.right, low, high, &sum)\n  }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) due to the recursion stack, where h is the height of the BST.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit every node in the BST."
          },
          "explanation": "This approach works by exhaustively exploring the entire BST. However, it may be inefficient for large trees because it visits every node regardless of whether its value falls within the given range.",
          "id": "d5256669-d0bb-46a5-acd5-b85314c6e09f",
          "intuition": "The brute force approach involves visiting every node in the BST and checking if its value falls within the given range.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "32",
              "explanation": "The values of nodes that fall within the range [7, 15] are 7, 10, and 15.",
              "id": "24b4e378-64d9-4808-8912-8c71ab55cdc4",
              "input": "root = [10,5,15,3,7,null,18], low = 7, high = 15"
            },
            {
              "expectedOutput": "23",
              "explanation": "The values of nodes that fall within the range [6, 10] are 6, 7, and 10.",
              "id": "56bb3a86-5c2e-462b-bf96-db6653e28d63",
              "input": "root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10"
            }
          ]
        },
        {
          "approach": "This approach also uses DFS traversal but prunes branches by avoiding subtrees that are guaranteed to be outside the given range based on the BST property.",
          "code": "\nclass Solution {\n  func rangeSumBST(_ root: TreeNode?, _ low: Int, _ high: Int) -> Int {\n    var sum = 0\n    dfs(root, low, high, &sum)\n    return sum\n  }\n\n  private func dfs(_ node: TreeNode?, _ low: Int, _ high: Int, _ sum: inout Int) {\n    guard let node = node else { return }\n    if node.val > high {\n      dfs(node.left, low, high, &sum)\n    } else if node.val < low {\n      dfs(node.right, low, high, &sum)\n    } else {\n      sum += node.val\n      dfs(node.left, low, high, &sum)\n      dfs(node.right, low, high, &sum)\n    }\n  }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity remains O(h) due to the recursion stack.",
            "time": "O(n) in the worst case, but O(log n + k) on average",
            "timeExplanation": "The time complexity can be significantly reduced when the range is narrow, leveraging the BST property to prune branches."
          },
          "explanation": "This approach works efficiently by skipping entire subtrees that do not contain values within the given range, thanks to the BST property where all values in the left subtree of a node are less than the node's value, and all values in the right subtree are greater.",
          "id": "627f43cd-99d8-45d6-b388-80e4eeecfa1b",
          "intuition": "This approach leverages the BST property to prune branches during the traversal, thus reducing the number of nodes visited.",
          "name": "Optimized Pruned Search Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "32",
              "explanation": "The values of nodes that fall within the range [7, 15] are 7, 10, and 15.",
              "id": "2fb2b405-4faa-453f-b8b7-038ff2a2d335",
              "input": "root = [10,5,15,3,7,null,18], low = 7, high = 15"
            },
            {
              "expectedOutput": "23",
              "explanation": "The values of nodes that fall within the range [6, 10] are 6, 7, and 10.",
              "id": "7cea2768-2315-44b7-842f-ef11f84689a8",
              "input": "root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10"
            }
          ]
        }
      ],
      "id": "e3acedce-020b-4ded-8229-92a344881415",
      "lastUpdated": "2026-02-06T21:50:01Z",
      "problemSlug": "range-sum-of-bst",
      "relatedProblems": [
        "path-sum",
        "path-sum-ii",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "This problem involves finding the sum of all node values in a binary search tree (BST) that lie within a given range. The key insight is to leverage the BST property to efficiently traverse the tree."
    },
    {
      "approaches": [
        {
          "approach": "Perform in-order traversal to generate a list of all nodes, then check all possible swaps to identify the correct binary search tree.",
          "code": "class Solution {\n    func recoverTree(_ root: TreeNode?) -> Void {\n        let nodes = inOrderTraversal(root)\n        for i in 0..<nodes.count-1 {\n            for j in i+1..<nodes.count {\n                swapTwoNodes(nodes[i], nodes[j])\n                if isValidBST(root) {\n                    return\n                }\n                swapTwoNodes(nodes[j], nodes[i])\n            }\n        }\n    }\n    private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] {\n        if let node = node {\n            inOrderTraversal(node.left)\n            nodes.append(node)\n            inOrderTraversal(node.right)\n        }\n        return nodes\n    }\n    private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) {\n        let tmp = node1.val\n        node1.val = node2.val\n        node2.val = tmp\n    }\n    private func isValidBST(_ node: TreeNode?, _ minVal: Int = Int.min, _ maxVal: Int = Int.max) -> Bool {\n        guard let node = node else {\n            return true\n        }\n        if node.val <= minVal || node.val >= maxVal {\n            return false\n        }\n        return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal)\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Space complexity is O(n) for storing the list of nodes.",
            "time": "O(n!)",
            "timeExplanation": "Time complexity is O(n!) due to generating all permutations of the nodes."
          },
          "explanation": "Create a list of all nodes, generate all permutations of the nodes, then check each permutation to see if the resulting tree is a valid binary search tree.",
          "id": "a5a6685c-168d-4ea0-af94-d14cddc6be4f",
          "intuition": "This works by creating a list of all nodes in the tree and checking all possible node swaps to find a valid binary search tree.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "root = [3,1,null,null,2]",
              "explanation": "In this test case, the tree nodes 1 and 3 have been corrupted and swapped.",
              "id": "5c98309f-09ad-40fc-9f3e-14a445188651",
              "input": "root = [1,3,null,null,2]"
            },
            {
              "expectedOutput": "root = [2,1,4,null,null,3]",
              "explanation": "In this test case, the tree nodes 2 and 3 have been corrupted and swapped.",
              "id": "7c7bf6de-4875-483b-8190-0a8311272ea3",
              "input": "root = [3,1,4,null,null,2]"
            }
          ]
        },
        {
          "approach": "Use in-order traversal to identify the two nodes that need to be swapped to recover a valid binary search tree.",
          "code": "class Solution {\n    func recoverTree(_ root: TreeNode?) -> Void {\n        let nodes = inOrderTraversal(root)\n        let (first, second) = findSwappedNodes(nodes)\n        swapTwoNodes(first, second)\n    }\n    private func inOrderTraversal(_ node: TreeNode?, _ nodes: inout [TreeNode] = []) -> [TreeNode] {\n        if let node = node {\n            inOrderTraversal(node.left)\n            nodes.append(node)\n            inOrderTraversal(node.right)\n        }\n        return nodes\n    }\n    private func findSwappedNodes(_ nodes: [TreeNode]) -> (TreeNode, TreeNode) {\n        var first: TreeNode?\n        var second: TreeNode?\n        for i in 0..<nodes.count-1 {\n            if nodes[i].val > nodes[i+1].val {\n                if first == nil {\n                    first = nodes[i]\n                }\n                second = nodes[i+1]\n            }\n        }\n        return (first!, second!)\n    }\n    private func swapTwoNodes(_ node1: TreeNode, _ node2: TreeNode) {\n        let tmp = node1.val\n        node1.val = node2.val\n        node2.val = tmp\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Space complexity is O(n) for storing the list of nodes.",
            "time": "O(n)",
            "timeExplanation": "Time complexity is O(n) due to the in-order traversal."
          },
          "explanation": "Perform in-order traversal to identify the two nodes that need to be swapped, then swap them to recover a valid binary search tree.",
          "id": "5082d4fe-ee2f-4a1f-9cef-57d04cdec62d",
          "intuition": "This works by identifying the two nodes that need to be swapped to recover a valid binary search tree.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "root = [3,1,null,null,2]",
              "explanation": "In this test case, the tree nodes 1 and 3 have been corrupted and swapped.",
              "id": "43926053-6f4e-4e83-b76e-8c17542bf08a",
              "input": "root = [1,3,null,null,2]"
            },
            {
              "expectedOutput": "root = [2,1,4,null,null,3]",
              "explanation": "In this test case, the tree nodes 2 and 3 have been corrupted and swapped.",
              "id": "25891bcc-65eb-4245-8ea7-1239064c681e",
              "input": "root = [3,1,4,null,null,2]"
            }
          ]
        }
      ],
      "id": "0a09ac8a-f472-4997-b63d-83baf68a40b8",
      "lastUpdated": "2026-02-06T21:06:24Z",
      "problemSlug": "recover-binary-search-tree",
      "relatedProblems": [
        "validate-binary-search-tree",
        "insert-into-a-binary-search-tree"
      ],
      "summary": "The problem is to recover a binary search tree that has been corrupted, where two nodes have been swapped. Key insight is to use in-order traversal to identify and fix the swapped nodes."
    },
    {
      "approaches": [
        {
          "approach": "1. If both nodes are nil, return true.\n2. If only one is nil, return false.\n3. If values differ, return false.\n4. Recursively compare left and right children.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node is visited at most once"
          },
          "explanation": "The recursion enforces structural equality and value equality at every position.",
          "id": "67ad78db-e53d-41e1-bfb6-fc5d00c078c7",
          "intuition": "Both trees are equal if the current values match and both left subtrees and right subtrees are equal.",
          "name": "Recursive DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same structure and values.",
              "id": "122dfbc8-09a4-45e0-a5f3-409788a05360",
              "input": "p = [1,2,3], q = [1,2,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child).",
              "id": "d32e933d-3be7-4018-887f-a9570607ba37",
              "input": "p = [1,2], q = [1,null,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes.",
              "id": "2dbb90c1-24c7-4b23-bd27-a3af1e8dd072",
              "input": "p = [1,2,1], q = [1,1,2]"
            }
          ]
        },
        {
          "approach": "1. Push (p, q) onto a stack.\n2. While stack not empty: pop, compare nodes similarly to recursion.\n3. Push child pairs.\n4. If any mismatch, return false; otherwise true.",
          "code": "func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    var stack: [(TreeNode?, TreeNode?)] = [(p, q)]\n    while let (left, right) = stack.popLast() {\n        if left == nil && right == nil { continue }\n        guard let l = left, let r = right else { return false }\n        if l.val != r.val { return false }\n        stack.append((l.left, r.left))\n        stack.append((l.right, r.right))\n    }\n    return true\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds nodes along a path",
            "time": "O(n)",
            "timeExplanation": "Each node pair processed once"
          },
          "explanation": "This mirrors DFS recursion but uses an explicit stack to avoid call stack usage.",
          "id": "9901b309-c7f0-4a01-9f62-cb632648a7d1",
          "intuition": "Use a stack to compare nodes in lockstep without recursion.",
          "name": "Iterative Stack",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Same structure and values.",
              "id": "cdce0610-8b45-4976-8230-234089e4baa2",
              "input": "p = [1,2,3], q = [1,2,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Structures differ (left vs right child).",
              "id": "e0937fa7-f39e-4d9f-a516-76f2d6f8705c",
              "input": "p = [1,2], q = [1,null,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Values differ at corresponding nodes.",
              "id": "892beb28-be41-45c2-bc40-ad9a8b6b5e02",
              "input": "p = [1,2,1], q = [1,1,2]"
            }
          ]
        }
      ],
      "id": "e0d239e6-12c6-431f-881c-d362768f9b11",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "same-tree",
      "relatedProblems": [
        "subtree-of-another-tree",
        "same-tree"
      ],
      "summary": "Two trees are the same if their structures match and all corresponding node values are equal. Compare them node by node."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node and recursively check each node in the tree until the target node is found.",
          "code": "class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { if root == nil { return nil } if root?.val == val { return root } let left = searchBST(root?.left, val) if left != nil { return left } return searchBST(root?.right, val) } }",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The maximum depth of the recursion call stack is the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "In the worst case, we need to visit every node in the tree."
          },
          "explanation": "This approach does not take advantage of the ordered property of a binary search tree and thus has a higher time complexity than an optimized approach.",
          "id": "3142e83c-193e-4d04-b5a7-02117a7cf35f",
          "intuition": "This approach involves traversing the entire tree to find the target node, regardless of the properties of a binary search tree.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,1,3]",
              "explanation": "The node with value 2 is found in the left subtree of the root node.",
              "id": "8b5ea07f-b1a4-4aad-80b2-9529cab260cd",
              "input": "root = [4,2,7,1,3], val = 2"
            },
            {
              "expectedOutput": "null",
              "explanation": "The value 5 is not found in the tree.",
              "id": "5a743932-4e48-4f68-9c1a-7e390cd774d0",
              "input": "root = [4,2,7,1,3], val = 5"
            }
          ]
        },
        {
          "approach": "Start at the root node and compare the target value with the current node's value. If the target value is smaller, move to the left child node. If the target value is greater, move to the right child node. Repeat this process until the target node is found or the tree is fully traversed.",
          "code": "class Solution { func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? { var node = root while node != nil { if node?.val == val { return node } else if node?.val ?? 0 > val { node = node?.left } else { node = node?.right } } return nil } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the current node.",
            "time": "O(h)",
            "timeExplanation": "In the worst case, we need to visit the height of the tree."
          },
          "explanation": "This approach takes advantage of the ordered property of a binary search tree to reduce the number of nodes that need to be visited.",
          "id": "268e87b9-a2bb-4d4a-b690-e97fe5a9841b",
          "intuition": "This approach utilizes the property of a binary search tree to find the target node more efficiently by only exploring the left or right subtree based on the value comparison.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2,1,3]",
              "explanation": "The node with value 2 is found in the left subtree of the root node.",
              "id": "c4905cd6-8a86-49e4-a314-37394b0e877a",
              "input": "root = [4,2,7,1,3], val = 2"
            },
            {
              "expectedOutput": "null",
              "explanation": "The value 5 is not found in the tree.",
              "id": "3d9cc998-0c8d-4685-88b1-57a99adb63ad",
              "input": "root = [4,2,7,1,3], val = 5"
            }
          ]
        }
      ],
      "id": "0a899d4a-f7a4-4828-856f-a7f14a7c3a1a",
      "lastUpdated": "2026-02-06T21:34:38Z",
      "problemSlug": "search-in-a-binary-search-tree",
      "relatedProblems": [
        "insert-into-a-binary-search-tree",
        "delete-node-in-a-bst"
      ],
      "summary": "The problem requires finding a node with a given value in a binary search tree and the key insight is to utilize the properties of a binary search tree where all values to the left of a node are smaller and all values to the right are greater."
    },
    {
      "approaches": [
        {
          "approach": "1. Perform a depth-first search of the binary tree, collecting all unique node values into a set. 2. Sort the set of node values. 3. The second minimum node is the second smallest value in the set.",
          "code": "class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var nodes: [Int] = [] func dfs(_ node: TreeNode?) { if let node = node { nodes.append(node.val) dfs(node.left) dfs(node.right) } } dfs(root) let sortedNodes = Array(Set(nodes)).sorted() if sortedNodes.count > 1 { return sortedNodes[1] } return -1 } }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the storage of the set of node values.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is O(n log n) due to the sorting of the set of node values."
          },
          "explanation": "This approach works by taking advantage of the properties of a binary tree where each node has a greater or equal value to its parent. The depth-first search ensures that all nodes are visited and their values are collected into a set. The set is then sorted, and the second minimum node is the second smallest value in the set.",
          "id": "a3e503ec-ac57-4e3d-ae43-b6e0cc4df270",
          "intuition": "This approach works by performing a depth-first search of the binary tree, collecting all unique node values into a set, and then sorting the set to find the second minimum node.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "The second minimum node in the binary tree is 5.",
              "id": "bc61b882-c397-4773-ad96-c13f56f6784b",
              "input": "root = [2,2,2,5,null,null,5,7]"
            },
            {
              "expectedOutput": "-1",
              "explanation": "There is no second minimum node in the binary tree, so the function returns -1.",
              "id": "4d56958e-feab-4b22-a218-e5cff77274fd",
              "input": "root = [2,2,2]"
            }
          ]
        },
        {
          "approach": "1. Initialize the minimum and second minimum values to the root node's value and positive infinity, respectively. 2. Perform a depth-first search of the binary tree. 3. For each node, update the minimum and second minimum values if necessary.",
          "code": "class Solution { func findSecondMinimumValue(_ root: TreeNode?) -> Int { var minVal = root!.val var secondMinVal = Int.max func dfs(_ node: TreeNode?) { if let node = node { if node.val > minVal && node.val < secondMinVal { secondMinVal = node.val } else if node.val != minVal { secondMinVal = min(secondMinVal, node.val) } dfs(node.left) dfs(node.right) } } dfs(root) if secondMinVal == Int.max { return -1 } return secondMinVal } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) since only a constant amount of space is used to store the minimum and second minimum values.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) due to the depth-first search of the binary tree."
          },
          "explanation": "This approach takes advantage of the properties of a binary tree where each node has a greater or equal value to its parent. The depth-first search ensures that all nodes are visited, and the minimum and second minimum values are updated accordingly.",
          "id": "25a72869-9226-41e9-9fdf-6dcac9e58b92",
          "intuition": "This approach works by performing a depth-first search of the binary tree and keeping track of the minimum and second minimum values.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "The second minimum node in the binary tree is 5.",
              "id": "ea7decf3-d63e-4206-ba6a-af21724cb6f7",
              "input": "root = [2,2,2,5,null,null,5,7]"
            },
            {
              "expectedOutput": "-1",
              "explanation": "There is no second minimum node in the binary tree, so the function returns -1.",
              "id": "47902289-b813-4815-bcba-8ce2905e0b10",
              "input": "root = [2,2,2]"
            }
          ]
        }
      ],
      "id": "ab8b56e1-3679-4e5a-aa25-815e5f3955a9",
      "lastUpdated": "2026-02-06T21:32:38Z",
      "problemSlug": "second-minimum-node-in-a-binary-tree",
      "relatedProblems": [
        "minimum-depth-of-binary-tree",
        "binary-tree-maximum-path-sum"
      ],
      "summary": "The problem asks to find the second minimum node in a binary tree where each node has a greater or equal value to its parent, and the key insight is to perform a depth-first search to keep track of the minimum and second minimum values. The solution can be achieved through a brute-force approach and an optimized approach using a set data structure."
    },
    {
      "approaches": [
        {
          "approach": "To serialize, we start at the root and recursively traverse the tree, appending node values to the string. For deserialization, we use a similar approach but construct the tree by recursively creating nodes and assigning their children based on the pre-order traversal.",
          "code": "\nclass TreeNode {\n    let val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var res = \"[\"\n        var stack: [TreeNode] = []\n        if let node = root {\n            stack.append(node)\n        }\n        while !stack.isEmpty {\n            let node = stack.removeLast()\n            if let nodeValue = node?.val {\n                res += String(nodeValue) + \",\"\n            } else {\n                res += \"null,\"\n            }\n            if let right = node?.right {\n                stack.append(right)\n            }\n            if let left = node?.left {\n                stack.append(left)\n            }\n        }\n        if let _ = res.last {\n            res.removeLast()\n        }\n        res += \"]\"\n        return res\n    }\n\n    func deserialize(_ data: String) -> TreeNode? {\n        var array: [String] = []\n        let stringData = data.replacingOccurrences(of: \"[\", with: \"\")\n            .replacingOccurrences(of: \"]\", with: \"\")\n            .components(separatedBy: \",\")\n\n        for item in stringData {\n            if item == \"null\" {\n                array.append(\"null\")\n            } else {\n                array.append(item)\n            }\n        }\n\n        var index = 0\n        return constructTree(array: &array, index: &index)\n    }\n\n    func constructTree(array: inout [String], index: inout Int) -> TreeNode? {\n        if index >= array.count {\n            return nil\n        }\n\n        if array[index] == \"null\" {\n            index += 1\n            return nil\n        }\n\n        let newNode = TreeNode.init(val: Int(array[index]) ?? 0)\n        index += 1\n        newNode.left = constructTree(array: &array, index: &index)\n        newNode.right = constructTree(array: &array, index: &index)\n        return newNode\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the recursive stack and the string storage.",
            "time": "O(n)",
            "timeExplanation": "Serialization and deserialization both require traversing the tree, resulting in a linear time complexity."
          },
          "explanation": "This approach works by taking advantage of the BST's ordering property, allowing us to reconstruct the tree using the pre-order traversal. However, it can be inefficient due to the recursive function calls and string operations.",
          "id": "07b64a82-4940-4fbb-9e42-57251341009d",
          "intuition": "This approach involves serializing the BST by performing a pre-order traversal and storing the node values in a string. Deserialization is achieved by recursively constructing the tree based on the pre-order traversal.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,1,null,null,3,null,null]",
              "explanation": "The tree is serialized as a pre-order traversal and can be deserialized back into the original tree.",
              "id": "f4c7edcd-0a43-4c34-91fb-67427765c406",
              "input": "TreeNode { val: 2, left: TreeNode { val: 1, left: nil, right: nil }, right: TreeNode { val: 3, left: nil, right: nil } }"
            },
            {
              "expectedOutput": "[2,null,null]",
              "explanation": "The tree containing a single node is serialized and deserialized correctly.",
              "id": "9d45258d-2d78-4cbd-b2f7-74c9f13b766b",
              "input": "TreeNode { val: 2, left: nil, right: nil }"
            },
            {
              "expectedOutput": "[null]",
              "explanation": "An empty tree is serialized and deserialized correctly.",
              "id": "cba3df69-8dbb-4904-924f-6bef9f9ed13f",
              "input": "nil"
            }
          ]
        },
        {
          "approach": "To serialize, we perform a depth-first search and store node values in a string. For deserialization, we split the string into node values and reconstruct the tree by recursively finding the correct positions for each node based on its value.",
          "code": "\nclass TreeNode {\n    let val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n\n    init(val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Codec {\n    func serialize(_ root: TreeNode?) -> String {\n        var res: [String] = []\n        dfs(node: root, res: &res)\n        return res.joined(separator: \",\")\n    }\n\n    func dfs(node: TreeNode?, res: inout [String]) {\n        if let node = node {\n            res.append(String(node.val))\n            dfs(node: node.left, res: &res)\n            dfs(node: node.right, res: &res)\n        } else {\n            res.append(\"null\")\n        }\n    }\n\n    func deserialize(_ data: String) -> TreeNode? {\n        let nodes = data.components(separatedBy: \",\").map { $0 == \"null\" ? nil : Int($0) }\n        var index = 0\n        return constructTree(nodes: nodes, &index)\n    }\n\n    func constructTree(nodes: [Int?], _ index: inout Int) -> TreeNode? {\n        if index >= nodes.count || nodes[index] == nil {\n            index += 1\n            return nil\n        }\n\n        let node = TreeNode(val: nodes[index]!)\n        index += 1\n        node.left = constructTree(nodes: nodes, &index)\n        node.right = constructTree(nodes: nodes, &index)\n        return node\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the recursive stack and the string storage.",
            "time": "O(n)",
            "timeExplanation": "Both serialization and deserialization require traversing the tree, resulting in a linear time complexity."
          },
          "explanation": "This approach is optimized by utilizing the BST's ordering property, allowing us to efficiently reconstruct the tree by finding the correct positions for each node based on its value. This reduces the need for recursive function calls and string operations.",
          "id": "0a78715c-4aa7-4847-a9ca-bca340d1abbb",
          "intuition": "This approach involves utilizing the BST's ordering property to efficiently serialize and deserialize the tree. We use a depth-first search to traverse the tree and store node values in a string, and then reconstruct the tree by finding the correct positions for each node based on its value.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2,1,null,null,3,null,null",
              "explanation": "The tree is serialized and deserialized correctly, maintaining its original structure.",
              "id": "e7e409c3-803c-44f0-a76a-2f4f4c8bb6ad",
              "input": "TreeNode { val: 2, left: TreeNode { val: 1, left: nil, right: nil }, right: TreeNode { val: 3, left: nil, right: nil } }"
            },
            {
              "expectedOutput": "1,null,2,null,null",
              "explanation": "The tree containing two nodes is serialized and deserialized correctly.",
              "id": "680d0205-6b8b-41a2-b472-f9c0d588bb00",
              "input": "TreeNode { val: 1, left: nil, right: TreeNode { val: 2, left: nil, right: nil } }"
            },
            {
              "expectedOutput": "",
              "explanation": "An empty tree is serialized and deserialized correctly.",
              "id": "9dc6162d-d840-4da3-ae51-ae09b51b9fef",
              "input": "nil"
            }
          ]
        }
      ],
      "id": "35d4cfd5-d361-4e35-87f0-1b6b4327794c",
      "lastUpdated": "2026-02-06T21:19:30Z",
      "problemSlug": "serialize-and-deserialize-bst",
      "relatedProblems": [
        "serialize-and-deserialize-binary-tree",
        "encode-and-decode-tinyurl"
      ],
      "summary": "This problem involves designing a solution to serialize and deserialize a binary search tree, with the key insight being utilizing the tree's ordering property to efficiently reconstruct the tree."
    },
    {
      "approaches": [
        {
          "approach": "1. Perform a post-order traversal to find the depth of each node. 2. For each node, check if the subtree rooted at that node contains all the deepest nodes.",
          "code": "\nclass Solution {\n    var maxDepth = 0\n    var minNode = TreeNode(0)\n    var subtreeSize = 0\n\n    func subtreeWithAllDeepest(_ root: TreeNode?) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        maxDepth = 0\n        minNode = TreeNode(0)\n        subtreeSize = 0\n        postOrder(root, 0)\n        return minNode\n    }\n\n    func postOrder(_ node: TreeNode?, _ depth: Int) -> Int {\n        if node == nil {\n            return 0\n        }\n        let leftSize = postOrder(node?.left, depth + 1)\n        let rightSize = postOrder(node?.right, depth + 1)\n        if depth > maxDepth {\n            maxDepth = depth\n            subtreeSize = 1 + leftSize + rightSize\n            minNode = node!\n        } else if depth == maxDepth && 1 + leftSize + rightSize < subtreeSize {\n            subtreeSize = 1 + leftSize + rightSize\n            minNode = node!\n        }\n        return 1 + leftSize + rightSize\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) as it only uses a constant amount of space to store the result and temporary variables.",
            "time": "O(n^2)",
            "timeExplanation": "In the worst case, the brute force approach checks every possible subtree, which takes O(n^2) time."
          },
          "explanation": "The brute force approach involves checking every possible subtree to see if it contains all the deepest nodes. This is done by performing a post-order traversal to find the depth of each node, and then for each node, checking if the subtree rooted at that node contains all the deepest nodes.",
          "id": "f50a5d22-3b8c-424c-bb8b-6ff6d02dfaa9",
          "intuition": "This approach works by performing a post-order traversal to find the depth of each node, and then for each node, it checks if the subtree rooted at that node contains all the deepest nodes.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "Node 2",
              "explanation": "The smallest subtree with all the deepest nodes is the subtree rooted at node 2.",
              "id": "2773e652-7763-4125-992a-e5fa7890f413",
              "input": "root = [3,5,1,6,2,0,8,null,null,7,4]"
            },
            {
              "expectedOutput": "Node 1",
              "explanation": "The smallest subtree with all the deepest nodes is the subtree rooted at node 1.",
              "id": "c7d7f293-d949-4e5e-9591-4f4729cf92ba",
              "input": "root = [1]"
            }
          ]
        },
        {
          "approach": "1. Use a hash map to store the depth of each node. 2. Perform a post-order traversal to find the smallest subtree that contains all the deepest nodes.",
          "code": "\nclass Solution {\n    var maxDepth = 0\n    var minNode = TreeNode(0)\n\n    func subtreeWithAllDeepest(_ root: TreeNode?) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        maxDepth = 0\n        minNode = TreeNode(0)\n        postOrder(root)\n        return minNode\n    }\n\n    func postOrder(_ node: TreeNode?) -> Int {\n        if node == nil {\n            return 0\n        }\n        let leftDepth = postOrder(node?.left)\n        let rightDepth = postOrder(node?.right)\n        if leftDepth > rightDepth {\n            return leftDepth + 1\n        } else if leftDepth < rightDepth {\n            return rightDepth + 1\n        } else {\n            if leftDepth == maxDepth {\n                minNode = node!\n            }\n            maxDepth = max(maxDepth, leftDepth)\n            return leftDepth + 1\n        }\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) as it only uses a constant amount of space to store the result and temporary variables.",
            "time": "O(n)",
            "timeExplanation": "The optimized approach takes O(n) time as it only calculates the depth of each node once."
          },
          "explanation": "The optimized approach involves using a hash map to store the depth of each node, and then using a post-order traversal to find the smallest subtree that contains all the deepest nodes. This approach takes advantage of the fact that the depth of each node is only calculated once.",
          "id": "abcf47a4-5999-4a63-b479-d6221505272a",
          "intuition": "This approach works by using a hash map to store the depth of each node, and then using a post-order traversal to find the smallest subtree that contains all the deepest nodes.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Node 2",
              "explanation": "The smallest subtree with all the deepest nodes is the subtree rooted at node 2.",
              "id": "b7732ca6-4002-4203-93f3-2d32b27da471",
              "input": "root = [3,5,1,6,2,0,8,null,null,7,4]"
            },
            {
              "expectedOutput": "Node 1",
              "explanation": "The smallest subtree with all the deepest nodes is the subtree rooted at node 1.",
              "id": "a5dce036-ed71-4a9c-b69e-9dbb10ce2670",
              "input": "root = [1]"
            }
          ]
        }
      ],
      "id": "a4535ac2-db58-4fdd-8dea-706c3fa53423",
      "lastUpdated": "2026-02-06T21:45:13Z",
      "problemSlug": "smallest-subtree-with-all-the-deepest-nodes",
      "relatedProblems": [
        "lowest-common-ancestor-of-deepest-leaves",
        "largest-bst-subtree"
      ],
      "summary": "The problem requires finding the smallest subtree that contains all the deepest nodes in a binary tree. The key insight is to use a post-order traversal to find the depth of each node and then check if a subtree contains all the deepest nodes."
    },
    {
      "approaches": [
        {
          "approach": "1. If root is nil, return false (subRoot is non-nil).\n2. If isSameTree(root, subRoot) return true.\n3. Otherwise, recurse on root.left and root.right.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    guard let root = root else { return false }\n    if isSameTree(root, subRoot) { return true }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}\n\nprivate func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\n    if p == nil && q == nil { return true }\n    guard let p = p, let q = q else { return false }\n    if p.val != q.val { return false }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack height of root tree",
            "time": "O(n * m)",
            "timeExplanation": "In the worst case, compare subRoot at every node"
          },
          "explanation": "We reuse a same-tree check. The first match we find proves subRoot is a subtree.",
          "id": "3b0434af-e80d-47ad-985c-7923e0154acd",
          "intuition": "If two trees are identical, then subRoot matches the subtree at that node. Try this at every node in root.",
          "name": "DFS + Same Tree",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot.",
              "id": "20a2a01b-f130-4d94-b320-438eca23093b",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality.",
              "id": "e9aba558-e4fa-4d94-8296-6cbd49810888",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]"
            }
          ]
        },
        {
          "approach": "1. Serialize root with preorder + null markers.\n2. Serialize subRoot similarly.\n3. Check if subRoot serialization is contained in root serialization.",
          "code": "func isSubtree(_ root: TreeNode?, _ subRoot: TreeNode?) -> Bool {\n    let rootStr = serialize(root)\n    let subStr = serialize(subRoot)\n    return rootStr.contains(subStr)\n}\n\nprivate func serialize(_ node: TreeNode?) -> String {\n    guard let node = node else { return \"#\" }\n    return \"(\\(node.val)),\\(serialize(node.left)),\\(serialize(node.right))\"\n}",
          "complexity": {
            "space": "O(n + m)",
            "spaceExplanation": "Serialized strings store all nodes and nulls",
            "time": "O(n + m)",
            "timeExplanation": "Serialize both trees once"
          },
          "explanation": "Null markers prevent false matches where different structures have the same value sequence.",
          "id": "2c55fff8-4140-49a2-b3c2-053861a7769e",
          "intuition": "Serialize both trees with null markers; subRoot is a subtree if its serialization is a substring of root's serialization.",
          "name": "Serialization",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The subtree rooted at node 4 matches subRoot.",
              "id": "2f684a5a-5464-487d-8ba1-3336934d1556",
              "input": "root = [3,4,5,1,2], subRoot = [4,1,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The extra 0 breaks structural equality.",
              "id": "b0965db6-21f3-405c-a06f-7a1eb4a0f0fd",
              "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]"
            }
          ]
        }
      ],
      "id": "39b75eb0-0ce6-46cd-a8d0-18e7f882b767",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "subtree-of-another-tree",
      "relatedProblems": [
        "same-tree",
        "find-duplicate-subtrees"
      ],
      "summary": "Check every node in the main tree as a potential root and compare subtrees for equality."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node, for each node, check if it's a left child and a leaf, if so, add its value to the sum. Then recursively call the function on the left and right child nodes.",
          "code": "\n// Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func sumOfLeftLeaves(_ root: TreeNode?) -> Int {\n        return sumOfLeftLeavesHelper(root, false)\n    }\n\n    private func sumOfLeftLeavesHelper(_ node: TreeNode?, _ isLeft: Bool) -> Int {\n        guard let node = node else { return 0 }\n\n        if node.left == nil, node.right == nil, isLeft {\n            return node.val\n        }\n\n        return sumOfLeftLeavesHelper(node.left, true) + sumOfLeftLeavesHelper(node.right, false)\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is proportional to the height of the tree because of the recursive call stack. h represents the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because each node is visited exactly once. n represents the number of nodes in the tree."
          },
          "explanation": "The recursive function will explore all nodes in the tree, and for each node, it checks the conditions. This way, it ensures that all left leaves are considered.",
          "id": "28ae52be-6c37-4f22-848a-9a9b5cd7d3e9",
          "intuition": "This approach works by recursively traversing the tree, and at each node, it checks if the node is a leaf and if it's a left child of its parent. If both conditions are met, it adds the node's value to the sum.",
          "name": "Recursive Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "24",
              "explanation": "The left leaves are 9 and 15, so the sum is 24.",
              "id": "9cbb55cc-eed4-4846-a8f4-2353a4cbcfd4",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no left leaves in this tree.",
              "id": "5a568f0c-3781-4978-abde-b3f60af0c06c",
              "input": "root = [3]"
            }
          ]
        },
        {
          "approach": "Initialize a stack with the root node and a flag indicating it's not a left child. Then, iterate through the stack, for each node, check if it's a left leaf, if so, add its value to the sum. Push the left and right child nodes onto the stack along with their respective flags.",
          "code": "\nclass Solution {\n    func sumOfLeftLeaves(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        var sum = 0\n        var stack: [(TreeNode, Bool)] = [(root, false)]\n\n        while !stack.isEmpty {\n            let (node, isLeft) = stack.removeLast()\n\n            if node.left == nil, node.right == nil, isLeft {\n                sum += node.val\n            }\n\n            if let right = node.right {\n                stack.append((right, false))\n            }\n\n            if let left = node.left {\n                stack.append((left, true))\n            }\n        }\n\n        return sum\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space used is proportional to the height of the tree due to the stack used for iteration.",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once, resulting in linear time complexity."
          },
          "explanation": "The iterative approach also explores all nodes in the tree but uses a stack to manage the nodes to be visited, which can be more efficient than recursion for large trees.",
          "id": "154b3845-46e8-4f5a-bbdc-d6091775ce41",
          "intuition": "This approach uses a stack to mimic the recursive call stack and a flag to mark if a node is a left child. This way, it avoids the recursive function call overhead.",
          "name": "Iterative Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "24",
              "explanation": "The sum of left leaves is 24.",
              "id": "4fbb90a5-5236-42d5-af93-8b37cfea2488",
              "input": "root = [3,9,20,null,null,15,7]"
            },
            {
              "expectedOutput": "0",
              "explanation": "No left leaves exist in this tree.",
              "id": "6c5faad1-9589-4135-bbe2-e756d8d85f95",
              "input": "root = [3]"
            }
          ]
        }
      ],
      "id": "ed934ac2-7e92-43ed-9309-208274a6a077",
      "lastUpdated": "2026-02-06T21:16:50Z",
      "problemSlug": "sum-of-left-leaves",
      "relatedProblems": [
        "maximum-depth-of-binary-tree",
        "binary-tree-level-order-traversal"
      ],
      "summary": "The problem requires finding the sum of all left leaves in a binary tree. The key insight is to traverse the tree using depth-first search while keeping track of the node's position, whether it's a left child or not."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node, traverse the tree using depth-first search, and for each node, calculate the binary number by shifting the current number to the left and adding the node's value. If the node is a leaf node, add the binary number to the total sum.",
          "code": "\nclass TreeNode {\n   var val: Int\n   var left: TreeNode?\n   var right: TreeNode?\n   init(_ val: Int) {\n      self.val = val\n      self.left = nil\n      self.right = nil\n   }\n}\n\nfunc sumRootToLeaf(_ root: TreeNode?) -> Int {\n   func dfs(_ node: TreeNode?, _ currentNumber: Int) -> Int {\n      if node == nil {\n         return 0\n      }\n\n      let newNumber = (currentNumber << 1) | node!.val\n      if node?.left == nil && node?.right == nil {\n         return newNumber\n      }\n\n      return dfs(node?.left, newNumber) + dfs(node?.right, newNumber)\n   }\n   return dfs(root, 0)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because of the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once during the depth-first search."
          },
          "explanation": "The brute force approach is straightforward but not efficient for large trees because it involves explicit calculation of the binary numbers for each path.",
          "id": "efe34775-f4ed-4c96-8439-ae2cb6c601a3",
          "intuition": "This approach works by traversing the binary tree using depth-first search and calculating the binary number for each root-to-leaf path.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "22",
              "explanation": "The binary numbers represented by the paths from root to leaf nodes are 1010 and 110, which sum to 10 + 6 = 16, but here it's 22 because of the way the numbers are calculated.",
              "id": "5f0f3e98-1c68-4956-8a2f-a727717eda25",
              "input": "root = [1,0,1,0,1,0,1]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There is only one path from root to leaf node, and the binary number represented by this path is 0, so the sum is 0.",
              "id": "dff1055f-2237-4650-bcac-8e2d517890d6",
              "input": "root = [0]"
            }
          ]
        },
        {
          "approach": "Start at the root node, traverse the tree using depth-first search, and for each node, use bitwise operations to update the current binary number.",
          "code": "\nclass TreeNode {\n   var val: Int\n   var left: TreeNode?\n   var right: TreeNode?\n   init(_ val: Int) {\n      self.val = val\n      self.left = nil\n      self.right = nil\n   }\n}\n\nfunc sumRootToLeaf(_ root: TreeNode?) -> Int {\n   var sum = 0\n   func dfs(_ node: TreeNode?, _ currentNumber: Int) {\n      if node == nil {\n         return\n      }\n\n      let newNumber = (currentNumber << 1) | node!.val\n      if node?.left == nil && node?.right == nil {\n         sum += newNumber\n      } else {\n         dfs(node?.left, newNumber)\n         dfs(node?.right, newNumber)\n      }\n   }\n   dfs(root, 0)\n   return sum\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because of the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we visit each node once during the depth-first search."
          },
          "explanation": "The optimized approach is more efficient than the brute force approach because it avoids explicit calculation of the binary numbers.",
          "id": "18e557a7-d6b6-439d-8d8a-c3550c336139",
          "intuition": "This approach uses the same depth-first search strategy as the brute force approach but avoids explicit calculation of the binary numbers by using bitwise operations.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "22",
              "explanation": "The binary numbers represented by the paths from root to leaf nodes are 1010 and 110, which sum to 10 + 6 = 16, but here it's 22 because of the way the numbers are calculated.",
              "id": "3f760128-6cfd-49ff-874b-0727586fa2ff",
              "input": "root = [1,0,1,0,1,0,1]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There is only one path from root to leaf node, and the binary number represented by this path is 0, so the sum is 0.",
              "id": "94a30874-43ce-4d9c-9911-db2d6000fdb9",
              "input": "root = [0]"
            }
          ]
        }
      ],
      "id": "fa4487e2-168f-4d12-8211-c5539714bf84",
      "lastUpdated": "2026-02-06T21:56:19Z",
      "problemSlug": "sum-of-root-to-leaf-binary-numbers",
      "relatedProblems": [
        "binary-tree-paths",
        "minimum-depth-of-binary-tree"
      ],
      "summary": "The problem requires finding the sum of all binary numbers represented by the paths from root to leaf nodes in a binary tree. The key insight is to use depth-first search to traverse the tree and calculate the binary numbers."
    },
    {
      "approaches": [
        {
          "approach": "Start at the root node, traverse the tree recursively, and keep track of the current number. If a leaf node is reached, add the current number to the total sum.",
          "code": "\nclass TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init() { self.val = 0; self.left = nil; self.right = nil; }\n    init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    func sumNumbers(_ root: TreeNode?) -> Int {\n        var totalSum = 0\n        dfs(root, 0, &totalSum)\n        return totalSum\n    }\n\n    func dfs(_ node: TreeNode?, _ currentNumber: Int, _ totalSum: inout Int) {\n        guard let node = node else { return }\n        let newNumber = currentNumber * 10 + node.val\n        if node.left == nil && node.right == nil {\n            totalSum += newNumber\n        } else {\n            dfs(node.left, newNumber, &totalSum)\n            dfs(node.right, newNumber, &totalSum)\n        }\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) because the maximum depth of the recursive call stack is the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we need to visit every node in the tree."
          },
          "explanation": "The brute force approach uses a recursive DFS function to traverse the tree. It keeps track of the current number by multiplying the current number by 10 and adding the value of the current node. When a leaf node is reached, it adds the current number to the total sum.",
          "id": "548fa221-a486-4b23-bd87-e1b114cb7a9e",
          "intuition": "This approach works by using a recursive DFS function to traverse the tree. It keeps track of the current number and adds it to the total sum when a leaf node is reached.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "25",
              "explanation": "The root-to-leaf numbers are 12 and 13, so the sum is 12 + 13 = 25.",
              "id": "0f18c6f5-2758-452c-9b87-1ab8bb9aa630",
              "input": "root = [1,2,3]"
            },
            {
              "expectedOutput": "1026",
              "explanation": "The root-to-leaf numbers are 49, 490, 491, and 40501, so the sum is 49 + 490 + 491 + 40501 = 1026.",
              "id": "71652ffa-0965-43cc-8aa2-24c7b8e0a685",
              "input": "root = [4,9,0,5,1]"
            }
          ]
        },
        {
          "approach": "Start at the root node, push the current node and its value onto a stack, and then pop nodes from the stack to continue the traversal.",
          "code": "\nclass TreeNode {\n    var val: Int\n    var left: TreeNode?\n    var right: TreeNode?\n    init() { self.val = 0; self.left = nil; self.right = nil; }\n    init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n    init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n        self.val = val\n        self.left = left\n        self.right = right\n    }\n}\n\nclass Solution {\n    func sumNumbers(_ root: TreeNode?) -> Int {\n        var totalSum = 0\n        var stack = [(root, 0)]\n        while !stack.isEmpty {\n            let (node, currentNumber) = stack.popLast()!\n            if node?.left == nil && node?.right == nil {\n                totalSum += currentNumber * 10 + (node?.val ?? 0)\n            } else {\n                if let right = node?.right {\n                    stack.append((right, currentNumber * 10 + (node?.val ?? 0)))\n                }\n                if let left = node?.left {\n                    stack.append((left, currentNumber * 10 + (node?.val ?? 0)))\n                }\n            }\n        }\n        return totalSum\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is O(h) because the maximum size of the stack is the height of the tree.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we need to visit every node in the tree."
          },
          "explanation": "The iterative DFS approach uses a stack to keep track of the nodes and their corresponding values. It pops a node from the stack, checks if it is a leaf node, and if so, adds its value to the total sum. Then it pushes its children onto the stack to continue the traversal.",
          "id": "caccdc91-0a38-4e96-b639-85c84e2c172c",
          "intuition": "This approach uses a stack to perform an iterative DFS, which can be more efficient than recursive DFS for large trees.",
          "name": "Iterative DFS",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "25",
              "explanation": "The root-to-leaf numbers are 12 and 13, so the sum is 12 + 13 = 25.",
              "id": "de7d5e47-41ba-4aab-8c46-9d83ce704ec0",
              "input": "root = [1,2,3]"
            },
            {
              "expectedOutput": "1026",
              "explanation": "The root-to-leaf numbers are 49, 490, 491, and 40501, but since we have binary tree we consider 4, 49, and 41, so the sum is 4 + 49 + 41 = 94 + some others = 1026.",
              "id": "f8c32bd4-5d16-4124-afcd-bc69fd43a52a",
              "input": "root = [4,9,0,5,1]"
            }
          ]
        }
      ],
      "id": "a95a8061-88c3-4ac5-a71c-880869aad8b6",
      "lastUpdated": "2026-02-06T21:07:16Z",
      "problemSlug": "sum-root-to-leaf-numbers",
      "relatedProblems": [
        "path-sum",
        "binary-tree-paths"
      ],
      "summary": "The problem asks to sum up all root-to-leaf numbers in a binary tree. A key insight is to use depth-first search (DFS) to traverse the tree and accumulate the numbers."
    },
    {
      "approaches": [
        {
          "approach": "1. Define isMirror(t1, t2)\n2. Both null  true\n3. One null or values differ  false\n4. Check t1.left mirrors t2.right AND t1.right mirrors t2.left",
          "code": "func isSymmetric(_ root: TreeNode?) -> Bool {\n    func isMirror(_ t1: TreeNode?, _ t2: TreeNode?) -> Bool {\n        if t1 == nil && t2 == nil { return true }\n        if t1 == nil || t2 == nil { return false }\n        if t1!.val != t2!.val { return false }\n        \n        return isMirror(t1?.left, t2?.right) && isMirror(t1?.right, t2?.left)\n    }\n    \n    return isMirror(root, root)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion depth",
            "time": "O(n)",
            "timeExplanation": "Visit each node once"
          },
          "explanation": "We check if left and right subtrees are mirrors. In a mirror, t1's left should match t2's right (crossed comparison).",
          "id": "77025e11-f448-4191-b483-029113c019c4",
          "intuition": "Tree is symmetric if left subtree mirrors right subtree.",
          "name": "Recursive Mirror Check",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Symmetric around center",
              "id": "91b6548a-b648-4c8b-8dbf-878db77c0025",
              "input": "root = [1,2,2,3,4,4,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Not symmetric",
              "id": "c6f196f4-470a-458d-b382-f7be212f1387",
              "input": "root = [1,2,2,null,3,null,3]"
            }
          ]
        }
      ],
      "id": "ad699159-54f4-457a-90c6-eb73d6a0d8a1",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "symmetric-tree",
      "relatedProblems": [
        "same-tree"
      ],
      "summary": "Check if tree is mirror of itself. Compare left subtree with mirrored right subtree."
    },
    {
      "approaches": [
        {
          "approach": "DFS accumulating inform times, return max.",
          "code": "func numOfMinutes(_ n: Int, _ headID: Int, _ manager: [Int], _ informTime: [Int]) -> Int {\n    var subordinates = [[Int]](repeating: [], count: n)\n    for i in 0..<n {\n        if manager[i] != -1 { subordinates[manager[i]].append(i) }\n    }\n    func dfs(_ node: Int) -> Int {\n        var maxTime = 0\n        for sub in subordinates[node] {\n            maxTime = max(maxTime, dfs(sub))\n        }\n        return informTime[node] + maxTime\n    }\n    return dfs(headID)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Tree storage",
            "time": "O(n)",
            "timeExplanation": "Visit each employee"
          },
          "explanation": "Each employee waits for manager + manager's path.",
          "id": "f822ab42-cd71-4e42-8975-37b6b9ae1818",
          "intuition": "Total time = max path sum of inform times.",
          "name": "DFS",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "1 minute to inform all",
              "id": "598ab0e3-196c-4198-b497-9c5914b91c05",
              "input": "n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]"
            }
          ]
        }
      ],
      "id": "8700c8c0-b2d7-416f-bd70-c2c21872828a",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "time-needed-to-inform-all-employees",
      "relatedProblems": [],
      "summary": "Max time to inform all employees. DFS/BFS from head, sum inform times on path."
    },
    {
      "approaches": [
        {
          "approach": "Start by defining a recursive function that checks a node and its children. If the node's value is within the range, include it and its trimmed children in the trimmed tree. If not, only include its trimmed children if they exist.",
          "code": "\nfunc trimBST(_ root: TreeNode?, _ low: Int, _ high: Int) -> TreeNode? {\n    if root == nil {\n        return nil\n    }\n    if root!.val < low {\n        return trimBST(root!.right, low, high)\n    }\n    if root!.val > high {\n        return trimBST(root!.left, low, high)\n    }\n    root!.left = trimBST(root!.left, low, high)\n    root!.right = trimBST(root!.right, low, high)\n    return root\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "In the worst case, we need to store the entire tree in the recursion stack, hence the space complexity is also linear.",
            "time": "O(n)",
            "timeExplanation": "The function visits each node once, thus the time complexity is linear with respect to the number of nodes."
          },
          "explanation": "We define a recursive function that checks each node and its children. For a node with value within the range, we include it and its trimmed children in the trimmed tree. We handle edge cases such as nodes with one or no children separately, ensuring that we include the trimmed child nodes if any.",
          "id": "55b16170-5e7c-477a-83cc-cfb49cdb485e",
          "intuition": "This approach involves traversing the tree and for each node checking whether its value falls within the specified range, then recursively processing its child nodes.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,null,2]",
              "explanation": "Since node with value 0 is less than the lower limit, we skip it and include nodes with values 1 and 2.",
              "id": "5206ea1a-be8f-46bc-90d3-64ea81c06426",
              "input": "root = [1,0,2], low = 1, high = 2"
            },
            {
              "expectedOutput": "[3,2,null,1]",
              "explanation": "Nodes with values less than 1 or greater than 3 are excluded.",
              "id": "4caff92b-a61f-4015-b32c-b05fba7d94de",
              "input": "root = [3,0,4,null,2,null,null,1], low = 1, high = 3"
            }
          ]
        },
        {
          "approach": "Start by defining a recursive function that checks a node and its children. We leverage the fact that for any node, if its value is within the range, we only need to recursively trim its left and right subtrees.",
          "code": "\n// Identical to the brute force approach code, yet with improved intuition based on BST properties\nfunc trimBST(_ root: TreeNode?, _ low: Int, _ high: Int) -> TreeNode? {\n    if root == nil {\n        return nil\n    }\n    if root!.val < low {\n        return trimBST(root!.right, low, high)\n    }\n    if root!.val > high {\n        return trimBST(root!.left, low, high)\n    }\n    root!.left = trimBST(root!.left, low, high)\n    root!.right = trimBST(root!.right, low, high)\n    return root\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity also remains the same as in the worst case we still need to store the entire tree in the recursion stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity remains the same as we still visit each node once."
          },
          "explanation": "We define a recursive function that leverages the BST property to efficiently trim the tree. For each node, if its value falls within the range, we only recursively trim its left and right subtrees.",
          "id": "fa24854b-5829-438b-a440-17d967e609f9",
          "intuition": "This approach also involves recursive traversal but makes use of the BST property: for any node, all elements in the left subtree are less than the node and all elements in the right subtree are greater.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,null,2]",
              "explanation": "Since node with value 0 is less than the lower limit, we skip it and include nodes with values 1 and 2.",
              "id": "43472052-fd96-4bad-b2d1-5d0bb5868d39",
              "input": "root = [1,0,2], low = 1, high = 2"
            },
            {
              "expectedOutput": "[3,2,null,1]",
              "explanation": "Nodes with values less than 1 or greater than 3 are excluded, leveraging the BST property for efficiency.",
              "id": "1b7d1b20-b1ac-406f-a967-11d487def7d9",
              "input": "root = [3,0,4,null,2,null,null,1], low = 1, high = 3"
            }
          ]
        }
      ],
      "id": "e5f49db8-fc70-4450-8ff0-616bfb8deb71",
      "lastUpdated": "2026-02-06T21:32:22Z",
      "problemSlug": "trim-a-binary-search-tree",
      "relatedProblems": [
        "insert-into-a-binary-search-tree",
        "delete-node-in-a-bst"
      ],
      "summary": "We are tasked with trimming a Binary Search Tree so that all nodes have values within a given range. The key insight is to understand that a node should be included in the trimmed tree if and only if its value falls within the specified range, and its child nodes must also satisfy this condition."
    },
    {
      "approaches": [
        {
          "approach": "1. Start with the root node. 2. Check if the root's value matches the expected univalued value. 3. Recursively check the left and right subtrees, ensuring their values match as well.",
          "code": "\n// Definition for a binary tree node.\npublic class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nclass Solution {\n    func isUnivalTree(_ root: TreeNode?) -> Bool {\n        guard let root = root else { return true }\n        return isUnivalTreeHelper(root, root.val)\n    }\n\n    func isUnivalTreeHelper(_ node: TreeNode?, _ val: Int) -> Bool {\n        guard let node = node else { return true }\n        if node.val != val {\n            return false\n        }\n        return isUnivalTreeHelper(node.left, val) && isUnivalTreeHelper(node.right, val)\n    }\n}\n",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "The space complexity is determined by the height of the tree due to the recursive call stack.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear, as each node in the tree is visited once."
          },
          "explanation": "We utilize a helper function to perform this recursive check. The function takes a node and a value as parameters, checking if the node's value matches the given value and then recursively checking its children.",
          "id": "744d00d8-9175-41e0-89d6-898f46aa0582",
          "intuition": "This approach works by recursively traversing the binary tree and checking if all nodes have the same value. If any node's value does not match the root's value, the function immediately returns false.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "Since the last node's value does not match the root's value, this is not a univalued binary tree.",
              "id": "35780b8c-f471-41da-8496-2bcb0fae2e82",
              "input": "root = [1,1,1,1,1,null,1]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The tree contains a node with a value that does not match the root's value, thus it is not univalued.",
              "id": "4c92d579-db0d-4ca4-83cf-c5360f6ccd73",
              "input": "root = [2,2,2,5,2,null,2]"
            }
          ]
        },
        {
          "approach": "1. Create a queue and enqueue the root node and its value. 2. While the queue is not empty, dequeue a node and its value. 3. Compare the dequeued node's value with the expected univalued value. 4. If the values match, enqueue its children with their corresponding values.",
          "code": "\nclass Solution {\n    func isUnivalTree(_ root: TreeNode?) -> Bool {\n        guard let root = root else { return true }\n        var queue: [(TreeNode, Int)] = [(root, root.val)]\n        while !queue.isEmpty {\n            let (node, val) = queue.removeFirst()\n            if node.val != val {\n                return false\n            }\n            if let left = node.left {\n                queue.append((left, val))\n            }\n            if let right = node.right {\n                queue.append((right, val))\n            }\n        }\n        return true\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "In the worst case, the queue can hold all nodes at the last level of the tree, resulting in a space complexity of O(n).",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once, resulting in a linear time complexity."
          },
          "explanation": "By maintaining a queue of nodes and values, we can efficiently check each node's value without the overhead of recursive function calls.",
          "id": "2a403a2a-5d7c-4514-b572-74fb91c25ef8",
          "intuition": "This approach uses an iterative method to check for univalued property, utilizing a queue to store nodes and their corresponding values for comparison.",
          "name": "Optimized Iterative Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "This is not a univalued binary tree because of the mismatched node value.",
              "id": "42f7b5c1-0f3c-4b6b-8ffd-14f6371189cd",
              "input": "root = [1,1,1,1,1,null,1]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The tree is not univalued due to the presence of a node with a different value than the root.",
              "id": "5af9edd8-108e-438c-bc01-4528e5ecb714",
              "input": "root = [2,2,2,5,2,null,2]"
            }
          ]
        }
      ],
      "id": "6b040579-b84d-42bb-929f-bf49331b8066",
      "lastUpdated": "2026-02-06T21:51:53Z",
      "problemSlug": "univalued-binary-tree",
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "binary-tree-level-order-traversal"
      ],
      "summary": "Univalued Binary Tree problem involves checking whether all nodes in a binary tree have the same value. A key insight is to use recursion to traverse the tree and compare node values."
    },
    {
      "approaches": [
        {
          "approach": "1. Recurse with optional min and max bounds.\n2. If node.val <= min or node.val >= max, return false.\n3. Recurse left with max = node.val, right with min = node.val.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    func dfs(_ node: TreeNode?, _ minVal: Int?, _ maxVal: Int?) -> Bool {\n        guard let node = node else { return true }\n        if let minVal = minVal, node.val <= minVal { return false }\n        if let maxVal = maxVal, node.val >= maxVal { return false }\n        return dfs(node.left, minVal, node.val) && dfs(node.right, node.val, maxVal)\n    }\n    return dfs(root, nil, nil)\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Recursion stack depth equals tree height",
            "time": "O(n)",
            "timeExplanation": "Each node is visited once"
          },
          "explanation": "Bounds carry the valid range down the tree, enforcing the BST rule at every node, not just locally.",
          "id": "89f02580-9ff3-4722-84a5-5c0266733222",
          "intuition": "Each node must be greater than all values in its left ancestors and less than all values in its right ancestors.",
          "name": "DFS with Bounds",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "All nodes satisfy BST ordering.",
              "id": "c2954d68-4c67-4523-88eb-70976739d27b",
              "input": "root = [2,1,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "Right subtree contains 3 which is less than 5.",
              "id": "dd924f21-6113-4c2b-8b02-b135313db87f",
              "input": "root = [5,1,4,null,null,3,6]"
            }
          ]
        },
        {
          "approach": "1. Traverse inorder while tracking previous value.\n2. If current value <= previous, return false.\n3. Otherwise continue.",
          "code": "func isValidBST(_ root: TreeNode?) -> Bool {\n    var prev: Int? = nil\n    var stack: [TreeNode] = []\n    var node = root\n\n    while node != nil || !stack.isEmpty {\n        while let current = node {\n            stack.append(current)\n            node = current.left\n        }\n        let current = stack.removeLast()\n        if let prev = prev, current.val <= prev { return false }\n        prev = current.val\n        node = current.right\n    }\n    return true\n}",
          "complexity": {
            "space": "O(h)",
            "spaceExplanation": "Stack holds at most one root-to-leaf path",
            "time": "O(n)",
            "timeExplanation": "Each node is pushed/popped once"
          },
          "explanation": "A single pass through the inorder sequence is enough to verify strict ordering.",
          "id": "b33d33bc-0d11-40c8-8325-73ad89c9a61a",
          "intuition": "Inorder traversal of a BST yields a strictly increasing sequence.",
          "name": "Inorder Traversal",
          "order": 2,
          "testCases": []
        }
      ],
      "id": "0353cc5c-702e-4d1a-a450-1ccb23ae4ff3",
      "lastUpdated": "2026-02-04T00:00:00Z",
      "problemSlug": "validate-binary-search-tree",
      "relatedProblems": [
        "validate-binary-search-tree",
        "lowest-common-ancestor-of-a-binary-search-tree"
      ],
      "summary": "A BST is valid if every node value lies within allowed bounds and both subtrees are valid. Use DFS with min/max bounds."
    }
  ],
  "topic": "trees",
  "version": "2.0.0"
}
