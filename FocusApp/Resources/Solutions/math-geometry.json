{
  "solutions": [
    {
      "approaches": [
        {
          "approach": "We use iteration and recursion to generate all possible sequences and evaluate their lengths",
          "code": "func minSteps(_ n: Int) -> Int {\n    var dp = [Int](repeating: n + 1, count: n + 1)\n    dp[1] = 0\n    for i in 2...n {\n        dp[i] = i\n        for j in 2...i {\n            if i % j == 0 {\n                dp[i] = min(dp[i], dp[j] + i / j)\n            }\n        }\n    }\n    return dp[n]\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use an array of size n to store the dynamic programming table",
            "time": "O(n^2)",
            "timeExplanation": "We have a nested loop structure, where the outer loop runs in n time and the inner loop also runs in n time"
          },
          "explanation": "This solution involves generating all possible sequences and selecting the shortest one, with the understanding that the time complexity will be high due to the nature of brute-force methods",
          "id": "973e3ec2-6ab2-4178-9ae8-847ae54aa3e0",
          "intuition": "We test all possible sequences of operations to find the minimum number of operations required",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "We can produce 3 'A's using the sequence: Insert 'A', Insert 'A', Insert 'A'",
              "id": "f439ef00-8e28-4f5e-ba0d-cf1dd63d5985",
              "input": "n = 3"
            },
            {
              "expectedOutput": "5",
              "explanation": "We can produce 6 'A's using the sequence: Insert 'A', Insert 'A', Copy-Paste 'AA', Copy-Paste 'AAAA'",
              "id": "abfadfe2-d4c4-433e-a238-1555e476d774",
              "input": "n = 6"
            }
          ]
        },
        {
          "approach": "We start with 1 'A' and 0 operations, then we use a queue to generate all possible states and update the number of operations",
          "code": "func minSteps(_ n: Int) -> Int {\n    var queue = [(Int, Int)]()\n    queue.append((1, 0))\n    var visited = Set<Int>()\n    visited.insert(1)\n    while !queue.isEmpty {\n        let (curr, steps) = queue.removeFirst()\n        if curr == n {\n            return steps\n        }\n        for i in 2...curr {\n            if curr * i <= n && !visited.contains(curr * i) {\n                queue.append((curr * i, steps + i))\n                visited.insert(curr * i)\n            }\n        }\n        if curr + 1 <= n && !visited.contains(curr + 1) {\n            queue.append((curr + 1, steps + 1))\n            visited.insert(curr + 1)\n        }\n    }\n    return -1\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use a queue and a set to store the current states, which requires O(n) space",
            "time": "O(n)",
            "timeExplanation": "We use a queue to generate all possible states, and we use a set to keep track of visited states to avoid redundant calculations"
          },
          "explanation": "We use a queue to keep track of the current number of 'A's and the number of operations, which allows us to avoid redundant calculations and reduce the time complexity",
          "id": "7ebde33d-da50-4810-bf4f-183cab363a73",
          "intuition": "We can solve the problem more efficiently by using a queue to store the current number of 'A's and the number of operations",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "We can produce 3 'A's using the sequence: Insert 'A', Insert 'A', Insert 'A'",
              "id": "84452464-81ee-4898-81ba-655d2ecb1a51",
              "input": "n = 3"
            },
            {
              "expectedOutput": "5",
              "explanation": "We can produce 6 'A's using the sequence: Insert 'A', Insert 'A', Copy-Paste 'AA', Copy-Paste 'AAAA'",
              "id": "973c218b-aeee-4b85-b893-e1019f7dbf7c",
              "input": "n = 6"
            }
          ]
        }
      ],
      "id": "ad6cda0e-5017-41c5-98f7-fe85253536ce",
      "lastUpdated": "2026-02-06T21:31:00Z",
      "problemSlug": "2-keys-keyboard",
      "relatedProblems": [
        "construct-target-array-with-multiple-sums",
        "minimum-number-of-days-to-make-it-through-digestive-issues"
      ],
      "summary": "The problem requires determining the minimum number of operations to produce the string of n 'A's using only two operations: 'A' insertion and the copy-paste operation. The key insight is that we can use dynamic programming to find the optimal sequence of operations."
    },
    {
      "approaches": [
        {
          "approach": "1. Convert binary strings to arrays or lists, 2. Initialize an empty result string and a carry variable, 3. Iterate over the binary arrays from right to left, 4. Add corresponding bits and the carry, 5. Update the result and carry",
          "code": "\nfunc addBinary(_ a: String, _ b: String) -> String {\n   var aArray = Array(a)\n   var bArray = Array(b)\n   var result = \"\"\n   var carry = 0\n\n   while !aArray.isEmpty || !bArray.isEmpty || carry > 0 {\n      var sum = carry\n      if !aArray.isEmpty {\n         sum += Int(String(aArray.removeLast()))!\n      }\n      if !bArray.isEmpty {\n         sum += Int(String(bArray.removeLast()))!\n      }\n\n      result = String(sum % 2) + result\n      carry = sum / 2\n   }\n\n   return result\n}\n",
          "complexity": {
            "space": "O(max(m, n))",
            "spaceExplanation": "The space complexity is proportional to the maximum length of the two binary strings, as we store the result in a new string.",
            "time": "O(max(m, n))",
            "timeExplanation": "The time complexity is proportional to the maximum length of the two binary strings."
          },
          "explanation": "This approach involves manual iteration over the binary strings, which can be time-consuming and prone to errors. However, it is straightforward and easy to understand.",
          "id": "d0fce763-6b5e-4be2-8ee5-2371b6e13e68",
          "intuition": "This approach works by treating binary numbers as strings, iterating over each character, and performing addition from right to left.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"100\"",
              "explanation": "The binary sum of 3 (11) and 1 is 4, which is 100 in binary.",
              "id": "1f966316-06d4-4709-a4ea-8ae6e00d3a22",
              "input": "a = \"11\", b = \"1\""
            },
            {
              "expectedOutput": "\"10101\"",
              "explanation": "The binary sum of 10 (1010) and 11 (1011) is 21, which is 10101 in binary.",
              "id": "d02faa57-bf9c-47e9-bcac-1e748e3f4a75",
              "input": "a = \"1010\", b = \"1011\""
            }
          ]
        },
        {
          "approach": "1. Convert binary strings to integers using a built-in function, 2. Perform integer addition, 3. Convert the result back to binary using a built-in function",
          "code": "\nfunc addBinary(_ a: String, _ b: String) -> String {\n   let sum = Int(a, radix: 2)! + Int(b, radix: 2)!\n   return String(sum, radix: 2)\n}\n",
          "complexity": {
            "space": "O(max(m, n))",
            "spaceExplanation": "The space complexity is proportional to the space taken by the built-in functions to convert binary strings to integers and back.",
            "time": "O(max(m, n))",
            "timeExplanation": "The time complexity is proportional to the time taken by the built-in functions to convert binary strings to integers and back."
          },
          "explanation": "This approach is more efficient and scalable, as it leverages optimized functions for binary conversion and arithmetic operations.",
          "id": "667f612d-fbf9-40fd-9971-4a4e4ab55b15",
          "intuition": "This approach uses built-in functions to convert binary strings to integers, perform addition, and convert the result back to binary.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "\"100\"",
              "explanation": "The binary sum of 3 (11) and 1 is 4, which is 100 in binary.",
              "id": "6131b233-15de-42c7-b9ec-a90eadc7cfed",
              "input": "a = \"11\", b = \"1\""
            },
            {
              "expectedOutput": "\"10101\"",
              "explanation": "The binary sum of 10 (1010) and 11 (1011) is 21, which is 10101 in binary.",
              "id": "a9e847f7-a55c-465c-a909-947d14ffd5a4",
              "input": "a = \"1010\", b = \"1011\""
            }
          ]
        }
      ],
      "id": "9ac894df-8781-4022-b67f-f4ece34ae36f",
      "lastUpdated": "2026-02-06T21:05:07Z",
      "problemSlug": "add-binary",
      "relatedProblems": [
        "add-strings",
        "multiply-strings"
      ],
      "summary": "Add Binary is a problem that requires adding two binary numbers and returning the result as a binary string. The key insight is to treat binary numbers as decimal numbers and use basic arithmetic operations to add them."
    },
    {
      "approaches": [
        {
          "approach": "The algorithm will start with the input number, calculate the sum of its digits, and keep repeating this process with the sum until the sum itself becomes a single digit",
          "code": "func addDigits(_ num: Int) -> Int { \n    var num = num \n    while num >= 10 { \n        var sum = 0 \n        while num > 0 { \n            sum += num % 10 \n            num /= 10 \n        } \n        num = sum \n    } \n    return num \n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store our variables.",
            "time": "O(logn)",
            "timeExplanation": "Each iteration of the outer while loop reduces the number of digits in num, resulting in O(logn) iterations where n is the input number."
          },
          "explanation": "If we take a number like 38, its digital root is calculated as follows: 3 + 8 = 11, then 1 + 1 = 2, so the digital root of 38 is 2.",
          "id": "20c48305-a34c-49c1-8ab0-f93a6a5f17ff",
          "intuition": "We'll keep summing up the digits until we are left with a single-digit number by continuously adding the digits of the number",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "3 + 8 = 11, 1 + 1 = 2",
              "id": "d04e174e-1398-45be-b44a-d13efac335de",
              "input": "num = 38"
            },
            {
              "expectedOutput": "0",
              "explanation": "The digital root of 0 is 0",
              "id": "fa0cc8f6-5c6d-4322-ae80-1d35ac206755",
              "input": "num = 0"
            }
          ]
        },
        {
          "approach": "To calculate the digital root of a number using this approach, we simply apply the formula (x-1)%9 + 1 for x > 0 and return 0 for x = 0.",
          "code": "func addDigits(_ num: Int) -> Int { \n    if num == 0 { return 0 } \n    return (num - 1) % 9 + 1 \n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as we are only using a fixed amount of space to store the variables involved in the calculation.",
            "time": "O(1)",
            "timeExplanation": "This approach takes constant time as it involves a simple calculation."
          },
          "explanation": "The reasoning behind this formula comes from the properties of digital roots and their cyclic nature when numbers are repeatedly reduced to their digital roots.",
          "id": "6efd79a0-e8ac-4ee0-8b00-3b7f0b081ead",
          "intuition": "The digital root of a number can be directly calculated without any need to iteratively add its digits. It can be found using the formula (x-1)%9 + 1 for numbers greater than 0, where x is the number. If the number is 0, its digital root is simply 0.",
          "name": "Mathematical Insight",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Directly applying the formula gives (38-1)%9 + 1 = 2",
              "id": "1e60426b-fe97-4380-978e-ff33b2b46e17",
              "input": "num = 38"
            },
            {
              "expectedOutput": "9",
              "explanation": "For numbers that are already single-digit, their digital root is the number itself, which the formula also correctly computes as (9-1)%9 + 1 = 9",
              "id": "1e1504e6-99c8-4012-967b-a990613b132c",
              "input": "num = 9"
            }
          ]
        }
      ],
      "id": "6a7b081a-c28e-4703-8311-f58ba3468d14",
      "lastUpdated": "2026-02-06T21:11:33Z",
      "problemSlug": "add-digits",
      "relatedProblems": [
        "happy-number",
        " ugliness-number"
      ],
      "summary": "The problem asks us to write a function that calculates the digital root of a given number. The digital root is the result of repeatedly adding all digits of a number until only one digit remains. This process is repeated until we get a single digit as a result, and this final result is the digital root."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate from end of both strings\n2. Add digits + carry\n3. Prepend result digit",
          "code": "func addStrings(_ num1: String, _ num2: String) -> String {\n    var i = num1.count - 1, j = num2.count - 1\n    var carry = 0, result = \"\"\n    let n1 = Array(num1), n2 = Array(num2)\n    while i >= 0 || j >= 0 || carry > 0 {\n        let d1 = i >= 0 ? Int(String(n1[i]))! : 0\n        let d2 = j >= 0 ? Int(String(n2[j]))! : 0\n        let sum = d1 + d2 + carry\n        result = String(sum % 10) + result\n        carry = sum / 10\n        i -= 1; j -= 1\n    }\n    return result\n}",
          "complexity": {
            "space": "O(max(m,n))",
            "spaceExplanation": "Result string",
            "time": "O(max(m,n))",
            "timeExplanation": "Single pass"
          },
          "explanation": "Handle different lengths by treating missing digits as 0.",
          "id": "95ee2720-ad72-48c7-aa2b-cf6244e53615",
          "intuition": "Add from right to left with carry.",
          "name": "Elementary Addition",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"134\"",
              "explanation": "11 + 123 = 134",
              "id": "f9bb24a6-17ae-41d2-85af-886812560c70",
              "input": "num1 = \"11\", num2 = \"123\""
            }
          ]
        }
      ],
      "id": "a9f855c4-5f40-48c3-82b4-efc5ad6cec5a",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "add-strings",
      "relatedProblems": [
        "add-two-numbers"
      ],
      "summary": "Add two numbers as strings. Digit by digit with carry."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize an empty array to store the result. 2. Process the input array from right to left. 3. At each step, add the current digit and the corresponding digit of the given integer. 4. Handle carry-over values by updating the result array and the given integer.",
          "code": "func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\n    var result = [Int]()\n    var k = k\n    for i in stride(from: num.count - 1, through: 0, by: -1) {\n        let sum = num[i] + k\n        k = sum / 10\n        result.append(sum % 10)\n    }\n    while k > 0 {\n        result.append(k % 10)\n        k /= 10\n    }\n    return result.reversed()\n}",
          "complexity": {
            "space": "O(max(n, log(k)))",
            "spaceExplanation": "The space complexity is O(max(n, log(k))) because we need to store the result array, which can be at most the length of the input array plus the number of digits in the given integer.",
            "time": "O(max(n, log(k)))",
            "timeExplanation": "The time complexity is O(max(n, log(k))) because in the worst case, we need to process the entire array and the given integer."
          },
          "explanation": "This solution is easy to understand and implement, but it may not be efficient for large arrays.",
          "id": "e1d21866-1e93-42e3-b727-9b6a8072726b",
          "intuition": "This approach works by simply iterating over the array from right to left, adding the given integer, and handling carry-over values.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1, 2, 0, 3, 4]",
              "explanation": "The result is obtained by adding 34 to the array-form of integer [1, 2, 0, 0].",
              "id": "eb9db05e-28b7-4788-92b8-d45127340c64",
              "input": "num = [1, 2, 0, 0], k = 34"
            },
            {
              "expectedOutput": "[4, 5, 5]",
              "explanation": "The result is obtained by adding 181 to the array-form of integer [2, 7, 4].",
              "id": "998e0b15-d3a7-4dab-8c74-c411f72f2ba1",
              "input": "num = [2, 7, 4], k = 181"
            },
            {
              "expectedOutput": "[1, 0, 2, 1]",
              "explanation": "The result is obtained by adding 806 to the array-form of integer [2, 1, 5].",
              "id": "e367f09c-1028-4676-b11b-c2e2febfccc7",
              "input": "num = [2, 1, 5], k = 806"
            }
          ]
        },
        {
          "approach": "1. Initialize a variable to store the carry-over value. 2. Process the input array from right to left, adding the carry-over value and updating the array in-place. 3. After processing the entire array, handle any remaining carry-over value.",
          "code": "func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\n    var num = num\n    var k = k\n    for i in stride(from: num.count - 1, through: 0, by: -1) {\n        num[i] += k\n        k = num[i] / 10\n        num[i] %= 10\n    }\n    while k > 0 {\n        num.insert(k % 10, at: 0)\n        k /= 10\n    }\n    return num\n}",
          "complexity": {
            "space": "O(max(n, log(k)))",
            "spaceExplanation": "The space complexity is O(max(n, log(k))) because we need to store the result array, which can be at most the length of the input array plus the number of digits in the given integer.",
            "time": "O(max(n, log(k)))",
            "timeExplanation": "The time complexity is O(max(n, log(k))) because in the worst case, we need to process the entire array and the given integer."
          },
          "explanation": "This solution is more efficient than the brute-force approach because it reduces the number of operations required to process the array and the given integer.",
          "id": "784f8dbc-44a6-4885-901f-0dbff502a3b9",
          "intuition": "This approach works by using a single pass to process the array and the given integer, handling carry-over values and updating the result array in-place.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1, 2, 0, 3, 4]",
              "explanation": "The result is obtained by adding 34 to the array-form of integer [1, 2, 0, 0].",
              "id": "21205013-c40d-4d50-b12d-d9d77a9ea1ca",
              "input": "num = [1, 2, 0, 0], k = 34"
            },
            {
              "expectedOutput": "[4, 5, 5]",
              "explanation": "The result is obtained by adding 181 to the array-form of integer [2, 7, 4].",
              "id": "3864dd99-3736-43f0-8d42-d48036e70a04",
              "input": "num = [2, 7, 4], k = 181"
            },
            {
              "expectedOutput": "[1, 0, 2, 1]",
              "explanation": "The result is obtained by adding 806 to the array-form of integer [2, 1, 5].",
              "id": "28a18d5e-ea63-4465-887a-ba55a80195b9",
              "input": "num = [2, 1, 5], k = 806"
            }
          ]
        }
      ],
      "id": "16cc6287-3929-4210-8b69-5be0845bcd4c",
      "lastUpdated": "2026-02-06T21:53:30Z",
      "problemSlug": "add-to-array-form-of-integer",
      "relatedProblems": [
        "plus-one",
        "multiply-strings"
      ],
      "summary": "The problem requires adding a given integer to an array-form of integer and returning the result as an array. The key insight is to process the array from right to left, handling carry-over values when necessary."
    },
    {
      "approaches": [
        {
          "approach": "Start with k = 1 and increment k until k * (k + 1) / 2 is greater than the number of coins. Return the last value of k for which k * (k + 1) / 2 was less than or equal to the number of coins.",
          "code": "func arrangeCoins(n: Int) -> Int { var k = 1; while k * (k + 1) / 2 <= n { k += 1 }; return k - 1 }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the variables.",
            "time": "O(sqrt(n))",
            "timeExplanation": "The time complexity is O(sqrt(n)) because we are trying all possible values of k up to sqrt(n)."
          },
          "explanation": "This approach is simple but inefficient as it involves trying all possible values of k.",
          "id": "7edc6037-e359-466b-902f-08f458134b37",
          "intuition": "The brute force approach involves trying all possible values of k to find the largest integer k such that k * (k + 1) / 2 is less than or equal to the number of coins.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The maximum number of steps that can be formed with 5 coins is 2, as shown below: Step 1: 1 coin, Step 2: 2 coins, Total coins used: 1 + 2 = 3, Remaining coins: 5 - 3 = 2, which is not enough to form another step.",
              "id": "981268d6-62cb-43c4-9286-6b81238fdefe",
              "input": "5"
            },
            {
              "expectedOutput": "3",
              "explanation": "The maximum number of steps that can be formed with 8 coins is 3, as shown below: Step 1: 1 coin, Step 2: 2 coins, Step 3: 3 coins, Total coins used: 1 + 2 + 3 = 6, Remaining coins: 8 - 6 = 2, which is enough to form another step but not enough to complete it.",
              "id": "dc2e192f-5ffe-4cde-9a76-4d5493ee981d",
              "input": "8"
            }
          ]
        },
        {
          "approach": "Let k * (k + 1) / 2 = n, then k^2 + k - 2 * n = 0. Using the quadratic formula, we get k = (-1 + sqrt(1 + 8 * n)) / 2.",
          "code": "func arrangeCoins(n: Int) -> Int { return Int((-1 + sqrt(1.0 + 8.0 * Double(n))) / 2) }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the variables.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because we are directly calculating the value of k."
          },
          "explanation": "This approach is more efficient than the brute force approach as it directly calculates the value of k.",
          "id": "b294e2c1-b61d-42ff-9c6d-91610320071b",
          "intuition": "The optimized approach involves using the quadratic formula to find the largest integer k such that k * (k + 1) / 2 is less than or equal to the number of coins.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The maximum number of steps that can be formed with 5 coins is 2.",
              "id": "f456c61a-6a01-401a-a05e-bed00964eb71",
              "input": "5"
            },
            {
              "expectedOutput": "3",
              "explanation": "The maximum number of steps that can be formed with 8 coins is 3.",
              "id": "dc2ee87d-c080-408f-9065-807e250b74f5",
              "input": "8"
            }
          ]
        }
      ],
      "id": "66dee1f7-94bc-4af0-96d8-19eb486d6031",
      "lastUpdated": "2026-02-06T21:18:51Z",
      "problemSlug": "arranging-coins",
      "relatedProblems": [
        "reverse-linked-list",
        "valid-palindrome"
      ],
      "summary": "This problem requires arranging coins in a staircase manner to find the maximum number of steps that can be formed with a given number of coins. The key insight is to find the largest integer k such that k * (k + 1) / 2 is less than or equal to the number of coins."
    },
    {
      "approaches": [
        {
          "approach": "Start with the given number, divide it by 7, and append the remainder to the result. Repeat this process until the number becomes 0",
          "code": "func convertToBase7(_ num: Int) -> String { \n    if num == 0 { \n        return \"0\" \n    } \n    var num = num \n    var result = \"\" \n    var isNegative = false \n    if num < 0 { \n        num = -num \n        isNegative = true \n    } \n    while num > 0 { \n        let remainder = num % 7 \n        num = num / 7 \n        result = String(remainder) + result \n    } \n    return isNegative ? \"-\" + result : result \n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the space used does not grow with the input size, it only depends on the maximum number of digits in the base 7 representation",
            "time": "O(logN)",
            "timeExplanation": "The time complexity is O(logN) because the number of iterations is proportional to the number of digits in the base 7 representation of the given number"
          },
          "explanation": "This approach involves using a loop to continuously divide the number by 7 and appending the remainder to the result. The loop continues until the number becomes 0",
          "id": "461a876c-f547-4c77-8556-8bddf43bb245",
          "intuition": "This approach works by continuously dividing the given number by 7 and appending the remainder to the result",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "202",
              "explanation": "The base 7 representation of 100 is 202",
              "id": "2be460e8-ec0c-42f8-a648-98bf4d96e68c",
              "input": "num = 100"
            },
            {
              "expectedOutput": "-10",
              "explanation": "The base 7 representation of -7 is -10",
              "id": "7d0f1774-562a-4906-9ca7-bdc25cbbecb9",
              "input": "num = -7"
            }
          ]
        },
        {
          "approach": "Use the Swift built-in functions to convert the number to a string, and then replace the characters to represent base 7",
          "code": "func convertToBase7(_ num: Int) -> String { \n    let sign = num < 0 ? \"-\" : \"\" \n    var num = abs(num) \n    var result = \"\" \n    while num > 0 { \n        result = String(num % 7) + result \n        num /= 7 \n    } \n    return sign + (result.isEmpty ? \"0\" : result) \n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the space used does not grow with the input size, it only depends on the maximum number of digits in the base 7 representation",
            "time": "O(logN)",
            "timeExplanation": "The time complexity is O(logN) because the number of iterations is proportional to the number of digits in the base 7 representation of the given number"
          },
          "explanation": "This approach involves using the Swift built-in functions to convert the number to a string and then replacing the characters to represent base 7. This is more efficient than the brute-force approach",
          "id": "0de153b2-3954-4f01-91dd-1501343aaea1",
          "intuition": "This approach works by using the Swift built-in functions to convert the number to a string and then replacing the characters to represent base 7",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "202",
              "explanation": "The base 7 representation of 100 is 202",
              "id": "2c337be8-cad5-44e7-a3bb-650cea7f221f",
              "input": "num = 100"
            },
            {
              "expectedOutput": "-10",
              "explanation": "The base 7 representation of -7 is -10",
              "id": "532c7aff-91c6-42bc-b00c-9135ccedaec0",
              "input": "num = -7"
            },
            {
              "expectedOutput": "0",
              "explanation": "The base 7 representation of 0 is 0",
              "id": "9e5edc8e-bbdb-480f-befd-029034e5c623",
              "input": "num = 0"
            }
          ]
        }
      ],
      "id": "dc5698a7-3c19-4fbc-b752-f06e372c41db",
      "lastUpdated": "2026-02-06T21:22:50Z",
      "problemSlug": "base-7",
      "relatedProblems": [
        "reverse-integer",
        "roman-to-integer"
      ],
      "summary": "The problem requires converting a given integer to base 7 representation. The key insight is to utilize the modulo and division operations to extract the remainder and quotient."
    },
    {
      "approaches": [
        {
          "approach": "Generate all permutations of the numbers from 1 to n, then check each permutation to see if it is a beautiful arrangement by checking if for every i, either i is a multiple of n[i] or n[i] is a multiple of i.",
          "code": "\nimport Foundation\n\nfunc constructArray(n: Int) -> [Int] {\n    var res: [Int] = []\n    if n == 1 {\n        return [1]\n    }\n    for num in 1...n {\n        res.append(num)\n        if res.count == n {\n            break\n        }\n    }\n    res = res[1...(res.count - 2)] + [1, res[0], res[res.count - 1]]\n    return res\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We need to store the result array of size n, therefore it takes O(n) space.",
            "time": "O(n)",
            "timeExplanation": "We are generating the array of size n, therefore it takes O(n) time."
          },
          "explanation": "This approach works by trying all possible arrangements of the numbers from 1 to n. It checks each permutation to see if it satisfies the condition of being a beautiful arrangement. If a permutation satisfies this condition, it is added to the result list.",
          "id": "c43aaa71-aa3e-4393-99e2-064bc91bc3fd",
          "intuition": "We can solve this problem by generating all permutations of the numbers from 1 to n and checking each permutation to see if it is a beautiful arrangement.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1, 3, 2]",
              "explanation": "In this case, 1 is a multiple of 3[0], 3 is a multiple of 3[1], and 2 is a multiple of 3[2].",
              "id": "530ab0c3-287e-44bb-82f1-c62e8cc4edc7",
              "input": "n = 3"
            },
            {
              "expectedOutput": "[2, 1, 4, 3]",
              "explanation": "In this case, 2 is a multiple of 4[0], 1 is a multiple of 4[1], 4 is a multiple of 4[2], and 3 is a multiple of 4[3].",
              "id": "16d58d9f-018e-4e83-976e-714f81c572ed",
              "input": "n = 4"
            }
          ]
        },
        {
          "approach": "Construct the result array by directly inserting the numbers from 1 to n in a specific order.",
          "code": "\nimport Foundation\n\nfunc constructArray(n: Int) -> [Int] {\n    var res: [Int] = Array(1...n)\n    var start = 1\n    var end = n - 1\n    while start <= end {\n        res.insert(res.remove(at: end), at: start + 1)\n        start += 2\n        end -= 2\n    }\n    return res\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We need to store the result array of size n, therefore it takes O(n) space.",
            "time": "O(n)",
            "timeExplanation": "We are constructing the array of size n, therefore it takes O(n) time."
          },
          "explanation": "This approach works by directly inserting the numbers from 1 to n in a specific order. It starts with the number 1, then inserts the number n, then the number 2, then the number n-1, and so on. This order ensures that the resulting array is a beautiful arrangement.",
          "id": "91cf7c9d-f138-4e4f-8ce3-7a26d10d0c8d",
          "intuition": "We can solve this problem by directly constructing the result array in a specific order.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1, 2]",
              "explanation": "In this case, 1 is a multiple of 2[0], and 2 is a multiple of 2[1].",
              "id": "d26f522a-f1d0-4de3-b60b-9447876f6e6e",
              "input": "n = 2"
            },
            {
              "expectedOutput": "[2, 1, 5, 4, 3]",
              "explanation": "In this case, 2 is a multiple of 5[0], 1 is a multiple of 5[1], 5 is a multiple of 5[2], 4 is a multiple of 5[3], and 3 is a multiple of 5[4].",
              "id": "cafe70de-91f8-4e01-93cd-38fa9bb28325",
              "input": "n = 5"
            }
          ]
        }
      ],
      "id": "77886072-2c4d-4bff-bb1b-fb11ad471c67",
      "lastUpdated": "2026-02-06T21:32:17Z",
      "problemSlug": "beautiful-arrangement-ii",
      "relatedProblems": [
        "beautiful-arrangement",
        "construct-array"
      ],
      "summary": "The problem asks us to find a beautiful arrangement of numbers from 1 to n. A beautiful arrangement is one where for every i, either i is a multiple of n[i] or n[i] is a multiple of i."
    },
    {
      "approaches": [
        {
          "approach": "Generate all possible subsets of numbers from 1 to n and check each subset for the beautiful array property.",
          "code": "func beautifulArray(_ n: Int) -> [Int] { let arr = Array(1...n); var result: [Int] = []; for i in arr { if result.count % 2 == 0 || (i - result.last!) % 4 != 0 { result.append(i) } } return result }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Storing the subsets and the resulting beautiful array takes linear space.",
            "time": "O(2^n)",
            "timeExplanation": "Generating all subsets takes exponential time."
          },
          "explanation": "This approach involves checking every possible subset of numbers to see if it forms a beautiful array. However, it is inefficient due to the large number of subsets and the property check for each subset.",
          "id": "a199fbae-6451-46cb-86e2-2d0dfef98491",
          "intuition": "Try all possible combinations of numbers and check if the resulting array is beautiful.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1, 3, 2, 4]",
              "explanation": "The beautiful array starts with odd numbers in ascending order, then even numbers in ascending order, to maintain the property for all pairs.",
              "id": "dc163737-5d9f-40a2-b024-0375460435b5",
              "input": "n = 4"
            },
            {
              "expectedOutput": "[1, 3, 5, 2, 4]",
              "explanation": "For n = 5, the beautiful array maintains the property by alternating between odd and even numbers in ascending order.",
              "id": "16a53a67-43d8-48c2-ada7-8f41dad7db04",
              "input": "n = 5"
            }
          ]
        },
        {
          "approach": "Start with the base case of a single element, then recursively construct the beautiful array for larger n by dividing it into two parts: one for odd indices and one for even indices.",
          "code": "func beautifulArray(_ n: Int) -> [Int] { if n == 1 { return [1] } let odds = beautifulArray(n / 2); let evens = beautifulArray((n + 1) / 2); return odds + evens.map { $0 * 2 } }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also linear as we store the beautiful array of size n.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear due to the recursive construction of the beautiful array."
          },
          "explanation": "The divide and conquer approach efficiently constructs the beautiful array by ensuring that the difference between any two elements at even and odd indices is never a multiple of 4.",
          "id": "c773feb7-77c7-4887-aea4-9762256c3754",
          "intuition": "Recursively build the beautiful array by considering even and odd indices separately.",
          "name": "Divide and Conquer",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1, 3, 2]",
              "explanation": "For n = 3, the beautiful array constructed by the divide and conquer approach is [1, 3, 2].",
              "id": "47cbf876-7d9b-4581-b9be-54616a845956",
              "input": "n = 3"
            },
            {
              "expectedOutput": "[1, 3, 5, 2, 4, 6]",
              "explanation": "The divide and conquer approach correctly constructs the beautiful array for n = 6 as [1, 3, 5, 2, 4, 6].",
              "id": "297094f2-7b9c-43cd-a1a8-39931fd5878e",
              "input": "n = 6"
            }
          ]
        }
      ],
      "id": "36b9e56e-0798-42d9-a2ac-d923a3fec4c9",
      "lastUpdated": "2026-02-06T21:49:27Z",
      "problemSlug": "beautiful-array",
      "relatedProblems": [
        "next-greater-element-iii",
        "construct-binary-search-tree-from-preorder-traversal"
      ],
      "summary": "A beautiful array is a sequence of integers in which for every pair (i, j), the absolute difference |A[i] - A[j]| is not a multiple of 4 if i is even and j is odd. The key insight is to recursively build the beautiful array."
    },
    {
      "approaches": [
        {
          "approach": "Start with the initial number X and try all possible operations: multiplication by 2 and subtraction by 1. Use a queue to store the current numbers and their corresponding operation counts.",
          "code": "\nimport Foundation\n\nfunc brokenCalc(_ X: Int, _ Y: Int) -> Int {\n    var queue: [(Int, Int)] = [(X, 0)]\n    var visited: Set<Int> = [X]\n\n    while !queue.isEmpty {\n        let (current, count) = queue.removeFirst()\n        if current == Y {\n            return count\n        }\n\n        let multiplied = current * 2\n        let subtracted = current - 1\n\n        if multiplied <= Y && !visited.contains(multiplied) {\n            queue.append((multiplied, count + 1))\n            visited.insert(multiplied)\n        }\n\n        if subtracted > 0 && !visited.contains(subtracted) {\n            queue.append((subtracted, count + 1))\n            visited.insert(subtracted)\n        }\n    }\n\n    return -1\n}\n",
          "complexity": {
            "space": "O(2^Y)",
            "spaceExplanation": "We store the visited numbers in a set, which can take up to 2^Y space in the worst case.",
            "time": "O(2^Y)",
            "timeExplanation": "In the worst-case scenario, we might need to try all possible operations, resulting in exponential time complexity."
          },
          "explanation": "This approach is straightforward but inefficient because it tries all possible operations without considering the optimal path.",
          "id": "eb5d3339-04f6-4854-b121-df66e0f7dd3e",
          "intuition": "This approach works by trying all possible operations until we reach the target number Y.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "We can reach 3 from 2 by multiplying by 2 and then subtracting 1: 2 -> 4 -> 3.",
              "id": "0b75ed27-5a95-40b3-81f8-ac88330ba50f",
              "input": "X = 2, Y = 3"
            },
            {
              "expectedOutput": "2",
              "explanation": "We can reach 8 from 5 by multiplying by 2 twice: 5 -> 10 -> 8 (10 is not a valid operation, so we need to go back to 5 and try again). The correct sequence is 5 -> 4 -> 8 or 5 -> 10 (invalid) and then 5 -> 4 -> 8.",
              "id": "d198b89b-3de4-4847-83fb-77401236d1ac",
              "input": "X = 5, Y = 8"
            }
          ]
        },
        {
          "approach": "Start with the initial number X and the target number Y. If Y is less than X, we can simply subtract 1 from X until we reach Y. Otherwise, we use a greedy approach to divide Y by 2 when it's even and add 1 when it's odd.",
          "code": "\nimport Foundation\n\nfunc brokenCalc(_ X: Int, _ Y: Int) -> Int {\n    if Y < X {\n        return X - Y\n    }\n\n    var count = 0\n    while Y > X {\n        if Y % 2 == 0 {\n            Y /= 2\n        } else {\n            Y += 1\n        }\n        count += 1\n    }\n\n    return count + X - Y\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the count and the current numbers.",
            "time": "O(logY)",
            "timeExplanation": "The number of operations is proportional to the number of bits in the binary representation of Y."
          },
          "explanation": "This approach is efficient because it considers the optimal path by always trying to divide Y by 2 when it's even, reducing the number of operations.",
          "id": "f9e218ff-8344-4a79-ad14-5a1a5d903e41",
          "intuition": "This approach works by always trying to divide the current number by 2 when it's even and subtracting 1 when it's odd.",
          "name": "Greedy Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "We can reach 3 from 2 by multiplying by 2 and then subtracting 1: 2 -> 4 -> 3.",
              "id": "442fac7d-be01-4f59-bcf4-c453c60ca0d7",
              "input": "X = 2, Y = 3"
            },
            {
              "expectedOutput": "1023",
              "explanation": "We can reach 1 from 1024 by repeatedly dividing by 2: 1024 -> 512 -> 256 -> ... -> 1.",
              "id": "dbe86b7e-9d2c-4e3e-b13f-484e640da1b9",
              "input": "X = 1024, Y = 1"
            }
          ]
        }
      ],
      "id": "c02a1d53-8ffd-4392-ad90-4367512ca6fd",
      "lastUpdated": "2026-02-06T21:54:01Z",
      "problemSlug": "broken-calculator",
      "relatedProblems": [
        "prime-palindrome",
        "minimum-sum-of-four-digit-number-after-splitting-and-rearranging"
      ],
      "summary": "The Broken Calculator problem requires finding the minimum number of operations to convert a number X to Y using only two operations: multiplication by 2 and subtraction by 1. The key insight is to use a greedy approach by always dividing X by 2 when it's even and subtracting 1 when it's odd."
    },
    {
      "approaches": [
        {
          "approach": "Create an array of boolean values representing the n bulbs, initially all off. For each round, toggle the bulbs at indices that are multiples of the round number. After n rounds, count the number of true values in the array.",
          "code": "\nfunc bulbSwitch(_ n: Int) -> Int {\n    var bulbs = [Bool](repeating: false, count: n)\n    for i in 1...n {\n        for j in stride(from: i-1, to: n, by: i) {\n            bulbs[j] = !bulbs[j]\n        }\n    }\n    return bulbs.filter { $0 }.count\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We need O(n) space to store the array of boolean values representing the bulbs.",
            "time": "O(n^2)",
            "timeExplanation": "The outer loop runs in O(n) time and the inner loop runs in O(n) time in the worst case."
          },
          "explanation": "The brute-force approach involves directly simulating the described process. It first creates an array representing the bulbs and then iterates over each round, toggling the appropriate bulbs. Finally, it counts the bulbs that are on.",
          "id": "29da873d-09e4-4d18-9918-702b59ad5ddc",
          "intuition": "This approach involves simulating each round of bulb toggling, and after the n rounds are complete, it counts the number of bulbs that are on.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The first round, first and fourth bulbs are toggled. The second round, second bulb is toggled. The third round, third bulb is toggled. The fourth round, fourth bulb is toggled. So, bulbs 1 and 2 are on.",
              "id": "825d1b6f-4d6f-48ca-9dc0-d52f07b44a80",
              "input": "n = 4"
            },
            {
              "expectedOutput": "1",
              "explanation": "After the first round, the first bulb is toggled. The second round, second bulb is toggled. The third round, third bulb is toggled. So, only the third bulb is on.",
              "id": "4b956039-7c22-4d1a-9ed4-c450caf016cf",
              "input": "n = 3"
            }
          ]
        },
        {
          "approach": "Count the number of perfect squares less than or equal to n.",
          "code": "\nimport Foundation\n\nfunc bulbSwitch(_ n: Int) -> Int {\n    return Int(sqrt(Double(n)))\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we are not using any data structures that grow with the size of n.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant because we are simply calculating the square root of n."
          },
          "explanation": "This approach works because each bulb's state is determined solely by whether it has an odd or even number of factors, since each factor corresponds to a round where the bulb is toggled. Only perfect squares have an odd number of factors, so only they will be toggled an odd number of times and end up in the 'on' state.",
          "id": "7b520a99-583f-4178-b982-5c8489a43564",
          "intuition": "The i-th bulb will be toggled an odd number of times if and only if i is a perfect square. So, the number of bulbs that are on after n rounds is equal to the number of perfect squares less than or equal to n.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The first and fourth bulbs are perfect squares (1 and 4), so they will be on.",
              "id": "13cea49d-41e3-43e3-8c44-ab44e7fd2b2b",
              "input": "n = 4"
            },
            {
              "expectedOutput": "10",
              "explanation": "There are 10 perfect squares less than or equal to 100 (1, 4, 9, 16, 25, 36, 49, 64, 81, 100), so 10 bulbs will be on.",
              "id": "0ff3ffe8-d7a8-41a0-b9e7-bfb6e33e6fe7",
              "input": "n = 100"
            }
          ]
        }
      ],
      "id": "0092b368-f1e8-453a-a359-a8b04776cc20",
      "lastUpdated": "2026-02-06T21:13:01Z",
      "problemSlug": "bulb-switcher",
      "relatedProblems": [
        "coin-change",
        "jump-game"
      ],
      "summary": "There are n bulbs, each with one of two states: on or off. Write a function that will return the number of bulbs that are on after n rounds, where in the first round the first bulb is toggled, in the second round the second and eighth bulbs are toggled, and so on. The key insight to this problem is that the i-th bulb will be toggled in the j-th round if and only if j is a factor of i."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a counter for valid configurations. 2. For each possible initial configuration, simulate all possible button presses. 3. Keep track of the resulting configuration. 4. For each button press sequence, compare the resulting configuration to the original.",
          "code": "\nfunc flipLights(n: Int, presses: Int) -> Int {\n    let masks: [Int] = [0b11111111, 0b10101010, 0b11001100, 0b10010010]\n    var stateSet: Set<Int> = []\n    for mask in 0...((1 << 4) - 1) {\n        var state: Int = (1 << n) - 1\n        for _ in 1...presses {\n            state = state ^ masks[mask % 4]\n        }\n        stateSet.insert(state)\n    }\n    return stateSet.count\n}\n",
          "complexity": {
            "space": "O(2^n)",
            "spaceExplanation": "The solution must store every possible configuration, resulting in an exponential amount of space required.",
            "time": "O(4^n)",
            "timeExplanation": "The solution must check every possible combination of initial configurations and every possible button press sequence."
          },
          "explanation": "The brute force solution works by examining all possible initial configurations and all possible button presses, allowing it to exhaustively determine valid configurations. However, this solution is highly inefficient.",
          "id": "f44f49e9-477c-4af0-b5c9-59c692d18108",
          "intuition": "The brute force solution checks every possible combination of initial bulb configurations and simulates all possible presses to determine the final states that result in the same configuration after all possible presses.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "There are two valid configurations: light on and light off.",
              "id": "aa3bb937-8a1a-4bac-acab-5c3b87849b52",
              "input": "n = 1, presses = 1"
            },
            {
              "expectedOutput": "3",
              "explanation": "There are three valid configurations: both lights on, both lights off, one light on and one light off.",
              "id": "cb734d26-b217-47d8-bbb1-8c3f147511a7",
              "input": "n = 2, presses = 1"
            }
          ]
        },
        {
          "approach": "1. For each possible initial configuration, simulate the first button press. 2. Use the result as a bitmask to reduce possible configurations. 3. Repeat the process for the remaining presses, using the result as a bitmask.",
          "code": "\nfunc flipLights(n: Int, presses: Int) -> Int {\n    if n == 0 || presses == 0 {\n        return 1\n    }\n    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return presses == 1 ? 3 : 4\n    }\n    let masks: [Int] = [0b11111111, 0b10101010, 0b11001100, 0b10010010]\n    var result: Set<Int> = []\n    for i in 0...15 {\n        var cur = (1 << n) - 1\n        for _ in 0...presses {\n            cur = cur ^ masks[i % 4]\n        }\n        result.insert(cur)\n    }\n    return result.count\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The solution uses a constant amount of space, regardless of input size.",
            "time": "O(1)",
            "timeExplanation": "The solution has a fixed number of operations, regardless of input size."
          },
          "explanation": "The optimized solution reduces the number of possible configurations to examine, taking advantage of the fact that some configurations are indistinguishable after a certain number of presses.",
          "id": "d1787af0-f655-4338-a142-704814e15626",
          "intuition": "The optimized solution represents the initial and final configurations using bits. By examining the results of the first press, it's possible to reduce the number of configurations to examine.",
          "name": "Optimized Bit Manipulation",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "There are four valid configurations: all lights on, all lights off, two lights on and one light off, two lights off and one light on.",
              "id": "97ef8787-25f5-4b54-8620-c1c2d2dd43ff",
              "input": "n = 3, presses = 1"
            },
            {
              "expectedOutput": "7",
              "explanation": "There are seven valid configurations: all lights on, all lights off, two pairs of lights on and off, two lights on and two lights off.",
              "id": "27dd842b-5850-4bbe-90dc-ce451090bf78",
              "input": "n = 4, presses = 2"
            }
          ]
        }
      ],
      "id": "c1d6f6f3-fae1-4ba2-bf1a-d2bf677d0671",
      "lastUpdated": "2026-02-06T21:32:43Z",
      "problemSlug": "bulb-switcher-ii",
      "relatedProblems": [
        "toggle-string",
        "minimum-number-of-flips"
      ],
      "summary": "This problem involves finding all possible configurations for 4 light bulbs where all possible button presses result in the same final state. The key insight here is to utilize bit manipulation to represent the initial and final configurations of the bulbs."
    },
    {
      "approaches": [
        {
          "approach": "Iterate through all numbers, and for each number, try to pick it and then recursively check if the second player can win.",
          "code": "func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool { var nums = Array(1...maxChoosableInteger); func dfs(_ total: Int, _ used: Int) -> Bool { if total >= desiredTotal { return true }; for i in nums.indices where (used & (1 << i)) == 0 { if !dfs(total + nums[i], used | (1 << i)) { return true } }; return false }; return dfs(0, 0) }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The maximum recursion depth is n",
            "time": "O(2^n)",
            "timeExplanation": "There are 2^n possible subsets of n elements"
          },
          "explanation": "This approach works but is inefficient due to the repeated computation of the same subproblems.",
          "id": "3c1f709a-0ccf-41b4-951b-e471169a0827",
          "intuition": "Check all possible combinations of picking numbers and see if the first player can win.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "Since no number is chosen, the total is 0 and less than the desired total.",
              "id": "10de799a-c5a5-4d29-93ec-019d81eb761a",
              "input": "maxChoosableInteger = 10, desiredTotal = 0"
            },
            {
              "expectedOutput": "false",
              "explanation": "Since the sum of all numbers from 1 to 10 is 55, the first player cannot win.",
              "id": "e75976f2-c668-445c-b72d-3042c69c557d",
              "input": "maxChoosableInteger = 10, desiredTotal = 40"
            }
          ]
        },
        {
          "approach": "Iterate through all numbers, and for each number, try to pick it and then recursively check if the second player can win. Store the results of subproblems in a dictionary.",
          "code": "func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool {\n    let nums = Array(1...maxChoosableInteger)\n    var memo: [Int: Bool] = [:]\n    func dfs(_ total: Int, _ used: Int) -> Bool {\n        if let res = memo[used] {\n            return res\n        }\n        if total >= desiredTotal {\n            memo[used] = true\n            return true\n        }\n        for i in nums.indices where (used & (1 << i)) == 0 {\n            if !dfs(total + nums[i], used | (1 << i)) {\n                memo[used] = true\n                return true\n            }\n        }\n        memo[used] = false\n        return false\n    }\n    return dfs(0, 0)\n}",
          "complexity": {
            "space": "O(2^n)",
            "spaceExplanation": "The dictionary can store up to 2^n subproblems",
            "time": "O(2^n)",
            "timeExplanation": "In the worst case, we still have to try all numbers"
          },
          "explanation": "This approach optimizes the solution by avoiding repeated computation of the same subproblems.",
          "id": "58e72455-5ceb-4908-91c3-c1e01383ea03",
          "intuition": "Use a bitmask to keep track of the chosen numbers and store the results of subproblems in a dictionary.",
          "name": "Memoization and Bitmasking",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The first player can pick the number 11 and win the game.",
              "id": "48351626-5448-4055-94af-6c58c46f454e",
              "input": "maxChoosableInteger = 10, desiredTotal = 11"
            },
            {
              "expectedOutput": "false",
              "explanation": "Since the sum of all numbers from 1 to 10 is 55, the first player cannot win.",
              "id": "1f995477-2952-4758-ad01-75d72e73d046",
              "input": "maxChoosableInteger = 10, desiredTotal = 40"
            }
          ]
        }
      ],
      "id": "62073a79-c43b-4955-9d26-53248f0f42d4",
      "lastUpdated": "2026-02-06T21:20:39Z",
      "problemSlug": "can-i-win",
      "relatedProblems": [
        "can-i-win",
        "nim-game"
      ],
      "summary": "Given an integer array `nums` and a target value `target`, the goal is to determine whether the first player in a game will win. Key insight: Using memoization and bitmasking to optimize the solution."
    },
    {
      "approaches": [
        {
          "approach": "Start with the given number, then check the current operation. If it's multiplication, multiply the current result by the number. If it's addition, add the number to the result. Repeat this process until the number reaches 1.",
          "code": "func clumsy(_ N: Int) -> Int {\n    var res: Int64 = Int64(N)\n    var idx: Int = 0\n    var num: Int64 = N\n    var operators: [String] = [\"]\", \"+\", \"-\", \"*\"]\n    while num > 1 {\n        if operators[idx%4] == \"*\" {\n            res *= num\n        } else if operators[idx%4] == \"/\" {\n            res /= num\n        } else if operators[idx%4] == \"+\" {\n            res += num\n        } else if operators[idx%4] == \"-\" {\n            res -= num\n        }\n        idx += 1\n        num -= 1\n    }\n    return Int(res)\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a constant amount of space to store the result and the current number.",
            "time": "O(N)",
            "timeExplanation": "The time complexity is linear because we only need to iterate through the numbers from N down to 1 once."
          },
          "explanation": "This approach is straightforward but inefficient because it involves many redundant calculations.",
          "id": "813b4ed0-8e00-4b7a-989d-d84b80ec9c08",
          "intuition": "This approach works by iterating through all numbers from the given number down to 1 and performing the operations as described.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "4 * 3 / 2 + 1 = 7",
              "id": "54bd733e-47f0-496e-8d2f-acb5d88819f7",
              "input": "N = 4"
            },
            {
              "expectedOutput": "12",
              "explanation": "10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 = 12",
              "id": "62cb4c8b-3452-417f-80f7-b79205dba341",
              "input": "N = 10"
            }
          ]
        },
        {
          "approach": "Start by pushing the given number onto the stack. Then, iterate through the numbers from N-1 down to 1. For each number, pop the top element from the stack, perform the operation, and push the result back onto the stack. Repeat this process until the number reaches 1.",
          "code": "func clumsy(_ N: Int) -> Int {\n    var res: [Int64] = [Int64(N)]\n    let operators: [String] = [\"]\", \"+\", \"-\", \"*\"]\n    var idx = 0\n    for num in stride(from: N-1, to: 0, by: -1) {\n        switch operators[idx%4] {\n        case \"*\":\n            res[res.count-1] *= Int64(num)\n        case \"/\":\n            res[res.count-1] /= Int64(num)\n        case \"+\":\n            res.append(Int64(num))\n        case \"-\":\n            res.append(-Int64(num))\n        default:\n            break\n        }\n        idx += 1\n    }\n    return Int(res.reduce(0) { $0 + $1 })\n}",
          "complexity": {
            "space": "O(N)",
            "spaceExplanation": "The space complexity is linear because in the worst-case scenario, we need to store all numbers from N down to 1 in the stack.",
            "time": "O(N)",
            "timeExplanation": "The time complexity is linear because we only need to iterate through the numbers from N down to 1 once."
          },
          "explanation": "This approach is more efficient than the brute-force approach because it avoids redundant calculations.",
          "id": "39b00138-734f-4657-84c4-5a5fe3a2691b",
          "intuition": "This approach works by using a stack to keep track of the operations.",
          "name": "Stack",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "7",
              "explanation": "4 * 3 / 2 + 1 = 7",
              "id": "039dfb94-6cae-495d-ae96-de1fe5a88ac5",
              "input": "N = 4"
            },
            {
              "expectedOutput": "12",
              "explanation": "10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 = 12",
              "id": "82fca2bb-3eb1-424a-ba89-e5e754320a5c",
              "input": "N = 10"
            }
          ]
        }
      ],
      "id": "a5ddb551-309d-4480-9d1c-b89563031458",
      "lastUpdated": "2026-02-06T21:54:57Z",
      "problemSlug": "clumsy-factorial",
      "relatedProblems": [
        "factorial-trailing-zeroes",
        "number-of-digit-one"
      ],
      "summary": "The problem is to calculate the clumsy factorial of a given number, which is a sequence of operations where you alternate between multiplying and adding, starting with a number and then decreasing the number by 1. The key insight is to use a stack to keep track of the operations."
    },
    {
      "approaches": [
        {
          "approach": "To multiply two complex numbers, we can apply the formula (a+bi) * (c+di) = (ac-bd) + (ad+bc)i where a, b, c, and d are the real and imaginary parts of the two numbers.",
          "code": "func complexNumberMultiply(_ num1: String, _ num2: String) -> String {\n    let n1 = num1.components(separatedBy: \"+\")\n    let n2 = num2.components(separatedBy: \"+\")\n    let a = Int(n1[0])!\n    let b = Int(String(n1[1].dropLast()))!\n    let c = Int(n2[0])!\n    let d = Int(String(n2[1].dropLast()))!\n    let real = a*c - b*d\n    let imag = a*d + b*c\n    return \"(real)+(imag)i\"\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is also constant as we are not using any additional data structures that scale with the input size.",
            "time": "O(1)",
            "timeExplanation": "This approach takes constant time as we are performing a fixed number of operations."
          },
          "explanation": "The formula can be derived by distributing the multiplication and then collecting like terms. This approach is straightforward but may not be the most efficient way to perform complex multiplication.",
          "id": "908faea3-296c-4052-881a-060177d4f149",
          "intuition": "This approach involves applying the formula for complex multiplication directly, which involves multiplying each term and then simplifying the result.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0+2i",
              "explanation": "The result of multiplying 1+1i by 1+1i is 0+2i.",
              "id": "24c5bae1-c249-447b-bffa-abe8f57c2b1e",
              "input": "num1 = \"1+1i\", num2 = \"1+1i\""
            },
            {
              "expectedOutput": "11-2i",
              "explanation": "The result of multiplying 1+2i by 3-4i is 11-2i.",
              "id": "3da9c12a-fecc-4228-832f-67c3995b25a8",
              "input": "num1 = \"1+2i\", num2 = \"3-4i\""
            }
          ]
        },
        {
          "approach": "Instead of calculating each term separately, we can calculate the real and imaginary parts of the result in one step using the formula (ac-bd) + (ad+bc)i.",
          "code": "func complexNumberMultiply(_ num1: String, _ num2: String) -> String {\n    let real1 = Int(num1.components(separatedBy: \"+\")[0])!\n    let imag1 = Int(String(num1.components(separatedBy: \"+\")[1].dropLast()))!\n    let real2 = Int(num2.components(separatedBy: \"+\")[0])!\n    let imag2 = Int(String(num2.components(separatedBy: \"+\")[1].dropLast()))!\n    let real = real1*real2 - imag1*imag2\n    let imag = real1*imag2 + imag1*real2\n    return \"(real)+(imag)i\"\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is also constant for the same reason as the brute force approach.",
            "time": "O(1)",
            "timeExplanation": "This optimized approach also takes constant time as we are performing a fixed number of operations, similar to the brute force approach."
          },
          "explanation": "This optimized approach involves using a single formula to calculate both the real and imaginary parts of the result, which reduces the number of calculations required and improves efficiency.",
          "id": "3144d07d-7ac5-4c55-b46f-816f2d5ae6fe",
          "intuition": "This approach involves recognizing that complex multiplication can be performed more efficiently by avoiding repeated calculations and using a simple and consistent formula.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "-10+11i",
              "explanation": "The result of multiplying 2+3i by 1+4i is -10+11i.",
              "id": "bc56bbf9-6e1c-4d3b-8d34-b381b25d0d85",
              "input": "num1 = \"2+3i\", num2 = \"1+4i\""
            },
            {
              "expectedOutput": "2+0i",
              "explanation": "The result of multiplying 1-1i by 1+1i is 2+0i.",
              "id": "eee09958-7fba-41e7-96a0-d4c4df99b112",
              "input": "num1 = \"1-1i\", num2 = \"1+1i\""
            }
          ]
        }
      ],
      "id": "e98e5e18-bf0d-4ad9-bde2-bfe391a7bf57",
      "lastUpdated": "2026-02-06T21:25:05Z",
      "problemSlug": "complex-number-multiplication",
      "relatedProblems": [
        "add-strings",
        "multiply-strings"
      ],
      "summary": "The problem requires multiplying two complex numbers and the key insight is to apply the formula for complex multiplication, which can be optimized using a more efficient approach than direct calculation. The problem involves complex numbers in the form of a+bi and c+di where a, b, c, and d are integers."
    },
    {
      "approaches": [
        {
          "approach": "Start from the square root of the area and try to find the factors of the area. For each factor, calculate the perimeter and update the result if the perimeter is smaller.",
          "code": "func constructRectangle(area: Int) -> [Int] {\n    var width = Int(sqrt(Double(area)))\n    while width > 0 {\n        if area % width == 0 {\n            return [area / width, width]\n        }\n        width -= 1\n    }\n    return []\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the result.",
            "time": "O(sqrt(area))",
            "timeExplanation": "We iterate from the square root of the area down to 1."
          },
          "explanation": "We start from the square root of the area because a larger factor of the area would be a multiple of a smaller factor that has already been checked.",
          "id": "77b8d21d-23a9-4cfb-ae65-e5b869988316",
          "intuition": "This approach works by trying all the possible factors of the area and finding the one with the minimum perimeter.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,2]",
              "explanation": "The only possible rectangle with area 4 is a square with side length 2.",
              "id": "4dd4492b-2ed1-4786-8ba9-f9199791301e",
              "input": "area = 4"
            },
            {
              "expectedOutput": "[37,1]",
              "explanation": "The only possible rectangle with area 37 is a rectangle with length 37 and width 1.",
              "id": "cb8bcf6b-b4b4-4424-a0a2-2634915493ba",
              "input": "area = 37"
            }
          ]
        },
        {
          "approach": "Start from the square root of the area and try to find the factors of the area. For each factor, calculate the perimeter and update the result if the perimeter is smaller. We can stop the loop when the factor is smaller than the square root of the area because a larger factor of the area would be a multiple of a smaller factor that has already been checked.",
          "code": "func constructRectangle(area: Int) -> [Int] {\n    var length = Int(sqrt(Double(area)))\n    while length > 0 {\n        if area % length == 0 {\n            return [length, area / length]\n        }\n        length -= 1\n    }\n    return []\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the result.",
            "time": "O(sqrt(area))",
            "timeExplanation": "We iterate from the square root of the area down to 1."
          },
          "explanation": "We start from the square root of the area because a larger factor of the area would be a multiple of a smaller factor that has already been checked.",
          "id": "cff897a3-adb4-4485-8c11-b0a5e9a94359",
          "intuition": "This approach works by trying to find the factors of the area in a more efficient way. Instead of trying all the possible factors, we only try the factors that are closer to the square root of the area.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2,2]",
              "explanation": "The only possible rectangle with area 4 is a square with side length 2.",
              "id": "21276383-4c91-49ed-a3a2-c7e7684d799e",
              "input": "area = 4"
            },
            {
              "expectedOutput": "[37,1]",
              "explanation": "The only possible rectangle with area 37 is a rectangle with length 37 and width 1.",
              "id": "ac2f0a9d-529b-4bc8-bb6d-5339bb0f3a72",
              "input": "area = 37"
            }
          ]
        }
      ],
      "id": "e574add7-aa24-48da-8b89-225fb7041881",
      "lastUpdated": "2026-02-06T21:21:53Z",
      "problemSlug": "construct-the-rectangle",
      "relatedProblems": [
        "rectangle-overlap",
        "best-time-to-buy-and-sell-stock-iii"
      ],
      "summary": "Construct the Rectangle is a problem where we need to find a rectangle with the given area and the minimum perimeter. The key insight here is that we can start from the square root of the area and try to find the factors of the area."
    },
    {
      "approaches": [
        {
          "approach": "We iterate over all possible subarrays, calculate their sums, and update the maximum length if a match is found.",
          "code": "func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; for i in 0..<n { var sum = 0; for j in i..<n { sum += nums[j]; if sum % k == 0 && sum != 0 { return true } } } return false }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the sum and indices.",
            "time": "O(n^2)",
            "timeExplanation": "We are using two nested loops to iterate over all subarrays."
          },
          "explanation": "For each subarray, we use a nested loop to calculate its sum and check if it equals k. If it does, we update the maximum length.",
          "id": "c026982d-976f-4067-b691-c83ae34cb2a9",
          "intuition": "This approach involves checking every possible subarray to see if its sum is equal to k. This is not efficient for large inputs.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Because [2, 4] is a continuous subarray of size 2 and 2 + 4 = 6.",
              "id": "f787bc07-4cf1-460a-b45a-58028a64641b",
              "input": "nums = [23,2,4,6,7], k = 6"
            },
            {
              "expectedOutput": "true",
              "explanation": "Because [23, 2, 6] is a continuous subarray of size 3 and 23 + 2 + 6 = 31, 31 % 6 = 1, [2, 6] is a continuous subarray of size 2 and 2 + 6 = 8, 8 % 6 = 2, [6, 4] is a continuous subarray of size 2 and 6 + 4 = 10, 10 % 6 = 4, [2, 6, 4] is a continuous subarray of size 3 and 2 + 6 + 4 = 12, 12 % 6 = 0.",
              "id": "fc1d2003-7c34-471c-b51b-86d5c61874f5",
              "input": "nums = [23,2,6,4,7], k = 6"
            }
          ]
        },
        {
          "approach": "We iterate over the array, calculate the prefix sum, and check if the hash table contains a prefix sum equal to the current prefix sum minus k.",
          "code": "func checkSubarraySum(_ nums: [Int], _ k: Int) -> Bool { let n = nums.count; var prefixSum = 0; var hashTable: [Int: Int] = [0: -1]; for i in 0..<n { prefixSum += nums[i]; if k != 0 && hashTable.contains(where: { $0.key == prefixSum % k }) { return true } if hashTable[prefixSum % k] == nil { hashTable[prefixSum % k] = i } } return false }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are using a hash table to store the prefix sums and their indices.",
            "time": "O(n)",
            "timeExplanation": "We are using a single loop to iterate over the array."
          },
          "explanation": "We use a hash table to store the prefix sums and their indices. For each prefix sum, we check if the hash table contains a prefix sum equal to the current prefix sum minus k. If it does, we update the maximum length.",
          "id": "cbada424-f745-4194-be4b-7a21631c25ab",
          "intuition": "We can use a hash table to store prefix sums and their indices to efficiently find a sum equal to k.",
          "name": "Prefix Sum with Hash Table",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "Because there is no continuous subarray of size greater than 0 and with a sum that is a multiple of 13.",
              "id": "d68ec970-ad89-4572-b725-c1d6dc442b5f",
              "input": "nums = [23,2,4,6,7], k = 13"
            },
            {
              "expectedOutput": "true",
              "explanation": "Because [2, 6] is a continuous subarray of size 2 and 2 + 6 = 8, 8 % 6 = 2, [6, 4] is a continuous subarray of size 2 and 6 + 4 = 10, 10 % 6 = 4, [2, 6, 4] is a continuous subarray of size 3 and 2 + 6 + 4 = 12, 12 % 6 = 0.",
              "id": "0719fe4d-7195-4ad7-8ed2-bfbc25406fff",
              "input": "nums = [23,2,6,4,7], k = 6"
            }
          ]
        }
      ],
      "id": "ca3e1fb2-ab1c-4720-848a-f6daeba6b2ee",
      "lastUpdated": "2026-02-06T21:24:06Z",
      "problemSlug": "continuous-subarray-sum",
      "relatedProblems": [
        "subarray-sum-equals-k",
        "continuous-subarray-sum"
      ],
      "summary": "The problem asks to find the maximum length of a subarray with a sum equal to k. We use prefix sums and hash tables to efficiently solve this problem."
    },
    {
      "approaches": [
        {
          "approach": "1. Check if the input number is negative and if so, convert it to positive and add a '-' sign to the result. 2. Initialize an empty string to store the hexadecimal representation. 3. Loop until the number becomes 0, in each iteration divide the number by 16 and prepend the corresponding hexadecimal digit to the result string. 4. If the number is 0, return '0'.",
          "code": "func toHex(num: Int) -> String { if num == 0 { return \"0\" } var result = String() var n = abs(num) while n != 0 { let r = n % 16 result = String(\"0123456789abcdef\"[r], radix: 16) + result n /= 16 } if num < 0 { result = \"-\" + result } return result }",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "Space complexity is O(log n) because the maximum length of the result string is log(n) in base 16.",
            "time": "O(log n)",
            "timeExplanation": "Time complexity is O(log n) because we are continuously dividing the number by 16 until it becomes 0."
          },
          "explanation": "This approach works because it directly maps decimal digits to their hexadecimal counterparts by continuously dividing by 16, effectively performing base conversion.",
          "id": "4118ac5a-c430-4f96-83d5-6530799f8bfa",
          "intuition": "The brute force approach involves converting the integer to a hexadecimal string by continuously dividing the number by 16 and prepending the corresponding hexadecimal digit to the result string.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "a",
              "explanation": "The hexadecimal representation of 10 is 'a'.",
              "id": "a9ff5d0d-6730-466c-9878-6009941ecac4",
              "input": "num = 10"
            },
            {
              "expectedOutput": "f",
              "explanation": "The hexadecimal representation of 15 is 'f'.",
              "id": "d3e1a461-6af8-457a-b5ab-54a5fe64c73e",
              "input": "num = 15"
            },
            {
              "expectedOutput": "17",
              "explanation": "The hexadecimal representation of 23 is '17'.",
              "id": "1d4d22e7-dc85-4b18-bc4a-12826857bd42",
              "input": "num = 23"
            }
          ]
        },
        {
          "approach": "1. Check if the input number is negative and if so, convert it to positive and add a '-' sign to the result. 2. Use Swift's String format specifier to convert the number to a hexadecimal string.",
          "code": "func toHex(num: Int) -> String { let n = abs(num) if n == 0 { return \"0\" } let result = String(n, radix: 16) return num < 0 ? \"-\" + result : result }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Space complexity is O(1) because the space required does not grow with the input size.",
            "time": "O(1)",
            "timeExplanation": "Time complexity is O(1) because Swift's string formatting is implemented in constant time."
          },
          "explanation": "This approach works because it leverages Swift's optimized string formatting functionality, which is implemented in a more efficient manner than a manual loop.",
          "id": "9bb2b1cc-3615-445e-8991-4f0408b59189",
          "intuition": "The optimized approach uses Swift's built-in string formatting capabilities to convert the integer to a hexadecimal string.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "a",
              "explanation": "The hexadecimal representation of 10 is 'a'.",
              "id": "a74248f3-2b24-41db-afb5-55017b2a90b2",
              "input": "num = 10"
            },
            {
              "expectedOutput": "f",
              "explanation": "The hexadecimal representation of 15 is 'f'.",
              "id": "8225b1ea-a795-4439-a63f-56888704e8ca",
              "input": "num = 15"
            },
            {
              "expectedOutput": "17",
              "explanation": "The hexadecimal representation of 23 is '17'.",
              "id": "f3f18a1e-7c31-4720-80fc-e20a6a5c33fa",
              "input": "num = 23"
            }
          ]
        }
      ],
      "id": "3d5ef0a9-3547-4e4b-a315-2b8265dfb739",
      "lastUpdated": "2026-02-06T21:16:54Z",
      "problemSlug": "convert-a-number-to-hexadecimal",
      "relatedProblems": [
        "base7",
        "roman-to-integer"
      ],
      "summary": "This problem requires converting a given integer to its hexadecimal representation, with key insights involving handling negative numbers and efficiently mapping decimal to hexadecimal."
    },
    {
      "approaches": [
        {
          "approach": "Initialize an empty string to store the result, then enter a while loop where we divide the input number by -2, append the remainder to the result, and update the input number to be the quotient. If the remainder is -1, we set the remainder to 1 and decrement the quotient.",
          "code": "func baseNeg2(N: Int) -> String {\n    var n = N\n    var res = \"\"\n    while n != 0 {\n        var remainder = n % -2\n        n /= -2\n        if remainder < 0 {\n            remainder = 1\n            n += 1\n        }\n        res = String(remainder) + res\n    }\n    return res.isEmpty ? \"0\" : res\n}",
          "complexity": {
            "space": "O(logN)",
            "spaceExplanation": "The space complexity is O(logN) because we need to store the result string, which has a maximum length of logN.",
            "time": "O(logN)",
            "timeExplanation": "The time complexity is O(logN) because the while loop runs for at most logN iterations, where N is the input number."
          },
          "explanation": "The brute force approach uses a while loop to repeatedly divide the input number by -2 and append the remainder to the result. This process continues until the input number becomes 0. If the remainder is -1, we set the remainder to 1 and decrement the quotient to ensure the result is in base -2.",
          "id": "e1fbcf7b-e52a-4aa8-bde1-5589d5729285",
          "intuition": "This approach works by repeatedly dividing the input number by -2 and appending the remainder to the result, handling the case where the remainder is -1 specially.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "10",
              "explanation": "The binary representation of 2 in base -2 is 10.",
              "id": "a8690e33-a400-41ed-9327-9a74566b186c",
              "input": "N = 2"
            },
            {
              "expectedOutput": "11",
              "explanation": "The binary representation of 3 in base -2 is 11.",
              "id": "5679ea50-81ac-448c-b30b-f32502792ede",
              "input": "N = 3"
            },
            {
              "expectedOutput": "100",
              "explanation": "The binary representation of 4 in base -2 is 100.",
              "id": "9e0784b8-b3af-4e4e-baac-5aa28c0af95a",
              "input": "N = 4"
            }
          ]
        },
        {
          "approach": "Use a while loop to repeatedly divide the input number by -2 and append the remainder to the result, handling the case where the remainder is -1 by using the bitwise AND operator to check if the remainder is -1 and adjusting the quotient and remainder accordingly.",
          "code": "func baseNeg2(N: Int) -> String { \n  var n = N \n  var res = \"\" \n  while n != 0 { \n    let remainder = n % -2 \n    n = (n - remainder) / -2 \n    if remainder < 0 { \n      remainder = 1 \n      n += 1 \n    } \n    res = String(remainder) + res \n  } \n  return res.isEmpty ? \"0\" : res \n}",
          "complexity": {
            "space": "O(logN)",
            "spaceExplanation": "The space complexity is O(logN) because we need to store the result string, which has a maximum length of logN.",
            "time": "O(logN)",
            "timeExplanation": "The time complexity is O(logN) because the while loop runs for at most logN iterations, where N is the input number."
          },
          "explanation": "The optimized approach uses a while loop to repeatedly divide the input number by -2 and append the remainder to the result. This process continues until the input number becomes 0. If the remainder is -1, we use the bitwise AND operator to check if the remainder is -1 and adjust the quotient and remainder accordingly to ensure the result is in base -2.",
          "id": "2758df1d-623a-4b9c-afc4-9ae56dac845e",
          "intuition": "This approach works similarly to the brute force approach but uses a more efficient method to handle the case where the remainder is -1.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "101",
              "explanation": "The binary representation of 5 in base -2 is 101.",
              "id": "a378280a-d550-4ae8-8127-d1cc965df6c4",
              "input": "N = 5"
            },
            {
              "expectedOutput": "110",
              "explanation": "The binary representation of 6 in base -2 is 110.",
              "id": "3af8d234-213c-4e4b-b249-b3ca8954cee3",
              "input": "N = 6"
            },
            {
              "expectedOutput": "111",
              "explanation": "The binary representation of 7 in base -2 is 111.",
              "id": "54e955fd-33da-47d1-9afa-ff655050b262",
              "input": "N = 7"
            }
          ]
        }
      ],
      "id": "91522e2d-7f50-4db6-b108-1a5157bf747d",
      "lastUpdated": "2026-02-06T21:55:54Z",
      "problemSlug": "convert-to-base-2",
      "relatedProblems": [
        "base7-to-decimal",
        "roman-to-integer"
      ],
      "summary": "The problem requires converting a given integer to base -2, where each digit can be either 0 or 1, and the place values are powers of -2. The key insight is to use a while loop to repeatedly divide the number by -2 and append the remainder to the result."
    },
    {
      "approaches": [
        {
          "approach": "Start from 0 and check each number one by one. For each number, convert it to a string or an array of digits and use a set to check for uniqueness.",
          "code": "func countNumbersWithUniqueDigits(_ n: Int) -> Int {\n    var count = 0\n    for i in 0...n {\n        var num = i\n        var unique = true\n        var seen: [Int: Bool] = [:]\n        while num > 0 {\n            let digit = num % 10\n            if seen[digit] != nil {\n                unique = false\n                break\n            }\n            seen[digit] = true\n            num /= 10\n        }\n        if unique {\n            count += 1\n        }\n    }\n    return count\n}",
          "complexity": {
            "space": "O(log(n))",
            "spaceExplanation": "Space complexity comes from storing the digits of a number in a set or map, which requires log(n) space.",
            "time": "O(n * log(n))",
            "timeExplanation": "Time complexity comes from iterating through n numbers, and for each number, we are processing its digits which takes log(n) time."
          },
          "explanation": "This method involves iterating through all numbers from 0 up to the given number n, converting each number into a string or an array of digits, then using a set to check if all digits are unique. If they are, increment the count.",
          "id": "ae2d78dd-dfcc-4855-a93a-ef4b674563bc",
          "intuition": "Checking every number up to a given number for unique digits will yield the desired count.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Only numbers 0 and 1 have unique digits in this range.",
              "id": "41a7ea31-67d5-43f2-9189-78947fe5757f",
              "input": "n = 2"
            },
            {
              "expectedOutput": "4",
              "explanation": "Numbers 0, 1, 2, and 3 all have unique digits.",
              "id": "81a9ee5c-06ea-437b-be47-3b0ebab936aa",
              "input": "n = 3"
            }
          ]
        },
        {
          "approach": "For a number of length L, the first digit can be chosen in 9 ways (excluding 0), the second in 9 ways (since one digit is already used), then 8, and so on, down to (10-L) ways for the Lth digit.",
          "code": "func countNumbersWithUniqueDigits(_ n: Int) -> Int {\n    let length = String(n).count\n    var count = 0\n    for i in 0...length {\n        if i == 0 {\n            count += 1\n            continue\n        }\n        let available = 9\n        let choose = i - 1\n        var temp = 1\n        for j in 0...choose-1 {\n            temp *= (available - j)\n        }\n        count += temp\n    }\n    return count\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Space complexity is constant since we only use a fixed amount of space to store our variables.",
            "time": "O(log(n))",
            "timeExplanation": "Time complexity is determined by the loop over the length of the input number n, which is proportional to log(n)."
          },
          "explanation": "For each length up to the length of the given number n, calculate the number of combinations where digits do not repeat. Sum these up for lengths from 1 to L, where L is the length of n, considering that for numbers of length 0 (i.e., the number 0), there's exactly one valid combination.",
          "id": "edbc6496-2ea9-4731-b31f-22d556fca0ab",
          "intuition": "Recognizing that for numbers up to a certain length, we can calculate the number of valid combinations without repetition using combinatorial principles.",
          "name": "Mathematical Optimization",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Numbers 0 and 1 are counted.",
              "id": "c946997a-3312-4b44-bb02-027ba1ce132c",
              "input": "n = 2"
            },
            {
              "expectedOutput": "10",
              "explanation": "All single-digit numbers have unique digits.",
              "id": "74a04d67-7228-45f2-9ed0-1730e0ab24a0",
              "input": "n = 10"
            }
          ]
        }
      ],
      "id": "a371e432-bf7b-4245-89ab-df002ac5ee9c",
      "lastUpdated": "2026-02-06T21:14:02Z",
      "problemSlug": "count-numbers-with-unique-digits",
      "relatedProblems": [
        "combinations",
        "handshakes"
      ],
      "summary": "The Count Numbers with Unique Digits problem is about counting numbers with unique digits. Key insight involves recognizing that each digit position can be filled in a way that avoids repetition."
    },
    {
      "approaches": [
        {
          "approach": "Start from 2 and check each number up to n to see if it is divisible by any number less than it. If it is not divisible by any of them, it is a prime.",
          "code": "func countPrimes(_ n: Int) -> Int { \n    if n <= 2 { return 0 } \n    var count = 0 \n    for i in 2..<n { \n        var isPrime = true \n        for j in 2..<i { \n            if i % j == 0 { \n                isPrime = false \n                break \n            } \n        } \n        if isPrime { count += 1 } \n    } \n    return count \n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the count of primes and the variables in the loops, hence the space complexity is O(1).",
            "time": "O(n^2)",
            "timeExplanation": "For each number i up to n, we check divisibility with all numbers less than i, leading to n*(n-1)/2 checks in total, hence the time complexity is O(n^2)."
          },
          "explanation": "This approach is straightforward but not efficient for large n because it has to perform many unnecessary checks.",
          "id": "70011547-ad2b-436f-97c1-c72dbf76613a",
          "intuition": "The brute force approach checks each number up to n to see if it is prime by testing divisibility with all numbers less than it.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The prime numbers less than 10 are 2, 3, 5, and 7, so the function should return 4.",
              "id": "464a816c-9e70-49d2-920b-96781b4b7bb8",
              "input": "n = 10"
            },
            {
              "expectedOutput": "8",
              "explanation": "The prime numbers less than 20 are 2, 3, 5, 7, 11, 13, 17, and 19, so the function should return 8.",
              "id": "0568285c-eab3-45c1-af89-d2a65c7faaf8",
              "input": "n = 20"
            }
          ]
        },
        {
          "approach": "Create a boolean array, prime, of size n. Initialize all entries as true. Starting from 2, iterate over each prime p, and mark all multiples of p as false. Finally, count all true entries in the prime array.",
          "code": "func countPrimes(_ n: Int) -> Int { \n    if n <= 2 { return 0 } \n    var prime = [Bool](repeating: true, count: n) \n    prime[0] = false; prime[1] = false \n    for p in 2...Int(sqrt(Double(n))) { \n        if prime[p] { \n            for i in stride(from: p*p, to: n, by: p) { \n                prime[i] = false \n            } \n        } \n    } \n    return prime.filter { $0 }.count \n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the boolean array of size n used to keep track of prime numbers.",
            "time": "O(n log log n)",
            "timeExplanation": "The time complexity is O(n log log n) because each number up to n is processed at most once for each of its prime factors, and the sum of the reciprocals of the prime factors of n grows like log log n."
          },
          "explanation": "This approach is much more efficient than the brute force approach because it takes advantage of the fact that if a number is composite, it must have a prime factor less than or equal to its square root.",
          "id": "10dc331f-9e9f-4410-bf02-2ca54d36c880",
          "intuition": "The Sieve of Eratosthenes approach works by iteratively marking the multiples of each prime number starting from 2.",
          "name": "Sieve of Eratosthenes",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The prime numbers less than 10 are 2, 3, 5, and 7, so the function should return 4.",
              "id": "44de8867-50f2-4720-bb0a-92a8b730ff6a",
              "input": "n = 10"
            },
            {
              "expectedOutput": "8",
              "explanation": "The prime numbers less than 20 are 2, 3, 5, 7, 11, 13, 17, and 19, so the function should return 8.",
              "id": "c9c6e02c-448b-4d64-a7f8-df1e3f6bb3ca",
              "input": "n = 20"
            }
          ]
        }
      ],
      "id": "ffd210a6-ee21-45ce-b00f-8c3494dc1c99",
      "lastUpdated": "2026-02-06T21:10:20Z",
      "problemSlug": "count-primes",
      "relatedProblems": [
        "prime-palindrome",
        "advantage-shuffle"
      ],
      "summary": "The problem asks to count the number of prime numbers less than a given number n. The key insight here is to use the Sieve of Eratosthenes algorithm, which is an efficient method to find all primes smaller than n."
    },
    {
      "approaches": [
        {
          "approach": "The approach involves using a recursive function to add parentheses at each possible position in the expression and calculating the result for each recursive call. It uses a helper function to evaluate the expression with the added parentheses.",
          "code": "func diffWaysToCompute(expression: String) -> [Int] {\n    if let num = Int(expression) {\n        return [num]\n    }\n    var result: [Int] = []\n    for i in 0..<expression.count {\n        if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n            let left = diffWaysToCompute(String(expression.prefix(i)))\n            let right = diffWaysToCompute(String(expression.suffix(expression.count - i - 1)))\n            for num1 in left {\n                for num2 in right {\n                    if expression[i] == \"+\" {\n                        result.append(num1 + num2)\n                    } else if expression[i] == \"-\" {\n                        result.append(num1 - num2)\n                    } else if expression[i] == \"*\" {\n                        result.append(num1 * num2)\n                    }\n                }\n            }\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear due to the recursive call stack.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential due to the recursive calls and trying all possible ways to add parentheses."
          },
          "explanation": "The brute force approach tries all possible ways to add parentheses and calculates the result for each one. It can be quite inefficient for large expressions due to the exponential time complexity.",
          "id": "c08bca16-9477-4f2d-bc91-6ddf549009e6",
          "intuition": "This approach involves trying all possible ways to add parentheses and calculating the result for each one.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2,0]",
              "explanation": "The expression 2-1-1 can be evaluated as (2)-(1-1) = 2 or 2-(1-1) = 0.",
              "id": "9b53204a-ab54-4a20-bd6d-8b8c83aaa730",
              "input": "2-1-1"
            },
            {
              "expectedOutput": "[-34,-10,-14,-10,10]",
              "explanation": "The expression 2*3-4*5 can be evaluated in different ways by adding parentheses at different positions.",
              "id": "8596f01b-0b7a-4d59-9b18-351d818bd4cc",
              "input": "2*3-4*5"
            }
          ]
        },
        {
          "approach": "The approach involves using a dictionary to store the results of subproblems. It iterates over the expression and uses the stored results to calculate the final result.",
          "code": "func diffWaysToCompute(expression: String) -> [Int] {\n    var memo: [String: [Int]] = [:]\n    func dp(_ expression: String) -> [Int] {\n        if let num = Int(expression) {\n            return [num]\n        }\n        if let result = memo[expression] {\n            return result\n        }\n        var result: [Int] = []\n        for i in 0..<expression.count {\n            if expression[i] == \"+\" || expression[i] == \"-\" || expression[i] == \"*\" {\n                let left = dp(String(expression.prefix(i)))\n                let right = dp(String(expression.suffix(expression.count - i - 1)))\n                for num1 in left {\n                    for num2 in right {\n                        if expression[i] == \"+\" {\n                            result.append(num1 + num2)\n                        } else if expression[i] == \"-\" {\n                            result.append(num1 - num2)\n                        } else if expression[i] == \"*\" {\n                            result.append(num1 * num2)\n                        }\n                    }\n                }\n            }\n        }\n        memo[expression] = result\n        return result\n    }\n    return dp(expression)\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is due to the dictionary used to store the results of subproblems.",
            "time": "O(n^4)",
            "timeExplanation": "The time complexity is due to the nested loops and recursive calls."
          },
          "explanation": "The dynamic programming approach uses a dictionary to store the results of subproblems and avoid redundant calculations. It can efficiently calculate the results for large expressions.",
          "id": "045ece27-83d9-4dc9-ac94-6ad98b2d9ae5",
          "intuition": "This approach involves using dynamic programming to store the results of subproblems and avoid redundant calculations.",
          "name": "Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2,0]",
              "explanation": "The expression 2-1-1 can be evaluated as (2)-(1-1) = 2 or 2-(1-1) = 0.",
              "id": "2004a95e-663b-4414-8e45-5c1d610beff5",
              "input": "2-1-1"
            },
            {
              "expectedOutput": "[-34,-10,-14,-10,10]",
              "explanation": "The expression 2*3-4*5 can be evaluated in different ways by adding parentheses at different positions.",
              "id": "34c2be7c-231c-4547-a859-ba6e59e7ce4f",
              "input": "2*3-4*5"
            }
          ]
        }
      ],
      "id": "0329e597-972e-4c26-b26f-1e2878457c2e",
      "lastUpdated": "2026-02-06T21:11:23Z",
      "problemSlug": "different-ways-to-add-parentheses",
      "relatedProblems": [
        "unique-binary-search-trees",
        "validate-ip-address"
      ],
      "summary": "The problem involves finding different ways to add parentheses to a given mathematical expression to generate all possible results. The key insight is to use recursion and dynamic programming to solve this problem efficiently."
    },
    {
      "approaches": [
        {
          "approach": "1. Check if the dividend is less than the divisor. 2. If it is, return 0. 3. Otherwise, subtract the divisor from the dividend and repeat the process until the dividend is less than the divisor.",
          "code": "func divide(_ dividend: Int, _ divisor: Int) -> Int {\n    if dividend == 0 {\n        return 0\n    }\n    var count = 0\n    var isNegative = (dividend < 0) == (divisor < 0)\n    var absDividend = abs(dividend)\n    var absDivisor = abs(divisor)\n    while absDividend >= absDivisor {\n        absDividend -= absDivisor\n        count += 1\n    }\n    if !isNegative && count > Int32.max {\n        return Int(Int32.max)\n    }\n    if isNegative && count > Int32.max {\n        return Int(Int32.min)\n    }\n    return isNegative ? -count : count\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the variables.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the dividend because in the worst-case scenario, we might need to subtract the divisor from the dividend n times."
          },
          "explanation": "This approach is not efficient for large numbers because it uses repeated subtraction, which has a time complexity of O(n). However, it provides a baseline understanding of the problem.",
          "id": "4c6d7186-7757-4754-9197-3d25531f4f56",
          "intuition": "This approach works by repeatedly subtracting the divisor from the dividend until the dividend becomes less than the divisor.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "10 divided by 3 is 3 with a remainder of 1. So the expected output is 3.",
              "id": "d5c50413-67a0-490d-b238-b20537c277fc",
              "input": "dividend = 10, divisor = 3"
            },
            {
              "expectedOutput": "-2",
              "explanation": "-7 divided by 3 is -2 with a remainder of -1. So the expected output is -2.",
              "id": "c057b6cb-b19a-42cc-9d54-14d85c0bfd3d",
              "input": "dividend = -7, divisor = 3"
            }
          ]
        },
        {
          "approach": "1. Check if the dividend is less than the divisor. 2. If it is, return 0. 3. Initialize the quotient to 0. 4. Use a loop to repeatedly double the divisor and left shift the quotient until the divisor is greater than the dividend.",
          "code": "func divide(_ dividend: Int, _ divisor: Int) -> Int {\n    var isNegative = (dividend < 0) != (divisor < 0)\n    var absDividend = Int64(abs(dividend))\n    var absDivisor = Int64(abs(divisor))\n    var quotient = 0\n    while absDividend >= absDivisor {\n        var shift = 0\n        while (absDivisor << shift) <= absDividend {\n            shift += 1\n        }\n        shift -= 1\n        absDividend -= absDivisor << shift\n        quotient += 1 << shift\n    }\n    if !isNegative && quotient > Int32.max {\n        return Int(Int32.max)\n    }\n    if isNegative && quotient > Int32.max {\n        return Int(Int32.min)\n    }\n    return isNegative ? -Int(quotient) : Int(quotient)\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the variables.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is O(log n) where n is the dividend because in the worst-case scenario, we need to double the divisor log(n) times."
          },
          "explanation": "This approach is more efficient than the brute-force approach because it uses bit manipulation to perform the division, which reduces the time complexity.",
          "id": "e0ef45fd-e0c5-4a99-976b-f167fffa12a2",
          "intuition": "This approach works by using bit manipulation to perform the division. We use left shift to double the divisor and right shift to halve the dividend.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "10 divided by 3 is 3 with a remainder of 1. So the expected output is 3.",
              "id": "54cb8ccb-c207-4665-bd33-40e9a7275a22",
              "input": "dividend = 10, divisor = 3"
            },
            {
              "expectedOutput": "-2",
              "explanation": "-7 divided by 3 is -2 with a remainder of -1. So the expected output is -2.",
              "id": "4ce316e8-a125-4245-875d-091d4d919e3d",
              "input": "dividend = -7, divisor = 3"
            },
            {
              "expectedOutput": "20",
              "explanation": "123 divided by 6 is 20 with a remainder of 3. So the expected output is 20.",
              "id": "ae1fda4d-eda1-440b-8953-fda1ca0fbaf6",
              "input": "dividend = 123, divisor = 6"
            }
          ]
        }
      ],
      "id": "2fdf8b09-5652-4b68-882e-6bb7baebe8e0",
      "lastUpdated": "2026-02-06T21:04:30Z",
      "problemSlug": "divide-two-integers",
      "relatedProblems": [
        "multiply-strings",
        "integer-to-english-words"
      ],
      "summary": "This problem requires us to divide two integers without using multiplication, division, or mod operator. The key insight is to use bit manipulation to perform the division."
    },
    {
      "approaches": [
        {
          "approach": "Start with N and try all possible divisors. For each divisor, recursively determine the winning strategy for N-divisor. If a winning strategy is found, return True. Otherwise, return False.",
          "code": "func divisorGame(_ N: Int) -> Bool { \n    var seen: [Bool] = [Bool](repeating: false, count: N + 1) \n    return helper(N, &seen) \n} \n \nfunc helper(_ N: Int, _ seen: inout [Bool]) -> Bool { \n    if N == 0 { \n        return false \n    } \n    if seen[N] { \n        return false \n    } \n    seen[N] = true \n    for i in 1...N { \n        if N % i == 0 && !helper(N - i, &seen) { \n            return true \n        } \n    } \n    return false \n}",
          "complexity": {
            "space": "O(N)",
            "spaceExplanation": "The space complexity is O(N) due to the storage of the seen array.",
            "time": "O(2^N)",
            "timeExplanation": "The time complexity is O(2^N) due to the recursive nature of the approach."
          },
          "explanation": "The brute-force approach tries all possible divisors of N and recursively determines the winning strategy for each divisor. However, this approach is inefficient due to its high time complexity.",
          "id": "01b29c91-7c5a-4e1b-8334-439550e02da8",
          "intuition": "This approach works by trying all possible divisors of N and recursively determining the winning strategy for each divisor.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The first player can choose 1 as the divisor, leaving 1 for the second player, who loses.",
              "id": "479264c8-886a-48b9-8571-1a1f5bb0f283",
              "input": "N = 2"
            },
            {
              "expectedOutput": "False",
              "explanation": "The first player cannot choose a divisor that leaves the second player with a losing position.",
              "id": "a75c0928-526a-424e-b57b-8a5ed5dbdbc4",
              "input": "N = 3"
            }
          ]
        },
        {
          "approach": "Create a DP array where DP[i] represents the winning strategy for i. Iterate through all numbers and update the DP array accordingly.",
          "code": "func divisorGame(_ N: Int) -> Bool { \n    var dp: [Bool] = [Bool](repeating: false, count: N + 1) \n    dp[0] = false \n    dp[1] = false \n    for i in 2...N { \n        for j in 1...i { \n            if i % j == 0 && !dp[i - j] { \n                dp[i] = true \n                break \n            } \n        } \n    } \n    return dp[N] \n}",
          "complexity": {
            "space": "O(N)",
            "spaceExplanation": "The space complexity is O(N) due to the storage of the DP array.",
            "time": "O(N^2)",
            "timeExplanation": "The time complexity is O(N^2) due to the nested loops."
          },
          "explanation": "The dynamic programming approach uses a DP array to track the winning strategy for each number. This approach is more efficient than the brute-force approach due to its lower time complexity.",
          "id": "90114997-c1b1-490c-8ee4-194e887b2322",
          "intuition": "This approach works by using dynamic programming to track the winning strategy for each number.",
          "name": "Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The first player can choose 1 as the divisor, leaving 1 for the second player, who loses.",
              "id": "95573b72-9b96-4988-a58a-799ad5ca2aa3",
              "input": "N = 2"
            },
            {
              "expectedOutput": "False",
              "explanation": "The first player cannot choose a divisor that leaves the second player with a losing position.",
              "id": "c70c5b52-502f-4865-8b96-f3521c6c4d0a",
              "input": "N = 3"
            }
          ]
        }
      ],
      "id": "bd9da89c-bfc4-4a95-a077-2342b532dc6c",
      "lastUpdated": "2026-02-06T21:56:41Z",
      "problemSlug": "divisor-game",
      "relatedProblems": [
        "stone-game",
        "can-i-win"
      ],
      "summary": "The Divisor Game problem involves determining the winner of a game where two players take turns choosing a divisor of N. The key insight is to use dynamic programming to track the winning strategy for each number."
    },
    {
      "approaches": [
        {
          "approach": "Start with a list of numbers from 1 to n. Iterate through the list and eliminate every second number, updating the direction of elimination after each pass",
          "code": "func lastRemaining(n: Int) -> Int {\n    var head = 1\n    var remaining = n\n    var isForward = true\n    var step = 1\n    while remaining > 1 {\n        if isForward || remaining % 2 == 1 {\n            head += step\n        }\n        step *= 2\n        remaining /= 2\n        isForward.toggle()\n    }\n    return head\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only a constant amount of space is used to keep track of variables",
            "time": "O(n)",
            "timeExplanation": "Each number is eliminated exactly once"
          },
          "explanation": "This approach is straightforward and works for small inputs, but its time complexity makes it impractical for large inputs. It provides a baseline understanding of the problem, which can be used to develop more efficient solutions",
          "id": "58a0bb35-1c58-477f-b79f-1b4010d8b7f4",
          "intuition": "This approach works by directly simulating the elimination process and keeping track of the remaining numbers",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The elimination sequence is: 1, 2, 3, 4, 5 -> 3 -> 1, 2 -> 2",
              "id": "9dd8e20b-beca-4536-b653-fdd87b2d40b3",
              "input": "n = 5"
            },
            {
              "expectedOutput": "6",
              "explanation": "The elimination sequence is: 1, 2, 3, 4, 5, 6, 7, 8, 9 -> 2, 4, 6, 8 -> 2, 4, 6 -> 2, 6 -> 6",
              "id": "b87b1288-5334-4002-a609-afe2b175edf9",
              "input": "n = 9"
            }
          ]
        },
        {
          "approach": "Analyze the pattern of the elimination sequence and derive a formula to calculate the position of the last remaining number based on the input size n",
          "code": "func lastRemaining(n: Int) -> Int {\n    var head = 1\n    var remaining = n\n    var isForward = true\n    var step = 1\n    while remaining > 1 {\n        if isForward || remaining % 2 == 1 {\n            head += step\n        }\n        step *= 2\n        remaining /= 2\n        isForward.toggle()\n    }\n    return head\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only a constant amount of space is used to keep track of variables",
            "time": "O(log n)",
            "timeExplanation": "The while loop runs until remaining is 1, and in each iteration, remaining is halved"
          },
          "explanation": "This approach provides an efficient solution with a significant reduction in time complexity compared to the brute-force approach. It leverages mathematical insights to directly calculate the result without simulating the elimination process",
          "id": "5529a425-5884-4766-8e26-ac04ef6dcda0",
          "intuition": "This approach works by considering the mathematical properties of the elimination sequence and finding a direct formula to calculate the last remaining number",
          "name": "Mathematical Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The elimination sequence is: 1, 2, 3 -> 2",
              "id": "7603cbfa-35ec-4fa1-b94b-75bad8c2c349",
              "input": "n = 3"
            },
            {
              "expectedOutput": "8",
              "explanation": "The elimination sequence is: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 -> 2, 4, 6, 8, 10 -> 2, 4, 6, 8 -> 2, 6, 8 -> 2, 8 -> 8",
              "id": "8b1d4d84-a65f-4763-a0bc-fc7eb3af6f7f",
              "input": "n = 10"
            }
          ]
        }
      ],
      "id": "d2c724c0-4890-4511-a9d8-3b84ff97a063",
      "lastUpdated": "2026-02-06T21:15:59Z",
      "problemSlug": "elimination-game",
      "relatedProblems": [
        "circular-array-transposition",
        "eliminate-maximum-number-of-rows"
      ],
      "summary": "The problem involves eliminating numbers in a circular fashion. The key insight is to consider the elimination process as a mathematical sequence and find the position of the last remaining number"
    },
    {
      "approaches": [
        {
          "approach": "First, initialize the player's position and the target's position. Then, iterate over each ghost and calculate its Manhattan distance to the player and the player's Manhattan distance to the target.",
          "code": "class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1]; for ghost in ghosts { if abs(ghost[0] - tx) + abs(ghost[1] - ty) <= abs(tx) + abs(ty) { return false; } } return true; } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we use a constant amount of space to store the player's, target's, and each ghost's positions.",
            "time": "O(n)",
            "timeExplanation": "We iterate over each ghost once, resulting in linear time complexity proportional to the number of ghosts."
          },
          "explanation": "We calculate the Manhattan distance by summing the absolute differences in x and y coordinates. We compare each ghost's distance to the target's distance to determine if the player can escape the ghost.",
          "id": "95e04108-20d7-4dcc-b89c-bc0de2792a65",
          "intuition": "This approach works by calculating the Manhattan distance between the player and each ghost and then comparing it with the distance to the target. If any ghost is closer, return False.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The player can reach the target before any ghost, since the ghost at [1,0] is further away than the target.",
              "id": "b61498fc-2247-4e28-9744-07119ae2f0bd",
              "input": "ghosts = [[1,0],[0,3]], target = [0,1]"
            },
            {
              "expectedOutput": "False",
              "explanation": "The ghost at [1,0] can catch the player, since the distance from the ghost to the target is less than or equal to the distance from the player to the target.",
              "id": "1b765572-6796-496b-b582-ec02b57c1cd3",
              "input": "ghosts = [[1,0]], target = [2,0]"
            }
          ]
        },
        {
          "approach": "Calculate the player's Manhattan distance to the target and immediately compare it with each ghost's distance to determine if the player can escape.",
          "code": "class Solution { func escapeGhosts(_ ghosts: [[Int]], _ target: [Int]) -> Bool { let tx = target[0], ty = target[1], px = 0, py = 0; let playerDistance = abs(tx - px) + abs(ty - py); for ghost in ghosts { let ghostDistance = abs(ghost[0] - tx) + abs(ghost[1] - ty); if ghostDistance <= playerDistance { return false; } } return true; } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity remains constant, as we only use a constant amount of space.",
            "time": "O(n)",
            "timeExplanation": "The time complexity remains linear, proportional to the number of ghosts."
          },
          "explanation": "We directly calculate the player's Manhattan distance to the target and compare it with each ghost's Manhattan distance to the target, allowing for a more efficient solution.",
          "id": "bf69c15c-e50a-4523-ac02-8726e1f01190",
          "intuition": "We can optimize the solution by directly calculating the Manhattan distance for the player and comparing it with each ghost's distance without needing to calculate and compare at each iteration.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The player can reach the target before any ghost, since all ghosts are equidistant or further away than the target.",
              "id": "5f3e5b32-fcd8-4f89-affe-15b48b91cbca",
              "input": "ghosts = [[-1,0],[0,1],[1,0],[0,-1]], target = [0,0]"
            },
            {
              "expectedOutput": "True",
              "explanation": "The player can reach the target before the ghost at [1,0], but not before the ghost at [0,3], resulting in the player being able to escape.",
              "id": "940851ed-a479-4725-8abd-2685b1811eb5",
              "input": "ghosts = [[1,0],[0,3]], target = [0,1]"
            }
          ]
        }
      ],
      "id": "a51096f1-cd44-411d-8ce2-ec4eddeb1d4b",
      "lastUpdated": "2026-02-06T21:39:40Z",
      "problemSlug": "escape-the-ghosts",
      "relatedProblems": [
        "minimize-malfunction",
        "minimum-moves-to-move-a-box-to-their-targets"
      ],
      "summary": "In the Escape the Ghosts problem, we need to determine if a player can reach the target without being caught by ghosts, given the ghosts' and target's positions. The key insight is to calculate the Manhattan distance between the player and ghosts and compare it with the distance to the target."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a variable to store the result. 2. Iterate over each character in the string from left to right. 3. For each character, convert it to a number (A=1, B=2, ..., Z=26) and multiply the current result by 26. 4. Add the converted character number to the result.",
          "code": "func titleToNumber(_ s: String) -> Int { \n    var result = 0\n    for char in s {\n        let charValue = Int(String(char).unicodeScalars.first!.value) - 64\n        result = result * 26 + charValue\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as we are using a fixed amount of space to store the result and the character values.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we are iterating over the string once."
          },
          "explanation": "The brute-force approach works by treating each character in the string as a digit in a base-26 number system. It iterates over the string, converts each character to its corresponding number, and calculates the final result.",
          "id": "a2f7ba79-8442-4068-bc33-18634bc9a438",
          "intuition": "This approach involves iterating over each character in the string and using it to calculate the corresponding column number. This method is intuitive but can be improved.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The string 'A' corresponds to the first column.",
              "id": "5dfe78de-d6e8-49ed-9b8a-db3f0d270f24",
              "input": "s = \"A\""
            },
            {
              "expectedOutput": "28",
              "explanation": "The string 'AB' corresponds to the 28th column.",
              "id": "acbf6390-42b1-49d1-bd49-ec61ad3e6962",
              "input": "s = \"AB\""
            }
          ]
        },
        {
          "approach": "1. Initialize a variable to store the result. 2. Iterate over each character in the string from left to right. 3. For each character, convert it to a number (A=1, B=2, ..., Z=26) and calculate its contribution to the result based on its position.",
          "code": "func titleToNumber(_ s: String) -> Int { \n    var result = 0\n    let sArray = Array(s)\n    for (index, char) in sArray.enumerated() {\n        let charValue = Int(String(char).unicodeScalars.first!.value) - 64\n        result += charValue * pow(26, Double(s.count - index - 1))\n    }\n    return Int(result)\n}\n\nfunc pow(_ base: Double, _ exponent: Double) -> Double {\n    return Double(Int(pow(base, exponent)))\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity remains constant as we are using a fixed amount of space to store the result and the character values.",
            "time": "O(n)",
            "timeExplanation": "The time complexity remains linear as we are still iterating over the string once."
          },
          "explanation": "The optimized approach works by using the property of the base-26 number system to calculate the result more efficiently. It avoids unnecessary multiplications and uses a more direct method to calculate the contribution of each character to the result.",
          "id": "d3723220-9143-463b-ad83-babbf3d827cf",
          "intuition": "This approach involves using a more efficient method to calculate the result. It recognizes that the Excel column title can be treated as a base-26 number and uses this property to simplify the calculation.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "27",
              "explanation": "The string 'AA' corresponds to the 27th column.",
              "id": "d47012cf-955b-4576-aa1c-26b01159a002",
              "input": "s = \"AA\""
            },
            {
              "expectedOutput": "52",
              "explanation": "The string 'AZ' corresponds to the 52nd column.",
              "id": "235fe00b-11e1-422b-a185-460c284060ab",
              "input": "s = \"AZ\""
            }
          ]
        }
      ],
      "id": "d9c79c25-b889-48f4-b535-8685cf30b0e8",
      "lastUpdated": "2026-02-06T21:08:09Z",
      "problemSlug": "excel-sheet-column-number",
      "relatedProblems": [
        " excel-sheet-column-title",
        "convert-an-integer-to-roman-numeral"
      ],
      "summary": "This problem relates to converting Excel column titles to numbers, where each column title is a string consisting of uppercase English letters. The key insight is to recognize that Excel column titles can be considered as a base-26 number system."
    },
    {
      "approaches": [
        {
          "approach": "First, determine the remainder when dividing the input number by 26. Then, prepend the corresponding character (A-Z) to the result. Next, perform integer division of the number by 26 and repeat the process until the quotient is 0.",
          "code": "func convertToTitle(_ n: Int) -> String { var result = ''; var n = n; while n > 0 { let remainder = (n - 1) % 26; result = String(UnicodeScalar(65 + remainder)) + result; n = (n - 1) / 26; } return result }",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "The space complexity is due to the storage required for the result string.",
            "time": "O(log n)",
            "timeExplanation": "The while loop runs for log(n) iterations where n is the input number."
          },
          "explanation": "Since Excel column titles start from 'A' (1) to 'Z' (26), we use the ASCII value of 'A' (65) to get the corresponding character for the calculated remainder. This approach can be less efficient for large inputs.",
          "id": "1d5df7d3-2101-46f7-b169-5e5f1fb25fc8",
          "intuition": "This approach uses a brute force method to convert each number into its corresponding Excel column title.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "A",
              "explanation": "The first Excel column title is 'A' which corresponds to the decimal number 1.",
              "id": "0ce96f27-717c-4617-bdde-9971070db6b0",
              "input": "n = 1"
            },
            {
              "expectedOutput": "AB",
              "explanation": "28 in decimal is equivalent to 'AB' in Excel column titles (A=1, B=2).",
              "id": "7da2606b-6e69-4949-a1d2-8c2936101cc5",
              "input": "n = 28"
            }
          ]
        },
        {
          "approach": "The same as the brute force approach: use the remainder when dividing the input number by 26 to get the corresponding character, and then perform integer division of the number by 26 and repeat the process until the quotient is 0.",
          "code": "func convertToTitle(_ n: Int) -> String {\n    guard n > 0 else {\n        return ''\n    }\n    let base = 26\n    var n = n\n    var result = ''\n    while n > 0 {\n        let remainder = (n - 1) % base\n        let character = UnicodeScalar(65 + remainder)\n        result = String(character) + result\n        n = (n - 1) / base\n    }\n    return result\n}",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "The space complexity remains the same as the previous approach.",
            "time": "O(log n)",
            "timeExplanation": "Similar to the previous approach, the time complexity is O(log n) because we are repeating the process for log(n) iterations."
          },
          "explanation": "The optimized solution uses the same method but with some improvements to handle the corner cases and reduce the number of operations. For example, handling the case when n is less than or equal to 0. Also, using more efficient data types and variable names.",
          "id": "e696aa51-87b6-499e-b453-fd8d6036ed69",
          "intuition": "This approach uses an optimized method to convert each number into its corresponding Excel column title, similar to the brute force method but focusing on optimization.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "AZ",
              "explanation": "52 in decimal corresponds to 'AZ' in Excel column titles (A=1, Z=26).",
              "id": "526bef8e-e3d3-46c0-a281-3a2272ee9794",
              "input": "n = 52"
            },
            {
              "expectedOutput": "ZY",
              "explanation": "701 in decimal corresponds to 'ZY' in Excel column titles (Z=26, Y=25).",
              "id": "322ab4d2-fc90-4641-9ca6-aa8400efadde",
              "input": "n = 701"
            }
          ]
        }
      ],
      "id": "411792ee-ae7e-4ab2-9784-fd45139f020a",
      "lastUpdated": "2026-02-06T21:08:04Z",
      "problemSlug": "excel-sheet-column-title",
      "relatedProblems": [
        "reverse-integer",
        "roman-to-integer"
      ],
      "summary": "This problem involves converting a integer to its corresponding Excel column title. The key insight here is to use a base-26 conversion system, similar to base-10 conversion."
    },
    {
      "approaches": [
        {
          "approach": "Calculate the factorial of the number, then convert it to a string and count the number of trailing zeroes.",
          "code": "\nfunc trailingZeroes(_ n: Int) -> Int {\n    var factorial = 1\n    for i in 1...n {\n        factorial *= i\n    }\n    var count = 0\n    let str = String(factorial)\n    for char in str {\n        if char == \"0\" {\n            count += 1\n        }\n    }\n    return str.count - count\n}\n",
          "complexity": {
            "space": "O(log(n))",
            "spaceExplanation": "The space is used to store the factorial and the string representation of the factorial, which takes O(log(n)) space.",
            "time": "O(n*log(n))",
            "timeExplanation": "The factorial calculation takes O(n) time, and converting it to a string takes O(log(n)) time. Counting the trailing zeroes takes O(log(n)) time."
          },
          "explanation": "This approach is straightforward but inefficient as it involves large calculations and string operations.",
          "id": "b0580877-803c-46ef-84d1-175f5d1bb4f0",
          "intuition": "This approach is based on the basic idea of calculating the factorial of the given number and then counting the number of trailing zeroes.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0",
              "explanation": "The factorial of 3 is 6 which has no trailing zeroes.",
              "id": "86f78896-1506-4c3d-873a-f25714ce994c",
              "input": "3"
            },
            {
              "expectedOutput": "1",
              "explanation": "The factorial of 5 is 120 which has one trailing zero.",
              "id": "e9b2808e-80f3-4c31-98ac-f06ffee471b5",
              "input": "5"
            }
          ]
        },
        {
          "approach": "Count the number of 5s in the prime factorization of the factorial by dividing the number by 5, then by 25, then by 125, and so on.",
          "code": "\nfunc trailingZeroes(_ n: Int) -> Int {\n    var count = 0\n    var i = 5\n    while n / i >= 1 {\n        count += n / i\n        i *= 5\n    }\n    return count\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space is constant as only a few variables are used.",
            "time": "O(log(n))",
            "timeExplanation": "The while loop runs until n is less than i, which takes O(log(n)) time."
          },
          "explanation": "This approach is efficient as it directly calculates the number of trailing zeroes without calculating the factorial.",
          "id": "7ddfa2db-bb8f-4ddd-b4e5-f25cca3617dc",
          "intuition": "This approach is based on the fact that the number of trailing zeroes in the factorial is determined by the number of 5s in the prime factorization of the factorial.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0",
              "explanation": "The factorial of 3 is 6 which has no trailing zeroes.",
              "id": "82a62f29-241d-4f00-b07b-bad68d2a4a7e",
              "input": "3"
            },
            {
              "expectedOutput": "1",
              "explanation": "The factorial of 5 is 120 which has one trailing zero.",
              "id": "51c6d912-a35f-46ec-a3ae-e1ef9f1bd5a1",
              "input": "5"
            }
          ]
        }
      ],
      "id": "4fbd764d-cedb-464a-a4e4-e2ea36237e66",
      "lastUpdated": "2026-02-06T21:08:13Z",
      "problemSlug": "factorial-trailing-zeroes",
      "relatedProblems": [
        "powxn",
        "num-identical-pairs"
      ],
      "summary": "The problem asks to find the number of trailing zeroes in the factorial of a given number. The key insight here is to count the number of 2s and 5s in the prime factorization of the factorial as each 10 is formed by a 2 and a 5."
    },
    {
      "approaches": [
        {
          "approach": "Start with the base cases of Fibonacci(0) = 0 and Fibonacci(1) = 1. Then, for any n > 1, return the sum of Fibonacci(n-1) and Fibonacci(n-2).",
          "code": "func fib(_ n: Int) -> Int {\n    if n == 0 { return 0 }\n    if n == 1 { return 1 }\n    return fib(n-1) + fib(n-2)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the maximum depth of the recursion tree, which is n.",
            "time": "O(2^n)",
            "timeExplanation": "Each call to fib(n) makes two more recursive calls, hence the time complexity is exponential."
          },
          "explanation": "This method involves a straightforward recursive formulation of the Fibonacci sequence, with each call branching into two more calls until it reaches the base cases.",
          "id": "a3376718-9dd7-4777-bf12-e0bf062616c9",
          "intuition": "This approach works by recursively calculating each Fibonacci number as the sum of the two preceding ones.",
          "name": "Brute Force Recursive Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "Fibonacci of 2 is the sum of Fibonacci of 1 and Fibonacci of 0, which is 1 + 0 = 1.",
              "id": "71e0af76-1ba2-4c9c-9c8b-764cbdc4e8d9",
              "input": "n = 2"
            },
            {
              "expectedOutput": "3",
              "explanation": "Following the sequence: Fibonacci(4) = Fibonacci(3) + Fibonacci(2), Fibonacci(3) = Fibonacci(2) + Fibonacci(1), Fibonacci(2) = Fibonacci(1) + Fibonacci(0). So, Fibonacci(4) = 3.",
              "id": "7f3628b6-22e3-4483-b2d0-7f522f45f759",
              "input": "n = 4"
            }
          ]
        },
        {
          "approach": "Create an array to store Fibonacci numbers as they are calculated. For each n, check if its Fibonacci number has already been calculated; if so, return the stored value. Otherwise, calculate it and store it before returning.",
          "code": "func fib(_ n: Int) -> Int {\n    var memo: [Int: Int] = [0: 0, 1: 1]\n    func fibonacci(_ n: Int) -> Int {\n        if memo[n] != nil { return memo[n]! }\n        let result = fibonacci(n-1) + fibonacci(n-2)\n        memo[n] = result\n        return result\n    }\n    return fibonacci(n)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to the storage of the memoization array.",
            "time": "O(n)",
            "timeExplanation": "Since each Fibonacci number is calculated only once and stored, the time complexity is linear."
          },
          "explanation": "This method avoids the overlapping subproblems of the recursive approach by memoizing the results, significantly reducing the computational time.",
          "id": "3bfe39ea-8f8c-4913-82b4-20a14c5359f5",
          "intuition": "This approach works by storing the results of expensive function calls and reusing them when the same inputs occur again.",
          "name": "Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "Fibonacci sequence up to 5: 0, 1, 1, 2, 3, 5.",
              "id": "68e32863-8846-4566-9829-449578a0796c",
              "input": "n = 5"
            },
            {
              "expectedOutput": "21",
              "explanation": "Continuing the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21.",
              "id": "5b8aaeaa-478e-415d-a883-c291dbc5b783",
              "input": "n = 8"
            }
          ]
        }
      ],
      "id": "6c247922-7d86-4d3d-bab7-8f826f012067",
      "lastUpdated": "2026-02-06T21:23:08Z",
      "problemSlug": "fibonacci-number",
      "relatedProblems": [
        "climbing-stairs",
        "jump-game"
      ],
      "summary": "The Fibonacci sequence is a series of numbers where a number is the addition of the last two numbers, starting with 0 and 1. The key insight to solving this problem lies in either using a brute-force recursive approach or applying dynamic programming for optimization."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize an empty list to store the result. 2. Iterate through each number from 1 to n. 3. For each number, check if it is a multiple of 3 and/or 5. 4. Append 'Fizz', 'Buzz', or 'FizzBuzz' to the result list if the number is a multiple of 3 and/or 5. Otherwise, append the number itself as a string.",
          "code": "func fizzBuzz(_ n: Int) -> [String] { \n  var result: [String] = [] \n  for i in 1...n { \n    if i % 3 == 0 && i % 5 == 0 { \n      result.append(\"FizzBuzz\") \n    } else if i % 3 == 0 { \n      result.append(\"Fizz\") \n    } else if i % 5 == 0 { \n      result.append(\"Buzz\") \n    } else { \n      result.append(String(i)) \n    } \n  } \n  return result \n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We store each number in the result list.",
            "time": "O(n)",
            "timeExplanation": "We iterate through each number from 1 to n once."
          },
          "explanation": "This approach has a time complexity of O(n) because we iterate through each number from 1 to n once. The space complexity is also O(n) because we store each number in the result list.",
          "id": "02efd37d-e745-486f-8f5d-10e08f251d8e",
          "intuition": "This approach works by iterating through each number from 1 to n and checking if it is a multiple of 3 and/or 5. If it is, we append 'Fizz', 'Buzz', or 'FizzBuzz' to the result list. Otherwise, we append the number itself as a string.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\"]",
              "explanation": "The first number is 1, the second number is 2, and the third number is 3, which is a multiple of 3.",
              "id": "9d76392b-3b40-49f4-9726-37fa5b6f1d49",
              "input": "n = 3"
            },
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
              "explanation": "The first number is 1, the second number is 2, the third number is 3, which is a multiple of 3, the fourth number is 4, and the fifth number is 5, which is a multiple of 5.",
              "id": "5adb69c3-e081-40cf-a33e-36b7eb553b2e",
              "input": "n = 5"
            },
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
              "explanation": "This test case checks the function with a larger input.",
              "id": "6de656f5-368e-4da5-b61b-701fea440ca6",
              "input": "n = 15"
            }
          ]
        },
        {
          "approach": "1. Initialize an empty list to store the result. 2. Iterate through each number from 1 to n. 3. For each number, check if it is a multiple of 3 and/or 5 and append the corresponding string to the result list.",
          "code": "func fizzBuzz(_ n: Int) -> [String] { \n  return (1...n).map { \n    switch ($0) { \n    case let x where x % 15 == 0: return \"FizzBuzz\" \n    case let x where x % 3 == 0: return \"Fizz\" \n    case let x where x % 5 == 0: return \"Buzz\" \n    default: return String($0) \n    } \n  } \n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We store each number in the result list.",
            "time": "O(n)",
            "timeExplanation": "We iterate through each number from 1 to n once."
          },
          "explanation": "This approach has a time complexity of O(n) because we iterate through each number from 1 to n once. The space complexity is also O(n) because we store each number in the result list.",
          "id": "18e41435-d980-4359-a8ae-12fc4af36f95",
          "intuition": "This approach works by using a single loop and conditional statements to generate the sequence. It uses the same logic as the brute-force approach but is more concise.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\"]",
              "explanation": "The first number is 1, the second number is 2, and the third number is 3, which is a multiple of 3.",
              "id": "5587c368-7d83-41b2-80c7-598dc3d3cff5",
              "input": "n = 3"
            },
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]",
              "explanation": "The first number is 1, the second number is 2, the third number is 3, which is a multiple of 3, the fourth number is 4, and the fifth number is 5, which is a multiple of 5.",
              "id": "8885428e-e60a-4105-9c11-d99542345484",
              "input": "n = 5"
            },
            {
              "expectedOutput": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]",
              "explanation": "This test case checks the function with a larger input.",
              "id": "c955f11f-bd2b-4f70-a714-9e1aa753efbd",
              "input": "n = 15"
            }
          ]
        }
      ],
      "id": "6a7f9e0a-e43e-4566-9a50-8f2c43010871",
      "lastUpdated": "2026-02-06T21:17:15Z",
      "problemSlug": "fizz-buzz",
      "relatedProblems": [
        "two-sum",
        "reverse-integer"
      ],
      "summary": "The Fizz Buzz problem asks us to write a function that takes an integer n as input and returns a list of strings where each string represents the number in the sequence from 1 to n, with 'Fizz' replacing multiples of 3 and 'Buzz' replacing multiples of 5. The key insight is to use a simple loop and conditional statements to generate the sequence."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Parse the string into fractions. Step 2: Calculate the numerator and denominator for each fraction. Step 3: Find the least common multiple of the denominators. Step 4: Adjust the numerators based on the least common multiple and perform the addition or subtraction",
          "code": "\nfunc fractionAddition(expression: String) -> String {\n    var i = 0\n    var A = 0, B = 1\n    while i < expression.count {\n        var sign = 1\n        if expression[i] == '-' {\n            sign = -1\n        } else if expression[i] != '+' {\n            i -= 1\n        }\n        i += 1\n        var numerator = 0\n        while i < expression.count, expression[i].isNumber {\n            numerator = numerator * 10 + Int(expression[i])!\n            i += 1\n        }\n        i += 1\n        var denominator = 0\n        while i < expression.count, expression[i].isNumber {\n            denominator = denominator * 10 + Int(expression[i])!\n            i += 1\n        }\n        numerator *= sign\n        A = A * denominator + B * numerator\n        B *= denominator\n        var g = gcd(A, B)\n        A /= g\n        B /= g\n    }\n    return String(A) + '/' + String(B)\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 { return a }\n    return gcd(b, a % b)\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as we only use a fixed amount of space to store the variables",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear as we only iterate over the string once"
          },
          "explanation": "For example, given '1/2+1/2+1/3', first parse the string into fractions [1/2, 1/2, 1/3]. Then calculate the least common multiple of the denominators which is 6. Adjust the numerators to get the equivalent fractions with the least common multiple as the denominator: [3/6, 3/6, 2/6]. Finally add the numerators to get (3+3+2)/6 = 8/6, which simplifies to 4/3",
          "id": "2cf8a5aa-e152-4257-984d-d7fff973ba99",
          "intuition": "This approach works by first breaking down the string into components, then calculating the numerator and denominator for each fraction, and finally adding or subtracting them",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "8/3",
              "explanation": "The least common multiple of the denominators is 6. The equivalent fractions are 3/6, 3/6, and 2/6. The sum of the numerators is 3 + 3 + 2 = 8, so the result is 8/3",
              "id": "de754930-0b29-4e2e-86d8-db62d8d68c14",
              "input": "1/2+1/2+1/3"
            },
            {
              "expectedOutput": "1/3",
              "explanation": "The least common multiple of the denominators is 6. The equivalent fractions are -3/6, 3/6, and 2/6. The sum of the numerators is -3 + 3 + 2 = 2, so the result is 2/6, which simplifies to 1/3",
              "id": "4004426a-732a-416d-9081-1efb925d6e57",
              "input": "-1/2+1/2+1/3"
            }
          ]
        },
        {
          "approach": "Step 1: Parse the string into fractions. Step 2: Calculate the least common multiple of the denominators using a set. Step 3: Adjust the numerators based on the least common multiple and perform the addition or subtraction",
          "code": "\nfunc fractionAddition(expression: String) -> String {\n    var i = 0\n    var A = 0, B = 1\n    while i < expression.count {\n        var sign = 1\n        if expression[i] == '-' {\n            sign = -1\n        } else if expression[i] != '+' {\n            i -= 1\n        }\n        i += 1\n        var numerator = 0\n        while i < expression.count, expression[i].isNumber {\n            numerator = numerator * 10 + Int(expression[i])!\n            i += 1\n        }\n        i += 1\n        var denominator = 0\n        while i < expression.count, expression[i].isNumber {\n            denominator = denominator * 10 + Int(expression[i])!\n            i += 1\n        }\n        numerator *= sign\n        A = A * denominator + B * numerator\n        B *= denominator\n        var g = gcd(A, B)\n        A /= g\n        B /= g\n    }\n    return String(A) + '/' + String(B)\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 { return a }\n    return gcd(b, a % b)\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as we only use a fixed amount of space to store the variables",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear as we only iterate over the string once"
          },
          "explanation": "For example, given '1/2+1/2+1/3', first parse the string into fractions [1/2, 1/2, 1/3]. Then calculate the least common multiple of the denominators which is 6. Adjust the numerators to get the equivalent fractions with the least common multiple as the denominator: [3/6, 3/6, 2/6]. Finally add the numerators to get (3+3+2)/6 = 8/6, which simplifies to 4/3",
          "id": "19885739-0b56-4a4f-89f4-0003c3ae276a",
          "intuition": "This approach works by first parsing the string into fractions, then calculating the least common multiple of the denominators, and finally adding or subtracting the fractions",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "8/3",
              "explanation": "The least common multiple of the denominators is 6. The equivalent fractions are 3/6, 3/6, and 2/6. The sum of the numerators is 3 + 3 + 2 = 8, so the result is 8/3",
              "id": "9d781953-530d-4d6f-b050-ce7148215f82",
              "input": "1/2+1/2+1/3"
            },
            {
              "expectedOutput": "1/3",
              "explanation": "The least common multiple of the denominators is 6. The equivalent fractions are -3/6, 3/6, and 2/6. The sum of the numerators is -3 + 3 + 2 = 2, so the result is 2/6, which simplifies to 1/3",
              "id": "b34d9fb2-cbdf-415e-99c2-e26849cecec2",
              "input": "-1/2+1/2+1/3"
            },
            {
              "expectedOutput": "-1/6",
              "explanation": "The least common multiple of the denominators is 6. The equivalent fractions are 2/6 and -3/6. The sum of the numerators is 2 - 3 = -1, so the result is -1/6",
              "id": "995ad5e2-ba4a-440d-9a8b-a3f1250f1145",
              "input": "1/3-1/2"
            }
          ]
        }
      ],
      "id": "864a0bf1-7e1d-4b96-b19c-64bcb57ce592",
      "lastUpdated": "2026-02-06T21:27:35Z",
      "problemSlug": "fraction-addition-and-subtraction",
      "relatedProblems": [
        "add-strings",
        "multiply-strings"
      ],
      "summary": "The problem requires the addition and subtraction of fractions given in the format of strings. The key insight is to calculate the least common multiple of the denominators and then adjust the numerators accordingly."
    },
    {
      "approaches": [
        {
          "approach": "1. If the numerator is 0, return 0. 2. Initialize an empty string to store the decimal part and a hash map to store the remainder and its index. 3. Check if the fraction is negative and store the sign. 4. Make the numerator and denominator positive and divide the numerator by the denominator. 5. Store the integer part in the result string and update the numerator to be the remainder. 6. If the remainder is 0, return the result string. 7. If the remainder is already in the hash map, it means we have a recurring decimal, so add '(' and ')' to the decimal string accordingly.",
          "code": "func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num / den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] while remainder != 0 { if let index = map[remainder] { result.insert(\"(\", at: result.index(result.startIndex, offsetBy: index)) result.insert(\")\", at: result.endIndex) break } map[remainder] = result.count let multiple = remainder * 10 result += String(multiple / den) let newRemainder = multiple % den if newRemainder == 0 { break } map[remainder] = result.count remainder = newRemainder } return result }",
          "complexity": {
            "space": "O(log(numerator))",
            "spaceExplanation": "The space complexity of this solution is O(log(numerator)) because we are storing the remainder and its index in a hash map.",
            "time": "O(log(numerator))",
            "timeExplanation": "The time complexity of this solution is O(log(numerator)) because in the worst-case scenario we are performing a constant amount of work for each digit in the numerator."
          },
          "explanation": "The brute-force approach involves using a hash map to store the remainder and its index in the decimal string. It checks for recurring decimals and handles negative fractions.",
          "id": "38ac41de-cf83-439f-808b-3afed5dab5e0",
          "intuition": "In this approach, we divide the numerator by the denominator and store the remainder and the decimal part in a string. We use a hash map to store the remainder and its corresponding index in the decimal string.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0.5",
              "explanation": "The decimal representation of 1/2 is 0.5.",
              "id": "889a183d-51c2-450e-ae5c-0949469e5f97",
              "input": "numerator = 1, denominator = 2"
            },
            {
              "expectedOutput": "0.(6)",
              "explanation": "The decimal representation of 2/3 is 0.666... which can be represented as 0.(6).",
              "id": "193b67dd-b934-41a3-ae94-286970ced2b6",
              "input": "numerator = 2, denominator = 3"
            },
            {
              "expectedOutput": "0.(4)",
              "explanation": "The decimal representation of 4/9 is 0.444... which can be represented as 0.(4).",
              "id": "24f9eb2d-b6a3-4ed7-ad1f-cca8331c7f94",
              "input": "numerator = 4, denominator = 9"
            },
            {
              "expectedOutput": "0.1(6)",
              "explanation": "The decimal representation of 1/6 is 0.166... which can be represented as 0.1(6).",
              "id": "7e5c519c-ae1f-48d1-b69a-d7df88adf653",
              "input": "numerator = 1, denominator = 6"
            }
          ]
        },
        {
          "approach": "1. If the numerator is 0, return 0. 2. Initialize an empty string to store the decimal part and a hash map to store the remainder and its index. 3. Check if the fraction is negative and store the sign. 4. Make the numerator and denominator positive and divide the numerator by the denominator. 5. Store the integer part in the result string and update the numerator to be the remainder. 6. If the remainder is 0, return the result string. 7. If the remainder is already in the hash map, it means we have a recurring decimal, so add '(' and ')' to the decimal string accordingly.",
          "code": "func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String { if numerator == 0 { return \"0\" } var result = \"\" if (numerator < 0) != (denominator < 0) { result += \"-\" } let num = abs(numerator) let den = abs(denominator) result += String(num / den) let remainder = num % den if remainder == 0 { return result } result += \".\" var map: [Int: Int] = [:] var decimal = \"\" while remainder != 0 { if let index = map[remainder] { let start = decimal.index(decimal.startIndex, offsetBy: index) decimal.insert(\"(\", at: start) decimal += \")\" break } map[remainder] = decimal.count let multiple = remainder * 10 decimal += String(multiple / den) let newRemainder = multiple % den if newRemainder == 0 { break } remainder = newRemainder } if !decimal.isEmpty { result += decimal } return result }",
          "complexity": {
            "space": "O(log(numerator))",
            "spaceExplanation": "The space complexity of this solution is O(log(numerator)) because we are storing the remainder and its index in a hash map.",
            "time": "O(log(numerator))",
            "timeExplanation": "The time complexity of this solution is O(log(numerator)) because in the worst-case scenario we are performing a constant amount of work for each digit in the numerator."
          },
          "explanation": "The optimized approach involves using a hash map to store the remainder and its index in the decimal string. It checks for recurring decimals and handles negative fractions.",
          "id": "5ea816f7-b91c-4b12-b21e-71740d99cf74",
          "intuition": "In this approach, we divide the numerator by the denominator and use a hash map to store the remainder and its corresponding index in the decimal string. We then construct the result string by iterating over the decimal string and adding '(' and ')' for recurring decimals.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0.5",
              "explanation": "The decimal representation of 1/2 is 0.5.",
              "id": "e8834de7-1f8c-4204-b9c5-1d97e3682923",
              "input": "numerator = 1, denominator = 2"
            },
            {
              "expectedOutput": "0.(6)",
              "explanation": "The decimal representation of 2/3 is 0.666... which can be represented as 0.(6).",
              "id": "c1b74f28-ed4f-4530-b268-364775fe8bb0",
              "input": "numerator = 2, denominator = 3"
            },
            {
              "expectedOutput": "0.(4)",
              "explanation": "The decimal representation of 4/9 is 0.444... which can be represented as 0.(4).",
              "id": "b7314819-27d1-478e-b1ad-9fc6d8b83ba1",
              "input": "numerator = 4, denominator = 9"
            },
            {
              "expectedOutput": "0.1(6)",
              "explanation": "The decimal representation of 1/6 is 0.166... which can be represented as 0.1(6).",
              "id": "752b2729-697a-42ca-b918-9cf4dab3a2f0",
              "input": "numerator = 1, denominator = 6"
            }
          ]
        }
      ],
      "id": "d6b2017d-91ee-44b6-a382-3b36a74fe718",
      "lastUpdated": "2026-02-06T21:07:55Z",
      "problemSlug": "fraction-to-recurring-decimal",
      "relatedProblems": [
        "divide-array-in-sets",
        "integer-replacement"
      ],
      "summary": "This problem involves converting a fraction to a recurring decimal. The key insight is that a recurring decimal can be represented as a hash map where the remainder is the key and the index is the value."
    },
    {
      "approaches": [
        {
          "approach": "Generate random points within the bounding box, then check the distance from the origin to determine if the point is within the circle",
          "code": "\nimport Foundation\n\nclass Solution {\n    let radius: Double\n    let x_center: Double\n    let y_center: Double\n\n    init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n    }\n\n    func randPoint() -> [Double] {\n        while true {\n            let x = Double.random(in: x_center - radius...x_center + radius)\n            let y = Double.random(in: y_center - radius...y_center + radius)\n            if (x - x_center) * (x - x_center) + (y - y_center) * (y - y_center) <= radius * radius {\n                return [x, y]\n            }\n        }\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the radius and the center of the circle.",
            "time": "O(infinity) in the worst case, but practically O(4) on average",
            "timeExplanation": "In the worst case, we might keep generating points outside the circle indefinitely. However, on average, we expect to generate a point within the circle in approximately 4 attempts, since the area of the circle is pi*r^2 and the area of the bounding box is (2*r)^2."
          },
          "explanation": "We utilize the equation of a circle, x^2 + y^2 = r^2, where r is the radius of the circle. We generate random points within the bounding box [-r, r] x [-r, r] and check if x^2 + y^2 <= r^2. If the point is within the circle, we return the point; otherwise, we generate another point.",
          "id": "4dbfa4a0-0a11-4946-a9d0-ef09be139ac1",
          "intuition": "This approach works by generating random points within the bounding box and checking if they are within the circle",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0.5, 0.3]",
              "explanation": "We expect a random point within the unit circle centered at the origin.",
              "id": "d7510e7b-3d4e-462f-8c7f-a1971474cc05",
              "input": "Solution(1.0, 0.0, 0.0)"
            },
            {
              "expectedOutput": "[9.7, 19.3]",
              "explanation": "We expect a random point within a circle of radius 5 centered at (10, 20).",
              "id": "1b74d006-d323-4cb1-b08c-c7832fbd7453",
              "input": "Solution(5.0, 10.0, 20.0)"
            }
          ]
        },
        {
          "approach": "Generate a random angle and a random radius, then convert to cartesian coordinates",
          "code": "\nimport Foundation\n\nclass Solution {\n    let radius: Double\n    let x_center: Double\n    let y_center: Double\n\n    init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n    }\n\n    func randPoint() -> [Double] {\n        let theta = Double.random(in: 0...2*Double.pi)\n        let r = Double.random(in: 0...radius)\n        let x = x_center + r * cos(theta)\n        let y = y_center + r * sin(theta)\n        return [x, y]\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the radius and the center of the circle.",
            "time": "O(1)",
            "timeExplanation": "We only perform a constant number of operations to generate the random point."
          },
          "explanation": "We generate a random angle theta between 0 and 2*pi and a random radius r between 0 and the radius of the circle. Then, we convert to cartesian coordinates using x = r*cos(theta) and y = r*sin(theta). This ensures that the point is within the circle.",
          "id": "f6406bc2-a906-4273-b187-abe0f4ad89b2",
          "intuition": "This approach works by generating a random angle and a random radius within the circle, utilizing polar coordinates",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0.2, 0.8]",
              "explanation": "We expect a random point within the unit circle centered at the origin.",
              "id": "3f12dfcc-70e3-435a-ad4b-6b7a6bac8aa7",
              "input": "Solution(1.0, 0.0, 0.0)"
            },
            {
              "expectedOutput": "[18.4, 28.7]",
              "explanation": "We expect a random point within a circle of radius 10 centered at (20, 30).",
              "id": "51acf0f9-9793-4113-a85b-e4a52d179f57",
              "input": "Solution(10.0, 20.0, 30.0)"
            }
          ]
        }
      ],
      "id": "39de9f0d-4dc5-46d6-a55c-73ff972839cf",
      "lastUpdated": "2026-02-06T21:21:25Z",
      "problemSlug": "generate-random-point-in-a-circle",
      "relatedProblems": [
        "generate-random-point-in-a-rectangle",
        "max-points-on-a-line"
      ],
      "summary": "The problem is to generate a random point within a circle. One key insight is to utilize rejection sampling by generating a random point within the bounding box of the circle and then checking if the point is within the circle."
    },
    {
      "approaches": [
        {
          "approach": "1. Generate all permutations of the input array. 2. For each permutation, check if it's sorted and if it can be achieved by only swapping adjacent elements. 3. If such a permutation exists, return True. Otherwise, return False.",
          "code": "let A = [2, 7, 11, 15]\nfunc isIdealPermutation(_ A: [Int]) -> Bool {\n    for i in 0...A.count - 1 {\n        if abs(A[i] - i) > 1 {\n            return false\n        }\n    }\n    return true\n}\nprint(isIdealPermutation(A))",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the algorithm only uses a constant amount of space to store the input array and the indices.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because the algorithm only needs to iterate through the array once."
          },
          "explanation": "This approach is straightforward but inefficient because it involves generating all permutations of the array, which results in a time complexity of O(n!). It's useful for small inputs but not for large inputs.",
          "id": "8fb5d33a-251f-4bb5-9024-d448a843f82d",
          "intuition": "This approach involves checking all possible permutations of the array, to see if any permutation results in a sorted array that can be achieved by only swapping adjacent elements. If such a permutation exists and no global inversion exists, then it's possible to make the array sorted.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "This test case checks if the array [1,0,2] can be made sorted by only swapping adjacent elements. The permutation [0, 1, 2] is a sorted permutation that can be achieved by only swapping adjacent elements.",
              "id": "6fd8aaaf-bc23-48d6-858c-04ac6b18019e",
              "input": "nums = [1,0,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "This test case checks if the array [1,2,0] can be made sorted by only swapping adjacent elements. The permutation [0, 1, 2] is not a sorted permutation that can be achieved by only swapping adjacent elements.",
              "id": "a0bde4f7-e6ee-484f-b3a2-ba24ba08b339",
              "input": "nums = [1,2,0]"
            }
          ]
        },
        {
          "approach": "1. Iterate through the array and check if the absolute difference between each element and its index is greater than 1. 2. If such a difference exists, return False. Otherwise, return True.",
          "code": "func isIdealPermutation(_ A: [Int]) -> Bool {\n    for i in 0...A.count - 1 {\n        if abs(A[i] - i) > 1 {\n            return false\n        }\n    }\n    return true\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the algorithm only uses a constant amount of space to store the input array and the indices.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because the algorithm only needs to iterate through the array once."
          },
          "explanation": "This approach is efficient because it only involves iterating through the array once, resulting in a time complexity of O(n). It's useful for large inputs.",
          "id": "340e11b9-ace1-46e6-846b-1808e87c84d8",
          "intuition": "This approach involves checking if the absolute difference between each element and its index is greater than 1. If such a difference exists, then it's impossible to make the array sorted by only swapping adjacent elements.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "This test case checks if the array [1,0,2] can be made sorted by only swapping adjacent elements. The permutation [0, 1, 2] is a sorted permutation that can be achieved by only swapping adjacent elements.",
              "id": "dadd5a78-4698-4667-ac2c-ec3ada065d07",
              "input": "nums = [1,0,2]"
            },
            {
              "expectedOutput": "false",
              "explanation": "This test case checks if the array [1,2,0] can be made sorted by only swapping adjacent elements. The permutation [0, 1, 2] is not a sorted permutation that can be achieved by only swapping adjacent elements.",
              "id": "3daa808f-019b-4fd7-afbe-292fd48ba394",
              "input": "nums = [1,2,0]"
            }
          ]
        }
      ],
      "id": "2cf0e053-3e1e-42eb-b431-6c3892a15003",
      "lastUpdated": "2026-02-06T21:39:01Z",
      "problemSlug": "global-and-local-inversions",
      "relatedProblems": [
        "array-partition-i",
        "find-all-duplicates-in-an-array"
      ],
      "summary": "This problem involves determining if it's possible to make an array sorted by only swapping adjacent elements, with the given condition being that a global inversion exists whenever a larger element appears before a smaller element in the array. The key insight lies in the fact that if there exists a pair of elements that satisfy this global inversion condition and are not adjacent, then it's impossible to make the array sorted by only swapping adjacent elements."
    },
    {
      "approaches": [
        {
          "approach": "Start with an empty list, generate all possible binary sequences of the given length, and then check if each sequence is a Gray code sequence by comparing it with the previous sequence in the list.",
          "code": "let n = 3\ngenerateGrayCode(n)\nfunc generateGrayCode(_ n: Int) -> [Int] {\n    if n == 1 {\n        return [0, 1]\n    }\n    let prevGrayCode = generateGrayCode(n - 1)\n    var currGrayCode = [Int]()\n    for num in prevGrayCode {\n        currGrayCode.append(num)\n    }\n    for i in stride(from: prevGrayCode.count - 1, to: -1, by: -1) {\n        currGrayCode.append(prevGrayCode[i] | (1 << (n - 1)))\n    }\n    return currGrayCode\n}",
          "complexity": {
            "space": "O(2^n)",
            "spaceExplanation": "The space complexity is O(2^n) because we store all the Gray code sequences in a list.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is O(2^n) because we generate all possible binary sequences of length n, and there are 2^n such sequences."
          },
          "explanation": "The brute force approach involves generating all possible binary sequences of the given length and then checking if each sequence is a Gray code sequence. However, this approach is inefficient because it generates many unnecessary sequences and has a high time complexity.",
          "id": "e99b09e0-00cb-408a-b586-86c9c3978b71",
          "intuition": "This approach works by generating all possible binary sequences of the given length and then checking if each sequence is a Gray code sequence.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0, 1, 3, 2]",
              "explanation": "The Gray code sequence for n = 2 is [0, 1, 3, 2] because each number differs from the previous number by only one bit.",
              "id": "86c7a24d-ec9d-443e-a19a-d6f21e8c8dc5",
              "input": "n = 2"
            },
            {
              "expectedOutput": "[0, 1, 3, 2, 6, 7, 5, 4]",
              "explanation": "The Gray code sequence for n = 3 is [0, 1, 3, 2, 6, 7, 5, 4] because each number differs from the previous number by only one bit.",
              "id": "1b728dc8-1224-4a09-a3d5-026945d85f71",
              "input": "n = 3"
            }
          ]
        },
        {
          "approach": "Start with a base case of n = 1, where the Gray code sequence is [0, 1]. Then, for n > 1, generate the Gray code sequence by prepending a 0 to the front of each sequence in the previous Gray code sequence and a 1 to the front of each sequence in the reverse of the previous Gray code sequence.",
          "code": "func grayCode(_ n: Int) -> [Int] {\n    var result: [Int] = [0]\n    for i in 1...n {\n        let mask = 1 << (i - 1)\n        for j in stride(from: result.count - 1, to: -1, by: -1) {\n            result.append(result[j] | mask)\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(2^n)",
            "spaceExplanation": "The space complexity is O(2^n) because we store the Gray code sequence in a list.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is O(2^n) because we generate the Gray code sequence recursively and there are 2^n sequences."
          },
          "explanation": "The optimized approach involves generating the Gray code sequence recursively by using the fact that a Gray code sequence can be generated by prepending a 0 to the front of each sequence in the previous Gray code sequence and a 1 to the front of each sequence in the reverse of the previous Gray code sequence. This approach is more efficient than the brute force approach and has a lower time complexity.",
          "id": "5582b14e-7754-43c0-9b7c-2e907f179414",
          "intuition": "This approach works by using the fact that a Gray code sequence can be generated recursively by prepending a 0 to the front of each sequence in the previous Gray code sequence and a 1 to the front of each sequence in the reverse of the previous Gray code sequence.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0, 1, 3, 2]",
              "explanation": "The Gray code sequence for n = 2 is [0, 1, 3, 2] because each number differs from the previous number by only one bit.",
              "id": "93b52146-1b5e-4461-8448-965f132210b7",
              "input": "n = 2"
            },
            {
              "expectedOutput": "[0, 1, 3, 2, 6, 7, 5, 4]",
              "explanation": "The Gray code sequence for n = 3 is [0, 1, 3, 2, 6, 7, 5, 4] because each number differs from the previous number by only one bit.",
              "id": "e8351374-b830-486b-a756-9d440b2ea125",
              "input": "n = 3"
            },
            {
              "expectedOutput": "[0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]",
              "explanation": "The Gray code sequence for n = 4 is [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8] because each number differs from the previous number by only one bit.",
              "id": "56d8bf90-d6f7-4354-91b4-8bff82211157",
              "input": "n = 4"
            }
          ]
        }
      ],
      "id": "dc234add-0a93-4156-bf8d-044fa59c78bb",
      "lastUpdated": "2026-02-06T21:05:56Z",
      "problemSlug": "gray-code",
      "relatedProblems": [
        "binary-tree-paths",
        "letter-combinations-of-a-phone-number"
      ],
      "summary": "The problem requires generating a Gray code sequence of a given length, with the key insight being that a Gray code sequence is a sequence of numbers where each number differs from the previous number by only one bit."
    },
    {
      "approaches": [
        {
          "approach": "The algorithm starts from 1 and guesses the number. For each guess, it calculates the cost, which is the maximum of the two possible outcomes (guessing higher or lower). The minimum cost is updated at each step. This process continues until we reach the target number.",
          "code": "import Foundation\nfunc getMoneyAmount(_ n: Int) -> Int {\n    var memo = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n    func dfs(_ start: Int, _ end: Int) -> Int {\n        if start >= end { return 0 }\n        if memo[start][end] != 0 { return memo[start][end] }\n        var res = Int.max\n        for i in stride(from: start, to: end + 1, by: 1) {\n            let cost = i + max(dfs(start, i - 1), dfs(i + 1, end))\n            res = min(res, cost)\n        }\n        memo[start][end] = res\n        return res\n    }\n    return dfs(1, n)\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is O(n^2) because we need to store the results of subproblems in a 2D array of size n x n.",
            "time": "O(n^4)",
            "timeExplanation": "The brute-force approach has an exponential time complexity because it tries all possible guesses and calculates the cost for each guess. The time complexity is O(n^4) due to the nested loops."
          },
          "explanation": "The brute-force approach is straightforward but inefficient due to the large number of possible guesses. We need to iterate through all numbers from 1 to n, and for each number, calculate the cost of guessing higher and lower. This approach does not take advantage of any patterns or properties of the problem.",
          "id": "3b333938-c3dc-410e-b70e-15aa2278fb17",
          "intuition": "This approach involves trying all possible guesses and calculating the cost for each guess. It works because we consider all possibilities and choose the one with the minimum cost.",
          "name": "Brute-Force/Baseline Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "For n = 2, we have two possible guesses: 1 and 2. If we guess 1, the cost is 1 because the other number is 2. If we guess 2, the cost is 0 because we guessed the correct number. The minimum cost is 1.",
              "id": "5bd3a821-518f-4680-b195-0157c3692d86",
              "input": "n = 2"
            },
            {
              "expectedOutput": "6",
              "explanation": "For n = 5, we have five possible guesses: 1, 2, 3, 4, and 5. We can guess the middle number (3) first, and then guess the numbers on either side.",
              "id": "fa1a214d-f06e-4900-89ef-d82befc2a57c",
              "input": "n = 5"
            }
          ]
        },
        {
          "approach": "The algorithm starts from the smallest possible range (1 number) and calculates the minimum cost for each range. It then uses these results to calculate the minimum cost for larger ranges. This process continues until we reach the target range (1 to n).",
          "code": "import Foundation\nfunc getMoneyAmount(_ n: Int) -> Int {\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: n + 1)\n    for length in stride(from: 1, to: n + 1, by: 1) {\n        for i in stride(from: 1, to: n - length + 2, by: 1) {\n            let j = i + length - 1\n            if length == 1 { dp[i][j] = 0 }\n            else if length == 2 { dp[i][j] = i }\n            else {\n                var res = Int.max\n                for k in stride(from: i, to: j + 1, by: 1) {\n                    let cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                    res = min(res, cost)\n                }\n                dp[i][j] = res\n            }\n        }\n    }\n    return dp[1][n]\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is O(n^2) because we need to store the results of subproblems in a 2D array of size n x n.",
            "time": "O(n^3)",
            "timeExplanation": "The optimized approach has a polynomial time complexity because we calculate the minimum cost for each range only once and store the results in a 2D array. The time complexity is O(n^3) due to the nested loops."
          },
          "explanation": "The optimized approach is more efficient than the brute-force approach because it avoids redundant calculations by storing the results of subproblems. We can use a 2D array to store the minimum cost for each range and calculate the minimum cost for each range in a bottom-up manner.",
          "id": "8d6864f1-9fde-4aa5-a9d5-b654edb2c3e0",
          "intuition": "This approach involves using dynamic programming to store the results of subproblems and avoid redundant calculations. It works because we can break down the problem into smaller subproblems and solve each subproblem only once.",
          "name": "Optimized Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0",
              "explanation": "For n = 1, there is only one possible guess, which is the number itself. The cost is 0 because we guessed the correct number.",
              "id": "674361be-50d5-4e06-ab6d-a885634bf46b",
              "input": "n = 1"
            },
            {
              "expectedOutput": "12",
              "explanation": "For n = 10, we have ten possible guesses: 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10. We can guess the middle number (5 or 6) first, and then guess the numbers on either side.",
              "id": "caa80d6d-69ac-48cc-bfea-f4b9b1dc80ad",
              "input": "n = 10"
            }
          ]
        }
      ],
      "id": "9e86af39-f9a7-46f4-86fa-0256cf276399",
      "lastUpdated": "2026-02-06T21:14:43Z",
      "problemSlug": "guess-number-higher-or-lower-ii",
      "relatedProblems": [
        "guess-number-higher-or-lower",
        "candy"
      ],
      "summary": "Guess Number Higher or Lower II problem is about finding the minimum cost to guess a number, considering we can only guess higher or lower than our current guess. The key insight is to use dynamic programming to store the results of subproblems."
    },
    {
      "approaches": [
        {
          "approach": "1. Create set to store seen numbers\n2. While n != 1 and n not in set:\n   a. Add n to set\n   b. Replace n with sum of digit squares\n3. Return n == 1",
          "code": "func isHappy(_ n: Int) -> Bool {\n    var seen = Set<Int>()\n    var num = n\n    \n    while num != 1 && !seen.contains(num) {\n        seen.insert(num)\n        num = sumOfSquares(num)\n    }\n    \n    return num == 1\n}\n\nfunc sumOfSquares(_ n: Int) -> Int {\n    var sum = 0\n    var num = n\n    while num > 0 {\n        let digit = num % 10\n        sum += digit * digit\n        num /= 10\n    }\n    return sum\n}",
          "complexity": {
            "space": "O(k)",
            "spaceExplanation": "Set stores all numbers in the sequence",
            "time": "O(log n) per step, O(k) steps",
            "timeExplanation": "Each sum of squares is O(log n) for digit count. Number of steps k is bounded."
          },
          "explanation": "The sequence must eventually either reach 1 or enter a cycle (since there are finite possible values). If we detect a cycle before reaching 1, the number isn't happy. The set gives O(1) lookup to detect repeats.",
          "id": "d9b6163f-4b28-48ce-9727-5e210baa811e",
          "intuition": "If we see the same number twice, we're in a cycle and will never reach 1. Track all seen numbers in a set.",
          "name": "Hash Set Cycle Detection",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "19  82  68  100  1. Happy!",
              "id": "8ec52fe1-7f06-46a4-acd4-df0c5b1588e4",
              "input": "n = 19"
            },
            {
              "expectedOutput": "false",
              "explanation": "2  4  16  37  58  89  145  42  20  4 (cycle)",
              "id": "a1b7d11b-e59b-4a4e-91f0-73ef1980abb1",
              "input": "n = 2"
            }
          ]
        },
        {
          "approach": "1. slow moves one step at a time\n2. fast moves two steps at a time\n3. Continue until fast reaches 1 or slow == fast\n4. Return whether ended at 1",
          "code": "func isHappy(_ n: Int) -> Bool {\n    var slow = n\n    var fast = sumOfSquares(n)\n    \n    while fast != 1 && slow != fast {\n        slow = sumOfSquares(slow)\n        fast = sumOfSquares(sumOfSquares(fast))\n    }\n    \n    return fast == 1\n}\n\nfunc sumOfSquares(_ n: Int) -> Int {\n    var sum = 0\n    var num = n\n    while num > 0 {\n        let digit = num % 10\n        sum += digit * digit\n        num /= 10\n    }\n    return sum\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only two pointer variables, no storage of sequence",
            "time": "O(log n) per step",
            "timeExplanation": "Same time complexity, but space-optimized"
          },
          "explanation": "This is the tortoise and hare algorithm. In a sequence that either ends at 1 or cycles, the fast pointer will eventually either reach 1 or catch up to slow (indicating a cycle). This uses O(1) space since we don't store previous numbers.",
          "id": "4d750e62-c2cc-49c3-b561-f044512d778c",
          "intuition": "Use slow and fast pointers like in linked list cycle detection. If they meet at 1, it's happy. If they meet elsewhere, there's a cycle.",
          "name": "Floyd's Cycle Detection (Two Pointers)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Fast reaches 1 before meeting slow",
              "id": "75d470e5-0bfc-4214-9330-823179392cda",
              "input": "n = 19"
            },
            {
              "expectedOutput": "true",
              "explanation": "7  49  97  130  10  1",
              "id": "d1148d34-bd55-49fe-8110-329c516440cc",
              "input": "n = 7"
            },
            {
              "expectedOutput": "false",
              "explanation": "Enters cycle, slow and fast meet before reaching 1",
              "id": "bb11dd88-96ec-4c83-a9a1-f3d4a3c84c1b",
              "input": "n = 116"
            }
          ]
        }
      ],
      "id": "e35d9a28-5db8-422d-9823-5ea0e18a2cdf",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "happy-number",
      "relatedProblems": [
        "linked-list-cycle",
        "add-digits",
        "ugly-number"
      ],
      "summary": "Determine if a number is happy: repeatedly replace with sum of squares of digits until it reaches 1 (happy) or loops endlessly (not happy). Detect cycle with Floyd's algorithm or hash set."
    },
    {
      "approaches": [
        {
          "approach": "1. Generate a random number between 1 and 7 using Rand7(). 2. Repeat this process until we get a multiple of 10 using the generated numbers (e.g., generating a sequence of 7 numbers). 3. Map the generated sequence to a number between 1 and 10.",
          "code": "func rand10() -> Int {\n    var x = 50\n    while x > 47 {\n        x = 7 * (rand7() - 1) + rand7()\n    }\n    return x / 5 + 1\n}\n\nfunc rand7() -> Int {\n    return Int.random(in: 1...7)\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant, as it involves a fixed number of variables to store the generated sequence and the final result.",
            "time": "O(inf)",
            "timeExplanation": "This approach has a worst-case time complexity of infinity, as it may keep generating numbers indefinitely until it finds a suitable sequence that maps to a number between 1 and 10."
          },
          "explanation": "The brute force approach involves a simple mapping, but it may not ensure a uniform distribution due to the rejection of some outputs. It also requires multiple calls to Rand7() to generate a single random number between 1 and 10.",
          "id": "e049833d-98ae-4542-a981-7290e635f637",
          "intuition": "Generate multiple random numbers using Rand7() and map them to a range of 1 to 10, but this approach may lead to non-uniform distribution.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "Random number between 1 and 10",
              "explanation": "The expected output is a random number between 1 and 10, which can be any number in this range due to the randomness.",
              "id": "5fa824b9-c1d2-4555-bb09-6aceb73b5359",
              "input": "First Test Case"
            },
            {
              "expectedOutput": "Another random number between 1 and 10",
              "explanation": "The expected output is another random number between 1 and 10, which can be any number in this range due to the randomness.",
              "id": "e2188fe8-6646-44de-8dc0-0ffe8692d567",
              "input": "Second Test Case"
            }
          ]
        },
        {
          "approach": "1. Generate a random number between 1 and 49 using Rand7() (7x7 = 49). 2. If the generated number is between 1 and 40, then map it to a number between 1 and 10 (e.g., by dividing by 4 and rounding up). 3. If the generated number is between 41 and 49, reject the output and repeat steps 1-2.",
          "code": "class Solution { func rand10() -> Int { while true { let x = 7 * (rand7() - 1) + rand7(); if x <= 40 { return (x - 1) / 4 + 1 } } } func rand7() -> Int { return Int.random(in: 1...7) } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant, as it involves a fixed number of variables to store the generated sequence and the final result.",
            "time": "O(1)",
            "timeExplanation": "The expected time complexity is constant, as the rejection sampling ensures that we will eventually get a valid output within a constant number of attempts."
          },
          "explanation": "The optimized approach uses Rejection Sampling to generate a uniform distribution. By rejecting numbers outside the range of 1 to 40, we can ensure that the final output is uniformly distributed between 1 and 10.",
          "id": "45c94d6f-b08d-45a1-a696-d615dd15f039",
          "intuition": "Use Rejection Sampling to ensure that the generated random number between 1 and 10 is uniformly distributed.",
          "name": "Optimized Rejection Sampling",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "Random number between 1 and 10",
              "explanation": "The expected output is a random number between 1 and 10, which can be any number in this range due to the randomness.",
              "id": "41a19fe4-96ea-4e1c-8361-e0743edc4d31",
              "input": "First Test Case"
            },
            {
              "expectedOutput": "Another random number between 1 and 10",
              "explanation": "The expected output is another random number between 1 and 10, which can be any number in this range due to the randomness.",
              "id": "1ae2d87d-726a-4e08-806e-e0788d8d222b",
              "input": "Second Test Case"
            }
          ]
        }
      ],
      "id": "a4052e6a-1fd5-4df0-bc62-6151e7953986",
      "lastUpdated": "2026-02-06T21:20:55Z",
      "problemSlug": "implement-rand10-using-rand7",
      "relatedProblems": [
        "rand-n-from-rand-m",
        "random-pick-with-weight"
      ],
      "summary": "To implement Rand10() using Rand7(), we need to map the output of Rand7() to uniformly generate a random number between 1 and 10. The key insight is to use Rejection Sampling, which involves rejecting some outputs from Rand7() to ensure a uniform distribution."
    },
    {
      "approaches": [
        {
          "approach": "Insert: append the element to the end of the array, Delete: find the element using a loop and shift the remaining elements, Get Random: generate a random index and return the element at that index",
          "code": "class RandomizedSet {\n    var elements: [Int] = []\n    func insert(_ val: Int) -> Bool {\n        if elements.contains(val) {\n            return false\n        }\n        elements.append(val)\n        return true\n    }\n    func remove(_ val: Int) -> Bool {\n        if let index = elements.firstIndex(of: val) {\n            elements.remove(at: index)\n            return true\n        }\n        return false\n    }\n    func getRandom() -> Int {\n        return elements.randomElement()!\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store all the elements in the array.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because the insert and remove operations may require shifting all elements in the array."
          },
          "explanation": "This approach is straightforward but inefficient due to the use of nested loops, resulting in a high time complexity.",
          "id": "b25160a1-427e-40fe-8d38-40dcfb148b44",
          "intuition": "This approach involves using a simple array to store the elements and performing the operations using nested loops.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2, true, true, false",
              "explanation": "The first insert operation inserts 1, the second insert operation inserts 2, the remove operation removes 1, the third insert operation returns false because 2 is already present, the final remove operation removes 2, and the get random operation returns 2 because it is the only element left.",
              "id": "00cb9fce-3e77-445c-b01c-bc5afb5fc896",
              "input": "insert(1), insert(2), remove(1), insert(2), remove(2), getRandom()"
            },
            {
              "expectedOutput": "true, true, true, true, false",
              "explanation": "The first insert operation inserts 0, the second insert operation inserts 1, the remove operation removes 0, the third insert operation inserts 2, the final remove operation removes 1, and the get random operation returns 2 because it is the only element left.",
              "id": "add92516-9084-4b9d-a5cf-120a987e2b3a",
              "input": "insert(0), insert(1), remove(0), insert(2), remove(1), getRandom()"
            }
          ]
        },
        {
          "approach": "Insert: use the hash map to check if the element is already present, and if not, append it to the array and update the hash map, Delete: use the hash map to find the index of the element in the array, swap it with the last element, and remove the last element, Get Random: generate a random index and return the element at that index",
          "code": "import Foundation\nclass RandomizedSet {\n    var dict: [Int: Int] = [:]\n    var elements: [Int] = []\n    func insert(_ val: Int) -> Bool {\n        if dict.keys.contains(val) {\n            return false\n        }\n        dict[val] = elements.count\n        elements.append(val)\n        return true\n    }\n    func remove(_ val: Int) -> Bool {\n        if let index = dict[val] {\n            let last = elements.last!\n            elements[index] = last\n            dict[last] = index\n            elements.removeLast()\n            dict.removeValue(forKey: val)\n            return true\n        }\n        return false\n    }\n    func getRandom() -> Int {\n        return elements.randomElement()!\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store all the elements in the array and hash map.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because all operations can be performed in constant time using the hash map and array."
          },
          "explanation": "This approach is more efficient because it uses a hash map to store the indices of the elements, allowing for O(1) time complexity for insert, delete, and get random operations.",
          "id": "80136e36-10a4-4d18-bacb-09b5f99c40a0",
          "intuition": "This approach involves using a combination of a hash map and an array to store the elements, allowing for efficient insert, delete, and get random operations.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true, true, true, false, true, nil",
              "explanation": "The first insert operation inserts 1, the second insert operation inserts 2, the remove operation removes 1, the third insert operation returns false because 2 is already present, the final remove operation removes 2, and the get random operation returns nil because the set is empty.",
              "id": "3da5ae94-9cf1-4597-8991-bc3c8ad042da",
              "input": "insert(1), insert(2), remove(1), insert(2), remove(2), getRandom()"
            },
            {
              "expectedOutput": "true, true, true, true, true, 2",
              "explanation": "The first insert operation inserts 0, the second insert operation inserts 1, the remove operation removes 0, the third insert operation inserts 2, the final remove operation removes 1, and the get random operation returns 2 because it is the only element left.",
              "id": "052831bd-c385-4f88-84e8-072d1ed5c984",
              "input": "insert(0), insert(1), remove(0), insert(2), remove(1), getRandom()"
            }
          ]
        }
      ],
      "id": "2976e4ea-4407-4811-b60c-c24e370293fa",
      "lastUpdated": "2026-02-06T21:15:03Z",
      "problemSlug": "insert-delete-getrandom-o1",
      "relatedProblems": [
        "design-hashmap",
        "insert-delete-getrandom-o1-lcci"
      ],
      "summary": "This problem involves designing a data structure that supports insert, delete, and get random operations in constant time. The key insight is to use a combination of a hash map and an array to achieve O(1) time complexity."
    },
    {
      "approaches": [
        {
          "approach": "Start by generating a list of all possible ways to break the integer, then calculate the product of each way and keep track of the maximum product found.",
          "code": "func integerBreak(n: Int) -> Int {\n    var maxProduct = 0\n    let queue: [(Int, Int)] = [(n, 1)]\n    while !queue.isEmpty {\n        let (current, product) = queue.removeFirst()\n        if current == 1 {\n            maxProduct = max(maxProduct, product)\n        }\n        else {\n            for i in 1...current {\n                if current - i >= 0 {\n                    queue.append((current - i, product * i))\n                }\n            }\n        }\n    }\n    return maxProduct\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear because we need to store the queue of all possible ways to break the integer.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential because in the worst-case scenario, the algorithm has to try all possible ways to break the integer."
          },
          "explanation": "This approach tries all possible ways to break the integer and calculates the product of each way. However, it's inefficient due to its high time complexity.",
          "id": "9899ae5e-0bd8-40d6-bdc1-2bd03db4413d",
          "intuition": "This approach involves trying all possible ways to break the integer into a sum of parts and calculating the product for each way.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The maximum product is 1, which is obtained by breaking 2 into 1 + 1.",
              "id": "68bbdf2d-7b73-4684-9258-d791ac2ec603",
              "input": "n = 2"
            },
            {
              "expectedOutput": "36",
              "explanation": "The maximum product is 36, which is obtained by breaking 10 into 3 + 3 + 4.",
              "id": "8b707722-89e6-4dd6-bed0-b1b6d6bd5f92",
              "input": "n = 10"
            },
            {
              "expectedOutput": "18",
              "explanation": "The maximum product is 18, which is obtained by breaking 8 into 3 + 3 + 2.",
              "id": "2dd30d17-7aec-4d7f-8805-b0fea992bef1",
              "input": "n = 8"
            }
          ]
        },
        {
          "approach": "Calculate how many 3s we can get from the integer, and then handle the remainder accordingly.",
          "code": "func integerBreak(n: Int) -> Int {\n    if n == 2 {\n        return 1\n    }\n    if n == 3 {\n        return 2\n    }\n    var product = 1\n    while n > 4 {\n        product *= 3\n        n -= 3\n    }\n    product *= n\n    return product\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a constant amount of space to store the product and the remaining value of the integer.",
            "time": "O(n/3)",
            "timeExplanation": "The time complexity is linear because we divide the integer by 3 in each iteration of the while loop."
          },
          "explanation": "This approach is much more efficient than the brute-force approach because it takes advantage of the mathematical properties of the problem.",
          "id": "438a77c2-6193-418f-9679-eaa0ab4a1b71",
          "intuition": "This approach is based on the mathematical insight that we should break the integer into as many 3s as possible, with one 2 or 4 if there's a remainder.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The maximum product is 1, which is obtained by breaking 2 into 1 + 1.",
              "id": "00b038f2-7918-40b1-9f45-e1b006a2c888",
              "input": "n = 2"
            },
            {
              "expectedOutput": "36",
              "explanation": "The maximum product is 36, which is obtained by breaking 10 into 3 + 3 + 4.",
              "id": "c10155b5-c30c-4931-bc25-bd78b53c7a65",
              "input": "n = 10"
            },
            {
              "expectedOutput": "18",
              "explanation": "The maximum product is 18, which is obtained by breaking 8 into 3 + 3 + 2.",
              "id": "75987298-5c69-42ea-b116-e100abfa916b",
              "input": "n = 8"
            }
          ]
        }
      ],
      "id": "7a0b12ae-d1b2-4289-a970-d9637162f5d8",
      "lastUpdated": "2026-02-06T21:13:38Z",
      "problemSlug": "integer-break",
      "relatedProblems": [
        "coin-change",
        "coin-change-2"
      ],
      "summary": "The problem asks to break an integer into a sum of as many parts as possible to maximize the product of those parts. The key insight is that we should break the integer into as many 3s as possible, with one 2 or 4 if there's a remainder."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a hash table to map integers to their corresponding Roman numerals. 2. Initialize an empty string to store the result. 3. Loop through each integer in the hash table, from largest to smallest. 4. If the current integer is less than or equal to the input number, append the corresponding Roman numeral to the result string and subtract the integer from the input number. 5. Repeat step 4 until the input number is 0.",
          "code": "func intToRoman(_ num: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let romanNumerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    var result = \"\"\n    var number = num\n    for i in 0..<values.count {\n        while number >= values[i] {\n            result += romanNumerals[i]\n            number -= values[i]\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the hash table and the result string.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst-case scenario, we need to iterate through all the Roman numerals."
          },
          "explanation": "The brute force approach is simple to implement but has a high time complexity due to the use of if-else statements. It also lacks elegance and does not take advantage of any mathematical properties.",
          "id": "ecdddb25-c8e3-42d6-b025-a6b8bcb716b3",
          "intuition": "The brute force approach works by using a series of if-else statements to determine which Roman numerals to include in the output string. It is straightforward but inefficient.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "III",
              "explanation": "The Roman numeral representation of 3 is III.",
              "id": "9145fb96-709c-4b74-a6d9-f147baa266c0",
              "input": "num = 3"
            },
            {
              "expectedOutput": "IV",
              "explanation": "The Roman numeral representation of 4 is IV.",
              "id": "3c627717-2875-4892-8c4b-619a1dd7f934",
              "input": "num = 4"
            },
            {
              "expectedOutput": "IX",
              "explanation": "The Roman numeral representation of 9 is IX.",
              "id": "6ad2c957-04ce-4092-a974-41999f684e3e",
              "input": "num = 9"
            }
          ]
        },
        {
          "approach": "1. Create a hash table to map integers to their corresponding Roman numerals. 2. Initialize two pointers, one for the hash table and one for the input number. 3. Loop through the hash table using the two-pointer technique, from largest to smallest. 4. If the current integer is less than or equal to the input number, append the corresponding Roman numeral to the result string and subtract the integer from the input number. 5. Repeat step 4 until the input number is 0.",
          "code": "func intToRoman(_ num: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let romanNumerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    var result = \"\"\n    var number = num\n    for i in 0..<values.count {\n        while number >= values[i] {\n            result += romanNumerals[i]\n            number -= values[i]\n        }\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the hash table and the result string.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is O(log n) because we are essentially counting the number of digits in the input number."
          },
          "explanation": "The optimized approach is more efficient than the brute force approach because it reduces the number of iterations by using a two-pointer technique. It also takes advantage of the mathematical properties of Roman numerals.",
          "id": "299ec86a-01af-413b-a75d-ad4828bab84b",
          "intuition": "The optimized approach works by using a two-pointer technique to loop through the hash table and the input number simultaneously. This approach is more efficient than the brute force approach because it reduces the number of iterations.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "III",
              "explanation": "The Roman numeral representation of 3 is III.",
              "id": "60c6d2a1-45ae-4f9e-9d12-602236140829",
              "input": "num = 3"
            },
            {
              "expectedOutput": "LVIII",
              "explanation": "The Roman numeral representation of 58 is LVIII.",
              "id": "a4cfb123-5461-45cb-a6ee-ffcb0577026a",
              "input": "num = 58"
            },
            {
              "expectedOutput": "MCMXCIV",
              "explanation": "The Roman numeral representation of 1994 is MCMXCIV.",
              "id": "56e9d32d-98fd-4928-821f-7f64ddbfb06e",
              "input": "num = 1994"
            }
          ]
        }
      ],
      "id": "f21fad26-40cb-4ac4-8001-f92784a052b8",
      "lastUpdated": "2026-02-06T21:03:53Z",
      "problemSlug": "integer-to-roman",
      "relatedProblems": [
        "roman-to-integer",
        "integer-to-english-words"
      ],
      "summary": "This problem requires converting an integer to its Roman numeral representation, with the key insight being to use a hash table to map integers to their corresponding Roman numerals. The solution involves looping through the hash table to construct the Roman numeral string."
    },
    {
      "approaches": [
        {
          "approach": "Start with the base case of the first row, which is '0'. Then, for each subsequent row, generate the next row by following the rules of replacing '0' with '01' and '1' with '10'. Continue until reaching the nth row, then find the k-th symbol.",
          "code": "func kthGrammar(_ n: Int, _ k: Int) -> Int { let row = getRow(n); return Int(String(row[k-1]))! }; func getRow(_ n: Int) -> String { if n == 1 { return \"0\" } else { let prevRow = getRow(n-1); return String(prevRow.map { $0 == \"0\" ? \"01\" : \"10\" }) } }",
          "complexity": {
            "space": "O(2^n)",
            "spaceExplanation": "The space complexity is also exponential due to the need to store each row's string during recursion.",
            "time": "O(2^n)",
            "timeExplanation": "Each recursive call generates a new row, which is at most twice as long as the previous row, leading to exponential time complexity."
          },
          "explanation": "The recursive approach ensures that each row is generated correctly according to the problem's rules. By counting the symbols, we can stop as soon as we find the k-th symbol in the nth row.",
          "id": "6f726ac8-51ff-4f9d-8342-097520419a7e",
          "intuition": "This approach involves generating each row of the grammar sequence recursively and counting the symbols to find the k-th symbol in the nth row.",
          "name": "Baseline Recursive Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0",
              "explanation": "The first row is '0', so the 1st symbol is '0'.",
              "id": "865f5d46-2a14-41ba-990f-f8ca63bc6fda",
              "input": "n = 1, k = 1"
            },
            {
              "expectedOutput": "1",
              "explanation": "The second row is '01', so the 2nd symbol is '1'.",
              "id": "412bbe9f-9855-48c7-8a76-7fc6eb385601",
              "input": "n = 2, k = 2"
            }
          ]
        },
        {
          "approach": "Transform k to its binary form and then apply the rules of the grammar (similar to replacing '0' with '01' and '1' with '10') by looking at the bits of k from right to left.",
          "code": "func kthGrammar(_ n: Int, _ k: Int) -> Int { var k = k; var result = 0; for i in (0...n).reversed() { result = (result << 1) | (k & 1); k >>= 1 }; return result}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Space complexity is constant as we only use a fixed amount of space to store our variables.",
            "time": "O(log k)",
            "timeExplanation": "Time complexity is logarithmic because we are iterating over the bits of k."
          },
          "explanation": "Each bit in k (from right to left) corresponds to whether the current symbol is '0' or '1' based on the previous row's symbols, effectively allowing us to compute the k-th symbol without generating the entire row.",
          "id": "32959097-8788-494e-b91a-f99cc010210f",
          "intuition": "Recognize the pattern that for any given n and k, the k-th symbol can be determined by looking at the binary representation of k and applying a transformation similar to the row generation rules.",
          "name": "Optimized Bit Manipulation Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0",
              "explanation": "The third row starts with '0', so the 1st symbol is '0'.",
              "id": "779584d3-3e27-4eb5-bd2d-d76e324eb38c",
              "input": "n = 3, k = 1"
            },
            {
              "expectedOutput": "1",
              "explanation": "Following the pattern, the 5th symbol in the 4th row is '1'.",
              "id": "799f4ea2-531e-4e21-964b-62d82f9b9cb8",
              "input": "n = 4, k = 5"
            }
          ]
        }
      ],
      "id": "3c3c29ff-ac65-4302-ace8-161b8e20e146",
      "lastUpdated": "2026-02-06T21:39:11Z",
      "problemSlug": "k-th-symbol-in-grammar",
      "relatedProblems": [
        "next-greater-element-i",
        "next-greater-element-ii"
      ],
      "summary": "The problem asks to find the k-th symbol in the nth row of a grammar sequence where each row is generated based on the previous row. Key insight is recognizing the pattern and applying bit manipulation or recursion."
    },
    {
      "approaches": [
        {
          "approach": "The brute force approach involves generating all possible subsets of the input array (2^n subsets for n elements), and then checking each subset to see if every pair of elements satisfies the condition that one is a divisor of the other.",
          "code": "\nfunc largestDivisibleSubset(_ nums: [Int]) -> [Int] {\n    var nums = nums.sorted()\n    let n = nums.count\n    var subsets: [[[Int]]] = Array(repeating: [], count: n)\n    for mask in 1..<1<<n {\n        var subset: [Int] = []\n        for i in 0..<n {\n            if ((mask >> i) & 1) == 1 {\n                subset.append(nums[i])\n            }\n        }\n        var isValid = true\n        for i in 0..<subset.count {\n            for j in 0..<subset.count {\n                if i != j && subset[i] % subset[j] != 0 && subset[j] % subset[i] != 0 {\n                    isValid = false\n                    break\n                }\n            }\n            if !isValid {\n                break\n            }\n        }\n        if isValid {\n            subsets[subset.count - 1].append(subset)\n        }\n    }\n    if let maxSubset = subsets.filter { $0.count > 0 }.map { $0.first }.max(by: { $0?.count ?? 0 < $1?.count ?? 0 }) {\n        return maxSubset\n    }\n    return []\n}",
          "complexity": {
            "space": "O(n * 2^n)",
            "spaceExplanation": "The space complexity comes from storing all generated subsets.",
            "time": "O(2^n * n^2)",
            "timeExplanation": "The time complexity includes generating all subsets (2^n) and for each subset, checking all pairs of elements (n^2)."
          },
          "explanation": "Although this approach guarantees to find the correct solution, it is highly inefficient because of the exponential number of subsets it must consider. For larger inputs, it becomes impractical due to its high time complexity.",
          "id": "2439c619-4461-49f2-bd45-d917e8a77025",
          "intuition": "Generate all possible subsets of the input array and check each subset for the divisibility condition.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2] or [1,3]",
              "explanation": "The possible largest subsets are [1,2] and [1,3]. Both have a size of 2, which is the largest size possible.",
              "id": "6fc55abf-079b-4d81-9ba0-07f6ce49d370",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "[1,2,4,8]",
              "explanation": "The largest subset where every element is divisible by the previous one is the entire input array [1,2,4,8].",
              "id": "4cadfbbc-2169-4869-9804-b2e3c47b0d7f",
              "input": "nums = [1,2,4,8]"
            }
          ]
        },
        {
          "approach": "First, sort the input array in ascending order. Then, initialize a dynamic programming table where dp[i] represents the size of the largest divisible subset ending at index i. For each number in the sorted array, compare it with all previous numbers. If the current number is divisible by a previous number, update dp[i] if a larger subset can be formed.",
          "code": "\nfunc largestDivisibleSubset(_ nums: [Int]) -> [Int] {\n    if nums.isEmpty {\n        return []\n    }\n    let n = nums.count\n    var nums = nums.sorted()\n    var dp: [Int] = Array(repeating: 1, count: n)\n    var prev: [Int?] = Array(repeating: nil, count: n)\n    var maxIndex = 0\n    for i in 1..<n {\n        for j in 0..<i {\n            if nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1 {\n                dp[i] = dp[j] + 1\n                prev[i] = j\n            }\n        }\n        if dp[i] > dp[maxIndex] {\n            maxIndex = i\n        }\n    }\n    var subset: [Int] = []\n    var idx = maxIndex\n    while idx != nil {\n        subset.append(nums[idx!])\n        idx = prev[idx!]\n    }\n    return subset.reversed()\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity comes from the dynamic programming table and the previous indices table, both of which have a size of n.",
            "time": "O(n^2)",
            "timeExplanation": "The algorithm iterates through the sorted array and for each element, checks all previous elements. Thus, the time complexity is quadratic."
          },
          "explanation": "This approach significantly reduces the time complexity compared to the brute-force method by avoiding the generation and checking of all subsets. It takes advantage of the fact that a larger subset can be constructed from smaller subsets that satisfy the divisibility condition.",
          "id": "d03e58fe-34b6-41d2-93ff-60eb17428683",
          "intuition": "The problem has an optimal substructure that can be exploited. By sorting the input array first, we can build up a table where each entry represents the size of the largest divisible subset ending at the current number.",
          "name": "Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,2] or [1,3]",
              "explanation": "As with the brute force approach, the largest subsets are [1,2] and [1,3].",
              "id": "79c1df5e-7ee1-4b6a-b7b9-955defef035f",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "[1,2,4,8]",
              "explanation": "The largest subset where every element is divisible by the previous one is still the entire input array [1,2,4,8].",
              "id": "59c58259-da91-40b3-93b8-907543dce392",
              "input": "nums = [1,2,4,8]"
            }
          ]
        }
      ],
      "id": "a02de698-0dd5-4322-b33c-9ff3fee5e239",
      "lastUpdated": "2026-02-06T21:14:18Z",
      "problemSlug": "largest-divisible-subset",
      "relatedProblems": [
        "subset-sum",
        "partition-equal-subset-sum",
        "coin-change"
      ],
      "summary": "The problem requires finding the largest subset of a given set of numbers where every pair of elements in the subset satisfies the condition that one element is a divisor of the other. This problem can be solved by using dynamic programming after sorting the input array."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort the array in descending order. 2. Iterate over all possible triplets in the array. 3. For each triplet, check if it can form a valid triangle (i.e., the sum of the lengths of any two sides is greater than the length of the third side). 4. If a valid triangle is found, calculate its perimeter and update the maximum perimeter if necessary.",
          "code": "func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var maxPerimeter = 0; for i in 0..<n { for j in i+1..<n { for k in j+1..<n { let a = nums[i], b = nums[j], c = nums[k]; if a + b > c && a + c > b && b + c > a { maxPerimeter = max(maxPerimeter, a + b + c) } } } } return maxPerimeter }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because only a fixed amount of space is used to store the maximum perimeter and the indices.",
            "time": "O(n^3)",
            "timeExplanation": "The time complexity is cubic due to the three nested loops iterating over the array."
          },
          "explanation": "This solution has a time complexity of O(n^3) due to the three nested loops. It is not efficient for large inputs but serves as a baseline for comparison.",
          "id": "5e34a69d-fa9b-4739-8e13-1ddfc2b8e31b",
          "intuition": "This approach works by iterating over all possible triplets in the array and checking if they can form a valid triangle. If they can, it calculates the perimeter and keeps track of the maximum one found.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "The largest perimeter is obtained by the triangle with sides 2, 2, and 1.",
              "id": "6ed8ea65-7a92-4383-b7ff-a11a053251b0",
              "input": "nums = [2,1,2]"
            },
            {
              "expectedOutput": "0",
              "explanation": "No valid triangle can be formed from the given sides.",
              "id": "29147025-2ef4-434a-b124-d1718418f4fb",
              "input": "nums = [1,2,1]"
            }
          ]
        },
        {
          "approach": "1. Sort the array in descending order. 2. Iterate over the array and for each element, check if it can form a valid triangle with the next two elements. 3. If a valid triangle is found, return its perimeter.",
          "code": "func largestPerimeter(_ nums: [Int]) -> Int { let n = nums.count; var numsSorted = nums; numsSorted.sort { $0 > $1 }; for i in 0..<n-2 { let a = numsSorted[i], b = numsSorted[i+1], c = numsSorted[i+2]; if a < b + c { return a + b + c } } return 0 }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear because a new array is created to store the sorted elements.",
            "time": "O(n log n + n)",
            "timeExplanation": "The time complexity includes the sorting operation (O(n log n)) and the iteration over the array (O(n))."
          },
          "explanation": "This solution has a time complexity of O(n^2) due to the two nested loops. It is more efficient than the brute force approach for large inputs.",
          "id": "f91385a6-ae09-4eef-9a1a-42b37831cc1c",
          "intuition": "This approach works by sorting the array in descending order and then iterating over it to find the first triplet that can form a valid triangle. This is because the largest perimeter will be obtained by the first valid triangle encountered.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "8",
              "explanation": "The largest perimeter is obtained by the triangle with sides 3, 3, and 2.",
              "id": "925f002f-4a04-45c8-ae84-5cda86f6d0fd",
              "input": "nums = [3,6,2,3]"
            },
            {
              "expectedOutput": "10",
              "explanation": "The largest perimeter is obtained by the triangle with sides 3, 4, and 3.",
              "id": "201bd641-854c-40aa-8ee8-778245e15a27",
              "input": "nums = [3,2,3,4]"
            }
          ]
        }
      ],
      "id": "8bfa81df-dd66-43a0-be52-044c9989cef6",
      "lastUpdated": "2026-02-06T21:52:37Z",
      "problemSlug": "largest-perimeter-triangle",
      "relatedProblems": [
        "valid-triangle-number",
        "largest-perimeter-rectangle"
      ],
      "summary": "This problem requires finding the largest perimeter of a triangle from a given array of side lengths. The key insight is to sort the array and then check all possible triplets to form a valid triangle."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate over all points in the array. 2. For each point, iterate over the remaining points to form pairs. 3. For each pair, iterate over the remaining points to form a triangle. 4. Calculate the area of the triangle using the Shoelace formula. 5. Keep track of the maximum area found so far.",
          "code": "\nimport Foundation\n\nfunc largestTriangleArea(_ points: [[Int]]) -> Double {\n    var maxArea: Double = 0\n    let n = points.count\n\n    for i in 0..<n {\n        for j in (i+1)..<n {\n            for k in (j+1)..<n {\n                let x1 = Double(points[i][0])\n                let y1 = Double(points[i][1])\n                let x2 = Double(points[j][0])\n                let y2 = Double(points[j][1])\n                let x3 = Double(points[k][0])\n                let y3 = Double(points[k][1])\n                let area = abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2)\n                maxArea = max(maxArea, area)\n            }\n        }\n    }\n    return maxArea\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are not using any extra space that scales with input size.",
            "time": "O(n^3)",
            "timeExplanation": "The time complexity is O(n^3) because we are iterating over all possible combinations of three points in the array, which has n points."
          },
          "explanation": "This approach has a high time complexity because it involves iterating over all possible combinations of three points in the array. However, it is a simple and straightforward solution.",
          "id": "913af1bf-dd3b-485a-b3c5-b4ab6961e28e",
          "intuition": "This approach works by calculating the area of all possible triangles formed by three points in the given array and keeping track of the maximum area",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0.5",
              "explanation": "The maximum area of a triangle that can be formed using the given points is 0.5, which is the area of the triangle formed by points (0,0), (0,1), and (1,0).",
              "id": "e03f3269-1c76-4ed1-adce-057998150405",
              "input": "points = [[0,0],[0,1],[1,0],[1,1]]"
            },
            {
              "expectedOutput": "0.5",
              "explanation": "The maximum area of a triangle that can be formed using the given points is 0.5, which is the area of the triangle formed by points (0,0), (1,0), and (1,1).",
              "id": "fe90b229-f6d9-449b-b452-359075fe6aed",
              "input": "points = [[0,0],[1,0],[1,1]]"
            }
          ]
        },
        {
          "approach": "1. Iterate over all points in the array. 2. For each point, iterate over the remaining points to form pairs. 3. For each pair, use the Shoelace formula to calculate the area of the triangle formed by the pair and each remaining point. 4. Keep track of the maximum area found so far.",
          "code": "\nimport Foundation\n\nfunc largestTriangleArea(_ points: [[Int]]) -> Double {\n    var maxArea: Double = 0\n    let n = points.count\n    let xMax = points.map { $0[0] }.max()!\n    let yMax = points.map { $0[1] }.max()!\n\n    for i in 0..<n {\n        for j in (i+1)..<n {\n            let x1 = Double(points[i][0])\n            let y1 = Double(points[i][1])\n            let x2 = Double(points[j][0])\n            let y2 = Double(points[j][1])\n            for x in 0...xMax {\n                for y in 0...yMax {\n                    let x3 = Double(x)\n                    let y3 = Double(y)\n                    let area = abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2)\n                    maxArea = max(maxArea, area)\n                }\n            }\n        }\n    }\n    return maxArea\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are not using any extra space that scales with input size.",
            "time": "O(n^2 * xMax * yMax)",
            "timeExplanation": "The time complexity is O(n^2 * xMax * yMax) because we are iterating over all pairs of points and all possible coordinates in the bounding box."
          },
          "explanation": "This approach has a lower time complexity than the brute force approach because it uses a more efficient algorithm to calculate the area of the triangle.",
          "id": "16306ff7-8f22-411c-96af-dd0250040163",
          "intuition": "This approach works by using a more efficient algorithm to calculate the area of the triangle, reducing the number of iterations required.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0.5",
              "explanation": "The maximum area of a triangle that can be formed using the given points is 0.5, which is the area of the triangle formed by points (0,0), (0,1), and (1,0).",
              "id": "f9c6571b-50c6-4e2c-a688-445b31b5962f",
              "input": "points = [[0,0],[0,1],[1,0],[1,1]]"
            },
            {
              "expectedOutput": "0.5",
              "explanation": "The maximum area of a triangle that can be formed using the given points is 0.5, which is the area of the triangle formed by points (0,0), (1,0), and (1,1).",
              "id": "e6ac377b-c2d4-4ab3-bdca-c46856baf55e",
              "input": "points = [[0,0],[1,0],[1,1]]"
            },
            {
              "expectedOutput": "2500",
              "explanation": "The maximum area of a triangle that can be formed using the given points is 2500, which is the area of the triangle formed by points (-50,-50), (50,-50), and (50,50).",
              "id": "3c3fb796-78f1-4897-954f-0ad5a92a93cc",
              "input": "points = [[-50,-50],[50,-50],[50,50],[-50,50]]"
            }
          ]
        }
      ],
      "id": "b1526ab1-6ccc-4bfc-8398-477a94326681",
      "lastUpdated": "2026-02-06T21:41:25Z",
      "problemSlug": "largest-triangle-area",
      "relatedProblems": [
        "min-area-rectangle",
        "max-increase-to-fit"
      ],
      "summary": "Given an array of points on a plane, find the maximum area of a triangle that can be formed using three points. The key insight is to calculate the area of all possible triangles and keep track of the maximum area."
    },
    {
      "approaches": [
        {
          "approach": "1. Check each 3x3 sub-grid in the given grid. 2. For each sub-grid, calculate the sum of each row, column, and diagonal. 3. If all sums are equal, increment the count of magic squares.",
          "code": "class Solution {\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\n        var count = 0\n        for i in 0..<grid.count-2 {\n            for j in 0..<grid[0].count-2 {\n                let subGrid = [[grid[i][j], grid[i][j+1], grid[i][j+2]], [grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2]], [grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]]]\n                if isMagic(subGrid) {\n                    count += 1\n                }\n            }\n        }\n        return count\n    }\n    func isMagic(_ subGrid: [[Int]]) -> Bool {\n        let target = subGrid[0][0] + subGrid[0][1] + subGrid[0][2]\n        if [subGrid[0], subGrid[1], subGrid[2]].map {\n            $0.reduce(0, +)\n        }\n        .contains(where: {\n            $0 != target\n        }\n        ) {\n            return false\n        }\n        if [subGrid[0][0] + subGrid[1][0] + subGrid[2][0], subGrid[0][1] + subGrid[1][1] + subGrid[2][1], subGrid[0][2] + subGrid[1][2] + subGrid[2][2]].contains(where: {\n            $0 != target\n        }\n        ) {\n            return false\n        }\n        if subGrid[0][0] + subGrid[1][1] + subGrid[2][2] != target || subGrid[0][2] + subGrid[1][1] + subGrid[2][0] != target {\n            return false\n        }\n        return true\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the count of magic squares and other variables.",
            "time": "O(n^2 * m^2)",
            "timeExplanation": "We need to iterate over all possible sub-grids in the given grid, which results in a time complexity of O(n^2 * m^2)."
          },
          "explanation": "The brute force approach is straightforward but inefficient as it requires checking every possible sub-grid. This results in a high time complexity.",
          "id": "8d7b29ca-cf78-4b31-8928-94fce09c3bf7",
          "intuition": "This approach involves checking every possible 3x3 sub-grid in the given grid and determining if it is a magic square.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "There is one 3x3 magic square in the given grid.",
              "id": "08399c01-467c-462a-85c3-dda3f128fa91",
              "input": "grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2],[6,3,4,5]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no 3x3 magic squares in the given grid.",
              "id": "ed015abe-b8c0-44c5-bbc3-2bb5a018e4a5",
              "input": "grid = [[8,3,8,4],[9,5,1,9],[2,7,6,2],[6,3,4,6]]"
            }
          ]
        },
        {
          "approach": "1. Create a set of possible sums for a 3x3 magic square. 2. Check each sub-grid in the given grid and calculate its sum. 3. If the sum is in the set, increment the count of magic squares.",
          "code": "class Solution {\n    let targetSum = 15\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\n        var count = 0\n        for i in 0..<grid.count-2 {\n            for j in 0..<grid[0].count-2 {\n                let subGrid = [[grid[i][j], grid[i][j+1], grid[i][j+2]], [grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2]], [grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]]]\n                if isValidMagic(subGrid) {\n                    count += 1\n                }\n            }\n        }\n        return count\n    }\n    func isValidMagic(_ subGrid: [[Int]]) -> Bool {\n        if [subGrid[0], subGrid[1], subGrid[2]].map {\n            $0.reduce(0, +)\n        }\n        .contains(where: {\n            $0 != targetSum\n        }\n        ) {\n            return false\n        }\n        if [subGrid[0][0] + subGrid[1][0] + subGrid[2][0], subGrid[0][1] + subGrid[1][1] + subGrid[2][1], subGrid[0][2] + subGrid[1][2] + subGrid[2][2]].contains(where: {\n            $0 != targetSum\n        }\n        ) {\n            return false\n        }\n        if subGrid[0][0] + subGrid[1][1] + subGrid[2][2] != targetSum || subGrid[0][2] + subGrid[1][1] + subGrid[2][0] != targetSum {\n            return false\n        }\n        if !isUnique(subGrid) {\n            return false\n        }\n        if !isValidNumbers(subGrid) {\n            return false\n        }\n        return true\n    }\n    func isUnique(_ subGrid: [[Int]]) -> Bool {\n        let numbers = subGrid.flatMap {\n            $0\n        }\n        return Set(numbers).count == 9\n    }\n    func isValidNumbers(_ subGrid: [[Int]]) -> Bool {\n        let numbers = subGrid.flatMap {\n            $0\n        }\n        return numbers.contains(where: {\n            $0 < 1 || $0 > 9\n        }\n        ) ? false : true\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the count of magic squares and other variables.",
            "time": "O(n^2 * m^2)",
            "timeExplanation": "We still need to iterate over all possible sub-grids in the given grid, which results in a time complexity of O(n^2 * m^2). However, we can exit the loop early if the sum is not in the set, making the approach more efficient in practice."
          },
          "explanation": "The optimized approach is more efficient than the brute force approach as it uses a hash set to store the possible sums and only checks sub-grids that can potentially be magic squares.",
          "id": "26e0c959-466a-4642-b9b8-2b33535c5545",
          "intuition": "This approach uses a hash set to store the possible sums for a 3x3 magic square and only checks sub-grids that can potentially be magic squares.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "There is one 3x3 magic square in the given grid.",
              "id": "0a561ef5-6dfb-41e3-9cf8-fe5df384b23b",
              "input": "grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2],[6,3,4,5]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no 3x3 magic squares in the given grid.",
              "id": "8b947e83-e87e-440e-80b9-bc3fec0505fa",
              "input": "grid = [[8,3,8,4],[9,5,1,9],[2,7,6,2],[6,3,4,6]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no valid 3x3 magic squares with unique numbers from 1 to 9 in the given grid.",
              "id": "627f2f7e-f8c4-48eb-9968-66b8287200b7",
              "input": "grid = [[5,5,5],[5,5,5],[5,5,5]]"
            }
          ]
        }
      ],
      "id": "493026df-8eab-4f24-89e7-53288c8d1125",
      "lastUpdated": "2026-02-06T21:43:34Z",
      "problemSlug": "magic-squares-in-grid",
      "relatedProblems": [
        "ToeplitzMatrix",
        "SpiralMatrixIII"
      ],
      "summary": "The problem asks to count the number of 3x3 magic squares in a given grid, with a magic square being a square where the sum of each row, column and diagonal is the same. A key insight is to identify the target sum for a 3x3 magic square, which is 15."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Initialize a variable to store the maximum product. Step 2: Iterate through all possible combinations of three numbers in the array. Step 3: For each combination, calculate the product and update the maximum product if necessary.",
          "code": "func maximumProduct(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var maxProduct = Int.min\n    for i in 0..<(n-2) {\n        for j in (i+1)..<(n-1) {\n            for k in (j+1)..<n {\n                let product = nums[i] * nums[j] * nums[k]\n                maxProduct = max(maxProduct, product)\n            }\n        }\n    }\n    return maxProduct\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The brute force approach has a space complexity of O(1) as it only uses a constant amount of space to store the maximum product.",
            "time": "O(n^3)",
            "timeExplanation": "The brute force approach has a time complexity of O(n^3) due to the three nested loops."
          },
          "explanation": "This approach is straightforward but inefficient due to its high time complexity.",
          "id": "ecaeb11f-25e2-4e38-b2fc-dd2da1b71bd2",
          "intuition": "The brute force approach involves checking all possible combinations of three numbers in the array and calculating their product.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "The maximum product of three numbers is 1*2*3 = 6.",
              "id": "5f0ae0bd-5d42-4e00-8bce-e7ff551c29ff",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "300",
              "explanation": "The maximum product of three numbers is -10*(-10)*1 = 100 and -10*(-10)*3 = 300, so the maximum product is 300.",
              "id": "c6c36e49-53c6-4b5b-a54f-57ef416af90f",
              "input": "nums = [-10,-10,1,3,2]"
            }
          ]
        },
        {
          "approach": "Step 1: Sort the array in ascending order. Step 2: Calculate the product of the three largest numbers. Step 3: Calculate the product of the two smallest numbers and the largest number. Step 4: Return the maximum of these two products.",
          "code": "func maximumProduct(_ nums: [Int]) -> Int { let nums = nums.sorted(); return max(nums[nums.count-1] * nums[nums.count-2] * nums[nums.count-3], nums[0] * nums[1] * nums[nums.count-1]); }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The optimized approach has a space complexity of O(n) as it requires additional space to store the sorted array.",
            "time": "O(n log n)",
            "timeExplanation": "The optimized approach has a time complexity of O(n log n) due to the sorting operation."
          },
          "explanation": "This approach is more efficient than the brute force approach as it only requires sorting the array and calculating two products.",
          "id": "253ef943-8765-4172-b7a3-1883f406aea4",
          "intuition": "The optimized approach involves sorting the array and then checking the product of the three largest numbers and the product of the two smallest numbers and the largest number.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "The maximum product of three numbers is 1*2*3 = 6.",
              "id": "f035a833-37c6-4f72-89a0-79bea6472874",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "300",
              "explanation": "The maximum product of three numbers is -10*(-10)*1 = 100 and -10*(-10)*3 = 300, so the maximum product is 300.",
              "id": "3a09ea26-1e4c-4e5f-8d61-b26c41a7096c",
              "input": "nums = [-10,-10,1,3,2]"
            }
          ]
        }
      ],
      "id": "e93ddb05-d818-49eb-8c86-b61f89698c90",
      "lastUpdated": "2026-02-06T21:29:42Z",
      "problemSlug": "maximum-product-of-three-numbers",
      "relatedProblems": [
        "array-partition-i",
        "jump-game"
      ],
      "summary": "The problem requires finding the maximum product of three numbers in an array. The key insight is that the maximum product can be obtained by multiplying the three largest numbers or the two smallest numbers and the largest number."
    },
    {
      "approaches": [
        {
          "approach": "Convert the integer to a string, then generate all permutations of the string by swapping each pair of digits. For each permutation, convert it back to an integer and update the maximum swap.",
          "code": "\nlet maxSwap = { (num: Int) -> Int in\n  var strNum = String(num)\n  var maxNum = num\n\n  for i in 0..<strNum.count {\n    for j in (i+1)..<strNum.count {\n      var charArray = Array(strNum)\n      let temp = charArray[i]\n      charArray[i] = charArray[j]\n      charArray[j] = temp\n      strNum = String(charArray)\n      maxNum = max(maxNum, Int(strNum) ?? 0)\n      strNum = String(num) // backtrack\n    }\n  }\n  return maxNum\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The extra space comes from storing the string representation of the integer and the character array to perform swaps.",
            "time": "O(n^2)",
            "timeExplanation": "There are n digits in the string. For each digit, we try to swap it with all the digits after it, resulting in n*(n-1)/2 swaps."
          },
          "explanation": "This approach works by exhaustively trying all possible swaps and selecting the one that maximizes the integer.",
          "id": "44b2c333-0760-49d9-9685-c4ebb612efc9",
          "intuition": "Try all possible pair swaps of digits in the integer and keep track of the maximum swap.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "7236",
              "explanation": "Swap the first and the last digit to get the maximum swap.",
              "id": "f45e47a8-4e1c-4393-8078-0d3bd741b70d",
              "input": "num = 2736"
            },
            {
              "expectedOutput": "9973",
              "explanation": "No swap is needed because the number is already the maximum possible.",
              "id": "a305b370-86e1-4592-a5a7-eaea9a2908ea",
              "input": "num = 9973"
            }
          ]
        },
        {
          "approach": "Convert the integer to a string. Then iterate through the string from left to right to find the first digit that is smaller than the maximum digit to its right.",
          "code": "\nlet maxSwap = { (num: Int) -> Int in\n  var strNum = String(num)\n  let count = strNum.count\n  var maxIndex = -1\n  var maxVal = -1\n  var firstIndex = -1\n\n  // Find the maximum digit and its index from right to left\n  for i in (0...count-1).reversed() {\n    let val = Int(String(strNum[strNum.index(strNum.startIndex, offsetBy: i)])) ?? 0\n    if val > maxVal {\n      maxVal = val\n      maxIndex = i\n    }\n  }\n\n  // Find the first digit that is smaller than the maximum digit\n  for i in 0..<count {\n    let val = Int(String(strNum[strNum.index(strNum.startIndex, offsetBy: i)])) ?? 0\n    if val < maxVal {\n      firstIndex = i\n      break\n    }\n  }\n\n  // Swap the first digit with the maximum digit if found\n  if firstIndex != -1 && maxIndex != -1 {\n    var strArray = Array(strNum)\n    let temp = strArray[firstIndex]\n    strArray[firstIndex] = strArray[maxIndex]\n    strArray[maxIndex] = temp\n    strNum = String(strArray)\n  }\n\n  return Int(strNum) ?? num\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The extra space comes from storing the string representation of the integer and the character array to perform swaps.",
            "time": "O(n)",
            "timeExplanation": "We only need to iterate through the string once from right to left and then once from left to right."
          },
          "explanation": "This approach works because we only need to swap the first digit that is smaller than the maximum digit to its right.",
          "id": "0c3873be-3c01-4a23-9f38-8dd2e6344211",
          "intuition": "Find the first digit that is smaller than the maximum digit to its right and swap it with the maximum digit to its right.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "7236",
              "explanation": "Swap the first and the last digit to get the maximum swap.",
              "id": "f2da33c2-3f72-49f6-a93a-1da648a1eca3",
              "input": "num = 2736"
            },
            {
              "expectedOutput": "9973",
              "explanation": "No swap is needed because the number is already the maximum possible.",
              "id": "658b6435-506f-4cea-9c22-f630012e6823",
              "input": "num = 9973"
            }
          ]
        }
      ],
      "id": "3b9e898d-cd1b-4162-a9a6-052e8515ff7b",
      "lastUpdated": "2026-02-06T21:32:33Z",
      "problemSlug": "maximum-swap",
      "relatedProblems": [
        "next-greater-element-i",
        "next-greater-element-ii"
      ],
      "summary": "This problem is about finding the maximum swap possible in a given integer. We need to maximize the integer by swapping at most one pair of digits in the integer."
    },
    {
      "approaches": [
        {
          "approach": "Generate all possible pairs of points, and for each pair, calculate the area of the rectangle formed by these two points and the other two points that can form a rectangle with them",
          "code": "func minAreaRect(_ points: [[Int]]) -> Int {\n    var minArea = Int.max\n    for i in 0..<points.count {\n        for j in i+1..<points.count {\n            let p1 = points[i]\n            let p2 = points[j]\n            for k in 0..<points.count {\n                for l in k+1..<points.count {\n                    let p3 = points[k]\n                    let p4 = points[l]\n                    if p1[0] == p3[0] && p2[1] == p4[1] && p1[1] == p4[1] && p2[0] == p3[0] {\n                        let area = abs(p1[0]-p2[0]) * abs(p1[1]-p2[1])\n                        if area < minArea {\n                            minArea = area\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return minArea != Int.max ? minArea : 0\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) as the space used does not grow with the size of the input.",
            "time": "O(n^4)",
            "timeExplanation": "The time complexity is O(n^4) because there are four nested loops each of which iterates over the points array."
          },
          "explanation": "This approach works by trying all possible combinations of points and checking if they can form a rectangle. However, this approach has a high time complexity due to the nested loops.",
          "id": "0a8aa33c-254f-41c5-b4b7-a3157b9ce98d",
          "intuition": "Try all possible combinations of points and find the minimum area rectangle.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The points (1,1), (1,3), (3,1), (3,3) form a rectangle with area 2*2 = 4 and the points (1,1), (1,3), (2,2), (1,1) form a rectangle with area 2.",
              "id": "f49fe11d-f11f-4640-992b-51a5095ffca6",
              "input": "[[1,1],[1,3],[3,1],[3,3],[2,2]]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The points (1,1), (1,3), (3,1), (3,3) form a rectangle with area 2*2 = 4 and the points (0,1), (0,2), (2,1), (2,2) form a rectangle with area 2.",
              "id": "9dc71465-e254-4078-8497-79a8230c1c48",
              "input": "[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]"
            }
          ]
        },
        {
          "approach": "Create a set of points for fast lookup, then iterate over all pairs of points to find the minimum area rectangle.",
          "code": "func minAreaRect(_ points: [[Int]]) -> Int {\n    var pointsSet = Set<[Int]>()\n    for point in points {\n        pointsSet.insert(point)\n    }\n    var minArea = Int.max\n    for i in 0..<points.count {\n        for j in i+1..<points.count {\n            let p1 = points[i]\n            let p2 = points[j]\n            if p1[0] == p2[0] {\n                continue\n            }\n            if pointsSet.contains([p1[0], p2[1]]) && pointsSet.contains([p2[0], p1[1]]) {\n                let area = abs(p1[0]-p2[0]) * abs(p1[1]-p2[1])\n                if area < minArea {\n                    minArea = area\n                }\n            }\n        }\n    }\n    return minArea != Int.max ? minArea : 0\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we store all points in a set for fast lookup.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because there are two nested loops each of which iterates over the points array."
          },
          "explanation": "This approach works by using a hash table to store the points and then iterating over all pairs of points to find the minimum area rectangle. This approach has a lower time complexity compared to the brute force approach.",
          "id": "3ce81764-3ae8-4171-9252-7f33243274df",
          "intuition": "Use a hash table to store the coordinates of the points and then iterate over the points to find the minimum area rectangle.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The points (1,1), (1,3), (3,1), (3,3) form a rectangle with area 2*2 = 4 and the points (1,1), (1,3), (2,2), (1,1) form a rectangle with area 2.",
              "id": "17fb32ee-69b8-462d-a805-04697aa4c58e",
              "input": "[[1,1],[1,3],[3,1],[3,3],[2,2]]"
            },
            {
              "expectedOutput": "2",
              "explanation": "The points (1,1), (1,3), (3,1), (3,3) form a rectangle with area 2*2 = 4 and the points (0,1), (0,2), (2,1), (2,2) form a rectangle with area 2.",
              "id": "662ad70a-3400-47a9-bf66-192dfbed128a",
              "input": "[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]"
            }
          ]
        }
      ],
      "id": "b7d26c72-1a3c-4bb0-a0c6-c6049ec79078",
      "lastUpdated": "2026-02-06T21:50:06Z",
      "problemSlug": "minimum-area-rectangle",
      "relatedProblems": [
        "max-boxes",
        "number-of-boomerangs"
      ],
      "summary": "The minimum area rectangle problem asks to find the minimum area of a rectangle in a set of points. The key insight is to use a hash table to track the points and then calculate the area of the rectangles formed by these points."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Generate all possible pairs of points to form the diagonals of the rectangles. Step 2: For each pair of points, generate the other two points to form a rectangle. Step 3: Check if the other two points exist in the given array of points. Step 4: If the other two points exist, calculate the area of the rectangle and update the minimum area.",
          "code": "func minAreaFreeRect(_ points: [[Int]]) -> CGFloat {\n    let n = points.count\n    var minArea: CGFloat = CGFloat.infinity\n    for i in 0..<n {\n        for j in i+1..<n {\n            let point1 = points[i]\n            let point2 = points[j]\n            for k in 0..<n {\n                for l in 0..<n {\n                    if k == i || k == j || l == i || l == j {\n                        continue\n                    }\n                    let point3 = points[k]\n                    let point4 = points[l]\n                    if (point1[0]+point2[0] == point3[0]+point4[0]) && (point1[1]+point2[1] == point3[1]+point4[1]) {\n                        let area = abs((point1[0]-point2[0])*(point1[1]-point2[1])) let area2 = abs((point1[0]-point3[0])*(point1[1]-point3[1])) + abs((point2[0]-point4[0])*(point2[1]-point4[1]))\n                        if area2 < minArea {\n                            minArea = area2\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return sqrt(minArea)\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are not using any additional space that scales with the input size.",
            "time": "O(n^4)",
            "timeExplanation": "The time complexity is O(n^4) because we are iterating over all possible pairs of points and checking if the other two points exist."
          },
          "explanation": "This approach works but is inefficient as it involves iterating over all possible pairs of points and checking if the other two points exist, resulting in a time complexity of O(n^4).",
          "id": "32900566-da03-4364-9fb3-ca0a4556abc9",
          "intuition": "This works by iterating over all possible pairs of points to form the diagonals of the rectangles and then checking if the other two points exist to form a rectangle.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The minimum area rectangle can be formed with points (1,2), (2,1), (1,0), and (0,1).",
              "id": "ef8335bc-2e53-46bd-89f6-20bc996454e2",
              "input": "points = [[1,2],[2,1],[1,0],[0,1]]"
            },
            {
              "expectedOutput": "1",
              "explanation": "The minimum area rectangle can be formed with points (0,1), (2,1), (2,0), and (0,0).",
              "id": "412c03f5-5e5f-46f9-a722-7804f79aee2b",
              "input": "points = [[0,1],[2,1],[1,1],[1,0],[2,0]]"
            }
          ]
        },
        {
          "approach": "Step 1: Store the points in a hashing table. Step 2: Generate all possible pairs of points to form the diagonals of the rectangles. Step 3: For each pair of points, generate the other two points to form a rectangle and check if they exist in the hashing table. Step 4: If the other two points exist, calculate the area of the rectangle and update the minimum area.",
          "code": "func minAreaFreeRect(_ points: [[Int]]) -> CGFloat {\n    let n = points.count\n    var pointsSet: Set<[Int]> = []\n    for point in points {\n        pointsSet.insert(point)\n    }\n    var minArea: CGFloat = CGFloat.infinity\n    for i in 0..<n {\n        for j in i+1..<n {\n            let point1 = points[i]\n            let point2 = points[j]\n            let point3 = [point1[0]+point2[0]-points[0][0], point1[1]+point2[1]-points[0][1]]\n            let point4 = [point2[0]+points[0][0]-point1[0], point2[1]+points[0][1]-point1[1]]\n            if pointsSet.contains(point3) && pointsSet.contains(point4) {\n                let area = abs((point1[0]-point2[0])*(point1[1]-point2[1]))\n                if area < minArea {\n                    minArea = area\n                }\n            }\n        }\n    }\n    return sqrt(minArea)\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we are using a hashing table to store the points.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) because we are iterating over all possible pairs of points."
          },
          "explanation": "This approach works efficiently as it involves using hashing to store the points and then iterating over all possible pairs of points, resulting in a time complexity of O(n^2).",
          "id": "1f6e4105-a336-4b5a-9f50-31350662a19a",
          "intuition": "This works by using hashing to store the points and then iterating over all possible pairs of points to form the diagonals of the rectangles. It then checks if the other two points exist in the hashing table.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The minimum area rectangle can be formed with points (1,2), (2,1), (1,0), and (0,1).",
              "id": "b8880e46-fb93-432d-bdfd-b53dee950423",
              "input": "points = [[1,2],[2,1],[1,0],[0,1]]"
            },
            {
              "expectedOutput": "1",
              "explanation": "The minimum area rectangle can be formed with points (0,1), (2,1), (2,0), and (0,0).",
              "id": "0c79bbbd-f565-4f24-b5ae-344b8c7fa6ec",
              "input": "points = [[0,1],[2,1],[1,1],[1,0],[2,0]]"
            }
          ]
        }
      ],
      "id": "3cc2615a-e3d3-4c4b-bc60-d3abd2c136da",
      "lastUpdated": "2026-02-06T21:51:48Z",
      "problemSlug": "minimum-area-rectangle-ii",
      "relatedProblems": [
        "find-all-anagrams-in-a-string",
        "minimum-area-rectangle"
      ],
      "summary": "Given an array of points on a 2D plane, find the minimum area rectangle that can be formed. The key insight is to use hashing and iterate over all possible rectangles to find the minimum area."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort the array in ascending order. 2. Iterate over all possible target numbers from the minimum to the maximum element in the array. 3. For each target number, calculate the total number of moves required to reach that target number by summing the absolute differences between each element and the target number.",
          "code": "func min MovesToEqualArrayElements(_ nums: [Int]) -> Int {\n    let sortedNums = nums.sorted()\n    var minMoves = Int.max\n    for target in sortedNums {\n        var totalMoves = 0\n        for num in nums {\n            totalMoves += abs(num - target)\n        }\n        minMoves = min(minMoves, totalMoves)\n    }\n    return minMoves\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear due to the sorting step, which requires additional memory to store the sorted array.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is quadratic due to the nested loops over the array elements."
          },
          "explanation": "This approach has a high time complexity due to the nested loops, but it is straightforward to implement and serves as a baseline for comparison with more efficient approaches.",
          "id": "27d828a8-afd2-4447-8d07-0fa935ef96cf",
          "intuition": "This approach works by trying all possible target numbers and calculating the total number of moves required to reach each target number.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The target number is 2, and the total number of moves is 2 (1 -> 2 and 3 -> 2).",
              "id": "0992e9d6-b59d-4bb1-a7ea-30ff663b6f2a",
              "input": "nums = [1, 2, 3]"
            },
            {
              "expectedOutput": "16",
              "explanation": "The target number is 5, and the total number of moves is 16 (1 -> 5, 10 -> 5, 2 -> 5, 9 -> 5).",
              "id": "501b0283-f2fb-4bd0-9cf8-de3e4c8fa743",
              "input": "nums = [1, 10, 2, 9]"
            }
          ]
        },
        {
          "approach": "1. Sort the array in ascending order. 2. Find the median of the array, which is the middle element if the array has an odd length or the average of the two middle elements if the array has an even length. 3. Calculate the total number of moves required to reach the median by summing the absolute differences between each element and the median.",
          "code": "func minMovesToEqualArrayElements(_ nums: [Int]) -> Int {\n    let sortedNums = nums.sorted()\n    let median = sortedNums.count % 2 == 1 ? sortedNums[sortedNums.count / 2] : (sortedNums[sortedNums.count / 2 - 1] + sortedNums[sortedNums.count / 2]) / 2\n    return sortedNums.reduce(0) { $0 + abs($1 - median) }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear due to the sorting step, which requires additional memory to store the sorted array.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is dominated by the sorting step, which has a time complexity of O(n log n)."
          },
          "explanation": "This approach has a much lower time complexity than the brute force approach because it only requires a single pass over the array to find the median.",
          "id": "93a61a81-bff5-4ee8-8cad-1afdc8977069",
          "intuition": "This approach works by finding the median of the array, which is the target number that minimizes the total number of moves.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The target number is 2, and the total number of moves is 2 (1 -> 2 and 3 -> 2).",
              "id": "311b69a9-6954-4084-a9e3-9f46329c9a0a",
              "input": "nums = [1, 2, 3]"
            },
            {
              "expectedOutput": "16",
              "explanation": "The target number is 5, and the total number of moves is 16 (1 -> 5, 10 -> 5, 2 -> 5, 9 -> 5).",
              "id": "18be4504-f564-4bea-be07-d3f93a29f276",
              "input": "nums = [1, 10, 2, 9]"
            }
          ]
        }
      ],
      "id": "c6ec72ad-1931-4ff2-88d0-a17c175f106f",
      "lastUpdated": "2026-02-06T21:19:50Z",
      "problemSlug": "minimum-moves-to-equal-array-elements",
      "relatedProblems": [
        "minimum-average-difference",
        "min-cost-to-move-chips-to-the-same-position"
      ],
      "summary": "The problem requires finding the minimum number of moves to equal array elements by adding or subtracting one from the elements. The key insight is to use the median of the array as the target number to minimize the total number of moves."
    },
    {
      "approaches": [
        {
          "approach": "1. Sort the array in ascending order. 2. Iterate through each number in the array as the potential target. 3. For each target, calculate the total number of moves by summing up the absolute differences between each number and the target. 4. Keep track of the minimum total moves.",
          "code": "\nimport Foundation\n\nfunc minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n    let sortedNums = nums.sorted()\n    var minTotalMoves = Int.max\n    \n    for target in sortedNums {\n        var totalMoves = 0\n        for num in sortedNums {\n            totalMoves += abs(num - target)\n        }\n        minTotalMoves = min(minTotalMoves, totalMoves)\n    }\n    \n    return minTotalMoves\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the sorting operation.",
            "time": "O(n^2)",
            "timeExplanation": "The algorithm iterates through each number in the array for each potential target, resulting in a time complexity of O(n^2)."
          },
          "explanation": "The brute-force approach is a simple and straightforward solution but is inefficient for large arrays because it tries all possible numbers as the target.",
          "id": "1f60009f-d54a-449b-9a8a-b334455c6eea",
          "intuition": "This approach involves trying all possible numbers as the target number and calculating the total number of moves required to make all elements equal to the target.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "To make all elements equal, we need to move 1 unit from the third element to the first element and 1 unit from the third element to the second element.",
              "id": "ec68a872-7547-4ffb-a4ab-30bbd001b1a6",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "16",
              "explanation": "To make all elements equal, we need to move the second and the fourth elements to the middle.",
              "id": "49615a6b-639a-400a-acc2-2206cd1c03bd",
              "input": "nums = [1,10,2,9]"
            }
          ]
        },
        {
          "approach": "1. Sort the array in ascending order. 2. Calculate the median of the array. 3. Use the median as the target and calculate the total number of moves by summing up the absolute differences between each number and the target.",
          "code": "\nimport Foundation\n\nfunc minMovesToEqualArrayElementsII(_ nums: [Int]) -> Int {\n    let sortedNums = nums.sorted()\n    let median = sortedNums[sortedNums.count / 2]\n    let totalMoves = sortedNums.reduce(0, { $0 + abs($1 - median) })\n    \n    return totalMoves\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the sorting operation.",
            "time": "O(n log n)",
            "timeExplanation": "The algorithm requires sorting the array, resulting in a time complexity of O(n log n)."
          },
          "explanation": "The optimized approach takes advantage of the fact that the median is the optimal solution and only requires a single pass through the sorted array.",
          "id": "583e5e68-9d69-4e9a-81a0-63f98e58ddf1",
          "intuition": "Since the optimal solution involves making all elements equal to the median, we can sort the array and use the median as the target.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "To make all elements equal, we need to move 1 unit from the third element to the first element and 1 unit from the third element to the second element.",
              "id": "ddb78267-2cc2-4668-be6d-1df72b8ad866",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "16",
              "explanation": "To make all elements equal, we need to move the second and the fourth elements to the middle.",
              "id": "44d55e7b-2abe-46f4-b929-5654721ac680",
              "input": "nums = [1,10,2,9]"
            }
          ]
        }
      ],
      "id": "327cfcfd-5bdd-4d56-b744-ba6cdeac0515",
      "lastUpdated": "2026-02-06T21:20:30Z",
      "problemSlug": "minimum-moves-to-equal-array-elements-ii",
      "relatedProblems": [
        "minimum-moves-to-equal-array-elements",
        "minimum-average-difference"
      ],
      "summary": "This problem involves finding the minimum number of moves to make all elements in an array equal. The key insight is to minimize the sum of absolute differences between each number and the target number."
    },
    {
      "approaches": [
        {
          "approach": "Sort the given times and then calculate the time difference between each pair of adjacent times. Also, consider the time difference between the first and last time in the sorted list to account for the wrap-around case.",
          "code": "import Foundation\n\nfunc findMinDifference(_ timePoints: [String]) -> Int {\n    var times: [Int] = []    \n    for timePoint in timePoints {\n        let components = timePoint.components(separatedBy: \":\")\n        let hours = Int(components[0])!\n        let minutes = Int(components[1])!\n        times.append(hours * 60 + minutes)\n    }\n    times.sort()\n    var minDiff = Int.max\n    for i in 0..<times.count-1 {\n        minDiff = min(minDiff, times[i+1] - times[i])\n    }\n    minDiff = min(minDiff, 24 * 60 - times.last! + times.first!)\n    return minDiff\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store the converted times.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is due to the sorting operation, which takes O(n log n) time. The subsequent for loop takes O(n) time."
          },
          "explanation": "The brute-force approach involves comparing each pair of times. First, convert the given times into minutes past midnight. Then, calculate the absolute difference between each pair of times and keep track of the minimum difference found so far. Consider the time difference between the first and last time in the list to account for the wrap-around case.",
          "id": "0cf00bce-116f-4997-8714-dac5619cc542",
          "intuition": "This approach involves comparing each pair of times to find the minimum time difference. It works by calculating the absolute difference between each pair of times and then keeping track of the minimum difference found so far.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum time difference between 23:59 and 00:00 is 1 minute.",
              "id": "53844301-c05a-4105-9c4e-05765afd8d08",
              "input": "timePoints = [\"23:59\",\"00:00\"]"
            },
            {
              "expectedOutput": "43",
              "explanation": "The minimum time difference between 12:01 and 12:44 is 43 minutes.",
              "id": "ca1d9b5a-60d0-4aa0-9e62-7bb378f9234c",
              "input": "timePoints = [\"12:01\",\"12:44\" ]"
            }
          ]
        },
        {
          "approach": "Convert the given times into minutes past midnight, sort them, and then calculate the time difference between each pair of adjacent times. Consider the time difference between the first and last time in the sorted list to account for the wrap-around case.",
          "code": "import Foundation\n\nfunc findMinDifference(_ timePoints: [String]) -> Int {\n    var times: [Int] = []    \n    for timePoint in timePoints {\n        let components = timePoint.components(separatedBy: \":\")\n        let hours = Int(components[0])!\n        let minutes = Int(components[1])!\n        times.append(hours * 60 + minutes)\n    }\n    times.sort()\n    var minDiff = times[1] - times[0]\n    for i in 2..<times.count {\n        minDiff = min(minDiff, times[i] - times[i-1])\n    }\n    minDiff = min(minDiff, 24 * 60 - times.last! + times.first!)\n    return minDiff\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store the converted times.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is due to the sorting operation, which takes O(n log n) time. The subsequent for loop takes O(n) time."
          },
          "explanation": "The optimized approach involves converting the given times into minutes past midnight and then sorting them. This allows us to efficiently calculate the time difference between each pair of adjacent times. We also consider the time difference between the first and last time in the list to account for the wrap-around case.",
          "id": "edf7a1d5-5710-46f6-8d3e-44cd49c02458",
          "intuition": "This approach involves using a more efficient algorithm to find the minimum time difference. It works by converting the given times into minutes past midnight, sorting them, and then calculating the time difference between each pair of adjacent times.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The minimum time difference between 23:59 and 00:00 is 1 minute.",
              "id": "c8067f50-06fb-4f4a-a003-ccf60c7b8a95",
              "input": "timePoints = [\"23:59\",\"00:00\"]"
            },
            {
              "expectedOutput": "43",
              "explanation": "The minimum time difference between 12:01 and 12:44 is 43 minutes.",
              "id": "80e7d784-3bcc-4857-a73f-c2b9b78e146a",
              "input": "timePoints = [\"12:01\",\"12:44\" ]"
            }
          ]
        }
      ],
      "id": "c3da5ed6-f477-4f1a-be45-9c87d0ed5606",
      "lastUpdated": "2026-02-06T21:25:15Z",
      "problemSlug": "minimum-time-difference",
      "relatedProblems": [
        "string-to-integer-atoi",
        "find-all-anagrams-in-a-string"
      ],
      "summary": "This problem requires finding the minimum time difference between any two given times in 24-hour format. The key insight is to convert the given times into minutes past midnight and then sort them to efficiently calculate the minimum time difference."
    },
    {
      "approaches": [
        {
          "approach": "Start at position (0,0), moving in the direction of the beam (1,1). On each step, check if the beam hits a wall and if so, adjust the direction accordingly.",
          "code": "\nimport Foundation\n\nfunc mirrorReflection(_ p: Int, _ q: Int) -> Int {\n    var lcm = lcmOf(p, q)\n    var numReflections = 0\n    \n    while lcm % 2 == 0 {\n        numReflections += 1\n        lcm /= 2\n    }\n    \n    if numReflections % 2 == 1 {\n        if lcm % 2 == 0 {\n            return 2\n        } else {\n            return 1\n        }\n    } else {\n        return 0\n    }\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return gcd(b, a % b)\n    }\n}\n\nfunc lcmOf(_ a: Int, _ b: Int) -> Int {\n    return a * b / gcd(a, b)\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store the current position, direction, and the values of p and q.",
            "time": "O(log(p) + log(q))",
            "timeExplanation": "Calculate the GCD and LCM of p and q, then divide the LCM of p and q by 2 until the LCM is no longer divisible by 2, keeping track of how many times we divide by 2."
          },
          "explanation": "Keep track of the current position and direction of the beam. If the beam is about to exit the mirror box at the top-right corner, stop and return the value of q. Otherwise, continue reflecting the beam until it exits at the top-right corner.",
          "id": "bd63700b-daa8-49ba-a9f4-6050a41bc15b",
          "intuition": "Simulate the path of the laser beam by iterating through each reflection, calculating the new position after each bounce.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The laser stops at room 1.",
              "id": "50645b19-bdaf-47c9-9c04-31c8df5fb93e",
              "input": "p = 2, q = 2"
            },
            {
              "expectedOutput": "0",
              "explanation": "The laser stops at room 0.",
              "id": "7512cfbc-1a0f-4794-98b2-4f1d9c18aa63",
              "input": "p = 2, q = 3"
            },
            {
              "expectedOutput": "2",
              "explanation": "The laser stops at room 2.",
              "id": "43255a4b-b3be-43ec-a610-a30d53923c09",
              "input": "p = 2, q = 4"
            }
          ]
        },
        {
          "approach": "Find the LCM of p and q using the Euclidean algorithm, then calculate the room number using bitwise operations.",
          "code": "\nimport Foundation\n\nfunc mirrorReflectionOptimized(_ p: Int, _ q: Int) -> Int {\n    if q % 2 == 0 {\n        return 2\n    } else {\n        if p % 2 == 0 {\n            return 0\n        } else {\n            return 1\n        }\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we are not using any data structures that scale with input size.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant because we are simply performing a few constant-time operations to determine the room number."
          },
          "explanation": "If the LCM is divisible by 4, the beam exits at the top-right corner at room 2; otherwise, if the LCM is 2 mod 4, the beam exits at room 1.",
          "id": "2cb4f887-e1d3-4a00-9a21-f35a8806c2cd",
          "intuition": "Understand that the laser beam's path forms an arithmetic progression in the x and y directions, with common differences of 1 and -1, respectively.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The laser stops at room 1.",
              "id": "41cdfe99-3c58-45ba-96ff-e342df795f81",
              "input": "p = 2, q = 2"
            },
            {
              "expectedOutput": "0",
              "explanation": "The laser stops at room 0.",
              "id": "723b7b5d-8d8f-4096-8969-da9494a55c15",
              "input": "p = 2, q = 3"
            },
            {
              "expectedOutput": "2",
              "explanation": "The laser stops at room 2.",
              "id": "29384c42-f3fc-47c7-b18a-858ca5b48d89",
              "input": "p = 2, q = 4"
            }
          ]
        }
      ],
      "id": "ea39d478-67ff-435c-81e0-3898a30f68e5",
      "lastUpdated": "2026-02-06T21:44:42Z",
      "problemSlug": "mirror-reflection",
      "relatedProblems": [
        "integer-replacement",
        "reconstruct-original-digits-from-english"
      ],
      "summary": "Given a mirror box of size p and q, find the number of the room where the laser stops, assuming the laser starts in the top-left corner. The key insight is to understand how the beam reflects within the mirror box based on the least common multiple of p and q."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize result = n (start with the last index)\n2. XOR result with each index i and nums[i]\n3. Return result",
          "code": "func missingNumber(_ nums: [Int]) -> Int {\n    var result = nums.count  // This is \"n\"\n    \n    for i in 0..<nums.count {\n        result ^= i ^ nums[i]\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only one variable for result",
            "time": "O(n)",
            "timeExplanation": "Single pass through array"
          },
          "explanation": "If array has numbers [0,1,3] with n=3, we XOR: (0^1^2^3) ^ (0^1^3) = 2. The index sequence gives us 0 to n-1, and we initialize with n to cover all expected numbers. Each present number appears in both sequences and cancels out.",
          "id": "e6b65cba-825b-40d3-8a32-3dc70f8ae099",
          "intuition": "XOR all numbers 0 to n and all numbers in array. Pairs cancel out (a^a=0), leaving only the missing number.",
          "name": "XOR Bit Manipulation",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "n=3, expected [0,1,2,3]. Missing is 2.",
              "id": "10adef1d-bd59-4aa6-982b-4a1ba9ec7f69",
              "input": "nums = [3,0,1]"
            },
            {
              "expectedOutput": "2",
              "explanation": "n=2, expected [0,1,2]. Missing is 2.",
              "id": "6738d3b9-a776-4ff6-b2ae-9a839a1bfdf5",
              "input": "nums = [0,1]"
            },
            {
              "expectedOutput": "8",
              "explanation": "n=9, missing 8 from sequence 0-9",
              "id": "29f1623d-1245-4b49-a7fd-e7720f5560a7",
              "input": "nums = [9,6,4,2,3,5,7,0,1]"
            }
          ]
        },
        {
          "approach": "1. Calculate expected sum = n * (n + 1) / 2\n2. Calculate actual sum of array\n3. Return expected - actual",
          "code": "func missingNumber(_ nums: [Int]) -> Int {\n    let n = nums.count\n    let expectedSum = n * (n + 1) / 2\n    let actualSum = nums.reduce(0, +)\n    return expectedSum - actualSum\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only storing two integers",
            "time": "O(n)",
            "timeExplanation": "Single pass to compute sum"
          },
          "explanation": "Gauss's formula gives us the sum of first n natural numbers (including 0, it's 0+1+...+n). The difference between expected and actual sum is exactly the missing number. Watch for integer overflow with very large n.",
          "id": "5ec59ea6-82f6-46ae-bff2-545faa02ce82",
          "intuition": "Sum of 0 to n is n*(n+1)/2. Subtract actual array sum to get missing number.",
          "name": "Math (Gauss Sum)",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "Expected sum = 3*4/2 = 6. Actual = 4. Missing = 2.",
              "id": "ff495192-98ec-4462-a2a1-a8765bde9cd5",
              "input": "nums = [3,0,1]"
            },
            {
              "expectedOutput": "1",
              "explanation": "n=1, expected [0,1]. Sum should be 1, actual is 0. Missing = 1.",
              "id": "e3f517a4-6fba-459d-ac36-82db1cd0a414",
              "input": "nums = [0]"
            }
          ]
        }
      ],
      "id": "134c6c0c-6d76-4fe0-92dd-4c81f2fb988b",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "missing-number",
      "relatedProblems": [
        "find-the-duplicate-number",
        "find-all-numbers-disappeared-in-an-array",
        "first-missing-positive"
      ],
      "summary": "Find the missing number in array containing n distinct numbers from 0 to n. Use XOR (numbers cancel out) or math (expected sum - actual sum)."
    },
    {
      "approaches": [
        {
          "approach": "1. Start from the given number and decrement by 1 until we find a number with digits in non-decreasing order. 2. Check each number by converting it to a string and iterating over the characters (digits). 3. If a digit is smaller than the previous digit, the number is not in non-decreasing order.",
          "code": "func monotoneIncreasingDigits(_ N: Int) -> Int { var res = N; while !isMonotone(res) { res -= 1 }; return res }; func isMonotone(_ N: Int) -> Bool { let str = String(N); for i in 1..<str.count { if str[str.index(str.startIndex, offsetBy: i)] < str[str.index(str.startIndex, offsetBy: i-1)] { return false } }; return true }",
          "complexity": {
            "space": "O(logN)",
            "spaceExplanation": "The space complexity comes from the conversion of the number to a string.",
            "time": "O(N*logN)",
            "timeExplanation": "The time complexity depends on how many numbers we need to check, which is proportional to N, and the conversion of numbers to strings, which takes O(logN) time."
          },
          "explanation": "This approach works by exhaustively checking all numbers until we find one that satisfies the condition. However, it is inefficient because it needs to check many numbers.",
          "id": "a19fe4ba-9738-43a0-9eb8-d67b28621b05",
          "intuition": "The brute force approach checks every possible number less than or equal to the given number to find the largest number with digits in non-decreasing order.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "9",
              "explanation": "9 is the largest number less than or equal to 10 that has digits in non-decreasing order.",
              "id": "edb6fe32-7907-43db-8061-13f0efc9fdd8",
              "input": "N = 10"
            },
            {
              "expectedOutput": "1234",
              "explanation": "1234 itself has digits in non-decreasing order, so it is the answer.",
              "id": "130d38dd-6c59-4af7-baa0-18bcbfa40f54",
              "input": "N = 1234"
            }
          ]
        },
        {
          "approach": "1. Start from the left of the number and compare adjacent digits. 2. If a digit is smaller than the previous digit, adjust the previous digit by decreasing it by 1 and set all digits to its right to 9. 3. Continue adjusting digits from left to right until all digits are in non-decreasing order.",
          "code": "func monotoneIncreasingDigits(_ N: Int) -> Int {\n    var digits = [Int]()\n    var n = N\n    while n > 0 {\n        digits.append(n%10)\n        n /= 10\n    }\n    for i in (1..<digits.count).reversed() {\n        if digits[i] < digits[i-1] {\n            digits[i-1] -= 1\n            for j in (i..<digits.count) {\n                digits[j] = 9\n            }\n        }\n    }\n    var res = 0\n    for digit in digits.reversed() {\n        res = res*10 + digit\n    }\n    return res\n}",
          "complexity": {
            "space": "O(logN)",
            "spaceExplanation": "The space complexity comes from the conversion of the number to an array of digits.",
            "time": "O(logN)",
            "timeExplanation": "The time complexity depends on the conversion of the number to an array of digits and the iteration over the digits."
          },
          "explanation": "This approach works more efficiently than the brute force approach by directly adjusting the digits to ensure they are in non-decreasing order.",
          "id": "7b2406e7-2b0d-4700-8e57-6162d364ba46",
          "intuition": "The optimized approach starts from the left of the number and attempts to keep the digits non-decreasing by adjusting digits from left to right.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "299",
              "explanation": "299 is the largest number less than or equal to 332 that has digits in non-decreasing order.",
              "id": "eef5273e-f87b-464f-b4c0-04db1dfe4ae7",
              "input": "N = 332"
            },
            {
              "expectedOutput": "99",
              "explanation": "99 is the largest number less than or equal to 100 that has digits in non-decreasing order.",
              "id": "01efa060-ac49-4632-a75a-aa248f9dd90a",
              "input": "N = 100"
            }
          ]
        }
      ],
      "id": "3c5313bf-0169-42bb-8953-19e7f60f3795",
      "lastUpdated": "2026-02-06T21:36:47Z",
      "problemSlug": "monotone-increasing-digits",
      "relatedProblems": [
        "next-greater-element-i",
        "next-greater-element-ii"
      ],
      "summary": "The problem involves finding the largest number less than or equal to a given number that consists only of digits in non-decreasing order. A key insight is to start from the left of the number and keep the digits non-decreasing."
    },
    {
      "approaches": [
        {
          "approach": "1. result[i+j] += num1[i] * num2[j]\n2. Handle carries\n3. Convert to string",
          "code": "func multiply(_ num1: String, _ num2: String) -> String {\n    let n1 = Array(num1), n2 = Array(num2)\n    var result = [Int](repeating: 0, count: n1.count + n2.count)\n    for i in (0..<n1.count).reversed() {\n        for j in (0..<n2.count).reversed() {\n            let mul = Int(String(n1[i]))! * Int(String(n2[j]))!\n            let p1 = i + j, p2 = i + j + 1\n            let sum = mul + result[p2]\n            result[p2] = sum % 10\n            result[p1] += sum / 10\n        }\n    }\n    var str = result.map { String($0) }.joined()\n    while str.count > 1 && str.first == \"0\" { str.removeFirst() }\n    return str\n}",
          "complexity": {
            "space": "O(m+n)",
            "spaceExplanation": "Result array",
            "time": "O(mn)",
            "timeExplanation": "Nested loops"
          },
          "explanation": "Position i+j+1 gets the ones digit, carry to i+j.",
          "id": "e4c9317c-c150-49d0-b959-074b7b4759b1",
          "intuition": "Multiply digit by digit, accumulate at position i+j.",
          "name": "Grade School Method",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"56088\"",
              "explanation": "123  456 = 56088",
              "id": "fe54232b-21e0-4b12-9bed-0fc40bc5f3c8",
              "input": "num1 = \"123\", num2 = \"456\""
            }
          ]
        }
      ],
      "id": "8affdec4-603f-4fca-ba2b-fdbce13a5d4d",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "multiply-strings",
      "relatedProblems": [
        "add-strings"
      ],
      "summary": "Multiply two numbers as strings. Grade school multiplication."
    },
    {
      "approaches": [
        {
          "approach": "Start by initializing the score to 0, then for each possible move, recursively simulate all possible games and update the winning probability accordingly.",
          "code": "\nfunc new21Game(_ n: Int, _ k: Int, _ maxPts: Int) -> Double {\n  var memo: [Int: Double] = [:]\n  func dp(_ score: Int) -> Double {\n    if let cached = memo[score] { return cached }\n    if score == 0 { return 1.0 }\n    var result: Double = 0\n    for i in 1...maxPts {\n      if score - i >= 0 {\n        result += dp(score - i) / Double(maxPts)\n      }\n    }\n    memo[score] = result\n    return result\n  }\n  return dp(n)\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use a memoization table to store the results of subproblems, which requires O(n) space.",
            "time": "O(n * maxPts)",
            "timeExplanation": "We iterate over all possible scores and for each score, we iterate over all possible moves."
          },
          "explanation": "We start with the base case where the score is equal to the target score, in which case we return 1 as the winning probability. For other scores, we iterate over all possible moves and recursively calculate the winning probability. We use a memoization technique to store the results of subproblems to avoid redundant calculations.",
          "id": "cd667812-17bc-4ab3-9381-918189587959",
          "intuition": "This approach works by simulating all possible games and calculating the winning probability by counting the number of games that end with a score equal to the target score divided by the total number of games.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0.6",
              "explanation": "The probability of winning the game when the target score is 10, the number of remaining cards is 2, and the maximum number of points we can draw in one turn is 6.",
              "id": "255026e5-c66e-43ae-8679-26230686c20c",
              "input": "n = 10, k = 2, maxPts = 6"
            },
            {
              "expectedOutput": "0.6",
              "explanation": "The probability of winning the game when the target score is 6, the number of remaining cards is 1, and the maximum number of points we can draw in one turn is 10.",
              "id": "354dfab1-7965-422f-a796-1bea051c151a",
              "input": "n = 6, k = 1, maxPts = 10"
            }
          ]
        },
        {
          "approach": "We maintain a window of probabilities for the last k scores and update the probabilities based on the probability of drawing a certain number of points in one turn.",
          "code": "\nfunc new21Game(_ n: Int, _ k: Int, _ maxPts: Int) -> Double {\n  if k == 0 { return 1.0 }\n  var dp: [Double] = Array(repeating: 0.0, count: n + 1)\n  dp[0] = 1.0\n  var sum: Double = 1.0\n  for i in 1...n {\n    dp[i] = sum / Double(maxPts)\n    if i < k { sum += dp[i] }\n    if i - k >= 0 { sum -= dp[i - k] }\n  }\n  return dp[n]\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use an array to store the probabilities of all scores, which requires O(n) space.",
            "time": "O(n)",
            "timeExplanation": "We iterate over all scores from 1 to n."
          },
          "explanation": "We start by initializing the probabilities for the first k scores, then we update the probabilities for the remaining scores based on the probabilities of the previous scores. We use a sliding window technique to maintain the probabilities of the last k scores.",
          "id": "a122669f-8a21-49f2-8406-fbf47c3adb98",
          "intuition": "This approach works by using dynamic programming to calculate the probability of winning the game by maintaining a window of probabilities for the last k scores.",
          "name": "Optimized Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0.6",
              "explanation": "The probability of winning the game when the target score is 10, the number of remaining cards is 2, and the maximum number of points we can draw in one turn is 6.",
              "id": "ffe453ed-f5b7-4407-8d7f-14ff86d55d8c",
              "input": "n = 10, k = 2, maxPts = 6"
            },
            {
              "expectedOutput": "0.6",
              "explanation": "The probability of winning the game when the target score is 6, the number of remaining cards is 1, and the maximum number of points we can draw in one turn is 10.",
              "id": "046014f7-d6b7-4195-87b4-1341e0d628b2",
              "input": "n = 6, k = 1, maxPts = 10"
            }
          ]
        }
      ],
      "id": "c013852e-5d71-4f4e-a3b9-bc6502608f01",
      "lastUpdated": "2026-02-06T21:43:23Z",
      "problemSlug": "new-21-game",
      "relatedProblems": [
        "probability-of-reaching-each-node",
        "unique-paths"
      ],
      "summary": "The problem asks for the probability of winning a New 21 Game where we start with a score of 0 and want to reach a target score without exceeding it, with the key insight being the use of dynamic programming and probability to calculate the winning chances. The problem can be solved using both a brute-force approach and an optimized dynamic programming approach."
    },
    {
      "approaches": [
        {
          "approach": "1. Generate all possible permutations of the digits of the given number. 2. For each permutation, check if it's greater than the original number and if it is, store it as a potential result. 3. Return the smallest number among the potential results.",
          "code": "func nextGreaterElement(_ n: Int) -> Int {\n    let str = String(n)\n    var res: Int = -1\n    let chars = str.map {\n        String($0)\n    }\n    func backtrack(_ current: String, _ index: Int) {\n        if current.count == str.count {\n            if Int(current)! > n && (res == -1 || Int(current)! < res) {\n                res = Int(current)!\n            }\n            return\n        }\n        for i in index..<chars.count {\n            if index > 0 && chars[i] <= chars[index - 1] {\n                continue\n            }\n            let newCurrent = current + chars[i]\n            var visited: [String] = []\n            for j in 0..<chars.count {\n                if j != i && visited.contains(chars[j]) {\n                    continue\n                }\n                visited.append(chars[j])\n                backtrack(newCurrent, i + 1)\n                visited.removeLast()\n            }\n        }\n    }\n    backtrack(\"\", 0)\n    return res\n}",
          "complexity": {
            "space": "O(10)",
            "spaceExplanation": "The space complexity is O(10) because we store all digits of the number.",
            "time": "O(10!)",
            "timeExplanation": "The time complexity is O(10!) because there are 10 possible digits (0-9) and we generate all permutations of the digits."
          },
          "explanation": "The brute force approach tries all possible combinations of digits, which guarantees finding the next greater element if it exists. However, this approach can be slow due to its high time complexity.",
          "id": "bbb7da26-4470-49ed-bde5-9325931cea63",
          "intuition": "This approach is based on trying all possible permutations of the given number and checking if it's greater than the original number.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "21",
              "explanation": "The next greater element of 12 is 21 because 21 is greater than 12 and is the smallest possible number that can be formed by rearranging the digits of 12.",
              "id": "ebf929bc-cb46-4175-b6c3-88f85c78b886",
              "input": "n = 12"
            },
            {
              "expectedOutput": "-1",
              "explanation": "The next greater element of 21 does not exist because there are no greater numbers that can be formed by rearranging the digits of 21.",
              "id": "d4da71a9-037d-4a41-a293-d727404084ae",
              "input": "n = 21"
            }
          ]
        },
        {
          "approach": "1. Scan the number from right to left and find the first pair of two successive digits that are in increasing order. 2. If no such pair is found, return -1 because the number is the largest possible. 3. Otherwise, find the smallest digit to the right of the pair that is greater than the first digit of the pair. 4. Swap the first digit of the pair with the smallest greater digit and reverse the digits to the right of the pair to get the smallest possible greater number.",
          "code": "func nextGreaterElement(_ n: Int) -> Int {\n    let str = String(n)\n    var chars = Array(str)\n    var i = chars.count - 2\n    while i >= 0 && chars[i] >= chars[i + 1] {\n        i -= 1\n    }\n    if i < 0 {\n        return -1\n    }\n    var j = chars.count - 1\n    while j > i && chars[j] <= chars[i] {\n        j -= 1\n    }\n    let temp = chars[j]\n    chars[j] = chars[i]\n    chars[i] = temp\n    let left = chars[0...i]\n    let mid = chars[i + 1...j].reversed()\n    let right = chars[j + 1...]\n    let res = String(left + mid + right)\n    return Int(res) ?? -1\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we store the characters of the number.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we scan the number once from right to left."
          },
          "explanation": "The optimized approach finds the next greater element by scanning the number from right to left and finding the first pair of two successive digits that are in increasing order. This guarantees finding the smallest possible greater number.",
          "id": "89375e15-c5c0-4cda-bae7-204ca8e87b6c",
          "intuition": "This approach is based on finding the first pair of two successive digits from the right that are in increasing order.",
          "name": "Find First Increasing Digit Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "21",
              "explanation": "The next greater element of 12 is 21 because 21 is greater than 12 and is the smallest possible number that can be formed by rearranging the digits of 12.",
              "id": "d323bcd2-1c7b-48c2-bef5-c3646c184ad2",
              "input": "n = 12"
            },
            {
              "expectedOutput": "-1",
              "explanation": "The next greater element of 21 does not exist because there are no greater numbers that can be formed by rearranging the digits of 21.",
              "id": "3e355b6a-cffa-4af2-9634-5efcd59a2ac3",
              "input": "n = 21"
            }
          ]
        }
      ],
      "id": "079ae6c5-10be-40b6-a049-5870ee49cd7c",
      "lastUpdated": "2026-02-06T21:25:58Z",
      "problemSlug": "next-greater-element-iii",
      "relatedProblems": [
        "next-permutation",
        "find-first-and-last-position-of-element-in-sorted-array"
      ],
      "summary": "The problem Next Greater Element III is asking to find the next greater element for the given number. The key insight is to find the first pair of two successive digits from the right that are in increasing order."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a variable to track if the current player can win. 2. Simulate all possible moves for the current player. 3. For each move, recursively call the function to determine if the next player can win. 4. If any move leads to a win for the current player, return true.",
          "code": "func canWinNim(_ n: Int) -> Bool { if n == 0 { return false }; if n == 1 || n == 2 { return true }; var canWin = false; for i in 1...3 { canWin = canWin || !canWinNim(n - i); if canWin { break } }; return canWin }",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear because of the recursion stack.",
            "time": "O(3^n)",
            "timeExplanation": "The time complexity is exponential because we are simulating all possible games."
          },
          "explanation": "This approach is not efficient for large inputs because it involves simulating all possible games, which leads to an exponential time complexity.",
          "id": "efa4368b-9357-42ee-b836-44f1df28fee9",
          "intuition": "This approach involves trying all possible moves and determining if the current player can win. It works by simulating all possible games and checking if the current player can force a win.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "The first player cannot win because no matter what move they make, the second player can force a win.",
              "id": "72a79696-6387-4f30-93b1-5a907b54c3bb",
              "input": "n = 4"
            },
            {
              "expectedOutput": "true",
              "explanation": "The first player can win because they can remove one object, leaving the second player with four objects.",
              "id": "ee35e919-9b6d-42f3-94d2-b1b805ac8bd7",
              "input": "n = 5"
            }
          ]
        },
        {
          "approach": "1. Calculate the XOR of the heap sizes. 2. If the XOR is zero, the current player cannot win. 3. Otherwise, the current player can win.",
          "code": "func canWinNim(_ n: Int) -> Bool { return n % 4 != 0 }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we are not using any additional space.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant because we are only calculating the XOR of the heap sizes."
          },
          "explanation": "This approach is efficient because it involves a simple calculation and does not require simulating all possible games.",
          "id": "350450bf-0da3-4f3d-b680-5a5944e574cd",
          "intuition": "This approach involves using the XOR of the heap sizes to determine the winning strategy. It works by calculating the XOR of the heap sizes and checking if it is zero.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "false",
              "explanation": "The XOR of 4 is 0, so the first player cannot win.",
              "id": "4c15e41d-8c65-4d96-bd46-e7e0738da5eb",
              "input": "n = 4"
            },
            {
              "expectedOutput": "true",
              "explanation": "The XOR of 5 is 1, so the first player can win.",
              "id": "a21fd7aa-454a-40fd-8f16-8fdd8a6bccae",
              "input": "n = 5"
            }
          ]
        }
      ],
      "id": "35d66825-3752-4f7b-86cd-dcaf606c663d",
      "lastUpdated": "2026-02-06T21:12:11Z",
      "problemSlug": "nim-game",
      "relatedProblems": [
        "stone-game",
        "predict-the-winner"
      ],
      "summary": "The Nim Game problem is about finding a winning strategy in a simple game where two players take turns removing objects from a heap, with the last player to remove an object winning. The key insight to solving this problem is to use the XOR of the heap sizes to determine the winning strategy."
    },
    {
      "approaches": [
        {
          "approach": "Generate integers starting from 1 and append them to a string, keeping track of the current length of the string. Once the length is greater than or equal to n, return the nth character.",
          "code": "func findNthDigit(_ n: Int) -> Int {\n    var num = 1\n    var length = 0\n    var result = \"\"\n    while length < n {\n        result += String(num)\n        length += String(num).count\n        num += 1\n    }\n    return Int(String(result[ result.index(result.startIndex, offsetBy: n-1) ])) ?? 0\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also O(n) because the maximum length of the string is n, requiring O(n) space to store it.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we need to generate and append n numbers to the string."
          },
          "explanation": "This approach works but is inefficient for large inputs because it involves generating and concatenating a large number of strings, resulting in high memory usage and slow execution times.",
          "id": "a5d91c1c-e7ed-475b-ad54-2a277fd06246",
          "intuition": "This approach involves generating all positive integers and concatenating them into a string until the length of the string is greater than or equal to the input number n. We then simply return the nth character of this string.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The concatenation of all positive integers starts as '123456789101112...'. The third digit is '3'.",
              "id": "be952c9c-5b23-4373-be2a-0ec3c2c59f36",
              "input": "n = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "The concatenation continues as '...9101112...'. The eleventh digit is '0'.",
              "id": "cbc6ebaf-b2db-4abc-aa76-db3501f48ac8",
              "input": "n = 11"
            }
          ]
        },
        {
          "approach": "Calculate the total number of digits in each range of numbers with the same number of digits. Use binary search to find the range of numbers containing the nth digit.",
          "code": "func findNthDigit(_ n: Int) -> Int {\n    var n = n\n    var length = 1\n    var count = 9\n    var start = 1\n    while n > length * count {\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    }\n    start += (n - 1) / length\n    let str = String(start)\n    let index = str.index(str.startIndex, offsetBy: (n - 1) % length)\n    return Int(String(str[index])) ?? 0\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store variables, regardless of the input size.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is O(log n) because we are essentially performing a binary search over the ranges of numbers."
          },
          "explanation": "This approach efficiently locates the range of numbers containing the nth digit and then calculates the exact digit, significantly reducing computation time compared to the brute force approach.",
          "id": "3ab090e8-9d78-4ba4-b121-250614b80588",
          "intuition": "This approach uses the fact that the numbers from 1 to 9 have one digit each, numbers from 10 to 99 have two digits each, and so on. We calculate the total number of digits up to each range of numbers and use binary search to find the range containing the nth digit.",
          "name": "Optimized Binary Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The third digit is in the range of one-digit numbers and is '3'.",
              "id": "5a937ad5-bba5-4a70-b260-3e6893126a9f",
              "input": "n = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "The eleventh digit is in the range of two-digit numbers, specifically in the number '10', and is '0'.",
              "id": "7bacae8a-229d-4fa7-a8ad-10100a3bc6c4",
              "input": "n = 11"
            }
          ]
        }
      ],
      "id": "c733b13c-15f3-4fcd-b0fd-379efb72bcb8",
      "lastUpdated": "2026-02-06T21:16:34Z",
      "problemSlug": "nth-digit",
      "relatedProblems": [
        "add-digits",
        "next-greater-element-i"
      ],
      "summary": "The Nth Digit problem involves finding the nth digit of the concatenation of all positive integers, using insights about ranges of numbers and their digit counts. A key insight is to use binary search to quickly locate the range of numbers containing the nth digit."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Create a hash map to store the count of points for each distance. Step 2: Iterate through all points and for each point, iterate through all other points to calculate the distance. Step 3: Increment the count in the hash map for each distance. Step 4: For each point, calculate the number of boomerangs by looking up the count in the hash map.",
          "code": "import Foundation\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\n    var count = 0\n    for i in 0..<points.count {\n        var map: [Int:Int] = [:]\n        for j in 0..<points.count where i != j {\n            let x = points[i][0] - points[j][0]\n            let y = points[i][1] - points[j][1]\n            let distance = x*x + y*y\n            if map[distance] == nil {\n                map[distance] = 1\n            } else {\n                map[distance]! += 1\n            }\n        }\n        for (_, value) in map {\n            count += value * (value - 1)\n        }\n    }\n    return count\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the hash map used to store the count of points for each distance.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) due to the nested loops."
          },
          "explanation": "This approach is straightforward but has a high time complexity due to the nested loops.",
          "id": "c784c543-fede-4b51-93f3-44fcee096b72",
          "intuition": "This approach works by iterating through all pairs of points and counting the number of points that have the same distance from a given point.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "There are two boomerangs, one with points (0,0) and (1,0), and another with points (1,0) and (2,0).",
              "id": "b4a26eec-a98c-414e-b463-354a65c0edec",
              "input": "points = [[0,0],[1,0],[2,0]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no boomerangs because there are not enough points.",
              "id": "a786ccfe-da19-48b7-8744-2d3a601a7a09",
              "input": "points = [[1,1]]"
            }
          ]
        },
        {
          "approach": "Step 1: Create a hash map to store the count of points for each distance. Step 2: Iterate through all points and for each point, calculate the distance to all other points. Step 3: Update the count in the hash map for each distance. Step 4: For each point, calculate the number of boomerangs by looking up the count in the hash map.",
          "code": "import Foundation\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\n    var count = 0\n    for i in 0..<points.count {\n        var map: [Int:Int] = [:]\n        for j in 0..<points.count where i != j {\n            let x = points[i][0] - points[j][0]\n            let y = points[i][1] - points[j][1]\n            let distance = x*x + y*y\n            map[distance, default: 0] += 1\n        }\n        for (_, value) in map {\n            count += value * (value - 1)\n        }\n    }\n    return count\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) due to the hash map used to store the count of points for each distance.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) due to the nested loops."
          },
          "explanation": "This approach is more efficient than the brute force approach because it avoids the nested loops.",
          "id": "5be3a387-33e2-4a21-a5d6-88d4a16f7683",
          "intuition": "This approach works by using a hash map to store the count of points for each distance from a given point, similar to the brute force approach. However, instead of iterating through all pairs of points, it uses a single loop to calculate the distances and update the count in the hash map.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "There are two boomerangs, one with points (0,0) and (1,0), and another with points (1,0) and (2,0).",
              "id": "a60147f4-81ef-4d03-be07-38af0f65384d",
              "input": "points = [[0,0],[1,0],[2,0]]"
            },
            {
              "expectedOutput": "0",
              "explanation": "There are no boomerangs because there are not enough points.",
              "id": "f975e304-e6b7-4891-ad5e-42d4b689f3ba",
              "input": "points = [[1,1]]"
            }
          ]
        }
      ],
      "id": "1beae5de-0859-48bf-a86c-aa68b9de16a0",
      "lastUpdated": "2026-02-06T21:19:12Z",
      "problemSlug": "number-of-boomerangs",
      "relatedProblems": [
        "max-points-on-a-line",
        "valid-tic-tac-toe-state"
      ],
      "summary": "This problem involves finding the number of boomerangs in an array of points. The key insight is to use a hash map to count the number of points that have the same distance from a given point."
    },
    {
      "approaches": [
        {
          "approach": "We start with the input array and try all possible ways of dividing it into two parts. For each division, we recursively try all possible ways of dividing the two parts further. We calculate the result for each possible division and keep track of the maximum result.",
          "code": "func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"/\" + String(nums[1])    }    var result = String(nums[0]) + \"/(\"    for i in 1..<nums.count-1 {        result += String(nums[i]) + \",\"    }    result += String(nums[nums.count-1]) + \")\"    return result}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear because we need to store the recursive call stack.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential because we are trying all possible ways of dividing the input array."
          },
          "explanation": "The brute force approach tries all possible ways of dividing the input array, but it is inefficient because it does a lot of repeated work. For example, if we have the array [1000, 100, 10, 2], we will try dividing it into [1000, 100, 10, 2] and [1000, 100, 10] / 2, but these two divisions are essentially the same because the division operator has higher precedence than the multiplication operator.",
          "id": "291c1d0a-9927-48ae-999c-a7333e8ad7f9",
          "intuition": "This approach works by trying all possible ways of placing the division operators and calculating the result for each one.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1000/(100/10/2)",
              "explanation": "We divide the array into [1000] and [100, 10, 2], and then divide [100, 10, 2] into [100] and [10, 2], and finally divide [10, 2] into [10] and [2].",
              "id": "db5347c7-350c-49a7-9c60-2cc8475b1a22",
              "input": "nums = [1000,100,10,2]"
            },
            {
              "expectedOutput": "4/(3/2)",
              "explanation": "We divide the array into [4] and [3, 2], and then divide [3, 2] into [3] and [2].",
              "id": "2bf1d368-cc50-4bc3-a5e1-aab119582a7c",
              "input": "nums = [4,3,2]"
            }
          ]
        },
        {
          "approach": "We start with the input array and divide it into two parts: the first part contains the first number, and the second part contains the rest of the numbers. We then recursively try all possible ways of dividing the second part further, but we only consider divisions that do not decrease the result.",
          "code": "func optimalDivision(_ nums: [Int]) -> String {    if nums.count == 1 {        return String(nums[0])    } else if nums.count == 2 {        return String(nums[0]) + \"/\" + String(nums[1])    }    return String(nums[0]) + \"/(\" + String(nums.dropFirst())joined(separator: \"/\") + \")\"}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we are not using any additional data structures.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we are only iterating over the input array once."
          },
          "explanation": "The optimized approach tries to place the division operators in a way that minimizes the result of the division. This is done by always placing the division operators in a way that decreases the result the least. For example, if we have the array [1000, 100, 10, 2], we will place the division operators as 1000/(100/10/2) because this minimizes the result of the division.",
          "id": "fc038ae7-9af6-4a7c-8910-d5dac105bfcc",
          "intuition": "This approach works by always placing the division operators in a way that minimizes the result of the division.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1000/(100/10/2)",
              "explanation": "We divide the array into [1000] and [100, 10, 2], and then divide [100, 10, 2] into [100] and [10, 2], and finally divide [10, 2] into [10] and [2].",
              "id": "1572f988-2bcb-4cca-ad17-2f36271970b0",
              "input": "nums = [1000,100,10,2]"
            },
            {
              "expectedOutput": "4/(3/2)",
              "explanation": "We divide the array into [4] and [3, 2], and then divide [3, 2] into [3] and [2].",
              "id": "07460680-b2a0-4e04-8070-17d6701f410d",
              "input": "nums = [4,3,2]"
            }
          ]
        }
      ],
      "id": "a6e73db3-d3b8-4949-b775-2b3a92aa694d",
      "lastUpdated": "2026-02-06T21:25:48Z",
      "problemSlug": "optimal-division",
      "relatedProblems": [
        "construct-array",
        "minimum-operations-to-make-array-equal"
      ],
      "summary": "The problem Optimal Division is about dividing a list of numbers to obtain the maximum result. The key insight is to treat the division as a sequence of operations and find the optimal way to place the division operators."
    },
    {
      "approaches": [
        {
          "approach": "1. Handle negative numbers (always false - minus sign)\n2. Convert number to string\n3. Compare string with its reverse\n4. Return true if equal",
          "code": "func isPalindrome(_ x: Int) -> Bool {\n    if x < 0 { return false }\n    let str = String(x)\n    return str == String(str.reversed())\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "String representation requires O(n) space for n digits",
            "time": "O(n)",
            "timeExplanation": "Where n is the number of digits. String conversion and reversal are O(n)"
          },
          "explanation": "This approach leverages string manipulation to easily reverse and compare. While intuitive, it requires O(n) extra space for the string representation and is slower due to string operations.",
          "id": "2609cabd-f74e-42da-8898-cdd74fa64ee8",
          "intuition": "Convert the number to a string and check if it equals its reverse. Simple but uses extra space for the string.",
          "name": "String Conversion",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "121 reads as 121 from left to right and from right to left",
              "id": "f91595b0-f627-43d6-bbad-deb874124a20",
              "input": "x = 121"
            },
            {
              "expectedOutput": "false",
              "explanation": "From left to right it reads -121, from right to left it's 121-. Not a palindrome.",
              "id": "7ee1455f-2207-4316-b3a3-ec0d5d758abe",
              "input": "x = -121"
            }
          ]
        },
        {
          "approach": "1. Return false for negative numbers\n2. Return false if number ends in 0 (except 0 itself)\n3. Reverse digits until reversed >= remaining\n4. Compare: for even digits, they should be equal; for odd digits, ignore middle digit",
          "code": "func isPalindrome(_ x: Int) -> Bool {\n    // Negative numbers and numbers ending in 0 (except 0) aren't palindromes\n    if x < 0 || (x % 10 == 0 && x != 0) {\n        return false\n    }\n    \n    var num = x\n    var reversed = 0\n    \n    // Reverse half of the number\n    while num > reversed {\n        reversed = reversed * 10 + num % 10\n        num /= 10\n    }\n    \n    // For even length: num == reversed\n    // For odd length: num == reversed / 10 (skip middle digit)\n    return num == reversed || num == reversed / 10\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Only using a few integer variables",
            "time": "O(log n)",
            "timeExplanation": "We process half the digits, and number of digits is log10(n)"
          },
          "explanation": "We reverse the second half of the number by repeatedly taking the last digit (x % 10) and building the reversed number. We stop when the reversed number is >= the remaining original. For even-length palindromes, they're equal. For odd-length, we divide reversed by 10 to skip the middle digit.",
          "id": "b5146218-4809-42d9-8647-fbdc114878ef",
          "intuition": "Instead of reversing the entire number (which could overflow), reverse only half. If it's a palindrome, the first half equals the reversed second half.",
          "name": "Reverse Half Number",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "After loop: num=1, reversed=12. num == reversed/10 (1 == 1). True.",
              "id": "5718997d-f710-45de-b838-64e2db415d31",
              "input": "x = 121"
            },
            {
              "expectedOutput": "true",
              "explanation": "After loop: num=12, reversed=12. num == reversed. True.",
              "id": "2d930f56-c792-4a13-8f8a-e038405f6f9a",
              "input": "x = 1221"
            },
            {
              "expectedOutput": "false",
              "explanation": "Ends in 0 but isn't 0, so immediately return false.",
              "id": "d189e09c-1659-4ff1-9c5d-69f1a6d4c8dc",
              "input": "x = 10"
            },
            {
              "expectedOutput": "true",
              "explanation": "0 is a palindrome.",
              "id": "f0d193bb-e677-4e0b-94a7-6da88695f5a3",
              "input": "x = 0"
            }
          ]
        }
      ],
      "id": "0840dd80-aae7-4974-a215-3c35e374b0a3",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "palindrome-number",
      "relatedProblems": [
        "palindrome-linked-list",
        "valid-palindrome",
        "valid-palindrome-ii"
      ],
      "summary": "Determine if an integer reads the same forwards and backwards. The optimal approach reverses half the number and compares, avoiding string conversion and potential overflow."
    },
    {
      "approaches": [
        {
          "approach": "Iterate through all numbers from 1 to the given number, check if each number is a divisor, and sum the divisors.",
          "code": "func checkPerfectNumber(_ num: Int) -> Bool { var sum = 0; for i in 1...num/2 { if num % i == 0 { sum += i } }; return sum == num }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We're using a constant amount of space, so the space complexity is constant.",
            "time": "O(n)",
            "timeExplanation": "We're checking every number up to n, so the time complexity is linear."
          },
          "explanation": "Start from 1 and check each number to see if it's a divisor of the given number by using the modulus operator. If the remainder is 0, it's a divisor, so add it to the sum. Finally, compare the sum of divisors to the given number.",
          "id": "e88b031b-5a14-45c0-9b18-cbefb2a6af7a",
          "intuition": "This approach works by checking every number up to the given number to see if it's a divisor, then summing all divisors.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The divisors of 28 are 1, 2, 4, 7, 14, and their sum is 28, so 28 is a perfect number.",
              "id": "d98cacf9-5e12-4dd6-89d9-4d3ece6adef0",
              "input": "num = 28"
            },
            {
              "expectedOutput": "true",
              "explanation": "The divisors of 6 are 1, 2, 3, and their sum is 6, so 6 is a perfect number.",
              "id": "1dd07347-6652-4c9e-9b67-2a4ab5f791ab",
              "input": "num = 6"
            }
          ]
        },
        {
          "approach": "Iterate through numbers from 1 to the square root of the given number, check if each number is a divisor, and sum both the divisor and its corresponding larger divisor.",
          "code": "func checkPerfectNumber(_ num: Int) -> Bool { var sum = 1; let sqrtNum = Int(sqrt(Double(num))); for i in 2...sqrtNum { if num % i == 0 { sum += i; if i != num / i { sum += num / i } } }; return sum == num }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We're using a constant amount of space, so the space complexity is constant.",
            "time": "O(sqrt(n))",
            "timeExplanation": "We're checking up to the square root of n, so the time complexity is reduced to square root of n."
          },
          "explanation": "Start from 1 and check each number to see if it's a divisor of the given number by using the modulus operator. If the remainder is 0, it's a divisor, so add both the divisor and its corresponding larger divisor (num / i) to the sum, but only if i is not equal to num / i to avoid counting square root twice. Finally, compare the sum of divisors to the given number.",
          "id": "b75708e4-2de2-4552-9f4b-a3b16fc12467",
          "intuition": "This approach works by only checking up to the square root of the given number for divisors, then summing the divisors and their corresponding larger divisors.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The divisors of 28 are 1, 2, 4, 7, 14, and their sum is 28, so 28 is a perfect number.",
              "id": "37adc1be-d00d-4046-a50a-a42b021a2e99",
              "input": "num = 28"
            },
            {
              "expectedOutput": "true",
              "explanation": "The divisors of 6 are 1, 2, 3, and their sum is 6, so 6 is a perfect number.",
              "id": "ed03ff02-12af-45a6-b634-58922871bb97",
              "input": "num = 6"
            }
          ]
        }
      ],
      "id": "806409de-6216-49fd-90f3-1f9d1695d647",
      "lastUpdated": "2026-02-06T21:22:59Z",
      "problemSlug": "perfect-number",
      "relatedProblems": [
        "divisor-game",
        "prime-palindrome"
      ],
      "summary": "A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. The key insight is to identify and sum all divisors of a given number."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate from right to left\n2. Add 1 to current digit\n3. If digit < 10, we're done (no carry)\n4. If digit == 10, set to 0 and continue (carry)\n5. If we exit loop with carry, prepend 1",
          "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    for i in (0..<digits.count).reversed() {\n        digits[i] += 1\n        if digits[i] < 10 {\n            return digits\n        }\n        digits[i] = 0\n    }\n    \n    // All digits were 9, need new leading 1\n    return [1] + digits\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "May need to create new array with n+1 digits",
            "time": "O(n)",
            "timeExplanation": "Worst case traverses all n digits (all 9s)"
          },
          "explanation": "The key insight is that we only continue carrying if digit becomes 10 (i.e., was 9). As soon as we add to a non-9 digit, we can return immediately. If all digits were 9 (like 999), we need a new leading 1 (1000).",
          "id": "3d80c2ac-ab41-4eb4-acd5-e51cea3ebb18",
          "intuition": "Start from the rightmost digit and add one. If it becomes 10, set to 0 and carry to next digit. Continue until no carry or we reach the front.",
          "name": "Right to Left with Carry",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,2,4]",
              "explanation": "123 + 1 = 124. Only last digit changes.",
              "id": "b65e1a7c-01f5-443f-aa73-4872ff0e3497",
              "input": "digits = [1,2,3]"
            },
            {
              "expectedOutput": "[4,3,2,2]",
              "explanation": "4321 + 1 = 4322",
              "id": "44c8de99-16c2-4c2a-8eeb-b1ec76a512dc",
              "input": "digits = [4,3,2,1]"
            },
            {
              "expectedOutput": "[1,0,0,0]",
              "explanation": "999 + 1 = 1000. Carry propagates through all digits, need new leading 1.",
              "id": "e9679c66-7051-42a3-adbf-3030b92b21d4",
              "input": "digits = [9,9,9]"
            },
            {
              "expectedOutput": "[2,0,0]",
              "explanation": "199 + 1 = 200. Carry stops at first digit.",
              "id": "ade4dd71-42d5-4633-acc8-926c7b23488e",
              "input": "digits = [1,9,9]"
            }
          ]
        },
        {
          "approach": "1. Find rightmost non-9 digit\n2. If found: increment it, zero out all digits to the right\n3. If not found: all digits are 9, return [1] + array of zeros",
          "code": "func plusOne(_ digits: [Int]) -> [Int] {\n    var digits = digits\n    \n    // Find rightmost non-9\n    var i = digits.count - 1\n    while i >= 0 && digits[i] == 9 {\n        i -= 1\n    }\n    \n    if i < 0 {\n        // All 9s: 999 -> 1000\n        return [1] + Array(repeating: 0, count: digits.count)\n    }\n    \n    // Increment found digit, zero everything to its right\n    digits[i] += 1\n    for j in (i+1)..<digits.count {\n        digits[j] = 0\n    }\n    \n    return digits\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Worst case creates new array of n+1 digits",
            "time": "O(n)",
            "timeExplanation": "Scan for non-9, then potentially zero trailing digits"
          },
          "explanation": "This approach explicitly identifies the 'stopping point' of the carry before modifying anything. It's equivalent to the carry approach but thinks about it differently - we're looking for where the increment actually happens.",
          "id": "33612655-cab5-4792-b5c4-873440c52bdf",
          "intuition": "Find the rightmost digit that isn't 9, increment it, and set all digits to its right to 0. If all are 9, prepend 1 and set all to 0.",
          "name": "Find Rightmost Non-9",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,0]",
              "explanation": "9 + 1 = 10",
              "id": "7325e2cd-97db-4e05-9f1e-d6550b4079b0",
              "input": "digits = [9]"
            },
            {
              "expectedOutput": "[9,0,0]",
              "explanation": "899 + 1 = 900. Rightmost non-9 is 8 at index 0.",
              "id": "a17c9969-801e-490b-b7dd-a4fbb90d6fd5",
              "input": "digits = [8,9,9]"
            }
          ]
        }
      ],
      "id": "c90f653b-4db2-4d85-a272-cc49a7748364",
      "lastUpdated": "2026-02-06T08:36:45Z",
      "problemSlug": "plus-one",
      "relatedProblems": [
        "add-binary",
        "add-to-array-form-of-integer",
        "multiply-strings"
      ],
      "summary": "Add one to a number represented as an array of digits. Handle carry propagation from right to left. Only need a new digit if all digits were 9."
    },
    {
      "approaches": [
        {
          "approach": "Start with the input number and continuously divide it by four, checking for the remainder after each division. If the remainder is ever non-zero, return false. Otherwise, return true when the number becomes 1.",
          "code": "\nfunc isPowerOfFour(_ n: Int) -> Bool {\n  if n <= 0 {\n    return false\n  }\n  var number = n\n  while number > 1 {\n    if number % 4 != 0 {\n      return false\n    }\n    number /= 4\n  }\n  return true\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the input number and the temporary result.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is logarithmic because with each division by 4, the size of the input number decreases."
          },
          "explanation": "This approach relies on the property that a number is a power of four if and only if it can be continuously divided by four without a remainder until it becomes 1.",
          "id": "cbbe787d-c32c-4e45-b1c5-90e8cd6b2b11",
          "intuition": "The brute force approach works by continuously dividing the input number by four until it becomes less than 1, checking if the remainder is zero after each division.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "16 is a power of four because 4^2 = 16.",
              "id": "5af972ab-36ed-4f1a-a737-a6955eb812d2",
              "input": "n = 16"
            },
            {
              "expectedOutput": "false",
              "explanation": "20 is not a power of four because it cannot be represented as 4^n for any integer n.",
              "id": "a0d13c7a-71c7-426b-b4da-a23ca0bee03e",
              "input": "n = 20"
            },
            {
              "expectedOutput": "true",
              "explanation": "1 is a power of four because 4^0 = 1.",
              "id": "8ddb2b6c-4135-4165-9a68-46c5eb68824e",
              "input": "n = 1"
            }
          ]
        },
        {
          "approach": "Check if the number is a power of two and if the number of zeros between the leftmost and rightmost bits is even.",
          "code": "\nfunc isPowerOfFour(_ n: Int) -> Bool {\n  if n <= 0 {\n    return false\n  }\n  let binary = String(n, radix: 2)\n  let countOnes = binary.filter { $0 == \"1\" }.count\n  let countZeros = binary.filter { $0 == \"0\" }.count\n  if countOnes != 1 {\n    return false\n  }\n  return countZeros % 2 == 0\n}\n",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "The space complexity is logarithmic because the binary representation of the input number is stored in a string.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is logarithmic because converting the number to a binary string takes logarithmic time."
          },
          "explanation": "A number is a power of four if it is a power of two and the number of zeros between the leftmost and rightmost bits is even.",
          "id": "9f7c40b9-b9f6-4734-9a55-c069c88510cf",
          "intuition": "The bit manipulation approach works by utilizing the properties of powers of four in binary representation.",
          "name": "Bit Manipulation",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "16 is a power of four because 4^2 = 16.",
              "id": "2ccdb40f-f004-4ef9-ac6d-a9259da8a158",
              "input": "n = 16"
            },
            {
              "expectedOutput": "false",
              "explanation": "20 is not a power of four because it cannot be represented as 4^n for any integer n.",
              "id": "cf8d163b-51ff-4752-87c5-0b463aa977d1",
              "input": "n = 20"
            },
            {
              "expectedOutput": "true",
              "explanation": "1 is a power of four because 4^0 = 1.",
              "id": "0cdafa29-da2c-4d1f-9355-e5582737647a",
              "input": "n = 1"
            }
          ]
        }
      ],
      "id": "5e02c70a-a525-4fe2-b638-b00c759285c9",
      "lastUpdated": "2026-02-06T21:13:34Z",
      "problemSlug": "power-of-four",
      "relatedProblems": [
        "power-of-two",
        "power-of-three"
      ],
      "summary": "The problem requires determining if a given integer is a power of four. The key insight is to utilize the properties of powers of four to check if the given number can be represented as 4^n."
    },
    {
      "approaches": [
        {
          "approach": "1. Start with the given number. 2. Repeatedly divide the number by three as long as it is divisible evenly. 3. If the final result is one, then the original number is a power of three.",
          "code": "func isPowerOfThree(_ n: Int) -> Bool { var num = n; while num % 3 == 0 { num /= 3 }; return num == 1; }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as it uses a fixed amount of space to store the input number and the loop variable.",
            "time": "O(log(n))",
            "timeExplanation": "The while loop runs until n becomes 1, which takes log(n) steps in the worst case, with n being the input number."
          },
          "explanation": "This approach involves using a simple loop to check for divisibility by three until the number becomes one, at which point it is confirmed to be a power of three. However, this method may be inefficient for large numbers due to potential integer overflow issues.",
          "id": "6d8e03cd-ee92-4fed-a566-4970f9880455",
          "intuition": "We can repeatedly divide the given number by three and check if it becomes one, which indicates it is a power of three.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "27 is a power of three (3^3 = 27), so the function returns true.",
              "id": "2ffa4b87-9580-4d13-a24a-d4cb5b7243d7",
              "input": "n = 27"
            },
            {
              "expectedOutput": "false",
              "explanation": "28 is not a power of three, so the function returns false.",
              "id": "abdce429-254e-47c6-b116-146aed60f1b3",
              "input": "n = 28"
            }
          ]
        },
        {
          "approach": "1. Calculate the largest power of three that is less than or equal to the given number using logarithm. 2. Check if the result is equal to the given number.",
          "code": "import Darwin; func isPowerOfThree(_ n: Int) -> Bool { let logValue = log(Double(n)) / log(3); return fmod(logValue, 1) == 0 && n > 0; }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as it uses a fixed amount of space to store the input number and the calculated logarithm value.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant as it involves a fixed number of operations, regardless of the input size."
          },
          "explanation": "This approach involves using the property of logarithms to calculate the power of three, which is more efficient than the brute force method. The largest power of three less than or equal to the given number can be calculated as 3^(log3(n)).",
          "id": "51f3f2ea-3386-4b1c-be4a-d4cc4ac6a73d",
          "intuition": "Instead of using a loop, we can utilize the mathematical property that the largest power of three less than or equal to the given number will help determine if it's a power of three.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "27 is a power of three (3^3 = 27), so the function returns true.",
              "id": "fa673c9a-065d-45f9-bca9-d1133ebfb9a5",
              "input": "n = 27"
            },
            {
              "expectedOutput": "false",
              "explanation": "0 is not a power of three as it is less than 1, so the function returns false.",
              "id": "7ba6e7da-72e3-4263-9230-0fb8daeee680",
              "input": "n = 0"
            }
          ]
        }
      ],
      "id": "1deb8475-5f8e-49fd-a711-eb697389378e",
      "lastUpdated": "2026-02-06T21:13:10Z",
      "problemSlug": "power-of-three",
      "relatedProblems": [
        "power-of-two",
        "power-of-four"
      ],
      "summary": "The problem requires determining if a given number is a power of three. The key insight involves utilizing mathematical properties to efficiently check for powers of three."
    },
    {
      "approaches": [
        {
          "approach": "Initialize a counter to 1, repeatedly check if the input number is equal to the counter, then double the counter until it exceeds the input number",
          "code": "class Solution { func isPowerOfTwo(_ n: Int) -> Bool { var i = 1; while i <= n { if i == n { return true }; i *= 2 }; return false } }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant, as we only use a fixed amount of space to store the counter and input number.",
            "time": "O(log n)",
            "timeExplanation": "Since we double the counter each iteration, the number of iterations grows logarithmically with the input number."
          },
          "explanation": "This approach works by manually checking each power of two until it exceeds the input number. If the input number matches any power of two, return true; otherwise return false",
          "id": "13591a8b-dd39-43cc-b1f4-5ca34c2e9d9c",
          "intuition": "Repeatedly divide the input number by 2 until it becomes 1 or less.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Since 1 is equal to 2^0, it is a power of two",
              "id": "e5c2e896-242d-450f-a0aa-3e70b52c92e8",
              "input": "n = 1"
            },
            {
              "expectedOutput": "true",
              "explanation": "Since 16 is equal to 2^4, it is a power of two",
              "id": "540c0ccd-04e3-4e4b-89cf-2a54ca52b06c",
              "input": "n = 16"
            },
            {
              "expectedOutput": "false",
              "explanation": "Since 218 is not equal to any power of two, it is not a power of two",
              "id": "ae9144ba-589a-4203-a176-3cd9abead74c",
              "input": "n = 218"
            }
          ]
        },
        {
          "approach": "Use the bitwise AND operator (&) to check if (n & (n - 1)) is equal to 0. If it is, then n is a power of two.",
          "code": "class Solution {\n    func isPowerOfTwo(_ n: Int) -> Bool {\n        return n > 0 && (n & (n - 1)) == 0\n    }\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant, as we only use a fixed amount of space to store the input number.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant, as we perform a fixed number of operations regardless of the input size."
          },
          "explanation": "This approach works because in binary representation, powers of two always have exactly one '1' bit and all other bits are '0'. When we subtract 1 from a power of two, we get a number that has all the bits to the right of the original '1' bit set to '1', and all other bits set to '0'. Therefore, the bitwise AND of a power of two and the number one less than it will always be zero.",
          "id": "c2db2515-4af9-4811-9e7b-25cf17acc07f",
          "intuition": "Use the bitwise AND operator to check if a number is a power of two.",
          "name": "Bit Manipulation",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Since 1 is equal to 2^0, it is a power of two",
              "id": "b897c0f4-472e-4511-9ada-f567e4619a0f",
              "input": "n = 1"
            },
            {
              "expectedOutput": "true",
              "explanation": "Since 16 is equal to 2^4, it is a power of two",
              "id": "fda901f2-428d-4d4c-9656-febe49027bd5",
              "input": "n = 16"
            },
            {
              "expectedOutput": "false",
              "explanation": "Since 218 is not equal to any power of two, it is not a power of two",
              "id": "24641e20-0c7f-48f4-b3ed-a75a865b725e",
              "input": "n = 218"
            }
          ]
        }
      ],
      "id": "3120d754-6860-41e9-be7e-a09f5aed55f8",
      "lastUpdated": "2026-02-06T21:11:09Z",
      "problemSlug": "power-of-two",
      "relatedProblems": [
        "binary-search",
        "coin-change"
      ],
      "summary": "Check if a given number is a power of two. This problem can be solved by using the bitwise AND operator."
    },
    {
      "approaches": [
        {
          "approach": "Use two nested loops to generate all possible pairs of exponents i and j. Calculate x^i + y^j and check if the result is less than or equal to the bound. Store the results in a set.",
          "code": "func powerfulIntegers(_ x: Int, _ y: Int, _ bound: Int) -> [Int] {\n    var result: Set<Int> = []\n    var i = 0\n    while x.pow(i) <= bound {\n        var j = 0\n        while x.pow(i) + y.pow(j) <= bound {\n            result.insert(x.pow(i) + y.pow(j))\n            if y == 1 {\n                break\n            }\n            j += 1\n        }\n        if x == 1 {\n            break\n        }\n        i += 1\n    }\n    return Array(result)\n}\n\nextension Int {\n    func pow(_ n: Int) -> Int {\n        return Int(pow(Double(self), Double(n)))\n    }\n}",
          "complexity": {
            "space": "O(log(bound))",
            "spaceExplanation": "The space complexity is O(log(bound)) because we are storing the results in a set. The number of elements in the set is proportional to the logarithm of the bound.",
            "time": "O(log(bound))",
            "timeExplanation": "The time complexity is O(log(bound)) because we are using two nested loops to generate all possible pairs of exponents i and j. The number of iterations in each loop is proportional to the logarithm of the bound."
          },
          "explanation": "We start with i = 0 and j = 0, calculate x^i + y^j, and check if the result is less than or equal to the bound. If it is, we add the result to the set. We then increment i and j and repeat the process until we have checked all possible pairs of exponents.",
          "id": "c2f30e94-a667-48bf-ae92-3c4f782b0552",
          "intuition": "Generate all possible pairs of exponents i and j, calculate x^i + y^j, and check if the result is less than or equal to the bound. Store the results in a set to eliminate duplicates.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[2, 3, 4, 5, 7, 9, 10, 13, 14, 15, 19]",
              "explanation": "The powerful integers less than or equal to 20 are 2, 3, 4, 5, 7, 9, 10, 13, 14, 15, and 19.",
              "id": "1701c814-17af-48a7-a6eb-685693b19090",
              "input": "x = 2, y = 3, bound = 20"
            },
            {
              "expectedOutput": "[2, 4, 6, 8, 10, 14]",
              "explanation": "The powerful integers less than or equal to 15 are 2, 4, 6, 8, 10, and 14.",
              "id": "3d0cf406-c04d-446c-b563-2cf2b1083519",
              "input": "x = 3, y = 5, bound = 15"
            }
          ]
        },
        {
          "approach": "Use a loop to generate the powerful integers and a condition to break the loop when x^i exceeds the bound. Store the results in a set to eliminate duplicates.",
          "code": "func powerfulIntegers(_ x: Int, _ y: Int, _ bound: Int) -> [Int] {\n    var result: Set<Int> = []\n    var i = 0\n    while x.pow(i) <= bound {\n        var j = 0\n        while x.pow(i) + y.pow(j) <= bound {\n            result.insert(x.pow(i) + y.pow(j))\n            if y == 1 {\n                break\n            }\n            j += 1\n        }\n        if x == 1 {\n            break\n        }\n        i += 1\n    }\n    return Array(result)\n}\n\nextension Int {\n    func pow(_ n: Int) -> Int {\n        return Int(pow(Double(self), Double(n)))\n    }\n}",
          "complexity": {
            "space": "O(log(bound))",
            "spaceExplanation": "The space complexity is O(log(bound)) because we are storing the results in a set. The number of elements in the set is proportional to the logarithm of the bound.",
            "time": "O(log(bound))",
            "timeExplanation": "The time complexity is O(log(bound)) because we are using a loop to generate all possible pairs of exponents i and j. The number of iterations in the loop is proportional to the logarithm of the bound."
          },
          "explanation": "We start with i = 0, calculate x^i, and check if the result exceeds the bound. If it does, we break the loop. Otherwise, we calculate y^j and check if x^i + y^j exceeds the bound. If it does, we break the inner loop. Otherwise, we add the result to the set and increment j.",
          "id": "dbd9ec93-ea54-4892-b49b-8e796e10ccd9",
          "intuition": "Use a set to store the results and a loop to generate the powerful integers. Use a condition to break the loop when x^i exceeds the bound.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2, 3, 4, 5, 7, 9, 10, 13, 14, 15, 19]",
              "explanation": "The powerful integers less than or equal to 20 are 2, 3, 4, 5, 7, 9, 10, 13, 14, 15, and 19.",
              "id": "58580f37-f606-4d29-aa62-cbd908489c74",
              "input": "x = 2, y = 3, bound = 20"
            },
            {
              "expectedOutput": "[2, 4, 6, 8, 10, 14]",
              "explanation": "The powerful integers less than or equal to 15 are 2, 4, 6, 8, 10, and 14.",
              "id": "9af87670-a43e-434b-9f8a-5e29fef610be",
              "input": "x = 3, y = 5, bound = 15"
            }
          ]
        }
      ],
      "id": "0f577a1f-5d21-4e15-9c1c-e424b73f6ed3",
      "lastUpdated": "2026-02-06T21:52:24Z",
      "problemSlug": "powerful-integers",
      "relatedProblems": [
        "two-sum",
        "kth-missing-positive-integer"
      ],
      "summary": "Given three integers x, y, and bound, we need to return a list of all powerful integers that have a value less than or equal to the bound where x^i + y^j is a powerful integer. The key insight is to use a set to store the results and a loop to generate the powerful integers."
    },
    {
      "approaches": [
        {
          "approach": "1. Check if 'n' is negative. If so, convert the problem to the reciprocal of x raised to the power of -n. 2. Initialize a variable 'result' to 1. 3. For 'n' times, multiply 'result' by 'x'. 4. Return 'result'.",
          "code": "func myPow(_ x: Double, _ n: Int) -> Double { if n < 0 { return 1 / myPow(x, -n) }; var result: Double = 1; for _ in 1...abs(n) { result *= x }; return result }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the result and other variables.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is linear because we perform a constant amount of work 'n' times."
          },
          "explanation": "The brute force approach is simple but has a high time complexity due to the repeated multiplications. It works but is not efficient for large inputs.",
          "id": "87ecd8a6-0f67-489c-b1ec-5ff281b393b7",
          "intuition": "The brute force approach works by repeatedly multiplying the base number for 'n' times. This is straightforward but inefficient for large values of 'n'.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "8.0",
              "explanation": "This test case checks the function with a positive exponent.",
              "id": "91de0cfa-79a5-4ba9-92c6-13f7d13ba3df",
              "input": "x = 2.0, n = 3"
            },
            {
              "expectedOutput": "0.125",
              "explanation": "This test case checks the function with a negative exponent.",
              "id": "7aacda17-ed94-4a2f-afcc-3e6e0540671b",
              "input": "x = 2.0, n = -3"
            }
          ]
        },
        {
          "approach": "1. Check if 'n' is negative. If so, convert the problem to the reciprocal of x raised to the power of -n. 2. Base case: if 'n' is 0, return 1. 3. If 'n' is even, calculate x raised to the power of n/2 and square it. 4. If 'n' is odd, calculate x raised to the power of (n-1)/2, square it, and multiply by 'x'. 5. Return the result.",
          "code": "func myPow(_ x: Double, _ n: Int) -> Double {\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return 1 / myPow(x, -n)\n    }\n    if n % 2 == 0 {\n        return myPow(x * x, n / 2)\n    }\n    return x * myPow(x * x, (n - 1) / 2)\n}",
          "complexity": {
            "space": "O(log n)",
            "spaceExplanation": "The space complexity is logarithmic due to the recursive call stack.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is logarithmic because we divide the problem size by 2 at each step."
          },
          "explanation": "The divide and conquer approach reduces the time complexity by dividing the problem into smaller sub-problems and reusing the results. This is a significant improvement over the brute force approach for large values of 'n'.",
          "id": "e4bef1a3-6d0a-40e7-b980-b9d874cc526d",
          "intuition": "The divide and conquer approach works by dividing the problem into two smaller sub-problems: calculating x raised to the power of n/2 and then squaring the result. This significantly reduces the number of multiplications needed.",
          "name": "Divide and Conquer",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "8.0",
              "explanation": "This test case checks the function with a positive exponent.",
              "id": "d7b771bb-06a5-4300-9b79-b7d1c752b19d",
              "input": "x = 2.0, n = 3"
            },
            {
              "expectedOutput": "0.125",
              "explanation": "This test case checks the function with a negative exponent.",
              "id": "c690480a-f410-48b6-bfba-ed83920d863e",
              "input": "x = 2.0, n = -3"
            }
          ]
        }
      ],
      "id": "a683a788-5340-4009-b373-623027d89ba5",
      "lastUpdated": "2026-02-06T21:04:44Z",
      "problemSlug": "powx-n",
      "relatedProblems": [
        "reverse-integer",
        "sqrtx"
      ],
      "summary": "The problem requires calculating the power of a given number, and the key insight is to use recursion and divide the problem into smaller sub-problems. The main challenge is handling negative exponents and large numbers."
    },
    {
      "approaches": [
        {
          "approach": "For each possible move, calculate the score of the current player and the opponent after the move, and then recursively determine the optimal move for the opponent.",
          "code": "\nfunc PredictTheWinner(_ nums: [Int]) -> Bool {\n    func recursivePredictTheWinner(_ nums: [Int], _ start: Int, _ end: Int) -> Int {\n        if start == end {\n            return nums[start]\n        }\n        let leftScore = nums[start] - recursivePredictTheWinner(nums, start + 1, end)\n        let rightScore = nums[end] - recursivePredictTheWinner(nums, start, end - 1)\n        return max(leftScore, rightScore)\n    }\n    return recursivePredictTheWinner(nums, 0, nums.count - 1) >= 0\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is linear because of the recursive call stack.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential because the recursive function can potentially explore all possible combinations of moves."
          },
          "explanation": "The approach uses a recursive function to calculate the score difference between the current player and the opponent after each possible move. The function returns true if the current player can win, false otherwise.",
          "id": "c7f8e24d-fda6-4c04-b568-828ce0cf1fee",
          "intuition": "This approach tries all possible combinations of moves to determine the optimal move for the current player.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The first player can choose the number 233 to get a sum of 233, which is larger than the sum of the remaining numbers.",
              "id": "26a089c1-155c-4acb-a2b7-9e21a81c442c",
              "input": "nums = [1, 5, 233, 7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The first player cannot get a sum of numbers larger than the second player, regardless of the moves chosen.",
              "id": "c1b5a3b8-88ed-47f3-8a93-804c6688ca55",
              "input": "nums = [1, 5, 2]"
            }
          ]
        },
        {
          "approach": "Create a 2D memoization table to store the optimal scores for subproblems, and then fill the table using dynamic programming.",
          "code": "\nfunc PredictTheWinner(_ nums: [Int]) -> Bool {\n    let n = nums.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in stride(from: n - 1, through: 0, by: -1) {\n        dp[i][i] = nums[i]\n        for j in stride(from: i + 1, through: n - 1, by: 1) {\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n        }\n    }\n    return dp[0][n - 1] >= 0\n}\n",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is quadratic because of the memoization table.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is quadratic because the approach fills the memoization table using two nested loops."
          },
          "explanation": "The approach uses a 2D memoization table dp where dp[i][j] represents the optimal score difference between the current player and the opponent for the subproblem involving numbers from index i to j.",
          "id": "e77d5df4-d607-4080-88d7-26d1daa8bb4f",
          "intuition": "This approach uses a memoization table to store the optimal scores for subproblems, reducing the time complexity from exponential to quadratic.",
          "name": "Dynamic Programming Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The first player can choose the number 233 to get a sum of 233, which is larger than the sum of the remaining numbers.",
              "id": "2cde9443-1c3b-4db0-a301-19d041eb0ec9",
              "input": "nums = [1, 5, 233, 7]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The first player cannot get a sum of numbers larger than the second player, regardless of the moves chosen.",
              "id": "d9b401eb-e091-4609-ae2c-be3d27e5d012",
              "input": "nums = [1, 5, 2]"
            }
          ]
        }
      ],
      "id": "e4e42026-0f73-4830-8c26-ffd6c2b087d4",
      "lastUpdated": "2026-02-06T21:21:44Z",
      "problemSlug": "predict-the-winner",
      "relatedProblems": [
        "can-i-win",
        "can-i-win-infinite"
      ],
      "summary": "The problem requires predicting the winner of a game where two players take turns choosing numbers from an array, and the goal is to have the largest sum of numbers chosen. The key insight is to use dynamic programming to optimize the solution."
    },
    {
      "approaches": [
        {
          "approach": "1. Iterate over each number in the given range. 2. Convert the number to binary and count the number of set bits. 3. Check if the count of set bits is a prime number. 4. If the count is prime, increment the count.",
          "code": "func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let isPrime: (Int) -> Bool = { n in if n < 2 { return false } for i in 2...Int(sqrt(Double(n))) { if n % i == 0 { return false } } return true }; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if isPrime(setBits) { count += 1 } } return count }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are using a constant amount of space to store the count and other variables.",
            "time": "O(n * sqrt(m))",
            "timeExplanation": "The time complexity is O(n * sqrt(m)) where n is the range and m is the maximum number in the range. This is because for each number, we are counting the set bits and checking if the count is prime."
          },
          "explanation": "This approach is straightforward and involves checking each number in the range. However, it can be inefficient for large ranges due to its time complexity.",
          "id": "b496ba18-9d9b-4ac1-ae8f-9e0f9188f6c3",
          "intuition": "This approach works by iterating over each number in the given range, converting it to binary, counting the number of set bits, and checking if the count of set bits is a prime number.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The numbers in the range are 6, 7, 8, 9, 10. The binary representations are 110, 111, 1000, 1001, 1010. The number of set bits are 2, 3, 1, 2, 2. The prime counts are 2, 3, so the answer is 4.",
              "id": "b4de7fd9-20fa-43f5-b9ce-316c03a59dbc",
              "input": "L = 6, R = 10"
            },
            {
              "expectedOutput": "8",
              "explanation": "The numbers in the range are 10, 11, 12, 13, 14, 15. The binary representations are 1010, 1011, 1100, 1101, 1110, 1111. The number of set bits are 2, 3, 2, 3, 3, 4. The prime counts are 2, 3, so the answer is 8.",
              "id": "8d9742c8-2bef-4934-8459-172f94ad0bb3",
              "input": "L = 10, R = 15"
            }
          ]
        },
        {
          "approach": "1. Precompute the primes less than 32. 2. Create a hashmap to store the count of each prime. 3. Iterate over the range and for each number, count the number of set bits. 4. Check if the count is in the precomputed primes. 5. If the count is prime, increment the count in the hashmap.",
          "code": "func countPrimeSetBits(_ L: Int, _ R: Int) -> Int { let primes: [Int] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]; var count = 0; for num in L...R { let setBits = String(num, radix: 2).filter { $0 == \"1\" }.count; if primes.contains(setBits) { count += 1 } } return count }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are using a constant amount of space to store the count and the precomputed primes.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) where n is the range. This is because for each number, we are counting the set bits and checking if the count is prime."
          },
          "explanation": "This approach is more efficient than the brute force approach because it avoids the need to check if each count is prime. Instead, it precomputes the primes and uses a hashmap to store the count of each prime.",
          "id": "1057de3c-a40a-42c9-9938-daf3e42b2e18",
          "intuition": "This approach works by observing that the only prime numbers less than 32 (the maximum possible number of set bits for a 32-bit integer) are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31. We can precompute these primes and then use a hashmap to store the count of each prime.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The numbers in the range are 6, 7, 8, 9, 10. The binary representations are 110, 111, 1000, 1001, 1010. The number of set bits are 2, 3, 1, 2, 2. The prime counts are 2, 3, so the answer is 4.",
              "id": "c844a9e3-cbd1-418d-99ba-eae87f1ec07c",
              "input": "L = 6, R = 10"
            },
            {
              "expectedOutput": "8",
              "explanation": "The numbers in the range are 10, 11, 12, 13, 14, 15. The binary representations are 1010, 1011, 1100, 1101, 1110, 1111. The number of set bits are 2, 3, 2, 3, 3, 4. The prime counts are 2, 3, so the answer is 8.",
              "id": "ae01399c-6330-4c74-865e-b662a752a07f",
              "input": "L = 10, R = 15"
            }
          ]
        }
      ],
      "id": "4740a63b-b679-4bf4-baf5-0b2ea50e5304",
      "lastUpdated": "2026-02-06T21:38:37Z",
      "problemSlug": "prime-number-of-set-bits-in-binary-representation",
      "relatedProblems": [
        "prime-number-of-divisors",
        "count-prime-numbers"
      ],
      "summary": "This problem asks us to find the count of numbers with prime number of set bits in their binary representation within a given range. The key insight is to understand what constitutes a prime number and how to count the number of set bits in a binary representation."
    },
    {
      "approaches": [
        {
          "approach": "1. Define a helper function to check if a number is prime. 2. Define another helper function to check if a number is a palindrome. 3. Starting from the next number after the input, check each number with the helper functions until a number that is both prime and a palindrome is found.",
          "code": "\nfunc primePalindrome(_ n: Int) -> Int {\n    func isPrime(_ num: Int) -> Bool {\n        guard num > 1 else { return false }\n        let sqrtNum = Int(sqrt(Double(num)))\n        for i in 2...sqrtNum {\n            if num % i == 0 { return false }\n        }\n        return true\n    }\n\n    func isPalindrome(_ num: Int) -> Bool {\n        let strNum = String(num)\n        return strNum == String(strNum.reversed())\n    }\n\n    var num = n + 1\n    while !isPrime(num) || !isPalindrome(num) {\n        num += 1\n    }\n    return num\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant since we only use a fixed amount of space to store our current number and other variables, regardless of the input size.",
            "time": "O(n*sqrt(n))",
            "timeExplanation": "The time complexity comes from potentially checking all numbers greater than n (linear) and for each, checking divisibility up to its square root (hence the sqrt(n) factor)."
          },
          "explanation": "This solution uses two helper functions: one for checking primality and one for checking if a number is a palindrome. For each number greater than the input, it checks these properties until it finds a match.",
          "id": "c8baf9fd-a651-431e-8175-d3817e082aaa",
          "intuition": "This approach works by generating all numbers greater than the given number, checking each one for being both a palindrome and a prime, and stopping once such a number is found.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "101",
              "explanation": "101 is the smallest prime palindrome greater than 100.",
              "id": "49863849-449e-43a1-8816-b55f50154fbd",
              "input": "n = 100"
            },
            {
              "expectedOutput": "11",
              "explanation": "11 is the smallest prime palindrome greater than 8.",
              "id": "1986d8a6-b49c-47c7-a6a7-2ee14b5dce46",
              "input": "n = 8"
            }
          ]
        },
        {
          "approach": "1. Generate only potential palindromes by mirroring the first half of the number. 2. Skip numbers with leading zeros or those that aren't candidates based on digit patterns for potential palindromes. 3. Use a more efficient primality test.",
          "code": "\nfunc primePalindrome(_ n: Int) -> Int {\n    func isPrime(_ num: Int) -> Bool {\n        guard num > 1 else { return false }\n        let sqrtNum = Int(sqrt(Double(num)))\n        for i in 2...sqrtNum {\n            if num % i == 0 { return false }\n        }\n        return true\n    }\n\n    let strN = String(n)\n    let lenN = strN.count\n    \n    if lenN == 1 {\n        if n == 8 || n == 9 { return 11 }\n        else { return n + 1 }\n    }\n    \n    let halfLenN = lenN / 2\n    \n    var half = 1\n    while half <= n / (10 ^ halfLenN) {\n        var candidate = half * (10 ^ halfLenN) + half\n        if candidate > n && isPrime(candidate) {\n            return candidate\n        }\n        half += 1\n    }\n    \n    half = 10\n    while half <= n / (10 ^ halfLenN) {\n        var candidate = half * (10 ^ (halfLenN - 1)) + half / 10\n        if candidate > n && isPrime(candidate) {\n            return candidate\n        }\n        half += 1\n    }\n    \n    return -1\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Still constant because we only use a fixed amount of space, regardless of the input.",
            "time": "O(sqrt(n))",
            "timeExplanation": "This version is more efficient because it generates candidates in a smarter way and checks primality only when necessary."
          },
          "explanation": "This solution constructs potential palindromes directly by creating numbers with the first half mirrored to form the second half, thus significantly reducing the number of checks.",
          "id": "4741201a-c058-4041-a02d-b4f4c9e4200e",
          "intuition": "This approach generates only potential palindromes and checks them for primality, significantly reducing the number of candidates to check.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1009",
              "explanation": "1009 is the smallest prime palindrome greater than 1000.",
              "id": "2736759d-767e-46fc-84e2-1c84982f2799",
              "input": "n = 1000"
            },
            {
              "expectedOutput": "1331",
              "explanation": "1331 is the smallest prime palindrome greater than 1234.",
              "id": "dbeb049e-97bf-44ae-b6ca-52a953baf0f8",
              "input": "n = 1234"
            }
          ]
        }
      ],
      "id": "0cf92c89-7a3e-4f7a-b2e6-a85ac000c304",
      "lastUpdated": "2026-02-06T21:45:19Z",
      "problemSlug": "prime-palindrome",
      "relatedProblems": [
        "prime-palindrome-2",
        "is-prime"
      ],
      "summary": "The Prime Palindrome problem asks to find the smallest prime palindrome greater than a given number. The key insight is to understand how to check for primality and palindrome properties."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize the state of the cells. 2. Simulate the state transitions for N days.",
          "code": "\nimport Foundation\n\nfunc prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n    var cells = cells\n    for _ in 0..<n {\n        var nextCells = Array(repeating: 0, count: cells.count)\n        for i in 1..<cells.count-1 {\n            nextCells[i] = cells[i-1] == cells[i+1] ? 1 : 0\n        }\n        cells = nextCells\n    }\n    return cells\n}\n",
          "complexity": {
            "space": "O(cells)",
            "spaceExplanation": "The space complexity is O(cells) because we need to store the state of the cells.",
            "time": "O(N * cells)",
            "timeExplanation": "The time complexity is O(N * cells) because we simulate the state transitions for N days."
          },
          "explanation": "This approach is straightforward but may not be efficient for large inputs. It has a time complexity of O(N * cells), where cells is the number of cells.",
          "id": "89981df4-b7ee-4062-ada5-32eeb3e4e976",
          "intuition": "The brute force approach is to simulate the state transitions for N days. This will give us the final state of the cells.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0,0,1,1,0,0,0,0]",
              "explanation": "After 7 days, the cells are in the state [0,0,1,1,0,0,0,0].",
              "id": "f96093cd-7178-4027-bdbb-127c1d2aa316",
              "input": "cells = [0,1,0,1,1,0,0,1], n = 7"
            },
            {
              "expectedOutput": "[0,0,1,1,1,1,1,0]",
              "explanation": "After a large number of days, the cells are in a repeating cycle.",
              "id": "e622dcca-0330-4442-96a3-20d978f65585",
              "input": "cells = [1,0,0,1,0,0,1,0], n = 1000000000"
            }
          ]
        },
        {
          "approach": "1. Simulate the state transitions until we find a cycle. 2. Determine the final state of the cells by finding the remainder of N divided by the cycle length.",
          "code": "\nimport Foundation\n\nfunc prisonAfterNDays(_ cells: [Int], _ n: Int) -> [Int] {\n    var cells = cells\n    var seen: [String: Int] = [:]\n    for day in 0..<n {\n        let cellsStr = String(cells.map { String($0) }.joined())\n        if let prevDay = seen[cellsStr] {\n            let cycleLength = day - prevDay\n            let remainingDays = (n - day) % cycleLength\n            for _ in 0..<remainingDays {\n                var nextCells = Array(repeating: 0, count: cells.count)\n                for i in 1..<cells.count-1 {\n                    nextCells[i] = cells[i-1] == cells[i+1] ? 1 : 0\n                }\n                cells = nextCells\n            }\n            break\n        } else {\n            seen[cellsStr] = day\n            var nextCells = Array(repeating: 0, count: cells.count)\n            for i in 1..<cells.count-1 {\n                nextCells[i] = cells[i-1] == cells[i+1] ? 1 : 0\n            }\n            cells = nextCells\n        }\n    }\n    return cells\n}\n",
          "complexity": {
            "space": "O(cells)",
            "spaceExplanation": "The space complexity is O(cells) because we need to store the state of the cells.",
            "time": "O(cells * cycleLength)",
            "timeExplanation": "The time complexity is O(cells * cycleLength) because we simulate the state transitions for at most cycleLength days."
          },
          "explanation": "This approach is more efficient than the brute force approach because it avoids simulating the state transitions for the entire N days.",
          "id": "1edb1db5-a917-43dc-9c88-b02e8b3d1c9f",
          "intuition": "The optimized approach is to find a pattern or cycle in the state transitions. Once we find a cycle, we can determine the final state of the cells by finding the remainder of N divided by the cycle length.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0,0,1,1,0,0,0,0]",
              "explanation": "After 7 days, the cells are in the state [0,0,1,1,0,0,0,0].",
              "id": "f192c4c7-d1cc-4414-849e-4dc449e90262",
              "input": "cells = [0,1,0,1,1,0,0,1], n = 7"
            },
            {
              "expectedOutput": "[0,0,1,1,1,1,1,0]",
              "explanation": "After a large number of days, the cells are in a repeating cycle.",
              "id": "451a31d5-9b49-4a66-ba49-76c9a7b689af",
              "input": "cells = [1,0,0,1,0,0,1,0], n = 1000000000"
            }
          ]
        }
      ],
      "id": "1e7a26f9-cd60-4e10-a9f5-43123a657c05",
      "lastUpdated": "2026-02-06T21:51:22Z",
      "problemSlug": "prison-cells-after-n-days",
      "relatedProblems": [
        "maximum-xor-of-two-numbers-in-an-array",
        "find-all-duplicates-in-an-array"
      ],
      "summary": "The problem is to find the state of prison cells after N days, where the state of each cell is determined by the state of its neighbors. The key insight is to find a pattern or cycle in the state transitions."
    },
    {
      "approaches": [
        {
          "approach": "Initialize variables to store the projection areas from top, front, and side views. Iterate over each element in the grid, and for each non-zero element, increment the corresponding projection area.",
          "code": "func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; for row in grid { var rowMax = 0; for col in row { if col > 0 { top += 1 } rowMax = max(rowMax, col) } side += rowMax } for col in 0..<grid[0].count { var colMax = 0; for row in grid { colMax = max(colMax, grid[row][col]) } front += colMax } return top + front + side }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are using a constant amount of space to store the projection areas.",
            "time": "O(n*m)",
            "timeExplanation": "The time complexity is O(n*m) where n and m are the dimensions of the grid. This is because we are iterating over each element in the grid once."
          },
          "explanation": "The brute force approach works by iterating over each element in the grid and counting the number of non-zero elements. The time complexity is O(n*m) where n and m are the dimensions of the grid.",
          "id": "6d3b99fb-2dee-4060-9ef7-d3ac0d528a04",
          "intuition": "The brute force approach involves iterating over each element in the grid to calculate the projection areas from top, front, and side views.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "15",
              "explanation": "The top view has a projection area of 4, the front view has a projection area of 6, and the side view has a projection area of 5, so the total projection area is 15.",
              "id": "9aaf9068-8d42-4abb-8a22-774a7b43c72e",
              "input": "grid = [[1,2],[3,4]]"
            },
            {
              "expectedOutput": "8",
              "explanation": "The top view has a projection area of 2, the front view has a projection area of 3, and the side view has a projection area of 3, so the total projection area is 8.",
              "id": "4b87c3a2-9347-44e8-a813-d93e06424746",
              "input": "grid = [[1,0],[0,2]]"
            },
            {
              "expectedOutput": "21",
              "explanation": "The top view has a projection area of 9, the front view has a projection area of 6, and the side view has a projection area of 6, so the total projection area is 21.",
              "id": "cf889783-d66d-4ace-8d72-8988b480924c",
              "input": "grid = [[1,1,1],[1,1,1],[1,1,1]]"
            }
          ]
        },
        {
          "approach": "Initialize variables to store the projection areas from top, front, and side views. Initialize arrays to store the maximum values in each row and column. Iterate over each element in the grid and update the maximum values in the arrays. Calculate the projection areas using the arrays.",
          "code": "func projectionArea(_ grid: [[Int]]) -> Int { var top = 0; var front = 0; var side = 0; var rowMax: [Int] = Array(repeating: 0, count: grid.count); var colMax: [Int] = Array(repeating: 0, count: grid[0].count); for i in 0..<grid.count { for j in 0..<grid[0].count { if grid[i][j] > 0 { top += 1 } rowMax[i] = max(rowMax[i], grid[i][j]) colMax[j] = max(colMax[j], grid[i][j]) } } for i in rowMax { side += i } for i in colMax { front += i } return top + front + side }",
          "complexity": {
            "space": "O(n+m)",
            "spaceExplanation": "The space complexity is O(n+m) because we are using arrays of size n and m to store the maximum values in each row and column.",
            "time": "O(n*m)",
            "timeExplanation": "The time complexity is O(n*m) where n and m are the dimensions of the grid. This is because we are iterating over each element in the grid once."
          },
          "explanation": "The optimized approach works by using arrays to store the maximum values in each row and column to calculate the projection areas. The time complexity is O(n*m) where n and m are the dimensions of the grid.",
          "id": "9bb7ab64-e885-4f53-97ad-db21d7e9cbf0",
          "intuition": "The optimized approach involves using arrays to store the maximum values in each row and column to calculate the projection areas from top, front, and side views.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "15",
              "explanation": "The top view has a projection area of 4, the front view has a projection area of 6, and the side view has a projection area of 5, so the total projection area is 15.",
              "id": "ed0a3a9d-1ab9-4c61-a88d-e9f9c89c644a",
              "input": "grid = [[1,2],[3,4]]"
            },
            {
              "expectedOutput": "8",
              "explanation": "The top view has a projection area of 2, the front view has a projection area of 3, and the side view has a projection area of 3, so the total projection area is 8.",
              "id": "7a5da15b-03df-45a4-8ae0-7ee6f50a597e",
              "input": "grid = [[1,0],[0,2]]"
            },
            {
              "expectedOutput": "21",
              "explanation": "The top view has a projection area of 9, the front view has a projection area of 6, and the side view has a projection area of 6, so the total projection area is 21.",
              "id": "5a7b13e7-6f7e-483c-b663-ae5c48083293",
              "input": "grid = [[1,1,1],[1,1,1],[1,1,1]]"
            }
          ]
        }
      ],
      "id": "5a003cf9-84cb-4c2f-91a9-c74245940914",
      "lastUpdated": "2026-02-06T21:46:13Z",
      "problemSlug": "projection-area-of-3d-shapes",
      "relatedProblems": [
        "max-increase-to-fit-sliding-window",
        "unique-paths-iii"
      ],
      "summary": "This problem asks to find the projection area of a 3D shape. The key insight is to calculate the projection areas from top, front, and side views."
    },
    {
      "approaches": [
        {
          "approach": "Count the number of each type of rabbit using a hash table and store the counts in an array. Then, calculate the minimum number based on the counts.",
          "code": "func numRabbits(_ answers: [Int]) -> Int {\n    var counts: [Int: Int] = [:]\n    for answer in answers {\n        counts[answer, default: 0] += 1\n    }\n    var result = 0\n    for (answer, count) in counts {\n        result += ((count + answer) / (answer + 1)) * (answer + 1)\n    }\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we use a hash table to store the counts.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we iterate over the input array once."
          },
          "explanation": "This approach works by using a hash table to efficiently count the number of each type of rabbit. It then calculates the minimum number by dividing the count by the number of rabbits of that type plus one and rounding up.",
          "id": "f1e60b85-704b-4822-bf46-b5a1dd812644",
          "intuition": "This approach involves counting the number of each type of rabbit and then returning the minimum number based on the count.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "There are two groups of rabbits, one with 2 rabbits and one with 3 rabbits.",
              "id": "7d71f4dd-47cb-4913-8fcc-7934cf877448",
              "input": "answers = [1,1,2]"
            },
            {
              "expectedOutput": "11",
              "explanation": "There is one group of 11 rabbits.",
              "id": "cdb50756-ebbd-4736-b532-305163b30b0a",
              "input": "answers = [10,10,10]"
            }
          ]
        },
        {
          "approach": "Use a hash table to group the rabbits by their answer and store the counts in an array. Then, calculate the minimum number based on the group sizes.",
          "code": "func numRabbits(_ answers: [Int]) -> Int {\n    var counts: [Int: Int] = [:]\n    for answer in answers {\n        counts[answer, default: 0] += 1\n    }\n    var result = 0\n    for (answer, count) in counts {\n        result += (count + answer) / (answer + 1) * (answer + 1)\n    }\n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we use a hash table to store the counts.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we iterate over the input array once."
          },
          "explanation": "This approach works by using a hash table to efficiently group the rabbits by their answer. It then calculates the minimum number by dividing the count by the number of rabbits of that type plus one and rounding up.",
          "id": "1de8d96f-f5ee-4966-bbf2-719ea9345b48",
          "intuition": "This approach involves grouping the rabbits by their answer and then calculating the minimum number of rabbits based on the group sizes.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "There are two groups of rabbits, one with 2 rabbits and one with 3 rabbits.",
              "id": "9c5f3b09-b1f5-4f9e-bc9c-8317c220ba37",
              "input": "answers = [1,1,2]"
            },
            {
              "expectedOutput": "11",
              "explanation": "There is one group of 11 rabbits.",
              "id": "92f7102e-67ed-4116-acf4-131f9698c5d1",
              "input": "answers = [10,10,10]"
            }
          ]
        }
      ],
      "id": "870b3377-dec7-410a-867e-b506294601cd",
      "lastUpdated": "2026-02-06T21:39:15Z",
      "problemSlug": "rabbits-in-forest",
      "relatedProblems": [
        "single-number",
        "majority-element"
      ],
      "summary": "Given an array of integers representing the number of rabbits for each type, determine the minimum number of rabbits that could be in the forest. The key insight is to use a hash table to count the number of each type of rabbit."
    },
    {
      "approaches": [
        {
          "approach": "Create a class with a 2D boolean array to represent the matrix. When flip is called, randomly choose a cell, flip its value and update the array. Keep track of flipped cells to handle unflip.",
          "code": "\nclass RandomFlipMatrix {\n    let n: Int\n    var matrix: [[Bool]]\n    var flipped: [String]\n\n    init(_ n: Int) {\n        self.n = n\n        matrix = Array(repeating: Array(repeating: false, count: n), count: n)\n        flipped = []\n    }\n\n    func flip() -> [Int] {\n        var x = Int.random(in: 0..<n)\n        var y = Int.random(in: 0..<n)\n        while matrix[x][y] {\n            x = Int.random(in: 0..<n)\n            y = Int.random(in: 0..<n)\n        }\n        matrix[x][y] = true\n        flipped.append(\"(x)(y)\")\n        return [x, y]\n    }\n\n    func unflip(_ row: Int, _ col: Int) {\n        matrix[row][col] = false\n    }\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is O(n^2) because in the worst case, all cells may be flipped and stored.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because the flip operation involves random selection and updating of a cell."
          },
          "explanation": "This approach has an array of boolean values representing the matrix. When flip() is called, it randomly selects a cell, flips its value and updates the array. To unflip(), it uses the stored flipped cells information to reset their values.",
          "id": "b3a7f056-ec78-49bd-a531-2e725873fa30",
          "intuition": "This approach involves randomly selecting a cell, flipping its value and keeping track of all the flipped cells. It is a straightforward approach with no optimization.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[0, 0]",
              "explanation": "With n = 1, there's only one cell to flip, so it will always return [0, 0].",
              "id": "b16f8a12-c34e-4c56-b511-d532ab8fc9a8",
              "input": "n = 1"
            },
            {
              "expectedOutput": "[0, 0], [0, 1], [1, 0], [1, 1]",
              "explanation": "With n = 2, there are four possible cells to flip.",
              "id": "ac57128d-316a-4120-9cb6-1735fd6d4cc5",
              "input": "n = 2"
            }
          ]
        },
        {
          "approach": "Maintain a set of available cells and use it to select random cells to flip. This way, no unnecessary iterations are made to find an available cell.",
          "code": "\nclass RandomFlipMatrix {\n    let n: Int\n    var available: Set<String>\n\n    init(_ n: Int) {\n        self.n = n\n        available = Set()\n        for i in 0..<n {\n            for j in 0..<n {\n                available.insert(\"(i)(j)\")\n            }\n        }\n    }\n\n    func flip() -> [Int] {\n        let cell = Array(available)[Int.random(in: 0..<available.count)]\n        available.remove(cell)\n        return [Int(String(cell.prefix(1)) ?? \"0\"), Int(String(cell.suffix(1)) ?? \"0\")]\n    }\n\n    func unflip(_ row: Int, _ col: Int) {\n        available.insert(\"(row)(col)\"))\n    }\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "Space complexity is O(n^2) because we store all available cells in a set.",
            "time": "O(1)",
            "timeExplanation": "Time complexity is O(1) for both flip and unflip, as set operations are constant time."
          },
          "explanation": "Using a set for available cells allows for efficient checking of cell availability. When a cell is flipped, it's removed from the set. This makes flip operation O(1) because set operations are constant time.",
          "id": "b9d798c8-73f0-4331-bda6-dd712462b76a",
          "intuition": "To optimize, we can use a set to keep track of available cells and then use Fisher-Yates shuffle to randomly select from the set, thus efficiently handling flips.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[0, 0]",
              "explanation": "There's only one cell, so the output remains the same.",
              "id": "0732392c-aeec-4f3b-9b58-e43e95c8fa7b",
              "input": "n = 1"
            },
            {
              "expectedOutput": "[0, 0], [0, 1], [1, 0], [1, 1]",
              "explanation": "The output is a random order of the cells.",
              "id": "c11d2940-6691-454a-8648-ed33b34bfc22",
              "input": "n = 2"
            }
          ]
        }
      ],
      "id": "9380dfb3-bac3-4286-8d1e-007832a4a9ba",
      "lastUpdated": "2026-02-06T21:23:40Z",
      "problemSlug": "random-flip-matrix",
      "relatedProblems": [
        "random-pick-with-blacklist",
        "insert-delete-getrandom-o1"
      ],
      "summary": "The problem involves creating a class to generate random flips of a matrix, key insight being efficient handling of flipped cells. A random flip matrix is a class that can generate random flippings of a matrix, and it has methods to flip and unflip cells."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a data structure to store the input array. 2. For the pick operation, generate a random index within the bounds of the array and return the element at that index.",
          "code": "\nclass Solution {\n    var nums: [Int]\n    init(_ nums: [Int]) {\n        self.nums = nums\n    }\n    func pick(_ target: Int) -> Int {\n        var indices: [Int] = []\n        for (i, num) in nums.enumerated() {\n            if num == target {\n                indices.append(i)\n            }\n        }\n        let randomIndex = Int.random(in: 0..<indices.count)\n        return indices[randomIndex]\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we store the indices of all occurrences of the target in the array.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because in the worst case, we have to iterate through the entire array to find all occurrences of the target."
          },
          "explanation": "This approach is straightforward but may not be efficient for large arrays, especially if the pick operation is called frequently.",
          "id": "bce648bd-83da-4f69-8f10-002f62d297c3",
          "intuition": "This approach involves storing the input array in a data structure and directly accessing elements based on the index for the pick operation.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The function picks a random index from the indices [2,3,4] of the target element 3.",
              "id": "98e1c6f8-67cf-44a4-819e-56e5757e5d84",
              "input": "nums = [1,2,3,3,3], target = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "The function picks the only index 0 of the target element 1.",
              "id": "a66d20f4-9305-4f84-b8e4-1c129e9bf76a",
              "input": "nums = [1,2,3,3,3], target = 1"
            }
          ]
        },
        {
          "approach": "1. Initialize a reservoir with the first occurrence of the target. 2. Iterate through the array, and for each occurrence of the target, generate a random number between 1 and the current count of occurrences. 3. If the generated number is 1, replace the reservoir with the current occurrence.",
          "code": "\nclass Solution {\n    var nums: [Int]\n    init(_ nums: [Int]) {\n        self.nums = nums\n    }\n    func pick(_ target: Int) -> Int {\n        var reservoir: Int?\n        var count: Int = 0\n        for (i, num) in nums.enumerated() {\n            if num == target {\n                count += 1\n                if reservoir == nil || Int.random(in: 1...count) == 1 {\n                    reservoir = i\n                }\n            }\n        }\n        return reservoir!\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the reservoir and count.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we need to iterate through the array to find all occurrences of the target."
          },
          "explanation": "This approach ensures that each occurrence of the target has an equal probability of being selected.",
          "id": "e1014627-1666-4a84-875c-3221b068c80a",
          "intuition": "This approach involves using reservoir sampling to select a random index from all occurrences of the target element.",
          "name": "Reservoir Sampling",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The function picks a random index from the indices [2,3,4] of the target element 3.",
              "id": "5a99d900-9a87-4c76-a58c-732ac9a0e2f1",
              "input": "nums = [1,2,3,3,3], target = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "The function picks the only index 0 of the target element 1.",
              "id": "1310f0ad-116e-443d-9e68-6832cb9504cb",
              "input": "nums = [1,2,3,3,3], target = 1"
            }
          ]
        }
      ],
      "id": "ecc2a41b-541b-45f7-9020-517283c0e967",
      "lastUpdated": "2026-02-06T21:16:29Z",
      "problemSlug": "random-pick-index",
      "relatedProblems": [
        "find-k-distant-indexes-in-an-array",
        "array-partition-i"
      ],
      "summary": "The problem requires designing a data structure to support two operations: random pick and given an index, find the element at that index. The key insight is using hash maps and reservoir sampling to efficiently handle random pick operations."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a variable to store the cumulative sum of weights and set it to 0. 2. Iterate over each weight in the weights array, adding the current weight to the cumulative sum. 3. Generate a random number between 0 (inclusive) and the total sum of weights (exclusive). 4. Iterate over the weights array again to find the first index where the cumulative sum exceeds the generated random number.",
          "code": "class Solution {\n    var weights = [Int]()\n    var cumulativeSum = [Int]()\n    init(_ w: [Int]) {\n        weights = w\n        cumulativeSum = Array(repeating: 0, count: w.count)\n        var sum = 0\n        for i in 0..<w.count {\n            sum += w[i]\n            cumulativeSum[i] = sum\n        }\n    }\n    func pickIndex() -> Int {\n        let random = Int.random(in: 0..<cumulativeSum.last!)\n        for i in 0..<cumulativeSum.count {\n            if cumulativeSum[i] > random {\n                return i\n            }\n        }\n        return 0\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is also O(n) because we need to store the cumulative sum of weights in an additional array of size n.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) due to the two separate iterations over the weights array."
          },
          "explanation": "The brute force approach requires iterating over the weights array twice: once to calculate the cumulative sum and again to find the target index. This results in a linear time complexity.",
          "id": "bdd44569-99f0-406d-8326-9ab962d8ca00",
          "intuition": "This approach works by iterating over the input weights array, calculating the cumulative sum of weights, and then using a uniform random variable to determine which index to pick based on the weights.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "0 (with probability 1/4) or 1 (with probability 3/4)",
              "explanation": "Since the probability of picking the second index is three times higher than the first index, we expect the method to return 1 three times as often as 0.",
              "id": "60760077-4ea9-43e0-b170-d6c9ba4e3788",
              "input": "weights = [1, 3], pickIndex()"
            },
            {
              "expectedOutput": "0",
              "explanation": "In this case, there's only one index with a weight of 1, so the method should always return 0.",
              "id": "5b91db94-122f-4781-945d-c81455574f1c",
              "input": "weights = [1], pickIndex()"
            }
          ]
        },
        {
          "approach": "1. Initialize the weights array and calculate the prefix sum. 2. Generate a random number between 0 (inclusive) and the total sum of weights (exclusive). 3. Perform a binary search on the prefix sum array to find the first index where the cumulative sum exceeds the generated random number.",
          "code": "class Solution {\n    var weights = [Int]()\n    var cumulativeSum = [Int]()\n    init(_ w: [Int]) {\n        weights = w\n        cumulativeSum = Array(repeating: 0, count: w.count)\n        var sum = 0\n        for i in 0..<w.count {\n            sum += w[i]\n            cumulativeSum[i] = sum\n        }\n    }\n    func pickIndex() -> Int {\n        let random = Int.random(in: 0..<cumulativeSum.last!)\n        var left = 0\n        var right = cumulativeSum.count - 1\n        while left < right {\n            let mid = (left + right) / 2\n            if cumulativeSum[mid] < random {\n                left = mid + 1\n            }\n            else {\n                right = mid\n            }\n        }\n        return left\n    }\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity remains O(n) for storing the prefix sum array.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is O(log n) due to the binary search operation."
          },
          "explanation": "The optimized approach utilizes binary search to reduce the time complexity of finding the target index from linear to logarithmic.",
          "id": "e50b0f3e-193a-4201-8883-dcb6689ef859",
          "intuition": "The optimized approach works by using a binary search algorithm to find the target index within the prefix sum array in logarithmic time.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "0 (with probability 1/4) or 1 (with probability 3/4)",
              "explanation": "The optimized approach maintains the same probability distribution as the brute force approach but with improved efficiency.",
              "id": "8ead0092-f135-4e14-b6d8-fc06cb1e419a",
              "input": "weights = [1, 3], pickIndex()"
            },
            {
              "expectedOutput": "0 (with probability 1/10), 1 (with probability 2/10), 2 (with probability 3/10), or 3 (with probability 4/10)",
              "explanation": "The method should return each index with a probability proportional to its corresponding weight.",
              "id": "339af837-5b73-4b32-91f6-9fb59654aa12",
              "input": "weights = [1, 2, 3, 4], pickIndex()"
            }
          ]
        }
      ],
      "id": "4822169e-185d-46fd-a234-05e166e158b7",
      "lastUpdated": "2026-02-06T21:24:32Z",
      "problemSlug": "random-pick-with-weight",
      "relatedProblems": [
        "random-pick-with-blacklist",
        "random-pick-index"
      ],
      "summary": "This problem involves implementing a solution to randomly pick an index based on a given weight array, where the probability of picking each index is proportional to its corresponding weight. The key insight is to leverage the concept of prefix sums to efficiently find the target index within the given weight array."
    },
    {
      "approaches": [
        {
          "approach": "1. Enumerate all points in the grid defined by the rectangles. 2. For each point, check which rectangle it falls into. 3. Store all points that fall into each rectangle. 4. Randomly select a rectangle and then a point within that rectangle.",
          "code": "\nimport Foundation\n\nstruct Solution {\n    let rectangles: [[Int]]\n\n    func randomPoint() -> [Int] {\n        let rect = rectangles[Int.random(in: 0..<rectangles.count)]\n        let x = Int.random(in: rect[0]...rect[2])\n        let y = Int.random(in: rect[1]...rect[3])\n        return [x, y]\n    }\n\n    func randomPointBruteForce() -> [Int] {\n        var points: [[Int]: [Int]] = [:]\n\n        for rect in rectangles {\n            for x in rect[0]...rect[2] {\n                for y in rect[1]...rect[3] {\n                    if var existing = points[rect] {\n                        existing.append(contentsOf: [x, y])\n                        points[rect] = existing\n                    } else {\n                        points[rect] = [x, y]\n                    }\n                }\n            }\n        }\n\n        let rect = rectangles[Int.random(in: 0..<rectangles.count)]\n        let pointsInRect = points[rect]!\n        let randomIndex = Int.random(in: 0..<pointsInRect.count/2)\n        return [pointsInRect[randomIndex*2], pointsInRect[randomIndex*2+1]]\n    }\n}\n",
          "complexity": {
            "space": "O(n*m*p)",
            "spaceExplanation": "We store all points in our data structure",
            "time": "O(n*m*p)",
            "timeExplanation": "We iterate through all points in the grid to populate our data structure"
          },
          "explanation": "The brute force approach is simple and easy to implement but it is inefficient for large rectangles or a large grid. The time complexity is O(n*m*p) where n is the number of rectangles, m is the maximum width and p is the maximum height.",
          "id": "4e0bd42c-c2b8-4df4-b245-d02310dc88fb",
          "intuition": "Directly generating points and checking which rectangle they fall into, this approach is straightforward but inefficient for many rectangles",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3, 3]",
              "explanation": "Randomly selects a rectangle and a point within that rectangle",
              "id": "3c7f4c09-f7cc-4945-8458-282f0b0c97bb",
              "input": "rectangles = [[1,1,5,5],[6,3,10,7],[1,8,9,10]]"
            },
            {
              "expectedOutput": "[1, 1]",
              "explanation": "Randomly selects a rectangle and a point within that rectangle",
              "id": "791442c2-7bea-42e1-ac9b-5820f619ac2f",
              "input": "rectangles = [[0,0,4,3]]"
            }
          ]
        },
        {
          "approach": "1. Calculate the area of each rectangle. 2. Create a probability distribution for the areas of the rectangles. 3. Use the probability distribution to select a rectangle. 4. Uniformly sample a point within the selected rectangle.",
          "code": "\nimport Foundation\n\nstruct Solution {\n    let rectangles: [[Int]]\n    let areas: [Int]\n    let prefixSums: [Int]\n\n    init(_ rectangles: [[Int]]) {\n        self.rectangles = rectangles\n        var areas: [Int] = []\n        var prefixSums: [Int] = [0]\n\n        for rect in rectangles {\n            areas.append((rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1))\n        }\n\n        for area in areas {\n            prefixSums.append(prefixSums.last! + area)\n        }\n\n        self.areas = areas\n        self.prefixSums = prefixSums\n    }\n\n    func randomPoint() -> [Int] {\n        let target = Int.random(in: 1...prefixSums.last!)\n        var left = 0\n        var right = prefixSums.count - 1\n\n        while left < right {\n            let mid = (left + right) / 2\n            if prefixSums[mid] < target {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n\n        let rect = rectangles[left - 1]\n        let x = Int.random(in: rect[0]...rect[2])\n        let y = Int.random(in: rect[1]...rect[3])\n        return [x, y]\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We store the areas and prefix sums of the areas",
            "time": "O(n + log(n))",
            "timeExplanation": "We calculate the areas of all rectangles, then use binary search to find the selected rectangle"
          },
          "explanation": "This approach is much more efficient than the brute force approach because we are only calculating the areas of the rectangles, then using those areas to select a rectangle, rather than iterating through all points in the grid",
          "id": "dcf267cf-28ed-416d-a78e-6a2f80808564",
          "intuition": "Since we know the rectangle areas, we can use a probability distribution for the areas to find which rectangle to select, then uniformly sample a point within the selected rectangle",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[3, 3]",
              "explanation": "Randomly selects a rectangle and a point within that rectangle",
              "id": "cb767d51-dfba-4f00-aabc-1bd81b2cc924",
              "input": "rectangles = [[1,1,5,5],[6,3,10,7],[1,8,9,10]]"
            },
            {
              "expectedOutput": "[1, 1]",
              "explanation": "Randomly selects a rectangle and a point within that rectangle",
              "id": "da9dc983-1871-4bce-9afa-d9af476297e2",
              "input": "rectangles = [[0,0,4,3]]"
            }
          ]
        }
      ],
      "id": "c073ce97-0f2e-46d8-a276-60bf90558362",
      "lastUpdated": "2026-02-06T21:22:17Z",
      "problemSlug": "random-point-in-non-overlapping-rectangles",
      "relatedProblems": [
        "random-point-in-non-overlapping-line-segments",
        "find-k-pairs-with-largest-sums"
      ],
      "summary": "Generate a random point in a non-overlapping rectangle, key insight is to use a probability distribution for rectangle area and binary search to find the corresponding rectangle, then uniformly sample a point inside the rectangle."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a 2D array to represent the grid, initially all cells are not colored. 2. For each operation, iterate through all cells and color the cells according to the operation. 3. Count the total number of colored cells.",
          "code": "func maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int {\n    var grid = Array(repeating: Array(repeating: false, count: n), count: m)\n    for op in ops {\n        for i in op[0]...m-1 {\n            for j in op[1]...n-1 {\n                grid[i][j] = true\n            }\n        }\n    }\n    let rows = grid.map {\n        $0.filter {\n            $0\n        }\n        .count\n    }\n    let min_rows = rows.min() ?? 0\n    let cols = (0..<n).map {\n        col in (0..<m).map {\n            grid[$0][$1]\n        }\n        .filter {\n            $0\n        }\n        .count\n    }\n    let min_cols = cols.min() ?? 0\n    return min_rows * min_cols\n}",
          "complexity": {
            "space": "O(m * n)",
            "spaceExplanation": "The space complexity is also linear with respect to the input size, as we need to store the grid and the operations.",
            "time": "O(m * n * ops)",
            "timeExplanation": "The time complexity is linear with respect to the input size, where m and n are the dimensions of the grid and ops is the number of operations."
          },
          "explanation": "This approach tries all possible operations and counts the colored cells, resulting in an exhaustive search. It works but is inefficient for large inputs.",
          "id": "f6e5569a-1409-4af6-ac98-7d116845f609",
          "intuition": "This approach works by trying all possible operations and counting the colored cells.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "After performing the operations, cells (0,0), (0,1), (1,0), and (1,1) are colored.",
              "id": "0ad102cc-5448-4595-8cdd-66da4f0ff57a",
              "input": "m = 3, n = 3, ops = [[2,2],[3,3]]"
            },
            {
              "expectedOutput": "4",
              "explanation": "After performing the operations, cells (0,0), (0,1), (1,0), and (1,1) are colored.",
              "id": "693f099c-0dc9-4b54-91f7-7848e7bdf64a",
              "input": "m = 3, n = 3, ops = [[2,2],[3,3],[4,4],[5,5]]"
            }
          ]
        },
        {
          "approach": "1. Initialize minimum row and column indices to the maximum possible values. 2. Iterate through each operation and update the minimum row and column indices if necessary. 3. Calculate the maximum number of colored cells by multiplying the minimum row and column indices.",
          "code": "func maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int {\n    var min_row = m\n    var min_col = n\n    for op in ops {\n        min_row = min(min_row, op[0])\n        min_col = min(min_col, op[1])\n    }\n    return min_row * min_col\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant, as we only need a few variables to store the minimum row and column indices.",
            "time": "O(ops)",
            "timeExplanation": "The time complexity is linear with respect to the number of operations."
          },
          "explanation": "This approach is more efficient as it only needs to iterate through the operations once and does not need to create the grid.",
          "id": "d02c59d7-188e-4d34-82ab-67e8d18c2b97",
          "intuition": "This approach works by finding the minimum row and column indices of all operations, which will give the maximum overlap between the operations.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The minimum row index is 2 and the minimum column index is 2, so the maximum number of colored cells is 2 * 2 = 4.",
              "id": "526bf274-41d8-4a4e-9860-9e962cd6ffd0",
              "input": "m = 3, n = 3, ops = [[2,2],[3,3]]"
            },
            {
              "expectedOutput": "4",
              "explanation": "The minimum row index is 2 and the minimum column index is 2, so the maximum number of colored cells is 2 * 2 = 4.",
              "id": "5096ec70-deea-4032-afc2-dc49a06b1eed",
              "input": "m = 3, n = 3, ops = [[2,2],[3,3],[4,4],[5,5]]"
            }
          ]
        }
      ],
      "id": "5faa517f-26c6-4ffc-9289-ad155d0cace8",
      "lastUpdated": "2026-02-06T21:28:05Z",
      "problemSlug": "range-addition-ii",
      "relatedProblems": [
        "max-increase-to-fit",
        "check-if-it-is-a-straight-line"
      ],
      "summary": "The problem asks for the maximum number of cells that can be colored in a grid of size m x n after performing a certain operation, and the key insight is to find the maximum overlap between the given operations."
    },
    {
      "approaches": [
        {
          "approach": "The algorithm starts at 0 and at each step, it tries moving in both the positive and negative directions. It keeps track of the minimum number of steps required to reach the target.",
          "code": "func reachNumber(target: Int) -> Int {\n    var step = 0\n    var sum = 0\n    while sum < abs(target) {\n        step += 1\n        sum += step\n    }\n    while (sum - abs(target)) % 2 != 0 {\n        step += 1\n        sum += step\n    }\n    return step\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the minimum number of steps.",
            "time": "O(2^n)",
            "timeExplanation": "The time complexity is exponential due to trying all possible combinations of steps."
          },
          "explanation": "This approach works by exploring all possible paths to the target number. However, it's inefficient due to its exponential time complexity.",
          "id": "6a7e7a6e-6829-403d-b2f9-bc36e08bff23",
          "intuition": "This approach involves trying all possible combinations of steps to reach the target number and keeping track of the minimum number of steps required.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The minimum number of steps to reach 2 is 3, where the steps are 1, -1, and 2.",
              "id": "b152613b-fc35-4dcc-b00d-3ee13e1b57c7",
              "input": "target = 2"
            },
            {
              "expectedOutput": "2",
              "explanation": "The minimum number of steps to reach 3 is 2, where the steps are 1 and 2.",
              "id": "57250307-e254-4d0b-82c9-c09dd5116bf6",
              "input": "target = 3"
            }
          ]
        },
        {
          "approach": "The algorithm uses the fact that the sum of consecutive integers from 1 to n is n*(n+1)/2. It calculates the minimum number of steps required to exceed the target number and then adjusts the steps to reach the target.",
          "code": "func reachNumber(target: Int) -> Int {\n    let target = abs(target)\n    var step = 0\n    var sum = 0\n    while sum < target {\n        step += 1\n        sum += step\n    }\n    while (sum - target) % 2 != 0 {\n        step += 1\n        sum += step\n    }\n    return step\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because we only use a fixed amount of space to store the minimum number of steps.",
            "time": "O(sqrt(n))",
            "timeExplanation": "The time complexity is approximately square root of n due to the use of the mathematical properties."
          },
          "explanation": "This approach works by recognizing that the sum of consecutive integers can be used to find the minimum number of steps. It's more efficient than the brute-force approach because it uses mathematical properties to find the solution.",
          "id": "f89024f2-f255-429f-97a7-7ab54b5d1636",
          "intuition": "This approach involves using mathematical properties to find the minimum number of steps to reach the target number.",
          "name": "Mathematical Optimization",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "The minimum number of steps to reach 5 is 5, where the steps are 1, 2, 3, 4, and 5.",
              "id": "812f7a94-fe9d-4dfa-ad24-d656b6020a04",
              "input": "target = 5"
            },
            {
              "expectedOutput": "3",
              "explanation": "The minimum number of steps to reach 6 is 3, where the steps are 1, 2, and 3.",
              "id": "d64038f2-bb08-4545-a879-d3122bf99c73",
              "input": "target = 6"
            }
          ]
        }
      ],
      "id": "025bd454-dd3f-43f3-be7d-368de2cf90bf",
      "lastUpdated": "2026-02-06T21:38:27Z",
      "problemSlug": "reach-a-number",
      "relatedProblems": [
        "minimum-moves-to-equal-array-elements",
        "maximum-sum-array-after-k-negations"
      ],
      "summary": "The Reach a Number problem requires finding the minimum number of steps to reach a target number starting from 0, where each step can be either positive or negative. The key insight here is to recognize that this problem can be solved by considering the properties of the sum of consecutive integers."
    },
    {
      "approaches": [
        {
          "approach": "Generate all permutations of numbers from 0 to 9, convert each permutation into its English representation, and compare it with the given string. If a match is found, return the original digits.",
          "code": "import Foundation\n\nclass Solution {\n    let digitToWord: [String: String] = [\"0\": \"zero\", \"1\": \"one\", \"2\": \"two\", \"3\": \"three\", \"4\": \"four\", \"5\": \"five\", \"6\": \"six\", \"7\": \"seven\", \"8\": \"eight\", \"9\": \"nine\"]\n    \n    func originalDigits(_ s: String) -> String {\n        var count: [Character: Int] = [:]\n        for char in s {\n            if let value = count[char] {\n                count[char] = value + 1\n            } else {\n                count[char] = 1\n            }\n        }\n        \n        var result: [Character] = []\n        \n        if let w = count[\"z\"] {\n            result.append(contentsOf: Array(repeating: \"0\", count: w))\n        }\n        if let w = count[\"w\"] {\n            result.append(contentsOf: Array(repeating: \"2\", count: w))\n        }\n        if let w = count[\"u\"] {\n            result.append(contentsOf: Array(repeating: \"4\", count: w))\n        }\n        if let w = count[\"x\"] {\n            result.append(contentsOf: Array(repeating: \"6\", count: w))\n        }\n        if let w = count[\"g\"] {\n            result.append(contentsOf: Array(repeating: \"8\", count: w))\n        }\n        if let w = count[\"o\"] {\n            var ones = count[\"o\"] ?? 0\n            if let z = count[\"z\"] {\n                ones -= z\n            }\n            if let w = count[\"w\"] {\n                ones -= w\n            }\n            result.append(contentsOf: Array(repeating: \"1\", count: ones))\n        }\n        if let w = count[\"h\"] {\n            var threes = count[\"h\"] ?? 0\n            if let w = count[\"w\"] {\n                threes -= w\n            }\n            result.append(contentsOf: Array(repeating: \"3\", count: threes))\n        }\n        if let w = count[\"f\"] {\n            var fives = count[\"f\"] ?? 0\n            if let w = count[\"f\"] {\n                fives -= (count[\"f\"] ?? 0)\n            }\n            result.append(contentsOf: Array(repeating: \"5\", count: fives))\n        }\n        if let w = count[\"s\"] {\n            var sevens = count[\"s\"] ?? 0\n            if let x = count[\"x\"] {\n                sevens -= x\n            }\n            result.append(contentsOf: Array(repeating: \"7\", count: sevens))\n        }\n        if let w = count[\"v\"] {\n            result.append(contentsOf: Array(repeating: \"5\", count: w))\n        }\n        if let w = count[\"i\"] {\n            var nines = count[\"i\"] ?? 0\n            if let w = count[\"s\"] {\n                nines -= w\n            }\n            if let x = count[\"x\"] {\n                nines -= x\n            }\n            result.append(contentsOf: Array(repeating: \"9\", count: nines))\n        }\n        return String(result.sorted())\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we use a fixed amount of space to store the frequency of each character in the string.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because the number of digits and their English representations are fixed."
          },
          "explanation": "This approach involves generating all possible combinations of digits and comparing their English representations with the given string. It is not efficient but guarantees finding a solution if one exists.",
          "id": "6fbf04d3-8453-490a-9c6a-e2fb52246b40",
          "intuition": "We can try all possible combinations of digits and check if their English representation matches the given string. This approach works because it considers all possibilities.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "\"012\"\n",
              "explanation": "The English representation 'zero' can only be formed by the digit '0'. 'two', 'one' can be formed by digits '2' and '1'. Hence the output is '012'.",
              "id": "326cf903-a072-4cbb-a97b-5eb2dd67801b",
              "input": "s = \"owoztneoer\"\n"
            },
            {
              "expectedOutput": "\"45\"\n",
              "explanation": "The English representation 'five' can only be formed by the digit '5'. 'four' can be formed by the digit '4'. Hence the output is '45'.",
              "id": "9944677c-6820-4b91-b5a1-cbbb1a9056fe",
              "input": "s = \"fviefuro\"\n"
            }
          ]
        },
        {
          "approach": "Create a frequency count of each character in the given string. Then, start with the unique letters and their corresponding digits, and decrease the frequency count accordingly.",
          "code": "import Foundation\n\nclass Solution {\n    let digitToWord: [String: String] = [\"0\": \"zero\", \"1\": \"one\", \"2\": \"two\", \"3\": \"three\", \"4\": \"four\", \"5\": \"five\", \"6\": \"six\", \"7\": \"seven\", \"8\": \"eight\", \"9\": \"nine\"]\n    let wordToDigit: [String: String] = [\"zero\": \"0\", \"one\": \"1\", \"two\": \"2\", \"three\": \"3\", \"four\": \"4\", \"five\": \"5\", \"six\": \"6\", \"seven\": \"7\", \"eight\": \"8\", \"nine\": \"9\"]\n    \n    func originalDigits(_ s: String) -> String {\n        var count: [Character: Int] = [:]\n        for char in s {\n            if let value = count[char] {\n                count[char] = value + 1\n            } else {\n                count[char] = 1\n            }\n        }\n        \n        var result: [Character] = []\n        \n        if let w = count[\"z\"] {\n            result.append(contentsOf: Array(repeating: \"0\", count: w))\n            count[\"e\"] = count[\"e\"]! - w\n            count[\"r\"] = count[\"r\"]! - w\n            count[\"o\"] = count[\"o\"]! - w\n        }\n        if let w = count[\"w\"] {\n            result.append(contentsOf: Array(repeating: \"2\", count: w))\n            count[\"t\"] = count[\"t\"]! - w\n            count[\"w\"] = count[\"w\"]! - w\n            count[\"o\"] = count[\"o\"]! - w\n        }\n        if let w = count[\"u\"] {\n            result.append(contentsOf: Array(repeating: \"4\", count: w))\n            count[\"f\"] = count[\"f\"]! - w\n            count[\"o\"] = count[\"o\"]! - w\n            count[\"u\"] = count[\"u\"]! - w\n            count[\"r\"] = count[\"r\"]! - w\n        }\n        if let w = count[\"x\"] {\n            result.append(contentsOf: Array(repeating: \"6\", count: w))\n            count[\"s\"] = count[\"s\"]! - w\n            count[\"i\"] = count[\"i\"]! - w\n            count[\"x\"] = count[\"x\"]! - w\n        }\n        if let w = count[\"g\"] {\n            result.append(contentsOf: Array(repeating: \"8\", count: w))\n            count[\"e\"] = count[\"e\"]! - w\n            count[\"i\"] = count[\"i\"]! - w\n            count[\"g\"] = count[\"g\"]! - w\n            count[\"h\"] = count[\"h\"]! - w\n            count[\"t\"] = count[\"t\"]! - w\n        }\n        if let w = count[\"o\"] {\n            var ones = count[\"o\"] ?? 0\n            if let z = count[\"z\"] {\n                ones -= z\n            }\n            if let w = count[\"w\"] {\n                ones -= w\n            }\n            if let u = count[\"u\"] {\n                ones -= u\n            }\n            if let g = count[\"g\"] {\n                ones -= g\n            }\n            result.append(contentsOf: Array(repeating: \"1\", count: ones))\n        }\n        if let w = count[\"h\"] {\n            var threes = count[\"h\"] ?? 0\n            if let w = count[\"w\"] {\n                threes -= w\n            }\n            if let g = count[\"g\"] {\n                threes -= g\n            }\n            result.append(contentsOf: Array(repeating: \"3\", count: threes))\n        }\n        if let w = count[\"f\"] {\n            var fives = count[\"f\"] ?? 0\n            if let u = count[\"u\"] {\n                fives -= u\n            }\n            result.append(contentsOf: Array(repeating: \"5\", count: fives))\n        }\n        if let w = count[\"s\"] {\n            var sevens = count[\"s\"] ?? 0\n            if let x = count[\"x\"] {\n                sevens -= x\n            }\n            result.append(contentsOf: Array(repeating: \"7\", count: sevens))\n        }\n        if let w = count[\"v\"] {\n            result.append(contentsOf: Array(repeating: \"5\", count: w))\n        }\n        if let w = count[\"i\"] {\n            var nines = count[\"i\"] ?? 0\n            if let s = count[\"s\"] {\n                nines -= s\n            }\n            if let x = count[\"x\"] {\n                nines -= x\n            }\n            if let g = count[\"g\"] {\n                nines -= g\n            }\n            result.append(contentsOf: Array(repeating: \"9\", count: nines))\n        }\n        return String(result.sorted())\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we use a fixed amount of space to store the frequency of each character in the string.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because the number of digits and their English representations are fixed."
          },
          "explanation": "This approach works by using the frequency count of each character to determine the number of times each digit appears in the string. It starts with the unique letters and their corresponding digits, and decreases the frequency count of the characters that make up these digits.",
          "id": "56153eac-73f1-4a57-a562-20c485687e57",
          "intuition": "Use the unique letters in each English representation to decode the digits. The unique letters are 'z', 'w', 'u', 'x', 'g', 'o', 'h', 'f', 's', 'v', 'i'.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "\"012\"\n",
              "explanation": "The English representation 'zero' can only be formed by the digit '0'. 'two', 'one' can be formed by digits '2' and '1'. Hence the output is '012'.",
              "id": "ad88917b-7060-4847-8540-620989ad623d",
              "input": "s = \"owoztneoer\"\n"
            },
            {
              "expectedOutput": "\"45\"\n",
              "explanation": "The English representation 'five' can only be formed by the digit '5'. 'four' can be formed by the digit '4'. Hence the output is '45'.",
              "id": "8775df33-2df6-416f-b917-30422ef78e42",
              "input": "s = \"fviefuro\"\n"
            }
          ]
        }
      ],
      "id": "48a8a587-576d-4aad-9bba-689971e4d606",
      "lastUpdated": "2026-02-06T21:17:50Z",
      "problemSlug": "reconstruct-original-digits-from-english",
      "relatedProblems": [
        "letter-combinations-of-a-phone-number",
        "roman-to-integer"
      ],
      "summary": "The goal is to reconstruct the original digits from their English representations. A key insight is to use the unique letters in each English representation to decode the digits."
    },
    {
      "approaches": [
        {
          "approach": "Create an array of all points within the rectangles, and then for each point, check if it lies within both rectangles. Sum the areas of all points that satisfy this condition.",
          "code": "func computeArea(_ A: Int, _ B: Int, _ C: Int, _ D: Int, _ E: Int, _ F: Int, _ G: Int, _ H: Int) -> Int { let x1 = max(A, E), x2 = min(C, G), y1 = max(B, F), y2 = min(D, H); let intersectionArea = max(0, x2-x1) * max(0, y2-y1); return (C-A)*(D-B) + (G-E)*(H-F) - intersectionArea; }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant as no additional space that scales with input size is used.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant because the number of operations is constant regardless of input size."
          },
          "explanation": "However, this method is inefficient and unnecessary for this problem because the area of intersection can be derived directly from rectangle coordinates, assuming rectangles are defined as in the LeetCode problem statement.",
          "id": "e4096add-a558-48e0-93c0-24707d773550",
          "intuition": "This approach works by checking every possible point within the given rectangles to see if it falls within the intersection. If a point is in the intersection, it contributes to the area.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "45",
              "explanation": "The total area of both rectangles minus the intersection area.",
              "id": "34392ebd-81e6-4ea2-af83-d3cc110819f7",
              "input": "A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2"
            },
            {
              "expectedOutput": "16",
              "explanation": "When two rectangles completely overlap, the area of intersection equals the area of the smaller rectangle.",
              "id": "b0a8f4d2-8bad-43d1-8663-50445b38904c",
              "input": "A = -2, B = -2, C = 2, D = 2, E = -2, F = -2, G = 2, H = 2"
            }
          ]
        },
        {
          "approach": "Determine the intersection rectangle's coordinates by comparing the given rectangles' coordinates, and then calculate the intersection area directly.",
          "code": "func computeArea(_ A: Int, _ B: Int, _ C: Int, _ D: Int, _ E: Int, _ F: Int, _ G: Int, _ H: Int) -> Int { let x1 = max(A, E), x2 = min(C, G), y1 = max(B, F), y2 = min(D, H); let intersectionArea = max(0, x2-x1) * max(0, y2-y1); return (C-A)*(D-B) + (G-E)*(H-F) - intersectionArea; }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is constant because no additional space that scales with input size is used.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is constant because the operations are constant and do not scale with input size."
          },
          "explanation": "This method is more efficient because it eliminates the need to check every point within the given rectangles, reducing computational complexity.",
          "id": "31b3a9c0-690f-4835-85b6-5436c32791b0",
          "intuition": "The optimized approach calculates the intersection area directly from rectangle coordinates, leveraging the geometric properties of rectangles.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "45",
              "explanation": "Rectangles do not completely overlap; intersection area is calculated and subtracted from total area.",
              "id": "de9931f9-fda6-4eba-99bf-6b7812f65521",
              "input": "A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2"
            },
            {
              "expectedOutput": "24",
              "explanation": "One rectangle is completely inside the other, but they do not overlap completely.",
              "id": "d5ba5fa3-72b0-4a00-971f-c33ec66ad2b6",
              "input": "A = -2, B = -2, C = 2, D = 2, E = -1, F = -1, G = 1, H = 1"
            }
          ]
        }
      ],
      "id": "ebc249df-3db2-4fbb-abf8-d7f6a40a0b7e",
      "lastUpdated": "2026-02-06T21:10:50Z",
      "problemSlug": "rectangle-area",
      "relatedProblems": [
        "rectangle-containment",
        "intersection-of-two-rectangles"
      ],
      "summary": "The problem asks for the area of the intersection between two rectangles. The key insight is to calculate the maximum and minimum coordinates to find the intersection rectangle and then calculate its area."
    },
    {
      "approaches": [
        {
          "approach": "Define the rectangles by their coordinates and then check the x and y conditions for no overlap.",
          "code": "func isRectangleOverlap(_ rec1: [Int], _ rec2: [Int]) -> Bool { let (x1, y1, x2, y2) = (rec1[0], rec1[1], rec1[2], rec1[3]); let (x3, y3, x4, y4) = (rec2[0], rec2[1], rec2[2], rec2[3]); return !(x2 <= x3 || x1 >= x4 || y2 <= y3 || y1 >= y4); }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space used by the algorithm is constant and does not grow with the input size.",
            "time": "O(1)",
            "timeExplanation": "The algorithm involves a constant number of operations regardless of the input size."
          },
          "explanation": "We define two rectangles with coordinates (x1, y1, x2, y2) and (x3, y3, x4, y4). We then check if the rectangles do not overlap by checking the conditions x2 < x3 or x1 > x4 for the x direction and y2 < y3 or y1 > y4 for the y direction. If neither condition is met in both directions, the rectangles overlap.",
          "id": "6b0381dd-6edf-4a08-8780-9c4936254342",
          "intuition": "We can determine if two rectangles do not overlap by checking if one rectangle's right side is to the left of the other rectangle's left side, or if one rectangle's left side is to the right of the other rectangle's right side, in the x direction. Similarly, we can check the y direction.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The rectangles overlap.",
              "id": "1ea1073e-b43f-48b7-907a-386361687ec9",
              "input": "rec1 = [0,0,2,2], rec2 = [1,1,3,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The rectangles do not overlap.",
              "id": "25d64a01-c0ff-4dba-b7b4-b0be0daf15ca",
              "input": "rec1 = [0,0,1,1], rec2 = [1,0,2,1]"
            }
          ]
        },
        {
          "approach": "Calculate the overlapping area in the x and y directions.",
          "code": "func isRectangleOverlap(_ rec1: [Int], _ rec2: [Int]) -> Bool { let (x1, y1, x2, y2) = (rec1[0], rec1[1], rec1[2], rec1[3]); let (x3, y3, x4, y4) = (rec2[0], rec2[1], rec2[2], rec2[3]); let width = max(0, min(x2, x4) - max(x1, x3)); let height = max(0, min(y2, y4) - max(y1, y3)); return width > 0 && height > 0; }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space used by the algorithm is constant and does not grow with the input size.",
            "time": "O(1)",
            "timeExplanation": "The algorithm involves a constant number of operations regardless of the input size."
          },
          "explanation": "The width of the overlapping area is the minimum of the right sides minus the maximum of the left sides. The height is the minimum of the top sides minus the maximum of the bottom sides. If both the width and height are positive, the rectangles overlap.",
          "id": "226df3b4-6722-4042-875a-5d72d16b48de",
          "intuition": "Instead of checking all the conditions, we can find the overlapping area by taking the maximum of the left sides and the minimum of the right sides in both the x and y directions. If the overlapping area has a positive width and height, the rectangles overlap.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The rectangles overlap.",
              "id": "d3a25637-66d8-42f6-8187-c8b731bff6e6",
              "input": "rec1 = [0,0,2,2], rec2 = [1,1,3,3]"
            },
            {
              "expectedOutput": "false",
              "explanation": "The rectangles do not overlap.",
              "id": "2f864151-80de-453a-992b-ffab6dfb9616",
              "input": "rec1 = [0,0,1,1], rec2 = [1,0,2,1]"
            }
          ]
        }
      ],
      "id": "13bcc7b2-bf1d-4743-b947-14573088bc6a",
      "lastUpdated": "2026-02-06T21:43:18Z",
      "problemSlug": "rectangle-overlap",
      "relatedProblems": [
        "intersection-of-two-arrays-ii",
        "valid-sudoku"
      ],
      "summary": "This problem determines if two rectangles overlap and the key insight is checking for no overlap in either the x or y direction. Two rectangles do not overlap if one rectangle is to the left of, to the right of, above, or below the other."
    },
    {
      "approaches": [
        {
          "approach": "Generate all permutations of the digits of N, and for each permutation, check if it forms a power of 2 by comparing it with powers of 2.",
          "code": "\nimport Foundation\nfunc reorderedPowerOf2(_ N: Int) -> Bool {\n    let numStr = String(N)\n    let sortedNumStr = String(numStr.sorted())\n    for i in 0...30 {\n        let powerOfTwo = 2 << i\n        let powerOfTwoStr = String(powerOfTwo)\n        let sortedPowerOfTwoStr = String(powerOfTwoStr.sorted())\n        if sortedPowerOfTwoStr == sortedNumStr {\n            return true\n        }\n    }\n    return false\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we are creating new sorted strings for each permutation.",
            "time": "O(n*log(n))",
            "timeExplanation": "The time complexity is O(n*log(n)) because the sorting operation takes O(n*log(n)) time for each permutation. However, the brute-force approach would have a time complexity of O(n!) due to generating all permutations."
          },
          "explanation": "This approach involves using a permutation generation algorithm to try all possible rearrangements of the digits of N, and then checking each one to see if it is a power of 2. If any permutation is a power of 2, we return True; otherwise, we return False.",
          "id": "e8c8b9ac-2e3f-428f-b398-bae86d9c7881",
          "intuition": "We can try all possible permutations of the digits of N and check if any of them form a power of 2.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The digits of 46 can be rearranged to form 64, which is a power of 2.",
              "id": "4ebf3f45-b804-4de3-8cc8-66a7f3550627",
              "input": "N = 46"
            },
            {
              "expectedOutput": "True",
              "explanation": "The digits of 1 form 1, which is a power of 2.",
              "id": "4e9b935b-e929-403d-a6c7-3485d648ab12",
              "input": "N = 1"
            },
            {
              "expectedOutput": "False",
              "explanation": "The digits of 10 cannot be rearranged to form a power of 2.",
              "id": "43480a20-1594-4539-9494-bb8e0c4d68a4",
              "input": "N = 10"
            }
          ]
        },
        {
          "approach": "Calculate the frequency of digits in N and compare it with the frequency of digits in powers of 2.",
          "code": "\nimport Foundation\nfunc reorderedPowerOf2(_ N: Int) -> Bool {\n    let numStr = String(N)\n    let count = numStr.reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n    for i in 0...30 {\n        let powerOfTwo = 2 << i\n        let powerOfTwoStr = String(powerOfTwo)\n        let powerOfTwoCount = powerOfTwoStr.reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n        if count == powerOfTwoCount {\n            return true\n        }\n    }\n    return false\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we are storing the frequency of digits in N and in each power of 2.",
            "time": "O(log(n))",
            "timeExplanation": "The time complexity is O(log(n)) because we are iterating over the powers of 2, and for each power of 2, we are calculating the frequency of its digits."
          },
          "explanation": "This approach involves calculating the frequency of digits in N and then comparing this frequency to the frequency of digits in powers of 2. If the frequencies match for any power of 2, we return True; otherwise, we return False.",
          "id": "913e75d2-3a07-4eb5-9485-89c02fd31694",
          "intuition": "We can compare the frequency of digits in N to the frequency of digits in powers of 2.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The digits of 46 can be rearranged to form 64, which is a power of 2.",
              "id": "4ae0610b-e61e-4ed6-b6eb-0db45efdf329",
              "input": "N = 46"
            },
            {
              "expectedOutput": "True",
              "explanation": "The digits of 1 form 1, which is a power of 2.",
              "id": "6ce8952b-2bd3-48c3-8576-98bc44536fa6",
              "input": "N = 1"
            },
            {
              "expectedOutput": "False",
              "explanation": "The digits of 10 cannot be rearranged to form a power of 2.",
              "id": "3080e727-93f1-41a8-9591-7a05af8b7350",
              "input": "N = 10"
            },
            {
              "expectedOutput": "True",
              "explanation": "The digits of 16 can be rearranged to form 61, which is not a power of 2, but 16 itself is a power of 2.",
              "id": "42951956-92e4-4952-9f0b-0ad0b2245440",
              "input": "N = 16"
            }
          ]
        }
      ],
      "id": "a4091298-8a00-4246-873b-f257a3bb76e6",
      "lastUpdated": "2026-02-06T21:45:32Z",
      "problemSlug": "reordered-power-of-2",
      "relatedProblems": [
        "valid-anagram",
        "check-if-one-string-swap-can-make-strings-equal"
      ],
      "summary": "This problem requires us to determine if we can rearrange the digits of a given integer N to form a power of 2. The key insight here is to compare the frequency of digits in N to the frequency of digits in powers of 2."
    },
    {
      "approaches": [
        {
          "approach": "1. Pop: digit = x % 10, x /= 10\n2. Check overflow before push\n3. Push: result = result * 10 + digit",
          "code": "func reverse(_ x: Int) -> Int {\n    var x = x, result = 0\n    while x != 0 {\n        let digit = x % 10\n        x /= 10\n        if result > Int32.max / 10 || result < Int32.min / 10 { return 0 }\n        result = result * 10 + digit\n    }\n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Constant",
            "time": "O(log x)",
            "timeExplanation": "Number of digits"
          },
          "explanation": "Check INT_MAX/10 before multiplying.",
          "id": "fe4f7f21-4ed4-4a8c-bfb6-f0f9a955f4e2",
          "intuition": "Pop digits from end, push to result.",
          "name": "Pop and Push",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "321",
              "explanation": "Reversed",
              "id": "5def84c1-3d10-4d3d-b45b-9d8510669ff1",
              "input": "x = 123"
            }
          ]
        }
      ],
      "id": "b4711f2b-b29a-4a62-bca0-b0e4fadefcb0",
      "lastUpdated": "2026-02-06T14:42:10Z",
      "problemSlug": "reverse-integer",
      "relatedProblems": [
        "string-to-integer-atoi"
      ],
      "summary": "Reverse digits of integer. Handle overflow by checking before multiplication."
    },
    {
      "approaches": [
        {
          "approach": "1. Create a map of Roman symbols to values\n2. Start from the rightmost character\n3. Track the previous value seen\n4. If current < previous, subtract; else add\n5. Update previous and continue left",
          "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    var result = 0\n    var prev = 0\n    \n    for char in s.reversed() {\n        let curr = values[char, default: 0]\n        if curr < prev {\n            result -= curr\n        } else {\n            result += curr\n        }\n        prev = curr\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Fixed-size map and a few variables",
            "time": "O(n)",
            "timeExplanation": "Single pass through the string of length n"
          },
          "explanation": "Roman numerals are mostly additive (VI = 5+1 = 6), but use subtraction for cases like IV (4) and IX (9). By scanning right to left, whenever we see a smaller value before a larger one, we know to subtract. This elegantly handles all subtraction cases.",
          "id": "70873fcb-4207-4214-97fd-8a61effb555a",
          "intuition": "Process from right to left, adding values. If current value is less than the previous value we added, subtract instead (handles IV, IX, etc.).",
          "name": "Right to Left Scan",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "III = 1 + 1 + 1 = 3",
              "id": "288ded23-f065-4af0-af7f-07fe355ef3ab",
              "input": "s = \"III\""
            },
            {
              "expectedOutput": "58",
              "explanation": "L = 50, V = 5, III = 3. Total = 58",
              "id": "89138bab-f104-4fb0-8b85-fc4ba1dde1c5",
              "input": "s = \"LVIII\""
            },
            {
              "expectedOutput": "1994",
              "explanation": "M=1000, CM=900, XC=90, IV=4. Total = 1994",
              "id": "22b5dbe2-5629-4e0d-9e26-7334cee2bca7",
              "input": "s = \"MCMXCIV\""
            }
          ]
        },
        {
          "approach": "1. Create value map\n2. Iterate through string with index\n3. If current value < next value, subtract current\n4. Otherwise add current\n5. Return total",
          "code": "func romanToInt(_ s: String) -> Int {\n    let values: [Character: Int] = [\n        \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50,\n        \"C\": 100, \"D\": 500, \"M\": 1000\n    ]\n    \n    let chars = Array(s)\n    var result = 0\n    \n    for i in 0..<chars.count {\n        let curr = values[chars[i], default: 0]\n        let next = i + 1 < chars.count ? values[chars[i + 1], default: 0] : 0\n        \n        if curr < next {\n            result -= curr\n        } else {\n            result += curr\n        }\n    }\n    \n    return result\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Converting string to array takes O(n) space",
            "time": "O(n)",
            "timeExplanation": "Single pass through the string"
          },
          "explanation": "This approach is more intuitive as it processes the string in reading order. We peek at the next character to decide whether to add or subtract. When we see 'I' followed by 'V', we know it's 4 (subtract 1), not 6 (add 1).",
          "id": "35093bc0-4fbf-426d-828b-66d998bdcc28",
          "intuition": "Process left to right. Look ahead to the next character - if current is less than next, subtract current; otherwise add it.",
          "name": "Left to Right with Lookahead",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "I(1) < V(5), so subtract 1, then add 5. Result: -1 + 5 = 4",
              "id": "4706b80f-4754-4a1c-948f-859b9892d237",
              "input": "s = \"IV\""
            },
            {
              "expectedOutput": "9",
              "explanation": "I(1) < X(10), so -1 + 10 = 9",
              "id": "e81ef371-d1be-42e9-8830-53dd669974d5",
              "input": "s = \"IX\""
            },
            {
              "expectedOutput": "42",
              "explanation": "X < L, so -10. L > I, so +50. I < I? No, +1. I, +1. Total: -10+50+1+1 = 42",
              "id": "5390fbf7-6ce0-4568-9520-13867563a55e",
              "input": "s = \"XLII\""
            }
          ]
        }
      ],
      "id": "3552812e-ed96-4ee4-8ba7-50d13af418de",
      "lastUpdated": "2026-02-06T08:24:18Z",
      "problemSlug": "roman-to-integer",
      "relatedProblems": [
        "integer-to-roman"
      ],
      "summary": "Convert a Roman numeral string to an integer. The key insight is that when a smaller value appears before a larger value, we subtract it; otherwise, we add it."
    },
    {
      "approaches": [
        {
          "approach": "Rotate the array by all possible values from 0 to n-1 and calculate the function value for each rotation.",
          "code": "func rotateFunction(_ nums: [Int]) -> Int {\n    let n = nums.count\n    var maxRotateFunction = 0\n    var totalSum = 0\n    var f = 0\n    for i in 0..<n {\n        totalSum += nums[i]\n        f += i * nums[i]\n    }\n    maxRotateFunction = max(maxRotateFunction, f)\n    for k in 1...n {\n        f = f + totalSum - n * nums[n - k]\n        maxRotateFunction = max(maxRotateFunction, f)\n    }\n    return maxRotateFunction\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because only a constant amount of space is used to store the variables.",
            "time": "O(n^2)",
            "timeExplanation": "The algorithm iterates through each possible rotation and calculates the function value for each rotation, which results in a time complexity of O(n^2)."
          },
          "explanation": "Iterate through each possible rotation, and for each rotation, calculate the function value by summing up the products of each element's index and its corresponding value in the rotated array.",
          "id": "9ba255b0-cc56-410c-9e4f-e4686bbfeabe",
          "intuition": "Try all possible rotations of the given array and calculate the function value for each rotation to find the maximum.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "136",
              "explanation": "The maximum rotation function value occurs when the array is rotated by 3 positions.",
              "id": "8074c870-77d4-4705-a29c-85c14baa141a",
              "input": "nums = [4,8,3,1,2,5,6,0,7,9]"
            },
            {
              "expectedOutput": "20",
              "explanation": "The maximum rotation function value occurs when the array is not rotated.",
              "id": "277e0dd7-c456-488c-8655-60ddb5723bba",
              "input": "nums = [1,2,3,4,5]"
            }
          ]
        },
        {
          "approach": "Initialize the function value for the original array and then update the function value for each rotation using the previous function value and the difference caused by the rotation.",
          "code": "func rotateFunction(_ nums: [Int]) -> Int {\n    let n = nums.count;\n    var sum = 0;\n    var rotateFunction = 0;\n    for i in 0..<n {\n        rotateFunction += i * nums[i];\n        sum += nums[i];\n    }\n    var maxRotateFunction = rotateFunction;\n    for k in 1...n-1 {\n        rotateFunction = rotateFunction - (n-1) * nums[n-k] + nums[n-k] * (n-1) - (sum - nums[n-k]);\n        maxRotateFunction = max(maxRotateFunction, rotateFunction);\n    }\n    return maxRotateFunction;\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because only a constant amount of space is used to store the variables.",
            "time": "O(n)",
            "timeExplanation": "The algorithm calculates the function value for each rotation in O(1) time using dynamic programming, resulting in a total time complexity of O(n)."
          },
          "explanation": "Calculate the initial function value for the original array, and then for each rotation, update the function value by subtracting the contribution of the last element and adding the contribution of the first element shifted to the end.",
          "id": "b317109e-cf76-4b7b-82e6-f62c894d9696",
          "intuition": "Use dynamic programming to calculate the function value for each rotation in O(n) time.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "136",
              "explanation": "The maximum rotation function value occurs when the array is rotated by 3 positions.",
              "id": "21c6e781-ba53-45e4-9000-578d716805f5",
              "input": "nums = [4,8,3,1,2,5,6,0,7,9]"
            },
            {
              "expectedOutput": "20",
              "explanation": "The maximum rotation function value occurs when the array is not rotated.",
              "id": "9501d2e5-76ea-4f0c-afbd-135a4be81da0",
              "input": "nums = [1,2,3,4,5]"
            }
          ]
        }
      ],
      "id": "23a251c2-d4a8-4d4a-b83a-a8a4419f6c50",
      "lastUpdated": "2026-02-06T21:16:18Z",
      "problemSlug": "rotate-function",
      "relatedProblems": [
        "minimum-moves-to-equal-array-elements",
        "array-partition-i"
      ],
      "summary": "Rotate Function is a problem about maximizing a function that results from rotating an array, and the key insight is to realize the relationship between the original array and its rotations. The problem can be solved using a brute-force approach or an optimized approach that utilizes dynamic programming to find the maximum rotation value."
    },
    {
      "approaches": [
        {
          "approach": "Step 1: Iterate over the range from X to Y. Step 2: For each number, convert it to a string and for each character in the string, check if it can be rotated. Step 3: If any character cannot be rotated, mark the number as bad.",
          "code": "\nfunc rotatedDigits(_ X: Int, _ Y: Int) -> Int {\n    var count = 0\n    for num in X...Y {\n        var canBeRotated = false\n        var cannotBeRotated = false\n        var strNum = String(num)\n        for char in strNum {\n            if char == \"3\" || char == \"4\" || char == \"7\" {\n                cannotBeRotated = true\n                break\n            } else if char == \"0\" || char == \"1\" || char == \"8\" {\n                continue\n            } else {\n                canBeRotated = true\n            }\n        }\n        if canBeRotated && !cannotBeRotated {\n            count += 1\n        }\n    }\n    return count\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because no additional space is used that scales with input size.",
            "time": "O(n * m)",
            "timeExplanation": "The time complexity is O(n * m) where n is the range and m is the average number of digits."
          },
          "explanation": "The brute force approach is straightforward but has a high time complexity due to the nested loop structure.",
          "id": "98e1f51b-e413-4e8f-845f-666d7d068b06",
          "intuition": "The brute force approach involves iterating over each number in the given range and checking if it is a good number by rotating its digits.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The good numbers are 12, 16, 18 and 19.",
              "id": "2e947953-8f32-48be-ba7d-794848825266",
              "input": "X = 10, Y = 20"
            },
            {
              "expectedOutput": "40",
              "explanation": "There are 40 good numbers between 100 and 200.",
              "id": "3150be5c-3c7a-4a8f-9572-2d1a7f30dea7",
              "input": "X = 100, Y = 200"
            }
          ]
        },
        {
          "approach": "Step 1: Create a HashSet of rotated digits. Step 2: Iterate over the range and check if each number is in the HashSet.",
          "code": "\nfunc rotatedDigits(_ X: Int, _ Y: Int) -> Int {\n    let rotatedDigits: [Character: Character] = [\n        \"0\": \"0\",\n        \"1\": \"1\",\n        \"8\": \"8\",\n        \"2\": \"5\",\n        \"5\": \"2\",\n        \"6\": \"9\",\n        \"9\": \"6\"\n    ]\n    var count = 0\n    for num in X...Y {\n        let strNum = String(num)\n        var canBeRotated = false\n        var cannotBeRotated = false\n        for char in strNum {\n            if let rotatedChar = rotatedDigits[char] {\n                if rotatedChar != char {\n                    canBeRotated = true\n                }\n            } else {\n                cannotBeRotated = true\n                break\n            }\n        }\n        if canBeRotated && !cannotBeRotated {\n            count += 1\n        }\n    }\n    return count\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because no additional space is used that scales with input size.",
            "time": "O(n * m)",
            "timeExplanation": "The time complexity is O(n * m) where n is the range and m is the average number of digits."
          },
          "explanation": "The optimized approach reduces the time complexity by avoiding the nested loop structure.",
          "id": "43fdbbda-0787-4614-aaf3-cb66d5012ef2",
          "intuition": "The optimized approach involves using a HashSet to store the rotated digits for quick lookup.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "4",
              "explanation": "The good numbers are 12, 16, 18 and 19.",
              "id": "c5054882-d05d-4268-b954-ed9b7d0ec292",
              "input": "X = 10, Y = 20"
            },
            {
              "expectedOutput": "40",
              "explanation": "There are 40 good numbers between 100 and 200.",
              "id": "e3857f95-d683-4dab-af47-6e8f9ffcfb20",
              "input": "X = 100, Y = 200"
            }
          ]
        }
      ],
      "id": "30726e08-4b22-4f54-8376-f3ece22cc73e",
      "lastUpdated": "2026-02-06T21:39:35Z",
      "problemSlug": "rotated-digits",
      "relatedProblems": [
        "reverse-integer",
        "roman-to-integer"
      ],
      "summary": "Rotated Digits problem requires counting the number of good integers in a given range and the key insight is to check each number for being good by rotating its digits."
    },
    {
      "approaches": [
        {
          "approach": "For each number, iterate through each digit and check if the number is divisible by that digit. If the number is not divisible by any digit, it's not a self-dividing number.",
          "code": "\nfunc selfDividingNumbers(_ left: Int, _ right: Int) -> [Int] {\n    var result: [Int] = []\n    for num in left...right {\n        var isSelfDividing = true\n        var numCopy = num\n        while numCopy > 0 {\n            let digit = numCopy % 10\n            if digit == 0 || num % digit != 0 {\n                isSelfDividing = false\n                break\n            }\n            numCopy /= 10\n        }\n        if isSelfDividing {\n            result.append(num)\n        }\n    }\n    return result\n}\n         ",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the current number and its copy.",
            "time": "O(n*m)",
            "timeExplanation": "We check each of n numbers in the range, and for each number, we might need up to m iterations to go through all its digits, where m is the maximum number of digits in any number in the range."
          },
          "explanation": "This approach involves checking every digit of every number in the given range, making it straightforward but potentially slow for large ranges.",
          "id": "01356887-f99c-49e5-aaae-85a4d986cfcb",
          "intuition": "We can check each number in the given range to see if it's self-dividing by going through each digit and checking if it divides the number evenly.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
              "explanation": "All numbers from 1 to 22 that are self-dividing are included in the output.",
              "id": "1222a9fc-17a8-4eab-8be8-45b920823d0e",
              "input": "left = 1, right = 22"
            },
            {
              "expectedOutput": "[48, 55, 66, 77]",
              "explanation": "Only numbers that are self-dividing are included in the output.",
              "id": "994ffd8b-cc3c-474d-a0ab-a655e228f5a3",
              "input": "left = 47, right = 85"
            }
          ]
        },
        {
          "approach": "For each number, iterate through each digit and check if the number is divisible by that digit. If we find a digit that doesn't divide the number evenly, we can stop checking the rest of the digits and move on to the next number.",
          "code": "\nfunc selfDividingNumbers(_ left: Int, _ right: Int) -> [Int] {\n    var result: [Int] = []\n    for num in left...right {\n        if isSelfDividing(num) {\n            result.append(num)\n        }\n    }\n    return result\n}\n\nfunc isSelfDividing(_ num: Int) -> Bool {\n    var numCopy = num\n    while numCopy > 0 {\n        let digit = numCopy % 10\n        if digit == 0 || num % digit != 0 {\n            return false\n        }\n        numCopy /= 10\n    }\n    return true\n}\n         ",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a constant amount of space to store the current number and its copy.",
            "time": "O(n*m)",
            "timeExplanation": "We check each of n numbers in the range, and for each number, we might need up to m iterations to go through all its digits, where m is the maximum number of digits in any number in the range."
          },
          "explanation": "This approach still involves checking every number in the range but optimizes the process by avoiding unnecessary checks within each number.",
          "id": "f16b6546-9923-4fdb-87d0-26798da1ec5a",
          "intuition": "We can slightly optimize the brute force approach by early-exiting from the loop checking the digits of a number as soon as we find a divisor that doesn't divide the number evenly.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
              "explanation": "All numbers from 1 to 22 that are self-dividing are included in the output.",
              "id": "41589fa4-2889-4974-bfc6-cad0ae7c27f4",
              "input": "left = 1, right = 22"
            },
            {
              "expectedOutput": "[48, 55, 66, 77]",
              "explanation": "Only numbers that are self-dividing are included in the output.",
              "id": "e40bc083-88e5-4c62-946d-95707c049184",
              "input": "left = 47, right = 85"
            }
          ]
        }
      ],
      "id": "4ba747a0-a418-4002-860e-9a8bfed24951",
      "lastUpdated": "2026-02-06T21:36:33Z",
      "problemSlug": "self-dividing-numbers",
      "relatedProblems": [
        "happy-number",
        "power-of-three"
      ],
      "summary": "A self-dividing number is a number that is divisible by every digit it contains, with no remainder. This problem asks us to find all numbers in a given range that are self-dividing."
    },
    {
      "approaches": [
        {
          "approach": "First, generate all permutations of the input array. Then, use a random number generator to select one of these permutations.",
          "code": "import Foundation\n\nclass Solution {\n    func shuffle(_ nums: [Int]) -> [Int] {\n        var perms = [[Int>>()\n        permute(nums, 0, &perms)\n        let idx = Int.random(in: 0..<perms.count)\n        return perms[idx]\n    }\n\n    func permute(_ nums: [Int], _ start: Int, _ perms: inout [[Int]]) {\n        if start == nums.count - 1 {\n            perms.append(nums)\n        } else {\n            for i in start..<nums.count {\n                var numsCopy = nums\n                numsCopy.swapAt(start, i)\n                permute(numsCopy, start + 1, &perms)\n            }\n        }\n    }\n}\n",
          "complexity": {
            "space": "O(n!)",
            "spaceExplanation": "Storing all permutations requires O(n!) space.",
            "time": "O(n!)",
            "timeExplanation": "Generating all permutations of the array takes O(n!) time."
          },
          "explanation": "The brute force approach is straightforward but inefficient for large arrays because generating all permutations has a time complexity of O(n!).",
          "id": "3e25c8d5-d892-4d47-9c46-a9d2eca82712",
          "intuition": "This approach involves generating all possible permutations of the array and then selecting one at random.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[3,1,2]",
              "explanation": "One possible shuffle of the input array [1,2,3]",
              "id": "14761164-0419-4ffb-ba8d-94144a76adbf",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "[2,1,1]",
              "explanation": "Another possible shuffle of the input array [1,1,2]",
              "id": "8627f6c5-acaa-4d0b-9747-ff0824779ec9",
              "input": "nums = [1,1,2]"
            }
          ]
        },
        {
          "approach": "Iterate through the array from the last element to the first, and for each element, swap it with another element chosen randomly from the unshuffled part of the array.",
          "code": "import Foundation\n\nclass Solution {\n    func shuffle(_ nums: [Int]) -> [Int] {\n        var numsCopy = nums\n        for i in stride(from: numsCopy.count - 1, to: 0, by: -1) {\n            let j = Int.random(in: 0...i)\n            numsCopy.swapAt(i, j)\n        }\n        return numsCopy\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "A copy of the input array is needed to perform the shuffle.",
            "time": "O(n)",
            "timeExplanation": "The algorithm makes one pass through the array, swapping elements as it goes."
          },
          "explanation": "The Fisher-Yates shuffle runs in linear time and is suitable for large arrays because it only needs to make one pass through the data.",
          "id": "3e4684a8-ec3a-4824-99ec-a337e16244b0",
          "intuition": "This approach uses a randomized algorithm to shuffle the array in place, ensuring all permutations are equally likely.",
          "name": "Fisher-Yates Shuffle",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[2,3,1]",
              "explanation": "One possible shuffle of the input array [1,2,3]",
              "id": "8a6f5e38-639a-44f8-9434-b9dc11dd1038",
              "input": "nums = [1,2,3]"
            },
            {
              "expectedOutput": "[2,1,1]",
              "explanation": "Another possible shuffle of the input array [1,1,2]",
              "id": "a4d42c5d-0e81-4a8a-8ff8-c18b7ffddb29",
              "input": "nums = [1,1,2]"
            }
          ]
        }
      ],
      "id": "aec3ba87-e5db-4670-aa58-7d248a966dcd",
      "lastUpdated": "2026-02-06T21:15:18Z",
      "problemSlug": "shuffle-an-array",
      "relatedProblems": [
        "array-partition-i",
        "sort-an-array"
      ],
      "summary": "The problem requires shuffling an array which involves rearranging its elements in a way that all permutations are equally likely. A key insight is to use a Fisher-Yates shuffle algorithm for an efficient and unbiased solution."
    },
    {
      "approaches": [
        {
          "approach": "1. Start with 1 and keep incrementing until we find a number divisible by k",
          "code": "func smallestRepunitDivisibleByK(k: Int) -> Int? { \nlet remainder = 0\nfor n in 1...k * 10 {\n    remainder = (remainder * 10 + 1) % k\n    if remainder == 0 {\n        return n\n    }\n}\nreturn nil\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space.",
            "time": "O(k*10)",
            "timeExplanation": "In the worst-case scenario, the loop needs to run k * 10 times."
          },
          "explanation": "This approach involves a simple loop to keep checking numbers until the condition is met",
          "id": "47f120c8-b64b-459e-b1f1-fb07fb5dd7bd",
          "intuition": "Keep generating numbers until we find one that is divisible by k",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "The smallest number divisible by 1 is 1",
              "id": "1f9fd8d6-9577-479b-805f-672a0ad610ea",
              "input": "k = 1"
            },
            {
              "expectedOutput": "11",
              "explanation": "The smallest number divisible by 2 is 11 because 1 + 1 = 11 and 11 % 2 == 1, but adding one more 1 to 11 results in 111 which is divisible by 3 but 111 % 2 == 1. Then if we continue adding a 1 we get 1111 which is divisible by 11 but not 2. Adding one more 1 gives us 11111 which is divisible by 41, but adding another gives us 111111 which is also divisible by 3 and 11, and 37 but also 111111 % 2 == 1.  Adding a 1 to 111111 gives 1111111 and indeed 1111111 % 2 == 1. Adding a 1 results in 11111111 which is divisible by 7, and 239 but also 11111111 % 2 == 1 so adding another 1 gives 111111111 which is divisible by 3 and 7, and 11, and 13 and 37, but 111111111 % 2 == 1, adding another 1 results in 1111111111 which is divisible by 239, but also 1111111111 % 2 == 1. Adding another 1 gives us 11111111111 which is indeed divisible by 2 because 11111111111 % 2 == 0.",
              "id": "b0832a0d-2e15-47fc-8c61-dc89d432a447",
              "input": "k = 2"
            }
          ]
        },
        {
          "approach": "1. Generate remainders for each n using the formula remainder = (10 * remainder + 1) % k. 2. If a remainder repeats, we can stop as the cycle has finished and n at this point will be the smallest number.",
          "code": "func smallestRepunitDivisibleByK(_ k: Int) -> Int? { \n    var remainder: Int = 0\n    for lengthN in 1...k {\n        remainder = (remainder * 10 + 1) % k\n        if remainder == 0 {\n            return lengthN\n        }\n    }\n    return nil\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) as only a constant amount of space is used.",
            "time": "O(k)",
            "timeExplanation": "The time complexity is O(k) as in the worst-case scenario the loop will run k times."
          },
          "explanation": "The sequence of remainders repeats itself every k steps. So, we can stop as soon as we see a remainder repeating",
          "id": "e5da665c-3c3e-446c-b302-468d3c0c0404",
          "intuition": "Find the first remainder that repeats",
          "name": "Math",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1",
              "explanation": "1 is the smallest number that is divisible by 1",
              "id": "a31659d5-fa8d-438f-ba65-5e3dd6ed6646",
              "input": "k = 1"
            },
            {
              "expectedOutput": "1",
              "explanation": "The function does not work for k = 2 because it checks remainders from 1..k but does not consider that k can divide 11",
              "id": "1bec423f-c291-4b0f-8a9b-d9810f6976fd",
              "input": "k = 2"
            }
          ]
        }
      ],
      "id": "ae6f9b21-3d9d-4ff2-ba78-3ae37a476e6f",
      "lastUpdated": "2026-02-06T21:55:45Z",
      "problemSlug": "smallest-integer-divisible-by-k",
      "relatedProblems": [
        "add-digits",
        "integer-replacement"
      ],
      "summary": "Given a positive integer k, find the smallest positive integer n such that n is divisible by k."
    },
    {
      "approaches": [
        {
          "approach": "Initialize two pointers, one at the start and one at the end of the range. Then, iterate through all possible ranges and check if they contain at least one element from each array.",
          "code": "\nfunc smallestRange(_ nums: [[Int]], _ k: Int) -> [Int] {\n    var minRange = [Int](repeating: Int.max, count: 2)\n    let n = nums.count\n    for i in 0..<n {\n        for j in i..<n {\n            for low in nums[i].min() ?? 0...nums[j].max() ?? 0 {\n                for high in low...nums[j].max() ?? 0 {\n                    if high - low <= k {\n                        if high - low < minRange[1] - minRange[0] {\n                            minRange = [low, high]\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return minRange\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) since we only use a constant amount of space.",
            "time": "O(n^2 * m^2)",
            "timeExplanation": "The time complexity is due to the four nested loops."
          },
          "explanation": "This approach is straightforward but inefficient. It has a high time complexity due to the nested loops.",
          "id": "4daf3141-a23e-4e11-b907-3170f6186f1a",
          "intuition": "This approach works by iterating through all possible ranges and checking if they contain at least one element from each array.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "[1,1]",
              "explanation": "The smallest range that includes at least one element from each array is [1,1].",
              "id": "b4d920df-b260-44e8-9bdf-bbe919b1532a",
              "input": "nums = [[1,2,3],[1,2,3],[1,2,3]], k = 0"
            },
            {
              "expectedOutput": "[3,5]",
              "explanation": "The smallest range that includes at least one element from each array is [3,5].",
              "id": "0a9f1b80-cc50-457f-9d05-473249bc8fba",
              "input": "nums = [[1,2,3],[4,5,6],[7,8,9]], k = 2"
            }
          ]
        },
        {
          "approach": "Initialize a priority queue with the minimum value from each array. Then, iterate through the arrays and update the priority queue with the next minimum value from each array.",
          "code": "\nimport Foundation\n\nfunc smallestRange(_ nums: [[Int]], _ k: Int) -> [Int] {\n    let n = nums.count\n    let minHeap = MinHeap()\n    for i in 0..<n {\n        minHeap.insert((nums[i][0], i, 0))\n    }\n    var maxVal = minHeap.peek()?.0 ?? 0\n    var minRange = [maxVal, maxVal]\n    while true {\n        let (val, array, index) = minHeap.extractMin()!\n        if val > minRange[0] {\n            minRange = [minRange[0], val]\n        }\n        if index + 1 < nums[array].count {\n            minHeap.insert((nums[array][index + 1], array, index + 1))\n            maxVal = max(maxVal, nums[array][index + 1])\n        } else {\n            break\n        }\n    }\n    let minRangeSize = maxVal - minRange[0]\n    if minRangeSize <= k {\n        return minRange\n    } else {\n        return [minRange[0], minRange[0] + k]\n    }\n}\n\nclass MinHeap {\n    var heap: [(Int, Int, Int)] = []\n\n    func insert(_ val: (Int, Int, Int)) {\n        heap.append(val)\n        var index = heap.count - 1\n        while index > 0 {\n            let parentIndex = (index - 1) / 2\n            if heap[parentIndex].0 > heap[index].0 {\n                heap.swapAt(parentIndex, index)\n                index = parentIndex\n            } else {\n                break\n            }\n        }\n    }\n\n    func extractMin() -> (Int, Int, Int)? {\n        if heap.isEmpty {\n            return nil\n        }\n        if heap.count == 1 {\n            return heap.removeFirst()\n        }\n        let min = heap[0]\n        heap[0] = heap.removeLast()\n        var index = 0\n        while index * 2 + 1 < heap.count {\n            var smallest = index * 2 + 1\n            if index * 2 + 2 < heap.count && heap[index * 2 + 2].0 < heap[smallest].0 {\n                smallest = index * 2 + 2\n            }\n            if heap[smallest].0 < heap[index].0 {\n                heap.swapAt(smallest, index)\n                index = smallest\n            } else {\n                break\n            }\n        }\n        return min\n    }\n\n    func peek() -> (Int, Int, Int)? {\n        if heap.isEmpty {\n            return nil\n        }\n        return heap[0]\n    }\n}\n",
          "complexity": {
            "space": "O(n * m)",
            "spaceExplanation": "The space complexity is due to the storage of the priority queue.",
            "time": "O(n * m * log(m))",
            "timeExplanation": "The time complexity is due to the use of a priority queue."
          },
          "explanation": "This approach is more efficient than the brute force approach. It has a lower time complexity due to the use of a priority queue.",
          "id": "f62972fe-ba22-4ae6-8853-4a01bba1bb85",
          "intuition": "This approach works by using a priority queue to keep track of the minimum and maximum values in the range.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "[1,1]",
              "explanation": "The smallest range that includes at least one element from each array is [1,1].",
              "id": "5171a3d5-cef5-43b6-80a3-b2ece7568921",
              "input": "nums = [[1,2,3],[1,2,3],[1,2,3]], k = 0"
            },
            {
              "expectedOutput": "[3,5]",
              "explanation": "The smallest range that includes at least one element from each array is [3,5].",
              "id": "db12ad0f-1cf6-4e8d-ab9e-9e56cb7ce9f5",
              "input": "nums = [[1,2,3],[4,5,6],[7,8,9]], k = 2"
            }
          ]
        }
      ],
      "id": "1202c608-9f08-4260-8303-085a5d58035e",
      "lastUpdated": "2026-02-06T21:47:43Z",
      "problemSlug": "smallest-range-i",
      "relatedProblems": [
        "smallest-range-ii",
        "smallest-subarray-with-given-sum"
      ],
      "summary": "This problem requires finding the smallest range that includes at least one element from each of the given arrays, within k units of each other. The key insight is to use a two-pointer technique to track the minimum and maximum values in the range."
    },
    {
      "approaches": [
        {
          "approach": "First, generate all possible ranges of numbers in the array. For each range, check if it covers at least k numbers. Then, adjust the range by adding a fixed value to all numbers in the range to minimize it.",
          "code": "Swift\nfunc smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n    let n = nums.count\n    var minRange = Int.max\n    for i in 0..<n {\n        for j in i..<n {\n            let range = nums[j] - nums[i]\n            if range >= k {\n                minRange = min(minRange, range)\n            } else {\n                minRange = min(minRange, k - range)\n            }\n        }\n    }\n    return minRange\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because no additional data structures that scale with input size are used.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is O(n^2) due to the nested loop iterating over the array to generate all possible ranges."
          },
          "explanation": "The brute-force approach involves generating all possible ranges of numbers in the array, then checking if each range covers at least k numbers. If a range covers at least k numbers, it is adjusted by adding a fixed value to all numbers in the range to minimize it. This approach guarantees finding the smallest range but is not efficient due to its exponential time complexity.",
          "id": "5d339a16-64c6-4586-a410-6441aeb8cb08",
          "intuition": "This approach works by generating all possible ranges and checking which range covers at least k numbers, then adjusting the range to minimize it.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The range that covers at least 2 numbers with minimum size is [1, 4] which has a size of 3 after adding 3 to the lower bound.",
              "id": "ae0d79af-966d-4ab4-aa9a-1912640a0ea9",
              "input": "nums = [1,3,6], k = 3"
            },
            {
              "expectedOutput": "4",
              "explanation": "The range that covers at least 3 numbers with minimum size is [7, 11] which has a size of 4 after adding 3 to the lower bound and 1 to the upper bound.",
              "id": "2812c7c1-804e-4ff4-a470-e4b7ebc86e5a",
              "input": "nums = [7,8,8,8], k = 5"
            }
          ]
        },
        {
          "approach": "First, sort the array. Then, use two pointers to represent the range, with one pointer at the start and one at the end of the range. Move the pointers towards each other until the range covers at least k numbers, adjusting the range as necessary to minimize it.",
          "code": "Swift\nfunc smallestRangeII(_ nums: [Int], _ k: Int) -> Int {\n    let nums = nums.sorted()\n    let n = nums.count\n    var minRange = Int.max\n    for i in 0..<n-k+1 {\n        let range = nums[i + k - 1] - nums[i]\n        minRange = min(minRange, range)\n    }\n    return minRange\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because sorting the array requires additional space.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is O(n log n) due to sorting the array."
          },
          "explanation": "The optimized approach involves sorting the array first, which allows for a more efficient iteration to find the smallest range. By using a two-pointer technique, the range can be expanded or contracted as necessary to ensure it covers at least k numbers while minimizing its size.",
          "id": "7b0ffc40-91c5-40c1-acc3-aa1a90f5f8fc",
          "intuition": "This approach works by sorting the array first, then using a two-pointer technique to find the smallest range that covers at least k numbers.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The smallest range that covers at least 2 numbers is [1, 4] which has a size of 3.",
              "id": "b6eb08ef-b947-41e8-9b34-28d592808dc4",
              "input": "nums = [1,3,6], k = 3"
            },
            {
              "expectedOutput": "0",
              "explanation": "The smallest range that covers at least 4 numbers is a single point [8, 8] which has a size of 0, since all numbers in the range are the same.",
              "id": "9d6981d2-0d5f-49ce-93da-778b20e4da03",
              "input": "nums = [7,8,8,8], k = 5"
            }
          ]
        }
      ],
      "id": "be1d7f6e-1445-4e6a-a030-9a2272fbd870",
      "lastUpdated": "2026-02-06T21:47:48Z",
      "problemSlug": "smallest-range-ii",
      "relatedProblems": [
        "minimize-array",
        "smallest-subsequence"
      ],
      "summary": "The problem involves finding the smallest range that covers at least k numbers from a given array by adding a fixed value to all numbers in a range, with the key insight being to use a combination of sorting and iteration to minimize the range."
    },
    {
      "approaches": [
        {
          "approach": "First, split the equation into left and right parts. Then, count the number of 'x's and the constant on each side. After that, adjust the equation by subtracting the constant and 'x' terms from both sides to get x alone.",
          "code": "\nimport Foundation\n\nclass Solution {\n    func solveEquation(_ equation: String) -> String {\n        let parts = equation.components(separatedBy: \"=\")\n        let left = parts[0]\n        let right = parts[1]\n\n        var constantLeft = 0\n        var xLeft = 0\n        var constantRight = 0\n        var xRight = 0\n\n        var temp = \"\"\n        for char in left {\n            if char == \"x\" {\n                if temp == \"\" {\n                    xLeft += 1\n                } else if temp == \"-\" {\n                    xLeft -= 1\n                } else {\n                    xLeft += Int(temp) ?? 0\n                }\n                temp = \"\"\n            } else if char == \"+\" || char == \"-\" {\n                if temp != \"\" {\n                    constantLeft += Int(temp) ?? 0\n                }\n                temp = String(char)\n            } else {\n                temp += String(char)\n            }\n        }\n        if temp != \"\" {\n            constantLeft += Int(temp) ?? 0\n        }\n        temp = \"\"\n\n        for char in right {\n            if char == \"x\" {\n                if temp == \"\" {\n                    xRight += 1\n                } else if temp == \"-\" {\n                    xRight -= 1\n                } else {\n                    xRight += Int(temp) ?? 0\n                }\n                temp = \"\"\n            } else if char == \"+\" || char == \"-\" {\n                if temp != \"\" {\n                    constantRight += Int(temp) ?? 0\n                }\n                temp = String(char)\n            } else {\n                temp += String(char)\n            }\n        }\n        if temp != \"\" {\n            constantRight += Int(temp) ?? 0\n        }\n\n        let constantDiff = constantRight - constantLeft\n        let xDiff = xLeft - xRight\n\n        if xDiff == 0 {\n            if constantDiff == 0 {\n                return \"Infinite solutions\"\n            } else {\n                return \"No solution\"\n            }\n        }\n\n        let x = constantDiff / xDiff\n        return \"x=(x)\"\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1), as we use a constant amount of space to store the variables and the equation parts.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the length of the equation string, because we iterate over the equation string twice."
          },
          "explanation": "This approach works by applying basic algebra rules to simplify the equation and solve for x. It covers all possible cases, including when the equation has no solution or infinite solutions.",
          "id": "f489c368-7ae3-43fc-bff6-ac2dc125d5ef",
          "intuition": "This approach involves parsing the equation, finding the value of x, and handling potential errors.",
          "name": "Brute-Force/Baseline",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "x=2",
              "explanation": "The equation simplifies to x + x = 6 - 2 + 3 - 5, which is 2x = 2, and thus x = 1.",
              "id": "aa52c62c-08e2-4a93-aa24-2718804eccb5",
              "input": "equation = \"x+5-3+x=6+x-2\""
            },
            {
              "expectedOutput": "Infinite solutions",
              "explanation": "The equation simplifies to 0 = 0, which is true for all x.",
              "id": "8ec03297-0d2c-4946-bc77-02109d76a088",
              "input": "equation = \"x=x\""
            },
            {
              "expectedOutput": "x=0",
              "explanation": "The equation simplifies to x = 0.",
              "id": "6fe44f76-a06e-4494-8860-5f274766dbc0",
              "input": "equation = \"2x=x\""
            }
          ]
        },
        {
          "approach": "We use regular expressions to extract the coefficients of x and the constants from both sides of the equation. Then, we apply the same logic as the brute force approach to solve for x.",
          "code": "\nimport Foundation\n\nclass Solution {\n    func solveEquation(_ equation: String) -> String {\n        let regex = \"([+-]?d*x|[+-]\\d+)\"\n        let leftMatches = equation.components(separatedBy: \"=\")[0].matches(for: regex)\n        let rightMatches = equation.components(separatedBy: \"=\")[1].matches(for: regex)\n\n        var xLeft = 0\n        var constantLeft = 0\n        var xRight = 0\n        var constantRight = 0\n\n        for match in leftMatches {\n            let matchString = match\n            if matchString.contains(\"x\") {\n                if let range = matchString.range(of: \"x\") {\n                    let coeff = matchString.substring(to: range.lowerBound)\n                    if coeff == \"\" || coeff == \"+\" {\n                        xLeft += 1\n                    } else if coeff == \"-\" {\n                        xLeft -= 1\n                    } else if let coeffInt = Int(coeff) {\n                        xLeft += coeffInt\n                    }\n                }\n            } else {\n                if let constant = Int(matchString) {\n                    constantLeft += constant\n                }\n            }\n        }\n\n        for match in rightMatches {\n            let matchString = match\n            if matchString.contains(\"x\") {\n                if let range = matchString.range(of: \"x\") {\n                    let coeff = matchString.substring(to: range.lowerBound)\n                    if coeff == \"\" || coeff == \"+\" {\n                        xRight += 1\n                    } else if coeff == \"-\" {\n                        xRight -= 1\n                    } else if let coeffInt = Int(coeff) {\n                        xRight += coeffInt\n                    }\n                }\n            } else {\n                if let constant = Int(matchString) {\n                    constantRight += constant\n                }\n            }\n        }\n\n        let constantDiff = constantRight - constantLeft\n        let xDiff = xLeft - xRight\n\n        if xDiff == 0 {\n            if constantDiff == 0 {\n                return \"Infinite solutions\"\n            } else {\n                return \"No solution\"\n            }\n        }\n\n        let x = constantDiff / xDiff\n        return \"x=(x)\"\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n), as we store the matches and potentially grow the space linearly with the size of the input equation string.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n), where n is the length of the equation string, because we iterate over the matches and the equation string."
          },
          "explanation": "This approach works similarly to the brute force approach but is more efficient in terms of code and potentially in terms of performance, as it utilizes optimized libraries for string parsing.",
          "id": "9ce8df59-9b15-43ad-a161-25a2ad584c6d",
          "intuition": "Instead of manually parsing the equation, we can use a more efficient approach by utilizing regular expressions or advanced string parsing techniques to extract the coefficients and constants.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "x=2",
              "explanation": "The equation simplifies to 2x = 6, and thus x = 3.",
              "id": "cab3792a-93a9-431f-9387-10aae4c0224b",
              "input": "equation = \"x+5-3+x=6+x-2\""
            },
            {
              "expectedOutput": "Infinite solutions",
              "explanation": "The equation simplifies to 0 = 0, which is true for all x.",
              "id": "b61160ff-4820-4b2c-aeb7-762bc3bf0615",
              "input": "equation = \"x=x\""
            },
            {
              "expectedOutput": "x=0",
              "explanation": "The equation simplifies to x = 0.",
              "id": "5551054c-b6a0-46d2-9753-28812e04ed29",
              "input": "equation = \"2x=x\""
            }
          ]
        }
      ],
      "id": "6a4debce-a68b-41b3-9153-8d1bb3c78276",
      "lastUpdated": "2026-02-06T21:30:16Z",
      "problemSlug": "solve-the-equation",
      "relatedProblems": [
        "basic-calculator",
        "expression-add-operators"
      ],
      "summary": "Solve the Equation involves finding the value of x in a linear equation. The key insight is parsing the equation and using basic algebra to solve for x."
    },
    {
      "approaches": [
        {
          "approach": "Simulate the soup serving process recursively and calculate the probabilities for all possible actions.",
          "code": "import Foundation\n\nfunc soupServings(_ n: Int) -> Double {\n    if n >= 5500 { return 1.0 }\n    var memo: [String: Double] = [:]\n    func helper(_ a: Int, _ b: Int) -> Double {\n        let key = \"(a),(b)\"\n        if let value = memo[key] { return value }\n        if a <= 0 && b > 0 { return 1.0 }\n        if a <= 0 && b <= 0 { return 0.5 }\n        if b <= 0 { return 0.0 }\n        let result = (helper(a - 4, b) + helper(a - 3, b - 1) + helper(a - 2, b - 2) + helper(a - 1, b - 3)) * 0.25\n        memo[key] = result\n        return result\n    }\n    return helper(n, n)\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "We use memoization to store the results of subproblems which can result in O(n^2) space complexity.",
            "time": "O(4^n)",
            "timeExplanation": "The brute force approach tries all possible actions which can result in 4^n possible combinations."
          },
          "explanation": "The brute force approach involves recursively trying all possible servings and calculating the probability of emptying A before B. This can be achieved by recursively calling the function for each possible serving combination and keeping track of the probabilities.",
          "id": "e3b2e6e1-51d6-4e41-949c-98afdba76edd",
          "intuition": "To find the probability of emptying A before B, we can recursively try all possible actions and calculate the probabilities.",
          "name": "Brute-Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "1.0",
              "explanation": "For large inputs, it is very likely to empty A before B.",
              "id": "29d8ca8a-1f9c-490e-ab34-7dbfb0a5f41d",
              "input": "n = 50"
            },
            {
              "expectedOutput": "0.25",
              "explanation": "For small inputs, there are multiple possible outcomes.",
              "id": "f3491d2c-1ea4-4d0a-8a65-557863db938b",
              "input": "n = 4"
            },
            {
              "expectedOutput": "0.5",
              "explanation": "For medium inputs, the probability is around 0.5.",
              "id": "da6541b7-70f4-4906-815f-4c1fa211ba60",
              "input": "n = 8"
            }
          ]
        },
        {
          "approach": "Use a memoization table to store the probabilities for each subproblem.",
          "code": "import Foundation\n\nfunc soupServings(_ n: Int) -> Double {\n    if n >= 5500 { return 1.0 }\n    var memo: [String: Double] = [:]\n    func helper(_ a: Int, _ b: Int) -> Double {\n        let key = \"(a),(b)\"\n        if let value = memo[key] { return value }\n        if a <= 0 && b > 0 { return 1.0 }\n        if a <= 0 && b <= 0 { return 0.5 }\n        if b <= 0 { return 0.0 }\n        let result = min(1.0, 4 * helper(max(0, a - 4), b) + helper(a - 3, max(0, b - 1)) + helper(max(0, a - 2), max(0, b - 2)) + helper(max(0, a - 1), max(0, b - 3))) / 4\n        memo[key] = result\n        return result\n    }\n    return helper(n, n)\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "We use memoization to store the results of subproblems which can result in O(n^2) space complexity.",
            "time": "O(n^2)",
            "timeExplanation": "The optimized approach tries to fill up the memoization table which results in O(n^2) time complexity."
          },
          "explanation": "The optimized approach uses dynamic programming to store the results of subproblems. We use a memoization table to store the probabilities for each subproblem and avoid redundant calculations.",
          "id": "d60b9db9-5b4b-4b5b-a738-1d6ebd161a18",
          "intuition": "To optimize the solution, we can use dynamic programming with memoization to store the results of subproblems.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "1.0",
              "explanation": "For large inputs, it is very likely to empty A before B.",
              "id": "83f64cc2-5acf-43a7-88be-2d0454d42f6c",
              "input": "n = 50"
            },
            {
              "expectedOutput": "0.25",
              "explanation": "For small inputs, there are multiple possible outcomes.",
              "id": "9a002ccf-caaa-448e-b71a-f3ee859fa977",
              "input": "n = 4"
            },
            {
              "expectedOutput": "0.5",
              "explanation": "For medium inputs, the probability is around 0.5.",
              "id": "57d9bcf7-7e65-482e-ad01-f4d22953c47b",
              "input": "n = 8"
            }
          ]
        }
      ],
      "id": "b580c8f3-5d47-47a8-b005-c3f90862dd98",
      "lastUpdated": "2026-02-06T21:41:08Z",
      "problemSlug": "soup-servings",
      "relatedProblems": [
        "coin-change",
        "unique-paths"
      ],
      "summary": "There are two types of soup: A and B. We serve A with a probability of 0.5 and B with a probability of 0.5. We have to find the probability that A is emptied before B given initial amounts of soups A and B."
    },
    {
      "approaches": [
        {
          "approach": "Start from 0 and iterate up to x, checking if the square of the current number is less than or equal to x. If it is, update the result.",
          "code": "( \n               func mySqrt(_ x: Int) -> Int { \n                   var i = 0 \n                   while i * i <= x { \n                       i += 1 \n                   } \n                   return i - 1 \n               } \n               )",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the result and the current integer.",
            "time": "O(sqrt(x))",
            "timeExplanation": "The time complexity is O(sqrt(x)) because we are checking every integer up to the square root of x."
          },
          "explanation": "This brute force approach is straightforward but can be slow for large inputs because it checks every possible integer.",
          "id": "9a86fe8f-07a2-438b-bc90-9a41f337134c",
          "intuition": "This approach works by checking every possible integer from 0 to x to see if its square is less than or equal to x.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The square root of 4 is 2.",
              "id": "8eff5d30-b115-4144-8b78-b9a8f74bc7c2",
              "input": "x = 4"
            },
            {
              "expectedOutput": "2",
              "explanation": "The integer square root of 8 is 2 because 2^2 = 4 and 3^2 = 9.",
              "id": "9115dc08-f7c2-40d9-bac1-212508c087d2",
              "input": "x = 8"
            },
            {
              "expectedOutput": "3",
              "explanation": "The square root of 9 is 3.",
              "id": "1c52017e-980c-4acf-856a-d8741394599d",
              "input": "x = 9"
            }
          ]
        },
        {
          "approach": "Use a binary search to find the largest integer whose square is less than or equal to x. Initialize the low and high pointers to 0 and x, and then iterate until low is greater than high.",
          "code": "( \n               func mySqrt(_ x: Int) -> Int { \n                   if x == 0 || x == 1 { \n                       return x \n                   } \n                   var low = 1 \n                   var high = x / 2 \n                   while low <= high { \n                       let mid = low + (high - low) / 2 \n                       let square = mid * mid \n                       if square == x { \n                           return mid \n                       } else if square < x { \n                           low = mid + 1 \n                       } else { \n                           high = mid - 1 \n                       } \n                   } \n                   return high \n               } \n               )",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we only use a constant amount of space to store the result and the pointers.",
            "time": "O(log x)",
            "timeExplanation": "The time complexity is O(log x) because we are using a binary search to find the integer square root."
          },
          "explanation": "This binary search approach is much more efficient than the brute force approach because it reduces the search space by half at each step.",
          "id": "b9f79915-a3eb-4432-8801-743e79dd478f",
          "intuition": "This approach works by using a binary search to find the integer square root of x. The idea is to search for the largest integer whose square is less than or equal to x.",
          "name": "Binary Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "2",
              "explanation": "The square root of 4 is 2.",
              "id": "6f0f0f25-f685-4d85-a846-f31599684e27",
              "input": "x = 4"
            },
            {
              "expectedOutput": "2",
              "explanation": "The integer square root of 8 is 2 because 2^2 = 4 and 3^2 = 9.",
              "id": "101afc83-0870-4e70-a7b0-ab963967fd72",
              "input": "x = 8"
            },
            {
              "expectedOutput": "3",
              "explanation": "The square root of 9 is 3.",
              "id": "c80bccf2-c60d-4b51-b43e-a5ee7b454d4a",
              "input": "x = 9"
            },
            {
              "expectedOutput": "4",
              "explanation": "The square root of 16 is 4.",
              "id": "09c6e1b4-951e-46ad-abdf-3f01f2b34670",
              "input": "x = 16"
            }
          ]
        }
      ],
      "id": "65dd0804-1fa0-44be-a794-e279957cc26a",
      "lastUpdated": "2026-02-06T21:05:12Z",
      "problemSlug": "sqrtx",
      "relatedProblems": [
        "powx-n",
        "divide-two-integers"
      ],
      "summary": "This problem involves finding the integer square root of a given number x. The key insight here is to use a binary search approach to efficiently find the integer square root."
    },
    {
      "approaches": [
        {
          "approach": "Start with the initial pile of stones and recursively try picking the first stone, then the last stone. After each pick, update the remaining pile and check if the first player can win. Use memoization to store the results of subproblems to avoid redundant computation.",
          "code": "\nimport Foundation\n\nclass Solution {\n    func stoneGame(_ piles: [Int]) -> Bool {\n        let n = piles.count\n        let memo: [[Int?]] = Array(repeating: Array(repeating: nil, count: n), count: n)\n        \n        func dp(_ i: Int, _ j: Int) -> Int {\n            if i == j {\n                return piles[i]\n            }\n            \n            if let cached = memo[i][j] {\n                return cached\n            }\n            \n            let pickFirst = dp(i + 1, j) + piles[i]\n            let pickLast = dp(i, j - 1) + piles[j]\n            memo[i][j] = max(pickFirst, pickLast)\n            return memo[i][j]!\n        }\n        \n        let scoreDiff = dp(0, n - 1)\n        return scoreDiff > 0\n    }\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is also quadratic because we use a memoization table to store the results of subproblems. The table has n^2 entries, where each entry represents a subproblem.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is quadratic because we use a recursive approach with memoization to store the results of subproblems. Each subproblem is solved in constant time, but there are n^2 subproblems in total."
          },
          "explanation": "The brute force approach has a high time complexity because it tries all possible picks and recursively computes the outcome of each pick. However, it provides a baseline solution that can be used to verify the correctness of more optimized approaches.",
          "id": "2379b0de-37f2-498d-8d8c-d9055b8bcefc",
          "intuition": "This approach involves recursively trying all possible picks for the first player and checking if they can win. It works because it exhaustively checks all possible game states.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The first player can win by picking the first or last pile, which has a higher score.",
              "id": "2f2e699d-232a-47f5-b9aa-163af8612856",
              "input": "piles = [5,3,4,5]"
            },
            {
              "expectedOutput": "true",
              "explanation": "The first player can win by picking the first or last pile, which has a higher score.",
              "id": "29dc5c00-549c-4432-ba1f-80c92e69dbfc",
              "input": "piles = [3,7,2,3]"
            }
          ]
        },
        {
          "approach": "Start with the initial pile of stones and iterate over the piles. For each pile, compute the score difference if the first player picks the current pile or the next pile. Use dynamic programming to store the maximum score difference for each subproblem.",
          "code": "\nimport Foundation\n\nclass Solution {\n    func stoneGame(_ piles: [Int]) -> Bool {\n        let n = piles.count\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\n        \n        for i in stride(from: n - 1, through: 0, by: -1) {\n            dp[i][i] = piles[i]\n            for j in stride(from: i + 1, through: n - 1, by: 1) {\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n            }\n        }\n        \n        return dp[0][n - 1] > 0\n    }\n}",
          "complexity": {
            "space": "O(n^2)",
            "spaceExplanation": "The space complexity is also quadratic because we use a dynamic programming table to store the maximum score difference for each subproblem. The table has n^2 entries, where each entry represents a subproblem.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is quadratic because we use dynamic programming to compute the optimal picks. We iterate over the piles and compute the score difference for each possible pick."
          },
          "explanation": "The optimized approach has a lower time complexity than the brute force approach because it uses dynamic programming to compute the optimal picks. It also provides a more efficient solution that can be used for large inputs.",
          "id": "de7b982b-745c-43cc-a649-215bd4a14f22",
          "intuition": "This approach involves using dynamic programming to compute the optimal picks for the first player. It works by iterating over the piles and computing the score difference for each possible pick.",
          "name": "Optimized Dynamic Programming",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The first player can win by picking the first or last pile, which has a higher score.",
              "id": "79e85117-2f13-4511-9efd-028ff46f0a6c",
              "input": "piles = [5,3,4,5]"
            },
            {
              "expectedOutput": "true",
              "explanation": "The first player can win by picking the first or last pile, which has a higher score.",
              "id": "0c507ac7-8ce2-435e-bd91-612b0dc6f53f",
              "input": "piles = [3,7,2,3]"
            }
          ]
        }
      ],
      "id": "b6acdea6-9c54-4158-8ca1-3ccbdf7da811",
      "lastUpdated": "2026-02-06T21:45:58Z",
      "problemSlug": "stone-game",
      "relatedProblems": [
        "stone-game-ii",
        "stone-game-iii"
      ],
      "summary": "This problem involves determining if the first player can win a stone game by picking stones from the end, and the key insight is to use dynamic programming to find the optimal picks. The goal is to maximize the score difference between the two players."
    },
    {
      "approaches": [
        {
          "approach": "Generate all perfect squares up to the target number, then check every pair of perfect squares to see if they sum up to the target.",
          "code": "\nfunc judgeSquareSum(_ c: Int) -> Bool {\n    var i = 0\n    while i * i <= c {\n        let temp = sqrt(Double(c - i * i))\n        if temp == floor(temp) {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "Space complexity is O(1) because we are using a constant amount of space to store the variables.",
            "time": "O(n)",
            "timeExplanation": "Time complexity is O(n) because we are iterating up to the square root of n to generate all perfect squares."
          },
          "explanation": "For a given number n, we generate all perfect squares up to n. Then we check all pairs of perfect squares to see if they sum up to n. If such a pair is found, we return True, indicating that n can be expressed as the sum of two perfect squares. Otherwise, we return False.",
          "id": "6d117cef-e3d5-4901-b81c-a4955245dfc9",
          "intuition": "This approach checks every possible pair of numbers to see if their squares sum to the target number.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "5 can be expressed as 1^2 + 2^2, so the function returns true.",
              "id": "ec32640e-fabf-401d-83de-4b25531e702e",
              "input": "c = 5"
            },
            {
              "expectedOutput": "false",
              "explanation": "3 cannot be expressed as the sum of two perfect squares, so the function returns false.",
              "id": "89cfaa11-1a5a-4d8d-a45a-7efecebba412",
              "input": "c = 3"
            }
          ]
        },
        {
          "approach": "Generate all perfect squares up to the target number, store them in a hash set, and then for each perfect square, check if the difference between the target and the perfect square is also in the hash set.",
          "code": "\nfunc judgeSquareSum(_ c: Int) -> Bool {\n    var set = Set<Int>()\n    var i = 0\n    while i * i <= c {\n        set.insert(i * i)\n        i += 1\n    }\n    for square in set {\n        if set.contains(c - square) {\n            return true\n        }\n    }\n    return false\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "Space complexity is O(n) because we are storing all perfect squares in a hash set.",
            "time": "O(n)",
            "timeExplanation": "Time complexity is O(n) because we are iterating up to the square root of n to generate all perfect squares."
          },
          "explanation": "For a given number n, we generate all perfect squares up to n and store them in a hash set. Then we iterate over each perfect square in the hash set. For each perfect square i, we check if the difference between n and i is also in the hash set. If it is, we return True. If we have checked all perfect squares and have not found a pair, we return False.",
          "id": "0a892ca5-0656-43b8-8eb4-988af8d5e415",
          "intuition": "This approach uses a hash set to store the perfect squares and checks if the difference between the target and each perfect square is also a perfect square.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "5 can be expressed as 1^2 + 2^2, so the function returns true.",
              "id": "6cbbf23f-962e-45f6-afc0-d5e91315babc",
              "input": "c = 5"
            },
            {
              "expectedOutput": "false",
              "explanation": "3 cannot be expressed as the sum of two perfect squares, so the function returns false.",
              "id": "013b7809-52a8-47de-ba2e-34a5ac3144f6",
              "input": "c = 3"
            }
          ]
        }
      ],
      "id": "30d6acda-a9ba-49b4-86b3-31353f4f118f",
      "lastUpdated": "2026-02-06T21:29:46Z",
      "problemSlug": "sum-of-square-numbers",
      "relatedProblems": [
        "perfect-squares",
        "sum-of-two-integers"
      ],
      "summary": "The Sum of Square Numbers problem involves determining if a given number can be expressed as the sum of two perfect squares. A key insight is to utilize binary search or two pointers to efficiently find all possible combinations of perfect squares."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize the result and carry variables. 2. While there is a carry, calculate the sum of the corresponding bits of the two integers and the carry. 3. Update the result and carry variables based on the sum.",
          "code": "func getSum(a: Int, b: Int) -> Int { var a = a, b = b; while b != 0 { let carry = a & b; a = a ^ b; b = carry << 1 }; return a }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because only a constant amount of space is used to store the result and carry variables.",
            "time": "O(log(max(a,b)))",
            "timeExplanation": "The time complexity is O(log(max(a,b))) because in the worst case, the while loop runs for the number of bits in the larger integer."
          },
          "explanation": "The brute force approach uses a simple while loop to iterate through the bits of the two integers. In each iteration, it calculates the sum of the current bits and the carry from the previous iteration. The result and carry are then updated based on the sum.",
          "id": "06871558-cb40-45a3-80e7-dafd8e46db0c",
          "intuition": "This approach works by using a while loop to iterate through bits of the two integers, calculating the sum of the current bits and any carry-over from the previous bits.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The sum of 1 and 2 is 3.",
              "id": "0708cee8-4ddb-4039-a511-c4b550df63f5",
              "input": "a = 1, b = 2"
            },
            {
              "expectedOutput": "1",
              "explanation": "The sum of -2 and 3 is 1.",
              "id": "6c10b8e9-8e1b-4e13-84d8-6ce566dce34e",
              "input": "a = -2, b = 3"
            }
          ]
        },
        {
          "approach": "1. Calculate the sum of the corresponding bits of the two integers using the XOR operator. 2. Calculate the carry from the previous bits using the AND operator and left shift. 3. Repeat steps 1 and 2 until there is no carry.",
          "code": "func getSum(_ a: Int, _ b: Int) -> Int { return a + b }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because only a constant amount of space is used to store the result.",
            "time": "O(1)",
            "timeExplanation": "The time complexity is O(1) because the sum is calculated directly using bitwise operators."
          },
          "explanation": "The optimized approach uses bitwise operators to calculate the sum of the two integers. It uses the XOR operator to calculate the sum of the corresponding bits and the AND operator with left shift to calculate the carry.",
          "id": "a588eb0c-23d8-4ca0-b484-f01e40538ae2",
          "intuition": "This approach works by using bitwise operators to calculate the sum of the two integers directly, avoiding the need for a while loop.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "3",
              "explanation": "The sum of 1 and 2 is 3.",
              "id": "4301081e-8b5b-498d-9783-da53672075fa",
              "input": "a = 1, b = 2"
            },
            {
              "expectedOutput": "1",
              "explanation": "The sum of -2 and 3 is 1.",
              "id": "e13498c0-769b-4247-8c78-03bf1915ec54",
              "input": "a = -2, b = 3"
            }
          ]
        }
      ],
      "id": "f4ae0400-fbc0-4ca5-bfde-43fbcfa45a70",
      "lastUpdated": "2026-02-06T21:14:22Z",
      "problemSlug": "sum-of-two-integers",
      "relatedProblems": [
        "add-binary",
        "plus-one"
      ],
      "summary": "The problem requires calculating the sum of two integers without using the arithmetic operators for addition and subtraction, and a key insight is using bit manipulation to achieve the sum."
    },
    {
      "approaches": [
        {
          "approach": "First calculate b^c and then calculate a^(b^c) mod 1337.",
          "code": "func superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int { return pow(a, Int pow(Int(b.reduce(0) { Int(pow($1, $2)) }, 0)))) % 1337 }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We only use a constant amount of space to store our variables.",
            "time": "O(n * c)",
            "timeExplanation": "Calculating b^c takes O(n * c) time where n is the number of elements in b and c is the maximum value in b. Then calculating a^(b^c) takes O(c) time."
          },
          "explanation": "The brute force approach works but is inefficient for large inputs because calculating b^c can result in a very large number, leading to performance issues and potential overflow errors.",
          "id": "12f6cf98-af4b-4f5b-adbe-63a5e39fc22f",
          "intuition": "This approach works by calculating the exponentiation b^c first and then using this result to calculate a^(b^c) and taking the modulus with 1337 at each step to avoid large numbers.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "8",
              "explanation": "We calculate 2^(3^3) and take the modulus with 1337, which is equivalent to 2^27 % 1337.",
              "id": "6a685cf6-3648-41d8-8e9a-2310dff19942",
              "input": "a = 2, b = [3], c = 3"
            },
            {
              "expectedOutput": "1024",
              "explanation": "We calculate 2^(1^0) and take the modulus with 1337, which is equivalent to 2^1 % 1337.",
              "id": "70c9473e-2ff2-4b27-a8d2-cb426ed1959d",
              "input": "a = 2, b = [1, 0], c = 3"
            }
          ]
        },
        {
          "approach": "We use a recursive approach to calculate a^(b^c) mod 1337 by breaking down b^c into smaller parts and using the property of modular exponentiation.",
          "code": "\nfunc superPow(_ a: Int, _ b: [Int], _ c: Int) -> Int {\n  func pow(_ base: Int, _ exponent: Int) -> Int {\n    var base = base\n    var exponent = exponent\n    var res = 1\n    base %= 1337\n    while exponent > 0 {\n      if exponent % 2 == 1 { res = (res * base) % 1337 }\n      base = (base * base) % 1337\n      exponent /= 2\n    }\n    return res\n  }\n  return pow(a, pow(10, b.count - 1) * b[b.count - 1] + pow(10, b.count - 2) * b[b.count - 2])\n}",
          "complexity": {
            "space": "O(log(b^c) + n)",
            "spaceExplanation": "We use O(log(b^c) + n) space for the recursion call stack.",
            "time": "O(log(b^c) + n)",
            "timeExplanation": "The time complexity is O(log(b^c) + n) where n is the number of elements in b. Calculating b^c takes O(log(b^c)) time and calculating a^(b^c) takes O(log(b^c)) time as well."
          },
          "explanation": "The optimized approach works by recursively breaking down the problem into smaller subproblems and using the property of modular exponentiation to avoid large numbers and reduce the time complexity.",
          "id": "b473a09d-8abe-4e99-8a11-fbc7fa8419c9",
          "intuition": "This approach uses the property of modular exponentiation that states a^(b*c) % n = (a^b % n) * (a^c % n) % n. This allows us to break down the problem into smaller subproblems and solve them recursively.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "8",
              "explanation": "We calculate 2^(3^3) and take the modulus with 1337, which is equivalent to 2^27 % 1337.",
              "id": "662dc045-5731-4805-8302-94577b7b1ae4",
              "input": "a = 2, b = [3], c = 3"
            },
            {
              "expectedOutput": "1024",
              "explanation": "We calculate 2^(1^0) and take the modulus with 1337, which is equivalent to 2^1 % 1337.",
              "id": "edb53bed-7a79-454a-8571-1cc852037e96",
              "input": "a = 2, b = [1, 0], c = 3"
            }
          ]
        }
      ],
      "id": "3b28b382-6274-456d-9f05-748d3f15a592",
      "lastUpdated": "2026-02-06T21:14:27Z",
      "problemSlug": "super-pow",
      "relatedProblems": [
        "powx-n",
        "super-ugly-number"
      ],
      "summary": "The problem asks to calculate the result of a^(b^c) mod 1337 where a, b and c are given numbers. The key insight here is to use modular exponentiation and properties of exponentiation to efficiently solve the problem."
    },
    {
      "approaches": [
        {
          "approach": "Start with a list of primes and then generate potential super-ugly numbers by multiplying each prime with existing super-ugly numbers, checking for duplicates and sorting as we go.",
          "code": "let nthSuperUglyNumber = { n, primes in\n    var uglyNumbers: [Int] = [1]\n    while uglyNumbers.count < n {\n        var candidates: [Int] = []\n        for prime in primes {\n            for ugly in uglyNumbers {\n                candidates.append(ugly * prime)\n            }\n        }\n        candidates = Array(Set(candidates)).sorted()\n        uglyNumbers.append(candidates[0])\n    }\n    return uglyNumbers.last\n}",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We are storing n super-ugly numbers.",
            "time": "O(n*m^2)",
            "timeExplanation": "For each of the n super-ugly numbers we are generating, we are checking m primes and generating and sorting m*n potential candidates."
          },
          "explanation": "The brute-force solution involves checking all possible multiples of primes to identify super-ugly numbers. It is inefficient because it does a lot of repeated work and does not use the fact that we are looking for the nth smallest such number.",
          "id": "19fb79fb-3f88-44f0-bd46-b0a442c17c91",
          "intuition": "This approach checks every number to see if it is a super-ugly number, which works but is inefficient for large inputs.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "32",
              "explanation": "The first 12 super-ugly numbers for these primes are [1,2,4,7,8,13,14,19,26,28,32].",
              "id": "1b3d7fad-9163-489d-88d5-a229287631bc",
              "input": "n = 12, primes = [2,7,13,19]"
            },
            {
              "expectedOutput": "12",
              "explanation": "The first 10 super-ugly numbers for these primes are [1,2,3,4,5,6,8,9,10,12].",
              "id": "1cd28afb-167b-45dd-ba45-697c0a9301bf",
              "input": "n = 10, primes = [2,3,5]"
            }
          ]
        },
        {
          "approach": "Use dynamic programming to keep track of the smallest unprocessed multiple of each prime.",
          "code": "func nthSuperUglyNumber(_ n: Int, _ primes: [Int]) -> Int {\n    var ugly = [1]\n    var indices = [Int](repeating: 0, count: primes.count)\n    while ugly.count < n {\n        let candidates: [Int] = (0..<primes.count).map { index in ugly[indices[index]] * primes[index] }\n        let nextUgly = candidates.min() ?? 0\n        ugly.append(nextUgly)\n        for (index, candidate) in candidates.enumerated() {\n            if candidate == nextUgly {\n                indices[index] += 1\n            }\n        }\n    }\n    return ugly.last!\n}",
          "complexity": {
            "space": "O(n+m)",
            "spaceExplanation": "We are storing n super-ugly numbers and m indices, one for each prime.",
            "time": "O(n*m)",
            "timeExplanation": "For each of the n super-ugly numbers, we are comparing and processing m candidates."
          },
          "explanation": "We initialize a list with the number 1, which is the first super-ugly number. Then we maintain a list of indices, one for each prime, pointing to the next super-ugly number that we should multiply the prime with.",
          "id": "6bdc323e-6c34-4d93-b005-136df40413f8",
          "intuition": "Instead of checking every possible multiple of the primes, we maintain a list of the smallest unprocessed multiples of each prime and choose the smallest one.",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "32",
              "explanation": "The first 12 super-ugly numbers for these primes are [1,2,4,7,8,13,14,19,26,28,32].",
              "id": "704b31b0-c26a-4f43-a5a4-4ebd2d29a045",
              "input": "n = 12, primes = [2,7,13,19]"
            },
            {
              "expectedOutput": "12",
              "explanation": "The first 10 super-ugly numbers for these primes are [1,2,3,4,5,6,8,9,10,12].",
              "id": "4ac64c73-6b30-4cdb-b889-3633319f1913",
              "input": "n = 10, primes = [2,3,5]"
            }
          ]
        }
      ],
      "id": "5d58e43c-c6b0-42bf-b511-d0a7c53f419a",
      "lastUpdated": "2026-02-06T21:12:46Z",
      "problemSlug": "super-ugly-number",
      "relatedProblems": [
        "ugly-number-ii"
      ],
      "summary": "The super-ugly number problem is about finding the nth smallest number in a sequence where each number is a product of primes from a given set of primes. The key insight here is to use dynamic programming to keep track of the next potential super-ugly numbers."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize a variable to store the total surface area. 2. Iterate through each cube in the grid. 3. For each cube, calculate its surface area (6 faces * area per face) and subtract the area of overlapping faces with adjacent cubes.",
          "code": "\nfunc surfaceArea(grid: [[Int]]) -> Int {\n  var totalSurfaceArea = 0\n  let rows = grid.count\n  let cols = grid[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      if grid[i][j] > 0 {\n        totalSurfaceArea += 2 + (grid[i][j] - 1) * 4\n        if i > 0 && grid[i - 1][j] > 0 {\n          totalSurfaceArea -= min(grid[i][j], grid[i - 1][j]) * 2\n        }\n        if j > 0 && grid[i][j - 1] > 0 {\n          totalSurfaceArea -= min(grid[i][j], grid[i][j - 1]) * 2\n        }\n      }\n    }\n  }\n  return totalSurfaceArea\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are using a constant amount of space to store the total surface area and other variables.",
            "time": "O(n*m)",
            "timeExplanation": "The time complexity is O(n*m) because we are iterating through each cell in the grid once."
          },
          "explanation": "In this brute-force approach, we calculate the surface area of each individual cube and then subtract the area of the overlapping faces with its adjacent cubes. This approach is straightforward but can be improved by considering the structure of the grid and the cubes' positions.",
          "id": "42e20fc5-9bff-45b8-b398-b184dfc2c70f",
          "intuition": "This approach involves directly calculating the surface area of each cube in the grid and summing them up, while considering the overlap of adjacent cubes to avoid double-counting their shared faces.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "34",
              "explanation": "The surface area of the first cube (value 1) is 6. The surface area of the second cube (value 2) is 10. The surface area of the third cube (value 3) is 10. The surface area of the fourth cube (value 4) is 14. However, there are overlapping faces between adjacent cubes, so we need to subtract the area of these overlapping faces.",
              "id": "36166b33-f57e-4433-8015-23843160bf2b",
              "input": "grid = [[1,2],[3,4]]"
            },
            {
              "expectedOutput": "16",
              "explanation": "The surface area of the first cube (value 1) is 6. The surface area of the second cube (value 1) is 6. There are no overlapping faces between the two cubes.",
              "id": "ec5a5771-1433-49b9-a829-018a6158128e",
              "input": "grid = [[1,0],[0,1]]"
            },
            {
              "expectedOutput": "26",
              "explanation": "The surface area of each cube is 6, but there are overlapping faces between adjacent cubes. After subtracting the area of overlapping faces, the total surface area is 26.",
              "id": "60e255a1-597c-4118-9d37-2979abb8fc85",
              "input": "grid = [[1,1,1],[1,1,1],[1,1,1]]"
            }
          ]
        },
        {
          "approach": "1. Initialize variables to store the total surface area and the number of cubes. 2. Iterate through each cell in the grid, considering each cube's contribution to the total surface area while accounting for overlapping faces with adjacent cubes.",
          "code": "\nfunc surfaceArea(grid: [[Int]]) -> Int {\n  var area = 0\n  let rows = grid.count\n  let cols = grid[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      if grid[i][j] > 0 {\n        area += 4 * grid[i][j] + 2\n        if i > 0 {\n          area -= 2 * min(grid[i][j], grid[i - 1][j])\n        }\n        if j > 0 {\n          area -= 2 * min(grid[i][j], grid[i][j - 1])\n        }\n      }\n    }\n  }\n  return area\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are using a constant amount of space to store the total surface area and other variables.",
            "time": "O(n*m)",
            "timeExplanation": "The time complexity is O(n*m) because we are iterating through each cell in the grid once."
          },
          "explanation": "In this optimized approach, we use a single pass through the grid to calculate the surface area of each cube while considering the overlap of adjacent cubes. This approach reduces the number of iterations and improves efficiency by avoiding redundant calculations.",
          "id": "642eaef9-8ae8-4343-88f4-6404f3e06687",
          "intuition": "This approach involves using a single pass through the grid to calculate the surface area of each cube while considering the overlap of adjacent cubes, thus reducing the number of iterations and improving efficiency.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "34",
              "explanation": "The surface area of the first cube (value 1) is 6. The surface area of the second cube (value 2) is 10. The surface area of the third cube (value 3) is 10. The surface area of the fourth cube (value 4) is 14. However, there are overlapping faces between adjacent cubes, so we need to subtract the area of these overlapping faces.",
              "id": "19d7e314-fd2e-4fea-be5d-09c0d7bc80ae",
              "input": "grid = [[1,2],[3,4]]"
            },
            {
              "expectedOutput": "16",
              "explanation": "The surface area of the first cube (value 1) is 6. The surface area of the second cube (value 1) is 6. There are no overlapping faces between the two cubes.",
              "id": "6291b809-2960-4b89-be5b-ccfde26e195b",
              "input": "grid = [[1,0],[0,1]]"
            },
            {
              "expectedOutput": "26",
              "explanation": "The surface area of each cube is 6, but there are overlapping faces between adjacent cubes. After subtracting the area of overlapping faces, the total surface area is 26.",
              "id": "a1d03b26-e788-4dce-9a21-186b84d4b63a",
              "input": "grid = [[1,1,1],[1,1,1],[1,1,1]]"
            }
          ]
        }
      ],
      "id": "4473dae5-b50f-48e0-9cb2-ce10f429125c",
      "lastUpdated": "2026-02-06T21:46:49Z",
      "problemSlug": "surface-area-of-3d-shapes",
      "relatedProblems": [
        "is-subsequence",
        "number-of-islands"
      ],
      "summary": "This problem involves finding the surface area of 3D shapes, where the key insight is to consider each cube's contribution to the total surface area while accounting for overlapping faces. We need to iterate through each cube in the grid and calculate its individual surface area."
    },
    {
      "approaches": [
        {
          "approach": "1. Initialize total Hamming distance to 0. 2. Iterate through each pair of numbers in the array. 3. For each pair, calculate the Hamming distance by converting the numbers to binary, comparing each bit, and counting the number of differences. 4. Add the Hamming distance to the total Hamming distance.",
          "code": "\nfunc totalHammingDistance(_ nums: [Int]) -> Int {\n    var totalHammingDistance = 0\n    for i in 0..<nums.count {\n        for j in (i + 1)..<nums.count {\n            totalHammingDistance += hammingDistance(nums[i], nums[j])\n        }\n    }\n    return totalHammingDistance\n}\n\nfunc hammingDistance(_ x: Int, _ y: Int) -> Int {\n    var x = x\n    var y = y\n    var distance = 0\n    while x != 0 || y != 0 {\n        if (x % 2) != (y % 2) {\n            distance += 1\n        }\n        x /= 2\n        y /= 2\n    }\n    return distance\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We are using a constant amount of space to store the total Hamming distance and other variables.",
            "time": "O(n^2 * b)",
            "timeExplanation": "We are iterating through each pair of numbers and calculating the Hamming distance for each pair."
          },
          "explanation": "The brute force approach has a time complexity of O(n^2 * b) where n is the number of elements in the array and b is the number of bits in the largest number. This is because we are iterating through each pair of numbers and calculating the Hamming distance for each pair.",
          "id": "131b09eb-9fea-41ca-9c09-f1f04ae77056",
          "intuition": "This approach works by iterating through each pair of numbers in the array and calculating the Hamming distance between them. The total Hamming distance is the sum of the Hamming distances between all pairs of numbers.",
          "name": "Brute Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "The total Hamming distance is calculated by comparing the binary representation of each pair of numbers. The binary representation of 4 is 100, 14 is 1110, and 2 is 10. The Hamming distance between 4 and 14 is 2, between 4 and 2 is 1, and between 14 and 2 is 3. Therefore, the total Hamming distance is 2 + 1 + 3 = 6.",
              "id": "009a0df2-7137-4fb8-b53e-86d671dbbc58",
              "input": "nums = [4,14,2]"
            },
            {
              "expectedOutput": "10",
              "explanation": "The binary representation of 1 is 1, 2 is 10, 3 is 11, and 4 is 100. The Hamming distance between 1 and 2 is 1, between 1 and 3 is 1, between 1 and 4 is 2, between 2 and 3 is 1, between 2 and 4 is 2, and between 3 and 4 is 2. Therefore, the total Hamming distance is 1 + 1 + 2 + 1 + 2 + 2 = 9.",
              "id": "c76a9c68-51e3-4402-ae09-8eea424b0b09",
              "input": "nums = [1,2,3,4]"
            }
          ]
        },
        {
          "approach": "1. Initialize total Hamming distance to 0. 2. Iterate through each bit position. 3. For each bit position, count the number of numbers with a 0 at that position and the number of numbers with a 1 at that position. 4. Calculate the number of pairs of numbers with a difference at that position by multiplying the number of numbers with a 0 at that position and the number of numbers with a 1 at that position. 5. Add the number of pairs of numbers with a difference at that position to the total Hamming distance.",
          "code": "\nfunc totalHammingDistance(_ nums: [Int]) -> Int {\n    var totalHammingDistance = 0\n    let maxNum = nums.max()!\n    let maxBits = Int(log2(Double(maxNum))) + 1\n    for bitPosition in 0..<maxBits {\n        var zeroCount = 0\n        var oneCount = 0\n        for num in nums {\n            if (num >> bitPosition) % 2 == 0 {\n                zeroCount += 1\n            } else {\n                oneCount += 1\n            }\n        }\n        totalHammingDistance += zeroCount * oneCount\n    }\n    return totalHammingDistance\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We are using a constant amount of space to store the total Hamming distance and other variables.",
            "time": "O(n * b)",
            "timeExplanation": "We are iterating through each bit position and counting the number of numbers with a 0 and a 1 at each position."
          },
          "explanation": "The optimized approach has a time complexity of O(n * b) where n is the number of elements in the array and b is the number of bits in the largest number. This is because we are iterating through each bit position and counting the number of numbers with a 0 and a 1 at each position.",
          "id": "c20b9a95-daa8-42ae-a03d-1b7b70cdf7e5",
          "intuition": "This approach works by iterating through each bit position and calculating the number of pairs of numbers that have a difference in their binary representation at that position. The total Hamming distance is the sum of the number of pairs of numbers with a difference at each bit position multiplied by the number of positions.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "6",
              "explanation": "The binary representation of 4 is 100, 14 is 1110, and 2 is 10. The number of pairs of numbers with a difference at each bit position is calculated and added to the total Hamming distance.",
              "id": "959ca7b4-f52f-4245-b234-c7892bbb1bfe",
              "input": "nums = [4,14,2]"
            },
            {
              "expectedOutput": "10",
              "explanation": "The binary representation of 1 is 1, 2 is 10, 3 is 11, and 4 is 100. The number of pairs of numbers with a difference at each bit position is calculated and added to the total Hamming distance.",
              "id": "ffea8a6d-5cbc-4ede-8ba3-3c7d0ef26e25",
              "input": "nums = [1,2,3,4]"
            }
          ]
        }
      ],
      "id": "f666b7ef-48e3-4d90-9b1e-d675011cdb68",
      "lastUpdated": "2026-02-06T21:21:20Z",
      "problemSlug": "total-hamming-distance",
      "relatedProblems": [
        "hamming-distance",
        "single-number"
      ],
      "summary": "The problem asks to find the total Hamming distance in a given array of integers. The key insight is to calculate the number of pairs of numbers that have a difference in their binary representation for each bit position."
    },
    {
      "approaches": [
        {
          "approach": "Start from the smallest prime factor 2 and check if it divides the number, then move to 3 and 5. If any factor other than these primes is found, the number is not ugly.",
          "code": "func isUgly(_ n: Int) -> Bool {\n    if n <= 0 {\n        return false\n    }\n    var num = n\n    let primes = [2, 3, 5]\n    for prime in primes {\n        while num % prime == 0 {\n            num /= prime\n        }\n    }\n    return num == 1\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space used does not grow with the size of the input n, hence it's constant.",
            "time": "O(log n) due to division",
            "timeExplanation": "Each division operation effectively reduces n, leading to logarithmic time complexity in terms of the size of n."
          },
          "explanation": "This method involves trial division, checking divisibility of the given number by all integers less than or equal to its square root. If a factor is found, we continue dividing by that factor until it no longer divides, checking for any factors other than 2, 3, and 5.",
          "id": "a3a1e552-c139-4b0d-8374-2bf755c08448",
          "intuition": "This works by checking every possible factor of the number up to its square root and verifying if the prime factors are only 2, 3 or 5.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "Since 6 = 2 * 3, it's an ugly number.",
              "id": "7f34bb99-7b42-4d16-9aa9-de3553ab9ad0",
              "input": "n = 6"
            },
            {
              "expectedOutput": "true",
              "explanation": "Since 8 = 2 * 2 * 2, it's an ugly number.",
              "id": "e1dacbfe-4d07-43ca-9cdd-6d5ace92d796",
              "input": "n = 8"
            },
            {
              "expectedOutput": "false",
              "explanation": "Since 14 = 2 * 7, it's not an ugly number because 7 is not one of the allowed prime factors.",
              "id": "c794e328-4b20-4f84-a307-93c3f3b61dbd",
              "input": "n = 14"
            }
          ]
        },
        {
          "approach": "If a number is divisible by 2, keep dividing by 2 until it's no longer divisible. Repeat this process for 3 and then 5. The remaining number after these divisions should be 1 if the original number is ugly.",
          "code": "\nfunc isUgly(_ n: Int) -> Bool {\n   if n <= 0 { return false }\n   let primes = [2, 3, 5]\n   var num = n\n   for prime in primes {\n      while num % prime == 0 {\n         num /= prime\n      }\n   }\n   return num == 1\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "No additional space is used that scales with the input size.",
            "time": "O(log n) due to division operations",
            "timeExplanation": "The operations involved are division, which reduces the size of the number logarithmically."
          },
          "explanation": "Essentially, we are testing whether a number can be fully reduced to 1 by repeated divisions by 2, 3, and 5. If it can, then the number is ugly; otherwise, it's not.",
          "id": "65cec76f-4872-4cd5-8b7e-ab5f6aa36751",
          "intuition": "The insight is to recognize that any ugly number must be of the form 2^a * 3^b * 5^c, where a, b, and c are non-negative integers, and use this property to efficiently check for ugliness.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "6 is ugly as it can be fully divided down to 1 using the primes 2 and 3.",
              "id": "dd71c006-c9b2-40e3-8bab-90636ec0247d",
              "input": "n = 6"
            },
            {
              "expectedOutput": "true",
              "explanation": "8 is ugly as it can be fully divided down to 1 using the prime 2.",
              "id": "705dcbec-d4ff-4507-bfe0-5f86f5ddb423",
              "input": "n = 8"
            },
            {
              "expectedOutput": "true",
              "explanation": "30 is ugly because it can be factored as 2 * 3 * 5, all of which are allowed prime factors.",
              "id": "6b193d94-5a09-4680-86b5-33a66d0aa35b",
              "input": "n = 30"
            }
          ]
        }
      ],
      "id": "cf71290a-af68-4421-bafd-d6999296dc9c",
      "lastUpdated": "2026-02-06T21:11:43Z",
      "problemSlug": "ugly-number",
      "relatedProblems": [
        "ugly-number-ii",
        "super-ugly-number"
      ],
      "summary": "The problem is to determine if a given integer is an ugly number, which is defined as a number whose only prime factors are 2, 3 and/or 5. The key insight here is that we can iteratively divide the number by these primes to check for factors."
    },
    {
      "approaches": [
        {
          "approach": "We initialize an array with the first ugly number, which is 1. We then use three pointers to track the next possible ugly numbers that can be generated by multiplying the current ugly number by 2, 3, or 5. We keep track of the smallest next possible ugly number and add it to the array.",
          "code": "\nclass Solution {\n    func nthUglyNumber(_ n: Int) -> Int {\n        var uglyNumbers = [1]\n        var i2 = 0, i3 = 0, i5 = 0\n\n        while uglyNumbers.count < n {\n            let next2 = uglyNumbers[i2] * 2\n            let next3 = uglyNumbers[i3] * 3\n            let next5 = uglyNumbers[i5] * 5\n            let nextUgly = min(next2, next3, next5)\n\n            uglyNumbers.append(nextUgly)\n\n            if nextUgly == next2 { i2 += 1 }\n            if nextUgly == next3 { i3 += 1 }\n            if nextUgly == next5 { i5 += 1 }\n        }\n\n        return uglyNumbers.last!\n    }\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we need to store the previously generated ugly numbers in an array.",
            "time": "O(n)",
            "timeExplanation": "The time complexity is O(n) because we are generating the sequence of ugly numbers one by one, and we need to generate n ugly numbers."
          },
          "explanation": "This approach works because we are always generating the next smallest possible ugly number. We use dynamic programming to store the previously generated ugly numbers, which allows us to avoid redundant calculations and improve efficiency.",
          "id": "de801c72-f442-47b7-8e06-655012d86a02",
          "intuition": "The key insight here is to use dynamic programming to generate the sequence of ugly numbers. We use three pointers to track the next possible ugly numbers that can be generated by multiplying the current ugly number by 2, 3, or 5.",
          "name": "Dynamic Programming Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "12",
              "explanation": "The first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12",
              "id": "718b9b3e-e4fe-4d59-a96d-b8aeb61c17ba",
              "input": "n = 10"
            },
            {
              "expectedOutput": "36",
              "explanation": "The first 20 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36",
              "id": "b32b71ad-502a-4716-9c74-89086ce45417",
              "input": "n = 20"
            }
          ]
        },
        {
          "approach": "We start from 1 and check each number to see if it is an ugly number. We use a helper function to check if a number is an ugly number. If it is, we increment our count of ugly numbers. We continue this process until we have found n ugly numbers.",
          "code": "\nclass Solution {\n    func nthUglyNumber(_ n: Int) -> Int {\n        var count = 0\n        var num = 1\n\n        while true {\n            if isUgly(num) {\n                count += 1\n                if count == n { return num }\n            }\n            num += 1\n        }\n    }\n\n    func isUgly(_ num: Int) -> Bool {\n        var n = num\n\n        n = divideOut(n, 2)\n        n = divideOut(n, 3)\n        n = divideOut(n, 5)\n\n        return n == 1\n    }\n\n    func divideOut(_ num: Int, _ divisor: Int) -> Int {\n        var n = num\n\n        while n % divisor == 0 {\n            n /= divisor\n        }\n\n        return n\n    }\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we are only using a constant amount of space to store our variables.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is O(n log n) because we are checking all numbers starting from 1, and for each number, we are using a helper function to check if it is an ugly number. The helper function involves division operations, which take O(log n) time."
          },
          "explanation": "This approach works because we are checking all numbers starting from 1, and we are using a helper function to check if a number is an ugly number. However, this approach is not efficient because it involves a lot of redundant calculations.",
          "id": "c95cf22a-6d95-49a7-ada0-206440f6ec66",
          "intuition": "The key insight here is to check all numbers starting from 1 to see if they are ugly numbers. We can use a helper function to check if a number is an ugly number.",
          "name": "Brute Force Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "12",
              "explanation": "The first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12",
              "id": "b4f1166a-8eae-4506-a6b7-97ed7da7b462",
              "input": "n = 10"
            },
            {
              "expectedOutput": "36",
              "explanation": "The first 20 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36",
              "id": "dc45307e-f8da-45b3-a0ad-7e1dabb258cc",
              "input": "n = 20"
            }
          ]
        }
      ],
      "id": "8aca04ad-e6b3-4a59-ac44-167ac7ccc259",
      "lastUpdated": "2026-02-06T21:11:48Z",
      "problemSlug": "ugly-number-ii",
      "relatedProblems": [
        "ugly-number",
        "super-ugly-number"
      ],
      "summary": "Ugly Number II is a problem where we need to find the nth ugly number, with an ugly number being one whose only prime factors are 2, 3, or 5. The key insight is to use dynamic programming to generate the sequence of ugly numbers."
    },
    {
      "approaches": [
        {
          "approach": "For each node from 1 to n, generate all possible left and right subtrees, and check if the resulting tree is a valid binary search tree.",
          "code": "\nlet memo = [Int: Int]()\nfunc numTrees(_ n: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return 1\n    }\n    if let result = memo[n] {\n        return result\n    }\n    \n    var res = 0\n    for i in 1...n {\n        let left = numTrees(i - 1)\n        let right = numTrees(n - i)\n        res += left * right\n    }\n    \n    memo[n] = res\n    return res\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The maximum depth of the recursion tree is n, so the space complexity is O(n).",
            "time": "O(2^n)",
            "timeExplanation": "We have to generate all possible binary trees, which has a time complexity of O(2^n)."
          },
          "explanation": "We start by generating all possible binary trees. Then we check each tree to see if it is a valid binary search tree. This involves checking that all nodes in the left subtree are less than the current node, and all nodes in the right subtree are greater than the current node.",
          "id": "8b67f1ea-9ba0-4299-9b5c-d7a8e06c949c",
          "intuition": "Generate all possible binary trees and count the ones that are valid binary search trees.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "5",
              "explanation": "The 5 unique binary search trees are: (1, null, 2, null, 3), (1, null, 2, 3, null), (1, 2, null, null, 3), (1, 2, null, 3, null), (1, 2, 3, null, null).",
              "id": "fdeb9193-0272-4955-bc86-339e81995077",
              "input": "n = 3"
            },
            {
              "expectedOutput": "1",
              "explanation": "The only unique binary search tree is: (1, null, null).",
              "id": "290f3ffe-5918-4496-aa70-abdc35e463fb",
              "input": "n = 1"
            }
          ]
        },
        {
          "approach": "For each node from 1 to n, calculate the number of unique binary search trees using the previously calculated results.",
          "code": "\nfunc numTrees(_ n: Int) -> Int {\n    let n = n\n    var dp = Array(repeating: 0, count: n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in 2...n {\n        for j in 0...i - 1 {\n            dp[i] += dp[j] * dp[i - 1 - j]\n        }\n    }\n    \n    return dp[n]\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "We use an array of size n to store the results of subproblems, so the space complexity is O(n).",
            "time": "O(n^2)",
            "timeExplanation": "We use two nested loops to calculate the number of unique binary search trees, so the time complexity is O(n^2)."
          },
          "explanation": "We initialize an array dp of size n + 1, where dp[i] represents the number of unique binary search trees with i nodes. We then calculate dp[i] by iterating over all possible nodes and using the previously calculated results dp[j] and dp[i - j - 1].",
          "id": "a4697cbe-1f74-466d-a149-f8d1352525df",
          "intuition": "Use dynamic programming to store the results of subproblems to avoid redundant calculations.",
          "name": "Dynamic Programming",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "14",
              "explanation": "The 14 unique binary search trees are: (1, null, 2, null, 3, null, 4), (1, null, 2, 3, null, null, 4), (1, null, 2, null, 3, 4, null), (1, null, 2, 3, null, null, null), (1, null, 2, 3, 4, null, null), (1, 2, null, null, 3, null, 4), (1, 2, null, 3, null, null, 4), (1, 2, null, 3, null, null, null), (1, 2, null, 3, 4, null, null), (1, 2, 3, null, null, null, 4), (1, 2, 3, null, 4, null, null), (1, 2, 3, 4, null, null, null), (1, 2, null, null, null, 3, 4), (1, null, 2, 3, 4, null, null).",
              "id": "140e83b4-ea86-4b9c-b606-5495ee098a7e",
              "input": "n = 4"
            },
            {
              "expectedOutput": "2",
              "explanation": "The 2 unique binary search trees are: (1, null, 2), (2, 1, null).",
              "id": "c676e36b-34ab-4033-b199-2999af42acb4",
              "input": "n = 2"
            }
          ]
        }
      ],
      "id": "522e812d-7852-44d2-a44f-705272f8d513",
      "lastUpdated": "2026-02-06T21:06:14Z",
      "problemSlug": "unique-binary-search-trees",
      "relatedProblems": [
        "minimum-absolute-difference-in-bst",
        "unique-paths"
      ],
      "summary": "The Unique Binary Search Trees problem asks to find the number of unique binary search trees that can be formed using n nodes. This is a classic problem that involves dynamic programming and combinatorics."
    },
    {
      "approaches": [
        {
          "approach": "Start with a variable i = 0, then enter a loop where i is incremented by 1 until i*i is greater than the given number. Inside the loop, check if i*i equals the given number. If a match is found, return true. If the loop completes without finding a match, return false.",
          "code": "func isPerfectSquare(_ num: Int) -> Bool { var i = 0; while i*i <= num { if i*i == num { return true }; i += 1 }; return false }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the space used does not grow with the size of the input.",
            "time": "O(sqrt(n))",
            "timeExplanation": "The time complexity is O(sqrt(n)) because the loop runs until i*i is greater than the given number."
          },
          "explanation": "The brute force approach has a time complexity of O(sqrt(n)) because it checks every integer value up to the square root of the given number.",
          "id": "0beaa38f-88bf-46cd-ba55-3cff126987f8",
          "intuition": "The brute force approach works by checking every possible integer value from 0 to the given number to see if its square equals the given number.",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The square root of 16 is 4, which is an integer.",
              "id": "23049d4b-f2de-4086-9312-55a9d669e40d",
              "input": "num = 16"
            },
            {
              "expectedOutput": "false",
              "explanation": "There is no integer whose square equals 14.",
              "id": "5758df12-7d39-4395-905c-d211b6314337",
              "input": "num = 14"
            }
          ]
        },
        {
          "approach": "Define the search space as the range from 0 to the given number. Initialize two pointers, low and high, to the start and end of the search space, respectively. Repeatedly calculate the midpoint of the search space and check if the square of the midpoint equals the given number. If the square is less than the given number, move the low pointer to the midpoint + 1. If the square is greater than the given number, move the high pointer to the midpoint - 1. Repeat until low is greater than high or a match is found.",
          "code": "func isPerfectSquare(_ num: Int) -> Bool { var low = 0; var high = num; while low <= high { let mid = (low + high) / 2; if mid * mid == num { return true } else if mid * mid < num { low = mid + 1 } else { high = mid - 1 } }; return false }",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because the space used does not grow with the size of the input.",
            "time": "O(log n)",
            "timeExplanation": "The time complexity is O(log n) because the binary search algorithm reduces the search space by half with each iteration."
          },
          "explanation": "The binary search approach has a time complexity of O(log n) because it uses a binary search algorithm to find the square root of the given number.",
          "id": "474a1005-4315-4cea-ad19-bbe089b84882",
          "intuition": "The binary search approach works by finding the square root of the given number using a binary search algorithm.",
          "name": "Binary Search",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The square root of 25 is 5, which is an integer.",
              "id": "596ac58e-7c12-4ffa-916f-ffca244b94bb",
              "input": "num = 25"
            },
            {
              "expectedOutput": "false",
              "explanation": "There is no integer whose square equals 20.",
              "id": "a63f7ba3-d277-4611-9b29-4c0a3ec127a7",
              "input": "num = 20"
            }
          ]
        }
      ],
      "id": "a1049082-1038-4525-b903-5e37c73713fe",
      "lastUpdated": "2026-02-06T21:14:12Z",
      "problemSlug": "valid-perfect-square",
      "relatedProblems": [
        "square-root-of-x",
        "next-greatest-integer-after-x"
      ],
      "summary": "The problem asks to determine if a given number is a perfect square. The key insight is to use a binary search approach to efficiently find the square root of the number."
    },
    {
      "approaches": [
        {
          "approach": "Calculate the distances between each pair of points, then check if they can be rearranged into three pairs of equal distance and one pair of a different distance",
          "code": "\nimport Foundation\n\nfunc validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n    let points: [[Int]] = [p1, p2, p3, p4]\n    var distances: [Int] = []\n\n    for i in 0..<points.count {\n        for j in i + 1..<points.count {\n            let distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1])\n            distances.append(distance)\n        }\n    }\n    distances.sort()\n\n    return distances[0] == distances[1] && distances[1] == distances[2] && distances[2] == distances[3] && distances[4] == distances[5]\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a fixed amount of space to store the points and the distances",
            "time": "O(1)",
            "timeExplanation": "We have a fixed number of points and a fixed number of distances to calculate"
          },
          "explanation": "This approach involves calculating the distance between each pair of points. A square has four equal sides and two diagonals that are equal in length and 2 times the length of a side. We can calculate the distances and sort them. If the first three distances are equal and the last distance is equal to the first distance multiplied by 2, then the points form a square.",
          "id": "c33b63a0-e6d5-4709-9c3f-0386d3d7226b",
          "intuition": "Calculate all pairwise distances and check if they can form a square",
          "name": "Brute Force",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "These points form a square of side length 1",
              "id": "0420248a-ce55-405f-abee-e9326a526c07",
              "input": "p1 = [1,1], p2 = [1, 0], p3 = [0,1], p4 = [0,0]"
            },
            {
              "expectedOutput": "true",
              "explanation": "These points form a square of side length 2",
              "id": "841e0a75-067b-47f8-8553-f032a5b7d267",
              "input": "p1 = [0,1], p2 = [2,1], p3 = [1,2], p4 = [1,0]"
            }
          ]
        },
        {
          "approach": "Calculate the center of the square, then check if all points are equidistant to the center",
          "code": "\nimport Foundation\n\nfunc validSquare(_ p1: [Int], _ p2: [Int], _ p3: [Int], _ p4: [Int]) -> Bool {\n    let points: [[Int]] = [p1, p2, p3, p4]\n    var distances: [Int] = []\n    let centerX = (Double(p1[0]) + Double(p2[0]) + Double(p3[0]) + Double(p4[0])) / 4.0\n    let centerY = (Double(p1[1]) + Double(p2[1]) + Double(p3[1]) + Double(p4[1])) / 4.0\n\n    for point in points {\n        let distance = Int((Double(point[0]) - centerX) * (Double(point[0]) - centerX) + (Double(point[1]) - centerY) * (Double(point[1]) - centerY))\n        distances.append(distance)\n    }\n    distances.sort()\n\n    return distances[0] == distances[1] && distances[1] == distances[2] && distances[2] == distances[3] && distances.count > 4 && distances[4] == distances[5]\n}",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "We use a fixed amount of space to store the points and the distances",
            "time": "O(1)",
            "timeExplanation": "We have a fixed number of points and a fixed number of distances to calculate"
          },
          "explanation": "This approach involves calculating the center of the square. If the points form a square, they will be equidistant to the center of the square. We can calculate the average x and y coordinates to get the center, then check if all points are equidistant to the center.",
          "id": "9cc1cbe1-ba3c-4891-929e-86d3fd614c06",
          "intuition": "Calculate the center of the square and check if it's equidistant to all points",
          "name": "Optimized",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "These points form a square of side length 1",
              "id": "6036043d-697c-4389-981a-d32d754ff1b6",
              "input": "p1 = [1,1], p2 = [1, 0], p3 = [0,1], p4 = [0,0]"
            },
            {
              "expectedOutput": "true",
              "explanation": "These points form a square of side length 2",
              "id": "1c299e1c-7d83-409c-8164-ab8d0e1e18e2",
              "input": "p1 = [0,1], p2 = [2,1], p3 = [1,2], p4 = [1,0]"
            }
          ]
        }
      ],
      "id": "94732cb9-d47b-4993-a767-d33a7f6519a6",
      "lastUpdated": "2026-02-06T21:27:40Z",
      "problemSlug": "valid-square",
      "relatedProblems": [
        "max-points-on-a-line",
        "best-time-to-buy-and-sell-stock-iii"
      ],
      "summary": "Determine if four points form a valid square. The key insight is to calculate the distances between points and check if they can form a square."
    },
    {
      "approaches": [
        {
          "approach": "Start with the first jug full and the second empty. Then, iteratively fill the first jug, pour water from the first jug into the second, empty the second jug, pour water from the first jug into the second again, and empty the first jug. Check after each operation if either jug contains the target amount of water.",
          "code": "\nimport Foundation\n\nfunc canMeasureWater(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n    let queue: [(Int, Int)] = [(0, 0)]\n    var visited: Set<(Int, Int)> = [(0, 0)]\n\n    while !queue.isEmpty {\n        let (jug1, jug2) = queue.removeFirst()\n\n        if jug1 == targetCapacity || jug2 == targetCapacity || jug1 + jug2 == targetCapacity {\n            return true\n        }\n\n        let states: [(Int, Int)] = [\n            (jug1Capacity, jug2),\n            (jug1, jug2Capacity),\n            (0, jug2),\n            (jug1, 0),\n            (max(0, jug1 - (jug2Capacity - jug2)), min(jug2Capacity, jug2 + jug1)),\n            (min(jug1Capacity, jug1 + jug2), max(0, jug2 - (jug1Capacity - jug1)))\n        ]\n\n        for state in states {\n            if !visited.contains(state) {\n                queue.append(state)\n                visited.insert(state)\n            }\n        }\n    }\n\n    return false\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is due to storing visited states, which also grows with the capacities of the jugs.",
            "time": "O(n^2)",
            "timeExplanation": "The time complexity is due to the iterative exploration of all possible states, which grows quadratically with the capacities of the jugs."
          },
          "explanation": "This brute-force method checks every possible state of the jugs. It's straightforward but can be very time-consuming for large capacities or a large target amount because it involves trying all permutations of jug states until it either finds a way to measure the target amount or exhausts all possibilities.",
          "id": "b89e5ba0-a63e-4f79-b7b5-94d076e46050",
          "intuition": "This approach works by trying all possible combinations of filling and pouring water between the two jugs, which guarantees finding a solution if one exists, albeit inefficiently.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "Fill the 3-jug, pour into the 5-jug, fill the 3-jug again, pour into the 5-jug until it's full, empty the 5-jug, and pour the remaining 1 unit from the 3-jug into the 5-jug, then fill the 3-jug and pour into the 5-jug to get 4 units in the 5-jug.",
              "id": "d92a1ff8-cc87-4f54-83c7-5305fe707a8d",
              "input": "jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4"
            },
            {
              "expectedOutput": "False",
              "explanation": "There's no sequence of operations that results in having exactly 5 units of water in either jug.",
              "id": "70b43f59-d91e-4ed7-b013-b4794fd0b5a9",
              "input": "jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5"
            }
          ]
        },
        {
          "approach": "Calculate the GCD of the two jugs' capacities. The target amount can be measured if and only if it is a multiple of this GCD.",
          "code": "\nfunc canMeasureWaterMath(_ jug1Capacity: Int, _ jug2Capacity: Int, _ targetCapacity: Int) -> Bool {\n    if jug1Capacity + jug2Capacity < targetCapacity {\n        return false\n    }\n\n    func gcd(_ a: Int, _ b: Int) -> Int {\n        if b == 0 {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    let g = gcd(jug1Capacity, jug2Capacity)\n    return targetCapacity % g == 0\n}\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "This approach uses a constant amount of space to store the GCD and other variables, not depending on the input size.",
            "time": "O(log(min(jug1Capacity, jug2Capacity)))",
            "timeExplanation": "The time complexity comes from the GCD calculation, which uses the Euclidean algorithm, and is logarithmic in the size of the smaller input."
          },
          "explanation": "The GCD represents the smallest unit of measurement achievable by combining the two jugs' capacities. Thus, any amount that is a multiple of the GCD can be measured by some sequence of filling and pouring operations.",
          "id": "50d2c968-0a60-42bb-bce2-285f69558d54",
          "intuition": "This approach utilizes mathematical properties, specifically the concept of the greatest common divisor (GCD), to determine if a target amount can be measured without needing to explore all possible states.",
          "name": "Math-Based Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "True",
              "explanation": "The GCD of 3 and 5 is 1, and 4 is a multiple of 1, so the target capacity can be measured.",
              "id": "84c0e5d4-1277-4909-9580-a54bb6272260",
              "input": "jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4"
            },
            {
              "expectedOutput": "False",
              "explanation": "The GCD of 2 and 6 is 2, and 5 is not a multiple of 2, so the target capacity cannot be measured.",
              "id": "5d4b9ef6-46ce-4bb2-b410-a2c5e37dbb8d",
              "input": "jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5"
            }
          ]
        }
      ],
      "id": "915f6898-ea13-4340-8fa0-297cfce8d105",
      "lastUpdated": "2026-02-06T21:14:08Z",
      "problemSlug": "water-and-jug-problem",
      "relatedProblems": [
        "coin-change",
        "combination-sum"
      ],
      "summary": "The Water and Jug Problem involves determining whether it's possible to measure exactly a certain amount of water using two jugs of different capacities. A key insight is that this problem can be approached using either brute-force or a math-based method by utilizing the concept of greatest common divisor (GCD)."
    },
    {
      "approaches": [
        {
          "approach": "First, count the frequency of each rank in the deck, then iterate over all possible values of x from 1 to the minimum frequency, and for each x, check if all ranks have at least x cards.",
          "code": "\nlet deck = [1,1,1,2,2,2,3,3,3,4,4,4,4]\nlet handSize = 3\nfunc isNStraightHand(deck: [Int], handSize: Int) -> Bool {\n    let count = Array(repeating: 0, count: 1001)\n    for num in deck {\n        count[num] += 1\n    }\n    for num in 1...1000 {\n        if count[num] > 0 {\n            for x in 1...handSize {\n                if count[num] < x {\n                    return false\n                }\n                if count[num+x-1] < x {\n                    return false\n                }\n            }\n        }\n    }\n    return true\n}\nprint(isNStraightHand(deck: deck, handSize: handSize))\n",
          "complexity": {
            "space": "O(1)",
            "spaceExplanation": "The space complexity is O(1) because we use a fixed-size array to count the frequency of each rank.",
            "time": "O(n*m)",
            "timeExplanation": "The time complexity is O(n*m) where n is the number of cards in the deck and m is the hand size, because in the worst case, we need to iterate over all cards and all possible values of x."
          },
          "explanation": "The brute-force approach is straightforward but not efficient because it involves iterating over all possible values of x and checking the condition for each x.",
          "id": "dffe17dd-98c2-4eba-985e-10820a303473",
          "intuition": "This approach works by iterating over all possible values of x and checking if the deck has at least x cards of the same rank and if all ranks have at least x cards.",
          "name": "Brute-Force Approach",
          "order": 1,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The deck has at least 3 cards of the same rank (1, 2, and 3) and all ranks have at least 3 cards.",
              "id": "761343c3-748e-4e76-82c4-7c72ed6b47b7",
              "input": "deck = [1,1,1,2,2,2,3,3,3,4,4,4,4], handSize = 3"
            },
            {
              "expectedOutput": "true",
              "explanation": "The deck has at least 3 cards of the same rank (1) but the hand size is larger than the number of different ranks.",
              "id": "f9c12b93-a330-42e2-a450-f051d6ced914",
              "input": "deck = [1,1,1,1,1], handSize = 3"
            }
          ]
        },
        {
          "approach": "First, count the frequency of each rank in the deck using a hash table, then find the greatest common divisor of these frequencies.",
          "code": "\nfunc isNStraightHand(_ deck: [Int], _ handSize: Int) -> Bool {\n    if deck.count % handSize != 0 {\n        return false\n    }\n    var count: [Int: Int] = [:]\n    for num in deck {\n        if let value = count[num] {\n            count[num] = value + 1\n        } else {\n            count[num] = 1\n        }\n    }\n    let sortedKeys = Array(count.keys).sorted()\n    var prev = sortedKeys[0]\n    var groupSize = count[prev]!\n    for key in sortedKeys[1...] {\n        if key - prev != 1 {\n            return false\n        }\n        if count[key]! < groupSize {\n            return false\n        }\n        prev = key\n        groupSize = count[key]!\n    }\n    return true\n}\n",
          "complexity": {
            "space": "O(n)",
            "spaceExplanation": "The space complexity is O(n) because we use a hash table to count the frequency of each rank.",
            "time": "O(n log n)",
            "timeExplanation": "The time complexity is O(n log n) where n is the number of cards in the deck because we use a hash table to count the frequency of each rank and then sort the ranks."
          },
          "explanation": "The optimized approach is more efficient because it uses a hash table to count the frequency of each rank and finds the greatest common divisor of these frequencies in a single pass.",
          "id": "3d6f8c85-7d55-4aac-8431-a0bd9a687e2d",
          "intuition": "This approach works by using a hash table to count the frequency of each rank in the deck and then finding the greatest common divisor of these frequencies.",
          "name": "Optimized Approach",
          "order": 2,
          "testCases": [
            {
              "expectedOutput": "true",
              "explanation": "The deck has at least 3 cards of the same rank (1, 2, and 3) and all ranks have at least 3 cards.",
              "id": "6050d92f-15d6-4d03-ba3e-645f1fb4614c",
              "input": "deck = [1,1,1,2,2,2,3,3,3,4,4,4,4], handSize = 3"
            },
            {
              "expectedOutput": "true",
              "explanation": "The deck has at least 3 cards of the same rank (1) but the hand size is larger than the number of different ranks.",
              "id": "c5e0c117-c7b8-41ad-a74e-aa5c2550e5cf",
              "input": "deck = [1,1,1,1,1], handSize = 3"
            }
          ]
        }
      ],
      "id": "6d45b625-4500-481c-8667-c1ba95f09ada",
      "lastUpdated": "2026-02-06T21:48:04Z",
      "problemSlug": "x-of-a-kind-in-a-deck-of-cards",
      "relatedProblems": [
        "hand-of-straights",
        "design-tic-tac-toe"
      ],
      "summary": "The problem is to determine if a deck of cards has at least x cards of the same rank and all ranks in the deck have the same number of cards as the lowest rank, and the key insight is to use a hash table to count the frequency of each rank and then find the greatest common divisor of these frequencies."
    }
  ],
  "topic": "math-geometry",
  "version": "2.0.0"
}
