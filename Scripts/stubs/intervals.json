{
  "insert-interval": {
    "summary": "Insert a new interval into a sorted list of non-overlapping intervals, merging if necessary. Process intervals in three phases: those before, those overlapping, and those after the new interval.",
    "approaches": [
      {
        "name": "Linear Scan with Three Phases",
        "intuition": "Since intervals are sorted and non-overlapping, we can process them in order: add all intervals that end before the new one starts, merge all that overlap with the new interval, then add remaining intervals.",
        "approach": "1. Add all intervals that end before newInterval starts (no overlap)\n2. Merge all intervals that overlap with newInterval\n3. Add the merged interval\n4. Add all remaining intervals (start after newInterval ends)",
        "explanation": "Two intervals [a,b] and [c,d] overlap if a <= d AND c <= b. For overlapping intervals, we merge by taking min of starts and max of ends. The key insight is that once we pass intervals that could overlap, all remaining intervals must come after.",
        "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var newInterval = newInterval\n    var i = 0\n    let n = intervals.count\n    \n    // Phase 1: Add intervals that end before newInterval starts\n    while i < n && intervals[i][1] < newInterval[0] {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    // Phase 2: Merge overlapping intervals\n    while i < n && intervals[i][0] <= newInterval[1] {\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    }\n    result.append(newInterval)\n    \n    // Phase 3: Add remaining intervals\n    while i < n {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Single pass through all n intervals",
          "spaceExplanation": "Output array can contain up to n+1 intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
            "expectedOutput": "[[1,5],[6,9]]",
            "explanation": "[1,3] overlaps with [2,5] \u2192 merge to [1,5]. [6,9] comes after."
          },
          {
            "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
            "expectedOutput": "[[1,2],[3,10],[12,16]]",
            "explanation": "[3,5], [6,7], [8,10] all overlap with [4,8] \u2192 merge to [3,10]"
          },
          {
            "input": "intervals = [], newInterval = [5,7]",
            "expectedOutput": "[[5,7]]",
            "explanation": "Empty list - just add the new interval"
          },
          {
            "input": "intervals = [[1,5]], newInterval = [2,3]",
            "expectedOutput": "[[1,5]]",
            "explanation": "New interval is completely inside existing one - merge is just [1,5]"
          }
        ]
      },
      {
        "name": "Binary Search + Merge",
        "intuition": "Use binary search to find where the new interval should be inserted, then handle merging. This can be faster for finding the insertion point but still O(n) overall due to potential merging.",
        "approach": "1. Binary search to find first interval that could overlap (start <= newInterval.end)\n2. Binary search to find last interval that could overlap (end >= newInterval.start)\n3. Merge all intervals in that range with newInterval\n4. Construct result with non-overlapping + merged + remaining",
        "explanation": "Binary search finds the boundaries faster, but we still need to merge intervals in the overlapping range. This approach shines when there are few or no overlaps, as binary search is O(log n). However, worst case is still O(n) when many intervals merge.",
        "code": "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    if intervals.isEmpty {\n        return [newInterval]\n    }\n    \n    var result: [[Int]] = []\n    var merged = newInterval\n    var inserted = false\n    \n    for interval in intervals {\n        if interval[1] < merged[0] {\n            // Current interval ends before merged starts\n            result.append(interval)\n        } else if interval[0] > merged[1] {\n            // Current interval starts after merged ends\n            if !inserted {\n                result.append(merged)\n                inserted = true\n            }\n            result.append(interval)\n        } else {\n            // Overlap - expand merged interval\n            merged[0] = min(merged[0], interval[0])\n            merged[1] = max(merged[1], interval[1])\n        }\n    }\n    \n    if !inserted {\n        result.append(merged)\n    }\n    \n    return result\n}",
        "complexity": {
          "time": "O(n)",
          "space": "O(n)",
          "timeExplanation": "Process each interval once",
          "spaceExplanation": "Output array stores all resulting intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [10,11]",
            "expectedOutput": "[[1,3],[6,9],[10,11]]",
            "explanation": "No overlap - new interval added at end"
          },
          {
            "input": "intervals = [[3,5],[6,9]], newInterval = [1,2]",
            "expectedOutput": "[[1,2],[3,5],[6,9]]",
            "explanation": "No overlap - new interval added at beginning"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-intervals",
      "range-module",
      "data-stream-as-disjoint-intervals"
    ]
  },
  "non-overlapping-intervals": {
    "summary": "Find minimum intervals to remove to make the rest non-overlapping. Greedy: sort by end time, keep intervals that don't overlap with previous kept interval. Remove count = total - kept.",
    "approaches": [
      {
        "name": "Greedy (Sort by End Time)",
        "intuition": "Always keep the interval that ends earliest - this leaves maximum room for subsequent intervals. Count how many we keep, subtract from total.",
        "approach": "1. Sort intervals by end time\n2. Track the end time of last kept interval\n3. For each interval:\n   a. If start >= lastEnd, keep it (update lastEnd)\n   b. Else, skip it (it overlaps)\n4. Return total - kept",
        "explanation": "Sorting by end time ensures we greedily pick intervals that finish earliest. If a new interval starts after the previous ends, it doesn't overlap. By choosing early-ending intervals, we maximize the number we can fit. The intervals we don't keep are the ones we'd remove.",
        "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by end time\n    let sorted = intervals.sorted { $0[1] < $1[1] }\n    \n    var kept = 1\n    var lastEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] >= lastEnd {\n            kept += 1\n            lastEnd = sorted[i][1]\n        }\n    }\n    \n    return intervals.count - kept\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Dominated by sorting",
          "spaceExplanation": "Creating sorted copy of intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
            "expectedOutput": "1",
            "explanation": "Remove [1,3]. Keep [1,2], [2,3], [3,4] which don't overlap."
          },
          {
            "input": "intervals = [[1,2],[1,2],[1,2]]",
            "expectedOutput": "2",
            "explanation": "All identical, can only keep 1. Remove 2."
          },
          {
            "input": "intervals = [[1,2],[2,3]]",
            "expectedOutput": "0",
            "explanation": "Already non-overlapping (touching endpoints is OK)"
          }
        ]
      },
      {
        "name": "Greedy (Sort by Start, Track Overlaps)",
        "intuition": "Sort by start time. When two intervals overlap, remove the one that ends later (it's more likely to cause future conflicts).",
        "approach": "1. Sort intervals by start time\n2. Track end of previous kept interval\n3. For each interval:\n   a. If overlap (start < prevEnd), increment removals, keep shorter one (update prevEnd to min)\n   b. Else, update prevEnd to current end",
        "explanation": "When intervals overlap, we want to keep the one ending sooner. By sorting by start time and keeping the smaller end when conflicts occur, we minimize future overlaps. This is equivalent to the end-time approach but processes differently.",
        "code": "func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n    guard intervals.count > 1 else { return 0 }\n    \n    // Sort by start time\n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    \n    var removals = 0\n    var prevEnd = sorted[0][1]\n    \n    for i in 1..<sorted.count {\n        if sorted[i][0] < prevEnd {\n            // Overlap - remove one (keep the one ending sooner)\n            removals += 1\n            prevEnd = min(prevEnd, sorted[i][1])\n        } else {\n            prevEnd = sorted[i][1]\n        }\n    }\n    \n    return removals\n}",
        "complexity": {
          "time": "O(n log n)",
          "space": "O(n)",
          "timeExplanation": "Sorting dominates",
          "spaceExplanation": "Sorted copy of intervals"
        },
        "testCases": [
          {
            "input": "intervals = [[1,100],[11,22],[1,11],[2,12]]",
            "expectedOutput": "2",
            "explanation": "Keep [1,11] and [11,22], remove the longer overlapping ones"
          }
        ]
      }
    ],
    "relatedProblems": [
      "merge-intervals",
      "insert-interval",
      "minimum-number-of-arrows-to-burst-balloons"
    ]
  }
}